--------------------------------------------------------
--  File created - Monday-October-11-2021   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for View ACLMV$_BASE_VIEW
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ACLMV$_BASE_VIEW" ("TABLE_OBJ#", "ACL_MVIEW_OBJ#", "SCHEMA_NAME", "TABLE_NAME", "ACL_MVIEW_NAME", "REFRESH_MODE", "REFRESH_ABILITY", "ACL_STATUS", "USER_SUPPLIED_MV", "JOB_NAME") AS 
  select
  a.table_obj# as table_obj#,
  b1.acl_mview_obj# as acl_mview_obj#,
  b1.schema_name,
  t.name as table_name,
  b1.acl_mview_name,
  decode (a.refresh_mode, 0, 'ON COMMIT', 1, 'ON DEMAND', '2', 'SCHEDULED')
          as refresh_mode,
  b1.refresh_ability,
  b1.acl_status,
  b1.user_supplied_mv as user_supplied_mv,
  a.job_name as job_name
from sys.aclmv$_mvinfo b1, sys.aclmv$ a, sys.obj$ t
where t.obj# = a.table_obj#
  and b1.acl_mview_obj# = a.acl_mview_obj#

;
--------------------------------------------------------
--  DDL for View ACLMV$_MVINFO
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ACLMV$_MVINFO" ("ACL_MVIEW_OBJ#", "SCHEMA_NAME", "ACL_MVIEW_NAME", "REFRESH_ABILITY", "ACL_STATUS", "USER_SUPPLIED_MV") AS 
  select
 w.obj# as acl_mview_obj#,
 s.sowner as schema_name,
 s.vname as acl_mview_name,
 decode(s.auto_fast,
              'C',  'COMPLETE',
              'F',  'INCREMENTAL',
              '?',  'COMPLETE',
              'N',  'ERROR',
              NULL, 'COMPLETE', 'ERROR') as refresh_ability,
 decode(bitand(w.mflags, 1), 0, 'FRESH', 'STALE') as acl_status,
 decode(bitand(mflags,power(2, 33)), power(2, 33), 'Y', 'N')
   as user_supplied_mv
from sys.user$ u, sys.sum$ w, sys.obj$ o, sys.snap$ s
where w.containernam(+) = s.vname
  and o.obj#(+) = w.obj#
  and o.owner# = u.user#(+)
  and ((u.name = s.sowner) or (u.name IS NULL))
  and s.instsite = 0
  and not (bitand(s.flag, 268435456) > 0       /* MV with user-defined types */
           and bitand(s.objflag, 32) > 0)                    /* secondary MV */
  and not (bitand(s.flag2, 33554432) > 0)               /* secondary CUBE MV */
  and ((bitand(w.mflags,power(2, 32)) > 0) or      /* system-generated aclmv */
       (bitand(w.mflags,power(2, 33))  > 0))         /* user-specified aclmv */

;
--------------------------------------------------------
--  DDL for View _ACTUAL_EDITION_OBJ
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ACTUAL_EDITION_OBJ" ("OBJ#", "DATAOBJ#", "DEFINING_OWNER#", "NAME", "NAMESPACE", "SUBNAME", "TYPE#", "CTIME", "MTIME", "STIME", "STATUS", "REMOTEOWNER", "LINKNAME", "FLAGS", "OID$", "SPARE1", "SPARE2", "SPARE3", "SPARE4", "SPARE5", "SPARE6", "SIGNATURE", "SPARE7", "SPARE8", "SPARE9", "DFLCOLLID", "CREAPPID", "CREVERID", "CREPATCHID", "MODAPPID", "MODVERID", "MODPATCHID", "SPARE10", "SPARE11", "SPARE12", "SPARE13", "SPARE14", "OWNER#", "DEFINING_EDITION") AS 
  select o."OBJ#",o."DATAOBJ#",o."OWNER#",o."NAME",o."NAMESPACE",o."SUBNAME",o."TYPE#",o."CTIME",o."MTIME",o."STIME",o."STATUS",o."REMOTEOWNER",o."LINKNAME",o."FLAGS",o."OID$",o."SPARE1",o."SPARE2",o."SPARE3",o."SPARE4",o."SPARE5",o."SPARE6",o."SIGNATURE",o."SPARE7",o."SPARE8",o."SPARE9",o."DFLCOLLID",o."CREAPPID",o."CREVERID",o."CREPATCHID",o."MODAPPID",o."MODVERID",o."MODPATCHID",o."SPARE10",o."SPARE11",o."SPARE12",o."SPARE13",o."SPARE14",
  
       o.spare3,
       case when (o.type# not in (select ue.type# from user_editioning$ ue
                                  where ue.user# = o.spare3) or
                  bitand(o.flags, 1048576) = 1048576 or
                  bitand(u.spare1, 16) = 0) then
         null
       when (u.type# = 2) then
        (select name from obj$ where obj# = u.spare2)
       else
        'ORA$BASE'
       end
from obj$ o, user$ u
where o.owner# = u.user#
  and o.type# != 88
  
;
--------------------------------------------------------
--  DDL for View ALL_ALL_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ALL_TABLES" ("OWNER", "TABLE_NAME", "TABLESPACE_NAME", "CLUSTER_NAME", "IOT_NAME", "STATUS", "PCT_FREE", "PCT_USED", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENTS", "MAX_EXTENTS", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "BACKED_UP", "NUM_ROWS", "BLOCKS", "EMPTY_BLOCKS", "AVG_SPACE", "CHAIN_CNT", "AVG_ROW_LEN", "AVG_SPACE_FREELIST_BLOCKS", "NUM_FREELIST_BLOCKS", "DEGREE", "INSTANCES", "CACHE", "TABLE_LOCK", "SAMPLE_SIZE", "LAST_ANALYZED", "PARTITIONED", "IOT_TYPE", "OBJECT_ID_TYPE", "TABLE_TYPE_OWNER", "TABLE_TYPE", "TEMPORARY", "SECONDARY", "NESTED", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "ROW_MOVEMENT", "GLOBAL_STATS", "USER_STATS", "DURATION", "SKIP_CORRUPT", "MONITORING", "CLUSTER_OWNER", "DEPENDENCIES", "COMPRESSION", "COMPRESS_FOR", "DROPPED", "SEGMENT_CREATED", "INMEMORY", "INMEMORY_PRIORITY", "INMEMORY_DISTRIBUTE", "INMEMORY_COMPRESSION", "INMEMORY_DUPLICATE", "EXTERNAL", "CELLMEMORY", "INMEMORY_SERVICE", "INMEMORY_SERVICE_NAME", "MEMOPTIMIZE_READ", "MEMOPTIMIZE_WRITE", "HAS_SENSITIVE_COLUMN") AS 
  select OWNER, TABLE_NAME, TABLESPACE_NAME, CLUSTER_NAME, IOT_NAME, STATUS,
     PCT_FREE, PCT_USED,
     INI_TRANS, MAX_TRANS,
     INITIAL_EXTENT, NEXT_EXTENT,
     MIN_EXTENTS, MAX_EXTENTS, PCT_INCREASE,
     FREELISTS, FREELIST_GROUPS, LOGGING,
     BACKED_UP, NUM_ROWS, BLOCKS, EMPTY_BLOCKS,
     AVG_SPACE, CHAIN_CNT, AVG_ROW_LEN,
     AVG_SPACE_FREELIST_BLOCKS, NUM_FREELIST_BLOCKS,
     DEGREE, INSTANCES, CACHE, TABLE_LOCK,
     SAMPLE_SIZE, LAST_ANALYZED, PARTITIONED,
     IOT_TYPE, NULL, NULL, NULL, TEMPORARY, SECONDARY, NESTED,
     BUFFER_POOL, FLASH_CACHE,
     CELL_FLASH_CACHE, ROW_MOVEMENT,
     GLOBAL_STATS, USER_STATS, DURATION, SKIP_CORRUPT, MONITORING,
     CLUSTER_OWNER, DEPENDENCIES, COMPRESSION, COMPRESS_FOR, DROPPED,
     SEGMENT_CREATED,
     INMEMORY, INMEMORY_PRIORITY, INMEMORY_DISTRIBUTE, INMEMORY_COMPRESSION,
     INMEMORY_DUPLICATE, EXTERNAL, CELLMEMORY, INMEMORY_SERVICE,
     INMEMORY_SERVICE_NAME, MEMOPTIMIZE_READ, MEMOPTIMIZE_WRITE,
     HAS_SENSITIVE_COLUMN
from all_tables
union all
select OWNER, TABLE_NAME, TABLESPACE_NAME, CLUSTER_NAME, IOT_NAME, STATUS,
     PCT_FREE, PCT_USED,
     INI_TRANS, MAX_TRANS,
     INITIAL_EXTENT, NEXT_EXTENT,
     MIN_EXTENTS, MAX_EXTENTS, PCT_INCREASE,
     FREELISTS, FREELIST_GROUPS, LOGGING,
     BACKED_UP, NUM_ROWS, BLOCKS, EMPTY_BLOCKS,
     AVG_SPACE, CHAIN_CNT, AVG_ROW_LEN,
     AVG_SPACE_FREELIST_BLOCKS, NUM_FREELIST_BLOCKS,
     DEGREE, INSTANCES, CACHE, TABLE_LOCK,
     SAMPLE_SIZE, LAST_ANALYZED, PARTITIONED,
     IOT_TYPE, OBJECT_ID_TYPE,
     TABLE_TYPE_OWNER, TABLE_TYPE, TEMPORARY, SECONDARY, NESTED,
     BUFFER_POOL, FLASH_CACHE,
     CELL_FLASH_CACHE, ROW_MOVEMENT,
     GLOBAL_STATS, USER_STATS, DURATION, SKIP_CORRUPT, MONITORING,
     CLUSTER_OWNER, DEPENDENCIES, COMPRESSION, COMPRESS_FOR, DROPPED,
     SEGMENT_CREATED,
     INMEMORY, INMEMORY_PRIORITY, INMEMORY_DISTRIBUTE, INMEMORY_COMPRESSION,
     INMEMORY_DUPLICATE, EXTERNAL, CELLMEMORY, INMEMORY_SERVICE,
     INMEMORY_SERVICE_NAME, MEMOPTIMIZE_READ, MEMOPTIMIZE_WRITE,
     HAS_SENSITIVE_COLUMN
from all_object_tables;

   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."TABLESPACE_NAME" IS 'Name of the tablespace containing the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."CLUSTER_NAME" IS 'Name of the cluster, if any, to which the table belongs';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."IOT_NAME" IS 'Name of the index-only table, if any, to which the overflow or mapping table entry belongs';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."STATUS" IS 'Status of the table will be UNUSABLE if a previous DROP TABLE operation failed,
VALID otherwise';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."PCT_FREE" IS 'Minimum percentage of free space in a block';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."PCT_USED" IS 'Minimum percentage of used space in a block';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INI_TRANS" IS 'Initial number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."MAX_TRANS" IS 'Maximum number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INITIAL_EXTENT" IS 'Size of the initial extent in bytes';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."NEXT_EXTENT" IS 'Size of secondary extents in bytes';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."MIN_EXTENTS" IS 'Minimum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."MAX_EXTENTS" IS 'Maximum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."PCT_INCREASE" IS 'Percentage increase in extent size';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."FREELISTS" IS 'Number of process freelists allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."FREELIST_GROUPS" IS 'Number of freelist groups allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."LOGGING" IS 'Logging attribute';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."BACKED_UP" IS 'Has table been backed up since last modification?';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."NUM_ROWS" IS 'The number of rows in the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."BLOCKS" IS 'The number of used blocks in the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."EMPTY_BLOCKS" IS 'The number of empty (never used) blocks in the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."AVG_SPACE" IS 'The average available free space in the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."CHAIN_CNT" IS 'The number of chained rows in the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."AVG_ROW_LEN" IS 'The average row length, including row overhead';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."AVG_SPACE_FREELIST_BLOCKS" IS 'The average freespace of all blocks on a freelist';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."NUM_FREELIST_BLOCKS" IS 'The number of blocks on the freelist';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."DEGREE" IS 'The number of threads per instance for scanning the table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INSTANCES" IS 'The number of instances across which the table is to be scanned';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."CACHE" IS 'Whether the table is to be cached in the buffer cache';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."TABLE_LOCK" IS 'Whether table locking is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."SAMPLE_SIZE" IS 'The sample size used in analyzing this table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."LAST_ANALYZED" IS 'The date of the most recent time this table was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."PARTITIONED" IS 'Is this table partitioned? YES or NO';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."IOT_TYPE" IS 'If index-only table, then IOT_TYPE is IOT or IOT_OVERFLOW or IOT_MAPPING else NULL';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."OBJECT_ID_TYPE" IS 'If user-defined OID, then USER-DEFINED, else if system generated OID, then SYST
EM GENERATED';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."TABLE_TYPE_OWNER" IS 'Owner of the type of the table if the table is an object table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."TABLE_TYPE" IS 'Type of the table if the table is an object table';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."TEMPORARY" IS 'Can the current session only see data that it place in this object itself?';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."SECONDARY" IS 'Is this table object created as part of icreate for domain indexes?';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."NESTED" IS 'Is the table a nested table?';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."BUFFER_POOL" IS 'The default buffer pool to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."FLASH_CACHE" IS 'The default flash cache hint to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."CELL_FLASH_CACHE" IS 'The default cell flash cache hint to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."ROW_MOVEMENT" IS 'Whether partitioned row movement is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."DURATION" IS 'If temporary table, then duration is sys$session or sys$transaction else NULL';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."SKIP_CORRUPT" IS 'Whether skip corrupt blocks is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."MONITORING" IS 'Should we keep track of the amount of modification?';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."CLUSTER_OWNER" IS 'Owner of the cluster, if any, to which the table belongs';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."DEPENDENCIES" IS 'Should we keep track of row level dependencies?';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."COMPRESSION" IS 'Whether table compression is enabled or not';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."COMPRESS_FOR" IS 'Compress what kind of operations';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."DROPPED" IS 'Whether table is dropped and is in Recycle Bin';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."SEGMENT_CREATED" IS 'Whether the table segment is created or not';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INMEMORY" IS 'Whether in-memory is enabled or not';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INMEMORY_PRIORITY" IS 'User defined priority in which in-memory column store object is loaded';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INMEMORY_DISTRIBUTE" IS 'How the in-memory columnar store object is distributed';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INMEMORY_COMPRESSION" IS 'Compression level for the in-memory column store option';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INMEMORY_DUPLICATE" IS 'How the in-memory column store object is duplicated';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."EXTERNAL" IS 'Whether the table is an  external table or not';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."CELLMEMORY" IS 'Cell columnar cache';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INMEMORY_SERVICE" IS 'How the in-memory columnar store object is distributed for service';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."INMEMORY_SERVICE_NAME" IS 'Service on which the in-memory columnar store object is distributed';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."MEMOPTIMIZE_READ" IS 'Whether the table is enabled for Fast Key Based Access';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."MEMOPTIMIZE_WRITE" IS 'Whether the table is enabled for Fast Data Ingestion';
   COMMENT ON COLUMN "SYS"."ALL_ALL_TABLES"."HAS_SENSITIVE_COLUMN" IS 'Whether the table has one or more sensitive columns';
   COMMENT ON TABLE "SYS"."ALL_ALL_TABLES"  IS 'Description of all object and relational tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_ATTR_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_ALIAS", "HIER_ALIAS", "ATTRIBUTE_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       ANALYTIC_VIEW_NAME,
       DIMENSION_ALIAS,
       HIER_ALIAS,
       ATTRIBUTE_NAME,
       CLASSIFICATION,
       VALUE,
       language,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_ATTR_CLASS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."OWNER" IS 'Owner of the analytic view attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."ANALYTIC_VIEW_NAME" IS 'Name of analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."DIMENSION_ALIAS" IS 'Alias of the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."HIER_ALIAS" IS 'Alias of the hierarchy within the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."ATTRIBUTE_NAME" IS 'Name of the attribute within the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."CLASSIFICATION" IS 'Name of analytic view attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."VALUE" IS 'Value of attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."LANGUAGE" IS 'Language of attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"."ORDER_NUM" IS 'Order number of attribute classification';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_ATTR_CLASS"  IS 'analytic view attribute classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_BASE_MEAS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS" ("OWNER", "ANALYTIC_VIEW_NAME", "MEASURE_NAME", "TABLE_ALIAS", "COLUMN_NAME", "AGGR_FUNCTION", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       ANALYTIC_VIEW_NAME,
       MEASURE_NAME,
       TABLE_ALIAS,
       COLUMN_NAME,
       AGGR_FUNCTION,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_BASE_MEAS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"."OWNER" IS 'Owner of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"."ANALYTIC_VIEW_NAME" IS 'Name of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"."MEASURE_NAME" IS 'Name of the analytic view base measure';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"."TABLE_ALIAS" IS 'Alias of the table or view in the USING clause to which the column belongs';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"."COLUMN_NAME" IS 'Column name in the table or view on which this measure is defined';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"."AGGR_FUNCTION" IS 'Aggregation expression specified for this measure, or NULL if not specified';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"."ORDER_NUM" IS 'Order number of the base measure within the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_BASE_MEAS"  IS 'Analytic view base measures in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_CALC_MEAS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_CALC_MEAS" ("OWNER", "ANALYTIC_VIEW_NAME", "MEASURE_NAME", "MEAS_EXPRESSION", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       ANALYTIC_VIEW_NAME,
       MEASURE_NAME,
       MEAS_EXPRESSION,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_CALC_MEAS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CALC_MEAS"."OWNER" IS 'Owner of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CALC_MEAS"."ANALYTIC_VIEW_NAME" IS 'Name of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CALC_MEAS"."MEASURE_NAME" IS 'Name of the analytic view calculated measure';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CALC_MEAS"."MEAS_EXPRESSION" IS 'Text of the expression';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CALC_MEAS"."ORDER_NUM" IS 'Order number of the calculated measure within the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CALC_MEAS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_CALC_MEAS"  IS 'Analytic view calculated measures in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_CLASS" ("OWNER", "ANALYTIC_VIEW_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       analytic_view_name,
       classification,
       value,
       language,
       order_num,
       origin_con_id
from INT$DBA_AVIEW_CLASS
where  OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CLASS"."OWNER" IS 'Owner of the analytic view classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CLASS"."ANALYTIC_VIEW_NAME" IS 'analytic view  name of owning analytic view classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CLASS"."CLASSIFICATION" IS 'Name of analytic view classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CLASS"."VALUE" IS 'Value of analytic view classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CLASS"."LANGUAGE" IS 'Language of analytic view classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CLASS"."ORDER_NUM" IS 'Order number of analytic view classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_CLASS"  IS 'Analytic view classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_COLUMNS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_NAME", "HIER_NAME", "COLUMN_NAME", "ROLE", "DATA_TYPE", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "NULLABLE", "CHARACTER_SET_NAME", "CHAR_COL_DECL_LENGTH", "CHAR_USED", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       ANALYTIC_VIEW_NAME,
       DIMENSION_NAME,
       HIER_NAME,
       COLUMN_NAME,
       ROLE,
       DATA_TYPE,
       DATA_LENGTH,
       DATA_PRECISION,
       DATA_SCALE,
       NULLABLE,
       CHARACTER_SET_NAME,
       CHAR_COL_DECL_LENGTH,
       CHAR_USED,
       --DATA_TYPE_MOD,
       --DATA_TYPE_OWNER,
       --CHAR_LENGTH,
       --COLLATION,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_COLUMNS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."OWNER" IS 'Owner of analytic view column';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."ANALYTIC_VIEW_NAME" IS 'Name of the owning analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."DIMENSION_NAME" IS 'Alias of the dimension in the analytic view (MEASURES for measures)';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."HIER_NAME" IS 'Alias of the hierarchy within DIM_NAME in the analytic view (MEASURES for measures)';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."ROLE" IS 'The role the attribute plays in the analytic view.  One of: KEY, AKEY, PROP, HIER,
 or MEAS';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."DATA_TYPE" IS 'Datatype of the column';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."DATA_LENGTH" IS 'Length of the column (in bytes)';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."DATA_PRECISION" IS 'Decimal precision for NUMBER datatype; binary precision for
 FLOAT datatype, NULL for all other datatypes';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."DATA_SCALE" IS 'Digits to right of decimal point in a number';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."NULLABLE" IS 'Does column allow NULL values?';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."CHARACTER_SET_NAME" IS 'Name of the character set: CHAR_CS or NCHAR_CS';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."CHAR_COL_DECL_LENGTH" IS 'Declaration length of character type column';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."CHAR_USED" IS 'B or C.  B indicates that the column uses BYTE length semantics.
 C indicates that the column uses CHAR length semantics. NULL indicates
 the datatype is not any of the following: CHAR, VARCHAR2, NCHAR, NVARCHAR2';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."ORDER_NUM" IS 'Order of the column, with the hierarchy columns first followed by measure
 columns.  The columns for a given hierarchy are grouped together, with the
 ordering of the hierarchies determined by dimension/hierarchy order as created.
 Within a given hierarchy, attributes are listed first in order created
 followed by hierarchical attributes';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_COLUMNS"  IS 'Analytic view columns in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_DIM_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_ALIAS", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       ANALYTIC_VIEW_NAME,
       DIMENSION_ALIAS,
       CLASSIFICATION,
       VALUE,
       language,
       order_num,
       origin_con_id
from INT$DBA_AVIEW_DIM_CLASS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"."OWNER" IS 'Owner of the analytic view dimension';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"."ANALYTIC_VIEW_NAME" IS 'Name of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"."DIMENSION_ALIAS" IS 'Alias of the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"."CLASSIFICATION" IS 'Name of analytic view dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"."VALUE" IS 'Value of analytic view dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"."LANGUAGE" IS 'Language of analytic view dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"."ORDER_NUM" IS 'Order of the classification in the list of classifications
 associated with the dimension key';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_DIM_CLASS"  IS 'Classifications of the analytic view dimensions in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_DIMENSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_OWNER", "DIMENSION_NAME", "DIMENSION_ALIAS", "DIMENSION_TYPE", "ALL_MEMBER_NAME", "ALL_MEMBER_CAPTION", "ALL_MEMBER_DESCRIPTION", "REFERENCES_DISTINCT", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       ANALYTIC_VIEW_NAME,
       DIMENSION_OWNER,
       DIMENSION_NAME,
       DIMENSION_ALIAS,
       --DECODE(avd.leaves_only, 1, 'LEAVES ONLY') LEAVES_ONLY,
       DIMENSION_TYPE,
       ALL_MEMBER_NAME,
       ALL_MEMBER_CAPTION,
       ALL_MEMBER_DESCRIPTION,
       REFERENCES_DISTINCT,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_DIMENSIONS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."OWNER" IS 'Owner of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."ANALYTIC_VIEW_NAME" IS 'Name of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."DIMENSION_OWNER" IS 'Owner of the base attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."DIMENSION_NAME" IS 'Name of the base attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."DIMENSION_ALIAS" IS 'Alias of the base analytic view dimension';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."DIMENSION_TYPE" IS 'Type of the base analytic view dimension, either TIME or STANDARD';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."ALL_MEMBER_NAME" IS 'Name of the ALL member';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."ALL_MEMBER_CAPTION" IS 'Caption of the ALL member, or NULL if not specified';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."ALL_MEMBER_DESCRIPTION" IS 'Description of the ALL member, or NULL if not specified';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."REFERENCES_DISTINCT" IS 'Does this dimension fact key reference distinct values of the hierarchy?';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."ORDER_NUM" IS 'Order number of analytic view Dimension';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_DIMENSIONS"  IS 'Analytic view Dimensions in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_HIER_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_ALIAS", "HIER_ALIAS", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       ANALYTIC_VIEW_NAME,
       DIMENSION_ALIAS,
       HIER_ALIAS,
       CLASSIFICATION,
       VALUE,
       language,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_HIER_CLASS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."OWNER" IS 'Owner of the analytic view hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."ANALYTIC_VIEW_NAME" IS 'Name of analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."DIMENSION_ALIAS" IS 'Alias of the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."HIER_ALIAS" IS 'Alias of the hierarchy within the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."CLASSIFICATION" IS 'Name of analytic view hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."VALUE" IS 'Value of hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."LANGUAGE" IS 'Language of hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."ORDER_NUM" IS 'Order number of hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_HIER_CLASS"  IS 'Analytic view hierarchy classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_HIERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_HIERS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_ALIAS", "HIER_OWNER", "HIER_NAME", "HIER_ALIAS", "IS_DEFAULT", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       ANALYTIC_VIEW_NAME,
       DIMENSION_ALIAS,
       HIER_OWNER,
       HIER_NAME,
       HIER_ALIAS,
       IS_DEFAULT,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_HIERS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."OWNER" IS 'Owner of analytic view hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."ANALYTIC_VIEW_NAME" IS 'Name of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."DIMENSION_ALIAS" IS 'Alias of the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."HIER_OWNER" IS 'Owner of the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."HIER_NAME" IS 'Name of the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."HIER_ALIAS" IS 'Alias specified for the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."IS_DEFAULT" IS 'Y if this is the default hierarchy for the dimension in the analytic view, N otherwise';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."ORDER_NUM" IS 'Order of the hierarchy within the list of hierarchies for the
 dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_HIERS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_HIERS"  IS 'Analytic view hierarchies in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_KEYS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_KEYS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_ALIAS", "AV_KEY_TABLE_ALIAS", "AV_KEY_COLUMN", "REF_DIMENSION_ATTR", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       ANALYTIC_VIEW_NAME,
       DIMENSION_ALIAS,
       AV_KEY_TABLE_ALIAS,
       AV_KEY_COLUMN,
       REF_DIMENSION_ATTR,
       ORDER_NUM,
       ORIGIN_CON_ID
from  INT$DBA_AVIEW_KEYS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_KEYS"."OWNER" IS 'Owner of analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_KEYS"."ANALYTIC_VIEW_NAME" IS 'Name of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_KEYS"."DIMENSION_ALIAS" IS 'Alias of the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_KEYS"."AV_KEY_TABLE_ALIAS" IS 'Table alias of the analytic view key column';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_KEYS"."AV_KEY_COLUMN" IS 'Name of the column for the analytic view key';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_KEYS"."REF_DIMENSION_ATTR" IS 'Name of the referenced dimension attribute';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_KEYS"."ORDER_NUM" IS 'Order number of the key in the list';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_KEYS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_KEYS"  IS 'Analytic view keys in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_LEVEL_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_ALIAS", "HIER_ALIAS", "LEVEL_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       ANALYTIC_VIEW_NAME,
       DIMENSION_ALIAS,
       HIER_ALIAS,
       LEVEL_NAME,
       CLASSIFICATION,
       VALUE,
       language,
       ORDER_NUM,
       origin_con_id
from INT$DBA_AVIEW_LEVEL_CLASS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."OWNER" IS 'Owner of the analytic view level classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."ANALYTIC_VIEW_NAME" IS 'Name of analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."DIMENSION_ALIAS" IS 'Alias of the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."HIER_ALIAS" IS 'Alias of the hierarchy within the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."LEVEL_NAME" IS 'Name of the level within the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."CLASSIFICATION" IS 'Name of analytic view level classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."VALUE" IS 'Value of level classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."LANGUAGE" IS 'Language of level classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."ORDER_NUM" IS 'Order number of level classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_LEVEL_CLASS"  IS 'analytic view level classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_LEVELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_LEVELS" ("OWNER", "ANALYTIC_VIEW_NAME", "DIMENSION_ALIAS", "HIER_ALIAS", "LEVEL_NAME", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       ANALYTIC_VIEW_NAME,
       DIMENSION_ALIAS,
       HIER_ALIAS,
       LEVEL_NAME,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_LEVELS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVELS"."OWNER" IS 'Owner of the analytic view level';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVELS"."ANALYTIC_VIEW_NAME" IS 'Name of analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVELS"."DIMENSION_ALIAS" IS 'Alias of the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVELS"."HIER_ALIAS" IS 'Alias of the hierarchy within the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVELS"."LEVEL_NAME" IS 'Name of the level within the attribute dimension in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVELS"."ORDER_NUM" IS 'Order number of analytic view level';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LEVELS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_LEVELS"  IS 'Analytic view levels in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_LVLGRPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS" ("OWNER", "ANALYTIC_VIEW_NAME", "CACHE_TYPE", "DIMENSION_ALIAS", "HIER_ALIAS", "LEVEL_NAME", "MEASURE_NAME", "AV_LVLGRP_ORDER", "LEVEL_MEAS_ORDER", "ORIGIN_CON_ID") AS 
  select owner,
       ANALYTIC_VIEW_NAME,
       CACHE_TYPE,
       DIMENSION_ALIAS,
       HIER_ALIAS,
       LEVEL_NAME,
       MEASURE_NAME,
       AV_LVLGRP_ORDER,
       LEVEL_MEAS_ORDER,
       ORIGIN_CON_ID
from INT$DBA_AVIEW_LVLGRPS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."OWNER" IS 'Owner of the analytic view level grouping';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."ANALYTIC_VIEW_NAME" IS 'Name of analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."CACHE_TYPE" IS 'Materialized View name associated to this level group';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."DIMENSION_ALIAS" IS 'Alias of the attribute dimension in the level grouping';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."HIER_ALIAS" IS 'Alias of the hierarchy within the attribute dimension in the level grouping';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."LEVEL_NAME" IS 'Name of the level within the hierarchy in the level grouping';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."MEASURE_NAME" IS 'Measure Name within this measure list';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."AV_LVLGRP_ORDER" IS 'Order of the level groups in the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."LEVEL_MEAS_ORDER" IS 'Order of the levels/measures in the level group';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_LVLGRPS"  IS 'Level groupings for an analytic view'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEW_MEAS_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS" ("OWNER", "ANALYTIC_VIEW_NAME", "MEASURE_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       analytic_view_name,
       measure_name,
       classification,
       value,
       language,
       order_num,
       origin_con_id
from INT$DBA_AVIEW_MEAS_CLASS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"."OWNER" IS 'Owner of the analytic view measure classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"."ANALYTIC_VIEW_NAME" IS 'Name of owning analytic view of the measure';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"."MEASURE_NAME" IS 'Name of owning measure of the classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"."CLASSIFICATION" IS 'Name of analytic view measure classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"."VALUE" IS 'Value of analytic view measure classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"."LANGUAGE" IS 'Language of analytic view measure classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"."ORDER_NUM" IS 'Order number of analytic view measure classification';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEW_MEAS_CLASS"  IS 'Analytic view measure classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ANALYTIC_VIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ANALYTIC_VIEWS" ("OWNER", "ANALYTIC_VIEW_NAME", "TABLE_OWNER", "TABLE_NAME", "TABLE_ALIAS", "DEFAULT_AGGR", "DEFAULT_MEASURE", "COMPILE_STATE", "DYN_ALL_CACHE", "ORIGIN_CON_ID") AS 
  select OWNER,
       ANALYTIC_VIEW_NAME,
       TABLE_OWNER,
       TABLE_NAME,
       TABLE_ALIAS,
       DEFAULT_AGGR,
       DEFAULT_MEASURE,
       COMPILE_STATE,
       DYN_ALL_CACHE,
       ORIGIN_CON_ID
from INT$DBA_AVIEWS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, ANALYTIC_VIEW_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."OWNER" IS 'Owner of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."ANALYTIC_VIEW_NAME" IS 'Name of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."TABLE_OWNER" IS 'Owner of the fact table or view on which the analytic view is defined';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."TABLE_NAME" IS 'Name of the fact table or view on which the analytic view is defined';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."TABLE_ALIAS" IS 'Alias of the fact table or view on which the analytic view is defined';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."DEFAULT_AGGR" IS 'Default aggregation of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."DEFAULT_MEASURE" IS 'Name of the default measure of the analytic view';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."COMPILE_STATE" IS 'Compile state of the analytic view: N/A, VALID, or INVALID';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."DYN_ALL_CACHE" IS 'Is cache dynamic across all levels enabled: Y or N';
   COMMENT ON COLUMN "SYS"."ALL_ANALYTIC_VIEWS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ANALYTIC_VIEWS"  IS 'Analytic views in the database'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY" ("APPLY_NAME", "QUEUE_NAME", "QUEUE_OWNER", "APPLY_CAPTURED", "RULE_SET_NAME", "RULE_SET_OWNER", "APPLY_USER", "APPLY_DATABASE_LINK", "APPLY_TAG", "DDL_HANDLER", "PRECOMMIT_HANDLER", "MESSAGE_HANDLER", "STATUS", "MAX_APPLIED_MESSAGE_NUMBER", "NEGATIVE_RULE_SET_NAME", "NEGATIVE_RULE_SET_OWNER", "STATUS_CHANGE_TIME", "ERROR_NUMBER", "ERROR_MESSAGE", "MESSAGE_DELIVERY_MODE", "PURPOSE", "LCRID_VERSION") AS 
  select a."APPLY_NAME",a."QUEUE_NAME",a."QUEUE_OWNER",a."APPLY_CAPTURED",a."RULE_SET_NAME",a."RULE_SET_OWNER",a."APPLY_USER",a."APPLY_DATABASE_LINK",a."APPLY_TAG",a."DDL_HANDLER",a."PRECOMMIT_HANDLER",a."MESSAGE_HANDLER",a."STATUS",a."MAX_APPLIED_MESSAGE_NUMBER",a."NEGATIVE_RULE_SET_NAME",a."NEGATIVE_RULE_SET_OWNER",a."STATUS_CHANGE_TIME",a."ERROR_NUMBER",a."ERROR_MESSAGE",a."MESSAGE_DELIVERY_MODE",a."PURPOSE",a."LCRID_VERSION"
  from dba_apply a, all_queues q
 where a.queue_name = q.name
   and a.queue_owner = q.owner
   and ((a.rule_set_owner is null and a.rule_set_name is null) or
        ((a.rule_set_owner, a.rule_set_name) in
          (select r.rule_set_owner, r.rule_set_name
             from all_rule_sets r)))
   and ((a.negative_rule_set_owner is null and
         a.negative_rule_set_name is null) or
        ((a.negative_rule_set_owner, a.negative_rule_set_name) in
          (select r.rule_set_owner, r.rule_set_name
             from all_rule_sets r)));

   COMMENT ON COLUMN "SYS"."ALL_APPLY"."APPLY_NAME" IS 'Name of the apply process';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."QUEUE_NAME" IS 'Name of the queue the apply process dequeues from';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."QUEUE_OWNER" IS 'Owner of the queue the apply process dequeues from';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."APPLY_CAPTURED" IS 'Yes, if applying captured messages; No, if applying enqueued messages';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."RULE_SET_NAME" IS 'Rule set used by apply process for filtering';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."APPLY_USER" IS 'Current user who is applying the messages';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."APPLY_DATABASE_LINK" IS 'For remote objects, the database link pointing to the remote database';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."APPLY_TAG" IS 'Tag associated with DDL and DML change records that will be applied';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."DDL_HANDLER" IS 'Name of the user specified ddl handler';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."PRECOMMIT_HANDLER" IS 'Name of the user specified precommit handler';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."MESSAGE_HANDLER" IS 'User specified procedure to handle messages other than DDL and DML messages';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."STATUS" IS 'Status of the apply process: DISABLED, ENABLED, ABORTED';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."MAX_APPLIED_MESSAGE_NUMBER" IS 'Maximum value of message that has been applied';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."NEGATIVE_RULE_SET_NAME" IS 'Negative rule set used by apply process for filtering';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."NEGATIVE_RULE_SET_OWNER" IS 'Owner of the negative rule set';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."STATUS_CHANGE_TIME" IS 'The time that STATUS of the apply process was changed';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."ERROR_NUMBER" IS 'Error number if the apply process was aborted';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."ERROR_MESSAGE" IS 'Error message if the apply process was aborted';
   COMMENT ON COLUMN "SYS"."ALL_APPLY"."PURPOSE" IS 'Purpose of this apply process ';
   COMMENT ON TABLE "SYS"."ALL_APPLY"  IS 'Details about each apply process that dequeues from the queue visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_CHANGE_HANDLERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_CHANGE_HANDLERS" ("CHANGE_TABLE_OWNER", "CHANGE_TABLE_NAME", "SOURCE_TABLE_OWNER", "SOURCE_TABLE_NAME", "HANDLER_NAME", "CAPTURE_VALUES", "APPLY_NAME", "OPERATION_NAME", "CREATION_TIME", "MODIFICATION_TIME") AS 
  select c."CHANGE_TABLE_OWNER",c."CHANGE_TABLE_NAME",c."SOURCE_TABLE_OWNER",c."SOURCE_TABLE_NAME",c."HANDLER_NAME",c."CAPTURE_VALUES",c."APPLY_NAME",c."OPERATION_NAME",c."CREATION_TIME",c."MODIFICATION_TIME"
  from DBA_APPLY_CHANGE_HANDLERS c, all_apply a
  where c.apply_name = a.apply_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."CHANGE_TABLE_OWNER" IS 'Owner of change table';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."CHANGE_TABLE_NAME" IS 'Name of change table';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."SOURCE_TABLE_OWNER" IS 'Owner of source table';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."SOURCE_TABLE_NAME" IS 'Name of source table';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."HANDLER_NAME" IS 'Name of statement-based change handler';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."CAPTURE_VALUES" IS 'Type of value to capture';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."APPLY_NAME" IS 'Name of apply process';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."OPERATION_NAME" IS 'Name of DML operation to which the DML handler is set';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."CREATION_TIME" IS 'Chang handler creation time';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CHANGE_HANDLERS"."MODIFICATION_TIME" IS 'Chang handler modification time';
   COMMENT ON TABLE "SYS"."ALL_APPLY_CHANGE_HANDLERS"  IS 'Details about apply change handler'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_CONFLICT_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_CONFLICT_COLUMNS" ("OBJECT_OWNER", "OBJECT_NAME", "METHOD_NAME", "RESOLUTION_COLUMN", "COLUMN_NAME", "APPLY_DATABASE_LINK") AS 
  select c.object_owner, c.object_name, c.method_name,
       c.resolution_column, c.column_name, c.apply_database_link
  from all_tab_columns o, dba_apply_conflict_columns c
 where c.object_owner = o.owner
   and c.object_name = o.table_name
   and c.column_name = o.column_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_CONFLICT_COLUMNS"."OBJECT_OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CONFLICT_COLUMNS"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CONFLICT_COLUMNS"."METHOD_NAME" IS 'Name of the method used to resolve conflict';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CONFLICT_COLUMNS"."RESOLUTION_COLUMN" IS 'Name of the column used to resolve conflict';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CONFLICT_COLUMNS"."COLUMN_NAME" IS 'Name of the column that is to be considered as part of a group to resolve conflict';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_CONFLICT_COLUMNS"."APPLY_DATABASE_LINK" IS 'For remote objects, name of database link pointing to remote database';
   COMMENT ON TABLE "SYS"."ALL_APPLY_CONFLICT_COLUMNS"  IS 'Details about conflict resolution on tables visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_DML_CONF_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_DML_CONF_COLUMNS" ("APPLY_NAME", "CONFLICT_HANDLER_NAME", "COLUMN_NAME") AS 
  select c."APPLY_NAME",c."CONFLICT_HANDLER_NAME",c."COLUMN_NAME"
from ALL_APPLY_DML_CONF_HANDLERS h, DBA_APPLY_DML_CONF_COLUMNS c
where c.apply_name = h.apply_name
      and c.conflict_handler_name = h.conflict_handler_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_COLUMNS"."APPLY_NAME" IS 'Name of the apply process';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_COLUMNS"."CONFLICT_HANDLER_NAME" IS 'Name of the conflict handler';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_COLUMNS"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON TABLE "SYS"."ALL_APPLY_DML_CONF_COLUMNS"  IS 'Details about dml conflict handler column groups on objects visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_DML_CONF_HANDLERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_DML_CONF_HANDLERS" ("APPLY_NAME", "OBJECT_OWNER", "OBJECT_NAME", "SOURCE_OBJECT_OWNER", "SOURCE_OBJECT_NAME", "COMMAND_TYPE", "CONFLICT_TYPE", "METHOD_NAME", "CONFLICT_HANDLER_NAME", "RESOLUTION_COLUMN", "SET_BY") AS 
  select h."APPLY_NAME",h."OBJECT_OWNER",h."OBJECT_NAME",h."SOURCE_OBJECT_OWNER",h."SOURCE_OBJECT_NAME",h."COMMAND_TYPE",h."CONFLICT_TYPE",h."METHOD_NAME",h."CONFLICT_HANDLER_NAME",h."RESOLUTION_COLUMN",h."SET_BY"
from all_tables o, all_apply a, DBA_APPLY_DML_CONF_HANDLERS h
where h.object_owner = o.owner and h.object_name = o.table_name and
      a.apply_name = h.apply_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."APPLY_NAME" IS 'Name of the apply process';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."OBJECT_OWNER" IS 'Owner of the target object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."OBJECT_NAME" IS 'Name of the target object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."SOURCE_OBJECT_OWNER" IS 'Owner of the source object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."SOURCE_OBJECT_NAME" IS 'Name of the source object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."COMMAND_TYPE" IS 'Type of the DML operation';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."CONFLICT_TYPE" IS 'Description of the conflict';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."METHOD_NAME" IS 'Description of the conflict handling method';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."CONFLICT_HANDLER_NAME" IS 'Name of the conflict handler';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."RESOLUTION_COLUMN" IS 'Name of the resolution column';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_CONF_HANDLERS"."SET_BY" IS 'Entity that set up the handler: USER, GOLDENGATE';
   COMMENT ON TABLE "SYS"."ALL_APPLY_DML_CONF_HANDLERS"  IS 'Details about dml conflict handlers on objects visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_DML_HANDLERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_DML_HANDLERS" ("OBJECT_OWNER", "OBJECT_NAME", "OPERATION_NAME", "USER_PROCEDURE", "ERROR_HANDLER", "APPLY_DATABASE_LINK", "APPLY_NAME", "ASSEMBLE_LOBS", "SET_BY") AS 
  select h.object_owner, h.object_name, h.operation_name,
       h.user_procedure, h.error_handler, h.apply_database_link, h.apply_name,
       h.assemble_lobs, h.set_by
  from all_tables o, dba_apply_dml_handlers h
 where h.object_owner = o.owner
   and h.object_name = o.table_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."OBJECT_OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."OPERATION_NAME" IS 'Name of the DML operation';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."USER_PROCEDURE" IS 'Name of the DML handler specified by the user';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."ERROR_HANDLER" IS 'Y if the user procedure is the error handler, N if it is the DML handler';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."APPLY_DATABASE_LINK" IS 'For remote objects, name of database link pointing to remote database';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."APPLY_NAME" IS 'Name of the apply process for the given object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."ASSEMBLE_LOBS" IS 'Y if LOBs should be assembled in DML or error handler';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_DML_HANDLERS"."SET_BY" IS 'Entity that set up the handler: USER, GOLDENGATE';
   COMMENT ON TABLE "SYS"."ALL_APPLY_DML_HANDLERS"  IS 'Details about the dml handler on tables visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_ENQUEUE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_ENQUEUE" ("RULE_OWNER", "RULE_NAME", "DESTINATION_QUEUE_NAME") AS 
  select e."RULE_OWNER",e."RULE_NAME",e."DESTINATION_QUEUE_NAME"
from dba_apply_enqueue e, ALL_RULES r, ALL_QUEUES aq
where e.rule_owner = r.rule_owner and e.rule_name = r.rule_name
  and e.destination_queue_name = '"'||aq.owner||'"' ||'.'|| '"'||aq.name||'"';

   COMMENT ON COLUMN "SYS"."ALL_APPLY_ENQUEUE"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ENQUEUE"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ENQUEUE"."DESTINATION_QUEUE_NAME" IS 'Name of the queue where events satisfying the rule will be enqueued';
   COMMENT ON TABLE "SYS"."ALL_APPLY_ENQUEUE"  IS 'Details about the apply enqueue action for user accessible rules where the destination queue exists and is visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_ERROR
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_ERROR" ("APPLY_NAME", "QUEUE_NAME", "QUEUE_OWNER", "LOCAL_TRANSACTION_ID", "SOURCE_DATABASE", "SOURCE_TRANSACTION_ID", "SOURCE_COMMIT_SCN", "MESSAGE_NUMBER", "ERROR_NUMBER", "ERROR_MESSAGE", "RECIPIENT_ID", "RECIPIENT_NAME", "MESSAGE_COUNT", "ERROR_CREATION_TIME", "SOURCE_COMMIT_POSITION", "ERROR_TYPE", "SOURCE_ROOT_NAME", "ERROR_POSITION") AS 
  (
select e.apply_name, e.queue_name, e.queue_owner, e.local_transaction_id,
       e.source_database, e.source_transaction_id,
       e.source_commit_scn, e.message_number, e.error_number,
       e.error_message, e.recipient_id, e.recipient_name, e.message_count,
       e.error_creation_time, e.source_commit_position,
       e.error_type, e.source_root_name, e.error_position
  from dba_apply_error e, all_users u, all_queues q
 where e.recipient_id = u.user_id
   and q.name = e.queue_name
   and q.owner = e.queue_owner
union all
select e.apply_name, e.queue_name, e.queue_owner, e.local_transaction_id,
       e.source_database, e.source_transaction_id,
       e.source_commit_scn, e.message_number, e.error_number,
       e.error_message, e.recipient_id, e.recipient_name, e.message_count,
       e.error_creation_time, e.source_commit_position,
       e.error_type, e.source_root_name, e.error_position
  from dba_apply_error e
 where e.recipient_id NOT IN (select user_id from dba_users));

   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."APPLY_NAME" IS 'Name of the apply process at the local site which processed the transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."QUEUE_NAME" IS 'Name of the queue at the local site where the transaction came from';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."QUEUE_OWNER" IS 'Owner of the queue at the local site where the transaction came from';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."LOCAL_TRANSACTION_ID" IS 'Local transaction ID for the error creation transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."SOURCE_DATABASE" IS 'Database where the transaction originated';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."SOURCE_TRANSACTION_ID" IS 'Original transaction ID at the source database';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."SOURCE_COMMIT_SCN" IS 'Original commit SCN for the transaction at the source database';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."MESSAGE_NUMBER" IS 'Identifier for the message in the transaction that raised an error';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."ERROR_NUMBER" IS 'Error number';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."ERROR_MESSAGE" IS 'Error message';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."RECIPIENT_ID" IS 'User ID of the original recipient';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."RECIPIENT_NAME" IS 'Name of the original recipient';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."MESSAGE_COUNT" IS 'Total number of messages inside the error transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."ERROR_CREATION_TIME" IS 'The time that this error occurred';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."SOURCE_COMMIT_POSITION" IS 'Original commit position for the transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."ERROR_TYPE" IS 'The type of the error transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."SOURCE_ROOT_NAME" IS 'Root Database where the transaction originated';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR"."ERROR_POSITION" IS 'Position of the LCR that encountered the error';
   COMMENT ON TABLE "SYS"."ALL_APPLY_ERROR"  IS 'Error transactions that were generated after dequeuing from the queue visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_ERROR_MESSAGES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_ERROR_MESSAGES" ("MESSAGE_ID", "LOCAL_TRANSACTION_ID", "TRANSACTION_MESSAGE_NUMBER", "ERROR_NUMBER", "ERROR_MESSAGE", "SOURCE_OBJECT_OWNER", "SOURCE_OBJECT_NAME", "OBJECT_OWNER", "OBJECT_NAME", "PRIMARY_KEY", "POSITION", "OPERATION", "CONFLICT_TYPE", "APPLIED_STATE", "SEQ#", "RBA", "CONFLICT_INFO", "SOURCE_PACKAGE_NAME", "PACKAGE_NAME", "MESSAGE") AS 
  select t."MESSAGE_ID",t."LOCAL_TRANSACTION_ID",t."TRANSACTION_MESSAGE_NUMBER",t."ERROR_NUMBER",t."ERROR_MESSAGE",t."SOURCE_OBJECT_OWNER",t."SOURCE_OBJECT_NAME",t."OBJECT_OWNER",t."OBJECT_NAME",t."PRIMARY_KEY",t."POSITION",t."OPERATION",t."CONFLICT_TYPE",t."APPLIED_STATE",t."SEQ#",t."RBA",t."CONFLICT_INFO",t."SOURCE_PACKAGE_NAME",t."PACKAGE_NAME",t."MESSAGE"
from DBA_APPLY_ERROR_MESSAGES t, all_apply_error e
where t.local_transaction_id = e.local_transaction_id ;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."MESSAGE_ID" IS 'AQ message ID for a message stored in the AQ exception queue';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."LOCAL_TRANSACTION_ID" IS 'Local transaction ID for the error creation transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."TRANSACTION_MESSAGE_NUMBER" IS 'Identifier for the message in the transaction that raised an error';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."ERROR_NUMBER" IS 'Error number';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."ERROR_MESSAGE" IS 'Error message';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."SOURCE_OBJECT_OWNER" IS 'Owner of the object at the source database';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."SOURCE_OBJECT_NAME" IS 'Name of the object at the source database';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."OBJECT_OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."PRIMARY_KEY" IS 'Primary key information';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."POSITION" IS 'Position information';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."OPERATION" IS 'Message operation';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."CONFLICT_TYPE" IS 'Conflict type';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."APPLIED_STATE" IS 'Conflict applied state';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."SEQ#" IS 'GoldenGate trail sequence number';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."RBA" IS 'GoldenGate trail rba';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."CONFLICT_INFO" IS 'Conflict resolution information';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_ERROR_MESSAGES"."MESSAGE" IS 'Message content';
   COMMENT ON TABLE "SYS"."ALL_APPLY_ERROR_MESSAGES"  IS 'Details about individual messages in an error transaction'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_EXECUTE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_EXECUTE" ("RULE_OWNER", "RULE_NAME", "EXECUTE_EVENT") AS 
  select e."RULE_OWNER",e."RULE_NAME",e."EXECUTE_EVENT"
from dba_apply_execute e, ALL_RULES r
where e.rule_owner = r.rule_owner and e.rule_name = r.rule_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_EXECUTE"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_EXECUTE"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_EXECUTE"."EXECUTE_EVENT" IS 'Whether the event satisfying the rule is executed';
   COMMENT ON TABLE "SYS"."ALL_APPLY_EXECUTE"  IS 'Details about the apply execute action for all rules visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_HANDLE_COLLISIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_HANDLE_COLLISIONS" ("APPLY_NAME", "OBJECT_OWNER", "OBJECT_NAME", "SOURCE_OBJECT_OWNER", "SOURCE_OBJECT_NAME", "ENABLED", "SET_BY") AS 
  select hc."APPLY_NAME",hc."OBJECT_OWNER",hc."OBJECT_NAME",hc."SOURCE_OBJECT_OWNER",hc."SOURCE_OBJECT_NAME",hc."ENABLED",hc."SET_BY"
from DBA_APPLY_HANDLE_COLLISIONS hc, ALL_APPLY a, all_tables t
where hc.apply_name = a.apply_name and hc.object_owner = t.owner
      and hc.object_name = t.table_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_HANDLE_COLLISIONS"."APPLY_NAME" IS 'Name of the apply process';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_HANDLE_COLLISIONS"."OBJECT_OWNER" IS 'Owner of the target object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_HANDLE_COLLISIONS"."OBJECT_NAME" IS 'Name of the target object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_HANDLE_COLLISIONS"."SOURCE_OBJECT_OWNER" IS 'Owner of the source object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_HANDLE_COLLISIONS"."SOURCE_OBJECT_NAME" IS 'Name of the source object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_HANDLE_COLLISIONS"."ENABLED" IS 'State of the collision handlers';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_HANDLE_COLLISIONS"."SET_BY" IS 'Entity that set up the handler: USER, GOLDENGATE';
   COMMENT ON TABLE "SYS"."ALL_APPLY_HANDLE_COLLISIONS"  IS 'Details about apply collision handlers on objects visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_INSTANTIATED_GLOBAL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_INSTANTIATED_GLOBAL" ("SOURCE_DATABASE", "INSTANTIATION_SCN", "APPLY_DATABASE_LINK", "SOURCE_ROOT_NAME") AS 
  select aig."SOURCE_DATABASE",aig."INSTANTIATION_SCN",aig."APPLY_DATABASE_LINK",aig."SOURCE_ROOT_NAME"
  from DBA_APPLY_INSTANTIATED_GLOBAL aig, ALL_APPLY aa
  where aa.apply_database_link = aig.apply_database_link;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_GLOBAL"."SOURCE_DATABASE" IS 'Name of the database that was instantiated';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_GLOBAL"."INSTANTIATION_SCN" IS 'Point in time when the database was instantiated at source';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_GLOBAL"."APPLY_DATABASE_LINK" IS 'For a remote database, the database link pointing to the remote database';
   COMMENT ON TABLE "SYS"."ALL_APPLY_INSTANTIATED_GLOBAL"  IS 'Details about database instantiated for the user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_INSTANTIATED_OBJECTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS" ("SOURCE_DATABASE", "SOURCE_OBJECT_OWNER", "SOURCE_OBJECT_NAME", "SOURCE_OBJECT_TYPE", "INSTANTIATION_SCN", "IGNORE_SCN", "APPLY_DATABASE_LINK", "SOURCE_ROOT_NAME") AS 
  select aio."SOURCE_DATABASE",aio."SOURCE_OBJECT_OWNER",aio."SOURCE_OBJECT_NAME",aio."SOURCE_OBJECT_TYPE",aio."INSTANTIATION_SCN",aio."IGNORE_SCN",aio."APPLY_DATABASE_LINK",aio."SOURCE_ROOT_NAME"
  from DBA_APPLY_INSTANTIATED_OBJECTS aio, ALL_APPLY aa
  where aa.apply_database_link = aio.apply_database_link;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS"."SOURCE_DATABASE" IS 'Name of the database where the objects originated';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS"."SOURCE_OBJECT_OWNER" IS 'Owner of the object at the source database';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS"."SOURCE_OBJECT_NAME" IS 'Name of the object at source';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS"."SOURCE_OBJECT_TYPE" IS 'Type of the object at source';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS"."INSTANTIATION_SCN" IS 'Point in time when the object was instantiated at source';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS"."IGNORE_SCN" IS 'SCN lower bound for messages that will be considered for apply';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS"."APPLY_DATABASE_LINK" IS 'For remote objects, the database link pointing to the remote database';
   COMMENT ON TABLE "SYS"."ALL_APPLY_INSTANTIATED_OBJECTS"  IS 'Details about objects instantiated for the user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_INSTANTIATED_SCHEMAS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_INSTANTIATED_SCHEMAS" ("SOURCE_DATABASE", "SOURCE_SCHEMA", "INSTANTIATION_SCN", "APPLY_DATABASE_LINK", "SOURCE_ROOT_NAME") AS 
  select ais."SOURCE_DATABASE",ais."SOURCE_SCHEMA",ais."INSTANTIATION_SCN",ais."APPLY_DATABASE_LINK",ais."SOURCE_ROOT_NAME"
  from DBA_APPLY_INSTANTIATED_SCHEMAS ais, ALL_APPLY aa
  where aa.apply_database_link = ais.apply_database_link;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_SCHEMAS"."SOURCE_DATABASE" IS 'Name of the database where the schemas originated';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_SCHEMAS"."INSTANTIATION_SCN" IS 'Point in time when the schema was instantiated at source';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_INSTANTIATED_SCHEMAS"."APPLY_DATABASE_LINK" IS 'For remote schemas, the database link pointing to the remote database';
   COMMENT ON TABLE "SYS"."ALL_APPLY_INSTANTIATED_SCHEMAS"  IS 'Details about schemas instantiated for the user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_KEY_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_KEY_COLUMNS" ("OBJECT_OWNER", "OBJECT_NAME", "COLUMN_NAME", "APPLY_DATABASE_LINK") AS 
  select k.object_owner, k.object_name, k.column_name, k.apply_database_link
  from all_tab_columns a, dba_apply_key_columns k
 where k.object_owner = a.owner
   and k.object_name = a.table_name
   and k.column_name = a.column_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_KEY_COLUMNS"."OBJECT_OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_KEY_COLUMNS"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_KEY_COLUMNS"."COLUMN_NAME" IS 'Column name of the object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_KEY_COLUMNS"."APPLY_DATABASE_LINK" IS 'Remote database link to which changes will be aplied';
   COMMENT ON TABLE "SYS"."ALL_APPLY_KEY_COLUMNS"  IS 'Alternative key columns for a STREAMS table visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_PARAMETERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_PARAMETERS" ("APPLY_NAME", "PARAMETER", "VALUE", "SET_BY_USER") AS 
  select pa.apply_name, pa.parameter, pa.value, pa.set_by_user
  from dba_apply_parameters pa, all_apply aa
 where pa.apply_name = aa.apply_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_PARAMETERS"."APPLY_NAME" IS 'Name of the apply process';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PARAMETERS"."PARAMETER" IS 'Name of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PARAMETERS"."VALUE" IS 'Either the default value or the value set by the user for the parameter';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PARAMETERS"."SET_BY_USER" IS 'YES if the value is set by the user, NO otherwise';
   COMMENT ON TABLE "SYS"."ALL_APPLY_PARAMETERS"  IS 'Details about parameters of each apply process that dequeues from the queue visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_PROGRESS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_PROGRESS" ("APPLY_NAME", "SOURCE_DATABASE", "APPLIED_MESSAGE_NUMBER", "OLDEST_MESSAGE_NUMBER", "APPLY_TIME", "APPLIED_MESSAGE_CREATE_TIME", "OLDEST_TRANSACTION_ID", "SPILL_MESSAGE_NUMBER", "SOURCE_ROOT_NAME") AS 
  select ap.apply_name, ap.source_database, ap.applied_message_number,
       ap.oldest_message_number, ap.apply_time, ap.applied_message_create_time,
       ap.oldest_transaction_id, ap.spill_message_number, ap.source_root_name
  from dba_apply_progress ap, all_apply a
 where ap.apply_name = a.apply_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."APPLY_NAME" IS 'Name of the apply process';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."SOURCE_DATABASE" IS 'Applying messages originating from this database';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."APPLIED_MESSAGE_NUMBER" IS 'All messages before this number have been successfully applied';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."OLDEST_MESSAGE_NUMBER" IS 'Earliest commit number of the transactions currently being applied';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."APPLY_TIME" IS 'Time at which the message was applied';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."APPLIED_MESSAGE_CREATE_TIME" IS 'Time at which the message to be applied was created';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."OLDEST_TRANSACTION_ID" IS 'Earliest transaction id currently being applied';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."SPILL_MESSAGE_NUMBER" IS 'Spill low water mark SCN';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_PROGRESS"."SOURCE_ROOT_NAME" IS 'Global name of the source root database';
   COMMENT ON TABLE "SYS"."ALL_APPLY_PROGRESS"  IS 'Information about the progress made by the apply process that dequeues from the queue visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_REPERROR_HANDLERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_REPERROR_HANDLERS" ("APPLY_NAME", "OBJECT_OWNER", "OBJECT_NAME", "SOURCE_OBJECT_OWNER", "SOURCE_OBJECT_NAME", "ERROR_NUMBER", "METHOD", "MAX_RETRIES", "DELAY_CSECS", "SET_BY") AS 
  select rh."APPLY_NAME",rh."OBJECT_OWNER",rh."OBJECT_NAME",rh."SOURCE_OBJECT_OWNER",rh."SOURCE_OBJECT_NAME",rh."ERROR_NUMBER",rh."METHOD",rh."MAX_RETRIES",rh."DELAY_CSECS",rh."SET_BY"
from DBA_APPLY_REPERROR_HANDLERS rh, ALL_APPLY a, all_tables t
where rh.apply_name = a.apply_name and rh.object_owner = t.owner
      and rh.object_name = t.table_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."APPLY_NAME" IS 'Name of the apply process';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."OBJECT_OWNER" IS 'Owner of the target object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."OBJECT_NAME" IS 'Name of the target object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."SOURCE_OBJECT_OWNER" IS 'Owner of the source object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."SOURCE_OBJECT_NAME" IS 'Name of the source object';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."ERROR_NUMBER" IS 'Error number for the handler';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."METHOD" IS 'Error handling method';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."MAX_RETRIES" IS 'Number of times to retry';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."DELAY_CSECS" IS 'Centiseconds to wait between retries';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_REPERROR_HANDLERS"."SET_BY" IS 'Entity that set up the handler: USER, GOLDENGATE';
   COMMENT ON TABLE "SYS"."ALL_APPLY_REPERROR_HANDLERS"  IS 'Details about apply reperror handlers on objects visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_SPILL_TXN
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_SPILL_TXN" ("APPLY_NAME", "XIDUSN", "XIDSLT", "XIDSQN", "PDB_ID", "FIRST_SCN", "MESSAGE_COUNT", "FIRST_MESSAGE_CREATE_TIME", "SPILL_CREATION_TIME", "FIRST_POSITION", "TRANSACTION_ID") AS 
  select ast."APPLY_NAME",ast."XIDUSN",ast."XIDSLT",ast."XIDSQN",ast."PDB_ID",ast."FIRST_SCN",ast."MESSAGE_COUNT",ast."FIRST_MESSAGE_CREATE_TIME",ast."SPILL_CREATION_TIME",ast."FIRST_POSITION",ast."TRANSACTION_ID"
  from DBA_APPLY_SPILL_TXN ast, ALL_APPLY aa
  where aa.apply_name = ast.apply_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."APPLY_NAME" IS 'Name of the apply that spilled the message';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."XIDUSN" IS 'Transaction ID undo segment number';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."XIDSLT" IS 'Transaction ID slot number';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."XIDSQN" IS 'Transaction ID sequence number';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."PDB_ID" IS 'PDB ID number';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."FIRST_SCN" IS 'SCN of first message in this transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."MESSAGE_COUNT" IS 'Number of messages spilled for this transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."FIRST_MESSAGE_CREATE_TIME" IS 'Source creation time of the first message in this transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."SPILL_CREATION_TIME" IS 'Time first message was spilled';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."FIRST_POSITION" IS 'Position of first message in this transaction';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_SPILL_TXN"."TRANSACTION_ID" IS 'Transaction ID of the spilled transaction';
   COMMENT ON TABLE "SYS"."ALL_APPLY_SPILL_TXN"  IS 'Streams apply spilled transactions info to the user'
;
--------------------------------------------------------
--  DDL for View ALL_APPLY_TABLE_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_APPLY_TABLE_COLUMNS" ("OBJECT_OWNER", "OBJECT_NAME", "COLUMN_NAME", "COMPARE_OLD_ON_DELETE", "COMPARE_OLD_ON_UPDATE", "APPLY_DATABASE_LINK") AS 
  select do."OBJECT_OWNER",do."OBJECT_NAME",do."COLUMN_NAME",do."COMPARE_OLD_ON_DELETE",do."COMPARE_OLD_ON_UPDATE",do."APPLY_DATABASE_LINK"
  from all_tab_columns a, dba_apply_table_columns do
 where do.object_owner = a.owner
   and do.object_name = a.table_name
   and do.column_name = a.column_name;

   COMMENT ON COLUMN "SYS"."ALL_APPLY_TABLE_COLUMNS"."OBJECT_OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_TABLE_COLUMNS"."OBJECT_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_TABLE_COLUMNS"."COLUMN_NAME" IS 'Name of column';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_TABLE_COLUMNS"."COMPARE_OLD_ON_DELETE" IS 'Compare old value of column on deletes';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_TABLE_COLUMNS"."COMPARE_OLD_ON_UPDATE" IS 'Compare old value of column on updates';
   COMMENT ON COLUMN "SYS"."ALL_APPLY_TABLE_COLUMNS"."APPLY_DATABASE_LINK" IS 'For remote tables, name of database link pointing to remote database';
   COMMENT ON TABLE "SYS"."ALL_APPLY_TABLE_COLUMNS"  IS 'Details about the columns of destination table object visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_ARGUMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ARGUMENTS" ("OWNER", "OBJECT_NAME", "PACKAGE_NAME", "OBJECT_ID", "OVERLOAD", "SUBPROGRAM_ID", "ARGUMENT_NAME", "POSITION", "SEQUENCE", "DATA_LEVEL", "DATA_TYPE", "DEFAULTED", "DEFAULT_VALUE", "DEFAULT_LENGTH", "IN_OUT", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "RADIX", "CHARACTER_SET_NAME", "TYPE_OWNER", "TYPE_NAME", "TYPE_SUBNAME", "TYPE_LINK", "TYPE_OBJECT_TYPE", "PLS_TYPE", "CHAR_LENGTH", "CHAR_USED", "ORIGIN_CON_ID") AS 
  select
   OWNER, OBJECT_NAME, PACKAGE_NAME, OBJECT_ID, OVERLOAD,
   SUBPROGRAM_ID, ARGUMENT_NAME, POSITION, SEQUENCE,
   DATA_LEVEL, DATA_TYPE, DEFAULTED, DEFAULT_VALUE, DEFAULT_LENGTH,
   IN_OUT, DATA_LENGTH, DATA_PRECISION, DATA_SCALE, RADIX,
   CHARACTER_SET_NAME, TYPE_OWNER, TYPE_NAME, TYPE_SUBNAME,
   TYPE_LINK, TYPE_OBJECT_TYPE, PLS_TYPE, CHAR_LENGTH, CHAR_USED, ORIGIN_CON_ID
from INT$DBA_ARGUMENTS
where (OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
   or  exists
       (select null
          from v$enabledprivs
         where priv_number in (-144,-141)
       )
   or  OBJ_ID(OWNER, nvl(PACKAGE_NAME, OBJECT_NAME), OBJECT_TYPE#,
              OBJECT_ID) in
       (select obj#
          from sys.objauth$
         where grantee# in (select kzsrorol from x$kzsro)
           and privilege# = 12
       )
      );

   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."OBJECT_NAME" IS 'Procedure or function name';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."PACKAGE_NAME" IS 'Package name';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."OBJECT_ID" IS 'Object number of the object';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."OVERLOAD" IS 'Overload unique identifier';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."SUBPROGRAM_ID" IS 'Unique sub-program Identifier';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."ARGUMENT_NAME" IS 'Argument name';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."POSITION" IS 'Position in argument list, or null for function return value';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."SEQUENCE" IS 'Argument sequence, including all nesting levels';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."DATA_LEVEL" IS 'Nesting depth of argument for composite types';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."DATA_TYPE" IS 'Datatype of the argument';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."DEFAULTED" IS 'Is the argument defaulted?';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."DEFAULT_VALUE" IS 'Default value for the argument';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."DEFAULT_LENGTH" IS 'Length of default value for the argument';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."IN_OUT" IS 'Argument direction (IN, OUT, or IN/OUT)';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."DATA_LENGTH" IS 'Length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."DATA_PRECISION" IS 'Length: decimal digits (NUMBER) or binary digits (FLOAT)';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."DATA_SCALE" IS 'Digits to right of decimal point in a number';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."RADIX" IS 'Argument radix for a number';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."CHARACTER_SET_NAME" IS 'Character set name for the argument';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."TYPE_OWNER" IS 'Owner name for the argument type in case of object types';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."TYPE_NAME" IS 'Object name for the argument type in case of object types';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."TYPE_SUBNAME" IS 'Subordinate object name for the argument type in case of object types';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."TYPE_LINK" IS 'Database link name for the argument type in case of object types';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."TYPE_OBJECT_TYPE" IS 'Object type of the argument type';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."PLS_TYPE" IS 'PL/SQL type name for the argument';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."CHAR_LENGTH" IS 'Character limit for string datatypes';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."CHAR_USED" IS 'Is the byte limit (B) or char limit (C) official for this string?';
   COMMENT ON COLUMN "SYS"."ALL_ARGUMENTS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ARGUMENTS"  IS 'Arguments in object accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_ASSEMBLIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ASSEMBLIES" ("OWNER", "ASSEMBLY_NAME", "FILE_SPEC", "SECURITY_LEVEL", "IDENTITY", "STATUS") AS 
  select u.name,
       o.name,
       a.filespec,
       decode(a.security_level, 0, 'SAFE', 1, 'EXTERNAL_1', 2, 'EXTERNAL_2',
                                3, 'EXTERNAL_3', 4, 'UNSAFE'),
       a.identity,
       decode(o.status, 0, 'N/A', 1, 'VALID', 'INVALID')
from sys."_CURRENT_EDITION_OBJ" o, sys.assembly$ a, sys.user$ u
where o.owner# = u.user#
  and o.obj# = a.obj#
  and (o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
       or o.obj# in
          ( select oa.obj#
            from sys.objauth$ oa
            where grantee# in (select kzsrorol from x$kzsro)
          )
       or (
            exists (select NULL from v$enabledprivs
                    where priv_number in (
                                           -282 /* CREATE ANY ASSEMBLY */,
                                           -283 /* ALTER ANY ASSEMBLY */,
                                           -284 /* DROP ANY ASSEMBLY */,
                                           -285 /* EXECUTE ANY ASSEMBLY */
                                         )
                   )
          )
      );

   COMMENT ON COLUMN "SYS"."ALL_ASSEMBLIES"."OWNER" IS 'Owner of the assembly';
   COMMENT ON COLUMN "SYS"."ALL_ASSEMBLIES"."ASSEMBLY_NAME" IS 'Name of the assembly';
   COMMENT ON COLUMN "SYS"."ALL_ASSEMBLIES"."FILE_SPEC" IS 'Operating system file specification of the assembly';
   COMMENT ON COLUMN "SYS"."ALL_ASSEMBLIES"."SECURITY_LEVEL" IS 'The maximum security level of the assembly';
   COMMENT ON COLUMN "SYS"."ALL_ASSEMBLIES"."IDENTITY" IS 'The identity of the assembly';
   COMMENT ON COLUMN "SYS"."ALL_ASSEMBLIES"."STATUS" IS 'Status of the assembly';
   COMMENT ON TABLE "SYS"."ALL_ASSEMBLIES"  IS 'Description of assemblies accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_ASSOCIATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ASSOCIATIONS" ("OBJECT_OWNER", "OBJECT_NAME", "COLUMN_NAME", "OBJECT_TYPE", "STATSTYPE_SCHEMA", "STATSTYPE_NAME", "DEF_SELECTIVITY", "DEF_CPU_COST", "DEF_IO_COST", "DEF_NET_COST", "INTERFACE_VERSION", "MAINTENANCE_TYPE") AS 
  select u.name, o.name, c.name,
         decode(a.property, 1, 'COLUMN', 2, 'TYPE', 3, 'PACKAGE', 4,
                'FUNCTION', 5, 'INDEX', 6, 'INDEXTYPE', 'INVALID'),
         u1.name, o1.name,a.default_selectivity,
         a.default_cpu_cost, a.default_io_cost, a.default_net_cost,
         a.interface_version#,
         decode (bitand(a.spare2, 1), 1, 'SYSTEM_MANAGED', 'USER_MANAGED')
   from  sys.association$ a, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u,
         sys."_CURRENT_EDITION_OBJ" o1, sys.user$ u1, sys.col$ c
   where a.obj#=o.obj# and o.owner#=u.user#
   AND   a.statstype#=o1.obj# (+) and o1.owner#=u1.user# (+)
   AND   a.obj# = c.obj#  (+)  and a.intcol# = c.intcol# (+)
   and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
       ( o.type# in (2)  /* table */
         and
         exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */,
                                        -42 /* ALTER ANY TABLE */)
                 )
       )
       or
       ( o.type# in (8, 9)   /* package or function */
         and
         exists (select null from v$enabledprivs
                  where priv_number in (-140 /* CREATE PROCEDURE */,
                                        -141 /* CREATE ANY PROCEDURE */,
                                        -142 /* ALTER ANY PROCEDURE */,
                                        -143 /* DROP ANY PROCEDURE */,
                                        -144 /* EXECUTE ANY PROCEDURE */)
                 )
       )
       or
       ( o.type# in (13)     /* type */
         and
         exists (select null from v$enabledprivs
                  where priv_number in (-180 /* CREATE TYPE */,
                                        -181 /* CREATE ANY TYPE */,
                                        -182 /* ALTER ANY TYPE */,
                                        -183 /* DROP ANY TYPE */,
                                        -184 /* EXECUTE ANY TYPE */)
                 )
       )
       or
       ( o.type# in (1)     /* index */
         and
         exists (select null from v$enabledprivs
                  where priv_number in (-71 /* CREATE ANY INDEX */,
                                        -72 /* ALTER ANY INDEX */,
                                        -73 /* DROP ANY INDEX */)
                 )
       )
       or
       ( o.type# in (32)     /* indextype */
         and
         exists (select null from v$enabledprivs
                  where priv_number =-212 /* EXECUTE ANY INDEXTYPE */
                )
       )
    );

   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."OBJECT_OWNER" IS 'Owner of the object for which the association is being defined';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."OBJECT_NAME" IS 'Object name for which the association is being defined';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."COLUMN_NAME" IS 'Column name in the object for which the association is being defined';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."OBJECT_TYPE" IS 'Schema type of the object - column, type, package or function';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."STATSTYPE_SCHEMA" IS 'Owner of the statistics type';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."STATSTYPE_NAME" IS 'Name of Statistics type which contains the cost, selectivity or stats funcs';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."DEF_SELECTIVITY" IS 'Default Selectivity if any of the object';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."DEF_CPU_COST" IS 'Default CPU cost if any of the object';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."DEF_IO_COST" IS 'Default I/O cost if any of the object';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."DEF_NET_COST" IS 'Default Networking cost if any of the object';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."INTERFACE_VERSION" IS 'Version number of Statistics type interface implemented';
   COMMENT ON COLUMN "SYS"."ALL_ASSOCIATIONS"."MAINTENANCE_TYPE" IS 'Whether it is system managed or user managed';
   COMMENT ON TABLE "SYS"."ALL_ASSOCIATIONS"  IS 'All associations available to the user'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_ATTR_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS" ("OWNER", "DIMENSION_NAME", "ATTRIBUTE_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       dimension_name,
       attribute_name,
       classification,
       value,
       language,
       order_num,
       origin_con_id
from INT$DBA_ATTR_DIM_ATTR_CLASS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"."OWNER" IS 'Owner of the attribute dimension attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"."DIMENSION_NAME" IS 'Name of owning attribute dimension of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"."ATTRIBUTE_NAME" IS 'Name of owning attribute of the classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"."CLASSIFICATION" IS 'Name of attribute dimension attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"."VALUE" IS 'Value of attribute dimension Attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"."LANGUAGE" IS 'Language of attribute dimension attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"."ORDER_NUM" IS 'Order number of attribute dimension attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_ATTR_CLASS"  IS 'Attribute dimension attribute classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_ATTRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_ATTRS" ("OWNER", "DIMENSION_NAME", "ATTRIBUTE_NAME", "TABLE_ALIAS", "COLUMN_NAME", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       DIMENSION_NAME,
       ATTRIBUTE_NAME,
       TABLE_ALIAS,
       COLUMN_NAME,
       order_num,
       origin_con_id
from INT$DBA_ATTR_DIM_ATTRS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTRS"."OWNER" IS 'Owner of the attribute dimension attribute';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTRS"."DIMENSION_NAME" IS 'Name of the owning attribute dimension of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTRS"."ATTRIBUTE_NAME" IS 'Name of the Attribute owned by the attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTRS"."TABLE_ALIAS" IS 'Alias of the table or view in the USING clause to which the column belongs';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTRS"."COLUMN_NAME" IS 'Column name in the table or view on which this attribute is defined';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTRS"."ORDER_NUM" IS 'Order number of attribute dimension Attribute within the Dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ATTRS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_ATTRS"  IS 'Attribute dimension attributes in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_CLASS" ("OWNER", "DIMENSION_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       dimension_name,
       classification,
       value,
       language,
       order_num,
       origin_con_id
from   INT$DBA_ATTR_DIM_CLASS
where OWNER = SYS_CONTEXT('USERENV','CURRENT_USER')
      or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_CLASS"."OWNER" IS 'Owner of the attribute dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_CLASS"."DIMENSION_NAME" IS 'Dimension name of owning attribute dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_CLASS"."CLASSIFICATION" IS 'Name of attribute dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_CLASS"."VALUE" IS 'Value of attribute dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_CLASS"."LANGUAGE" IS 'Language of attribute dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_CLASS"."ORDER_NUM" IS 'Order number of attribute dimension classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_CLASS"  IS 'Attribute dimension classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIMENSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIMENSIONS" ("OWNER", "DIMENSION_NAME", "DIMENSION_TYPE", "ALL_MEMBER_NAME", "ALL_MEMBER_CAPTION", "ALL_MEMBER_DESCRIPTION", "COMPILE_STATE", "ORIGIN_CON_ID") AS 
  select owner,
       dimension_name,
       DIMENSION_TYPE,
       ALL_MEMBER_NAME,
       ALL_MEMBER_CAPTION,
       ALL_MEMBER_DESCRIPTION,
     --MEMBER_NAME_ATTR,
     --MEMBER_CAPTION_ATTR,
     --MEMBER_DESCRIPTION_ATTR,
       COMPILE_STATE,
       origin_con_id
from INT$DBA_ATTR_DIM
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIMENSIONS"."DIMENSION_NAME" IS 'Name of the attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIMENSIONS"."DIMENSION_TYPE" IS 'Indication of whether the attribute dimension is a time dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIMENSIONS"."ALL_MEMBER_NAME" IS 'ALL member name of the attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIMENSIONS"."ALL_MEMBER_CAPTION" IS 'ALL member caption of the attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIMENSIONS"."ALL_MEMBER_DESCRIPTION" IS 'ALL member description of the attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIMENSIONS"."COMPILE_STATE" IS 'Compile state of the attribute dimension: N/A, VALID, or INVALID';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIMENSIONS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIMENSIONS"  IS 'attribute dimensions in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_JOIN_PATHS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_JOIN_PATHS" ("OWNER", "DIMENSION_NAME", "JOIN_PATH_NAME", "ON_CONDITION", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER, DIMENSION_NAME, JOIN_PATH_NAME, ON_CONDITION, ORDER_NUM,
       ORIGIN_CON_ID
from   INT$DBA_ATTR_DIM_JOIN_PATHS
where  OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_JOIN_PATHS"."OWNER" IS 'Owner of the attribute dimension join path';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_JOIN_PATHS"."DIMENSION_NAME" IS 'Name of the owning attribute dimension join path';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_JOIN_PATHS"."JOIN_PATH_NAME" IS 'Name of the attribute dimension join path';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_JOIN_PATHS"."ON_CONDITION" IS 'Condition of the attribute dimension join path';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_JOIN_PATHS"."ORDER_NUM" IS 'Order number of Dimension join path within the Dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_JOIN_PATHS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_JOIN_PATHS"  IS 'Attribute dimension join paths in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_KEYS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_KEYS" ("OWNER", "DIMENSION_NAME", "LEVEL_NAME", "IS_ALTERNATE", "ATTRIBUTE_NAME", "ATTR_ORDER_NUM", "KEY_ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       DIMENSION_NAME,
       LEVEL_NAME,
       IS_ALTERNATE,
       ATTRIBUTE_NAME,
       ATTR_ORDER_NUM,
       KEY_ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_ATTR_DIM_KEYS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_KEYS"."OWNER" IS 'Owner of attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_KEYS"."DIMENSION_NAME" IS 'Name of the owning attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_KEYS"."LEVEL_NAME" IS 'Level name of the key, NULL if PARENT CHILD dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_KEYS"."IS_ALTERNATE" IS 'Indication of whether or not the dimension key is an alternate key';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_KEYS"."ATTRIBUTE_NAME" IS 'Name of the key attribute';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_KEYS"."ATTR_ORDER_NUM" IS 'Order of the attribute in the list of attributes comprising the key';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_KEYS"."KEY_ORDER_NUM" IS 'Order of the key in the list of keys (if alternate keys specified)';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_KEYS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_KEYS"  IS 'attribute dimension keys in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_LEVEL_ATTRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS" ("OWNER", "DIMENSION_NAME", "LEVEL_NAME", "ATTRIBUTE_NAME", "ROLE", "IS_MINIMAL_DTM", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       DIMENSION_NAME,
       LEVEL_NAME,
       ATTRIBUTE_NAME,
       ROLE,
       IS_MINIMAL_DTM,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_ATTR_DIM_LEVEL_ATTRS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"."OWNER" IS 'Owner of the attribute dimension level attribute';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"."DIMENSION_NAME" IS 'Name of the owning attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"."LEVEL_NAME" IS 'Name of the dimension level, or NULL for parent child keys';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"."ATTRIBUTE_NAME" IS 'Name of the attribute determined by the level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"."ROLE" IS 'Role of the attribute determined by the level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"."IS_MINIMAL_DTM" IS 'Indication of whether the attribute minimally determined: Y or N';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"."ORDER_NUM" IS 'Order of the attribute in the list of attributes determined by the level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_LEVEL_ATTRS"  IS 'Determined attributes of each level in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_LEVELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_LEVELS" ("OWNER", "DIMENSION_NAME", "LEVEL_NAME", "SKIP_WHEN_NULL", "LEVEL_TYPE", "MEMBER_NAME_EXPR", "MEMBER_CAPTION_EXPR", "MEMBER_DESCRIPTION_EXPR", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       DIMENSION_NAME,
       LEVEL_NAME,
       SKIP_WHEN_NULL,
       LEVEL_TYPE,
       MEMBER_NAME_EXPR,
       MEMBER_CAPTION_EXPR,
       MEMBER_DESCRIPTION_EXPR,
       order_num ,
       origin_con_id
from INT$DBA_ATTR_DIM_LEVELS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."OWNER" IS 'Owner of the attribute dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."DIMENSION_NAME" IS 'Name of the owning attribute dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."LEVEL_NAME" IS 'Name of the attribute dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."SKIP_WHEN_NULL" IS 'Indication of whether to skip the level when the key is NULL: Y or N';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."LEVEL_TYPE" IS 'Type of attribute dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."MEMBER_NAME_EXPR" IS 'Member name expression of Dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."MEMBER_CAPTION_EXPR" IS 'Member caption expression of Dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."MEMBER_DESCRIPTION_EXPR" IS 'Member description expression of Dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."ORDER_NUM" IS 'Order number of Dimension Level within the Dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_LEVELS"  IS 'Attribute dimension Levels in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_LVL_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS" ("OWNER", "DIMENSION_NAME", "LEVEL_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       dimension_name,
       level_name,
       classification,
       value,
       language,
       order_num,
       origin_con_id
from  INT$DBA_ATTR_DIM_LVL_CLASS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"."OWNER" IS 'Owner of the attribute dimension level classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"."DIMENSION_NAME" IS 'Name of owning attribute dimension of the level';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"."LEVEL_NAME" IS 'Name of owning level of the classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"."CLASSIFICATION" IS 'Name of attribute dimension level classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"."VALUE" IS 'Value of attribute dimension level classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"."LANGUAGE" IS 'Language of attribute dimension level classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"."ORDER_NUM" IS 'Order number of attribute dimension level classification';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_LVL_CLASS"  IS 'Attribute dimension level classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_ORDER_ATTRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS" ("OWNER", "DIMENSION_NAME", "LEVEL_NAME", "AGG_FUNC", "ATTRIBUTE_NAME", "ORDER_NUM", "CRITERIA", "NULLS_POSITION", "ORIGIN_CON_ID") AS 
  select OWNER, DIMENSION_NAME, LEVEL_NAME, AGG_FUNC, ATTRIBUTE_NAME,
       ORDER_NUM, CRITERIA, NULLS_POSITION, ORIGIN_CON_ID
from INT$DBA_ATTR_DIM_ORDER_ATT
where  OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
       (select obj#
       from sys.objauth$
       where grantee# in (select kzsrorol from x$kzsro )
       )
       or /* user has sys privs */
       ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."OWNER" IS 'Owner of attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."DIMENSION_NAME" IS 'Name of the owning attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."LEVEL_NAME" IS 'Level name of the order by, NULL if parent child dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."AGG_FUNC" IS 'Aggregation function of the order by; MIN, MAX, or NULL if parent child dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."ATTRIBUTE_NAME" IS 'Name of the order attribute';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."ORDER_NUM" IS 'Order number of the attribute in the list of order attributes';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."CRITERIA" IS 'Criteria of using the order attribute: ASC or DESC';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."NULLS_POSITION" IS 'Position of the NULLs: FIRST or LAST';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_ORDER_ATTRS"  IS 'Attribute dimension order by elements in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_DIM_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_DIM_TABLES" ("OWNER", "DIMENSION_NAME", "TABLE_OWNER", "TABLE_NAME", "TABLE_ALIAS", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       DIMENSION_NAME,
       TABLE_OWNER,
       TABLE_NAME,
       TABLE_ALIAS,
       order_num,
       origin_con_id
from INT$DBA_ATTR_DIM_TABLES
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, DIMENSION_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_TABLES"."DIMENSION_NAME" IS 'Name of the attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_TABLES"."TABLE_OWNER" IS 'Owner of the table or view on which the attribute dimension is defined';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_TABLES"."TABLE_NAME" IS 'Name of the table or view on which the attribute dimension is defined';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_TABLES"."TABLE_ALIAS" IS 'Alias specified for the table or view, or TABLE_NAME if not specified';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_TABLES"."ORDER_NUM" IS 'Order of the table in the list of tables in the USING clause';
   COMMENT ON COLUMN "SYS"."ALL_ATTRIBUTE_DIM_TABLES"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_ATTRIBUTE_DIM_TABLES"  IS 'Attribute dimension tables in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ATTRIBUTE_TRANSFORMATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ATTRIBUTE_TRANSFORMATIONS" ("TRANSFORMATION_ID", "OWNER", "NAME", "FROM_TYPE", "TO_TYPE", "ATTRIBUTE", "ATTRIBUTE_TRANSFORMATION") AS 
  SELECT t.transformation_id, t.owner, t.name,
       t.from_schema||'.'||t.from_type, t.to_schema||'.'||t.to_type,
       at.attribute_number,
       at.sql_expression
FROM transformations$ t, attribute_transformations$ at, sys.user$ u
WHERE
t.transformation_id = at.transformation_id and
u.user# = USERENV('SCHEMAID')
and (u.name = t.owner                                      /* user is the owner */
or (exists (select null from v$enabledprivs        /* user has system privelege */
               where priv_number in (-184 /* EXECUTE ANY TYPE */)))
or
(t.from_type in                                 /* user has execute on from type */
(
select t.from_type from transformations$ t, obj$ o, objauth$ oa
where
o.obj# = oa.obj# and
t.from_type = o.name and
(oa.grantor# = userenv('SCHEMAID') OR      oa.obj# in
         (select ro.obj#
          from sys.objauth$ ro
          where grantee# in (select kzsrorol from x$kzsro))
)
and t.to_type in                                  /* user has execute on to type */
(
select t.to_type from transformations$ t, obj$ o, objauth$ oa
where
o.obj# = oa.obj# and
t.to_type = o.name and
(oa.grantor# = userenv('SCHEMAID') OR
    oa.obj# in
         (select ro.obj#
          from sys.objauth$ ro
          where grantee# in (select kzsrorol from x$kzsro))))))
)
;
--------------------------------------------------------
--  DDL for View ALL_AUDITED_SYSTEM_ACTIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AUDITED_SYSTEM_ACTIONS" ("TYPE", "COMPONENT", "ACTION", "NAME") AS 
  select type, component, action, name from auditable_system_actions
                                     where component not like 'Database Vault'
/* 2. Some non configurable audited actions */
UNION ALL
select audit_type, component, action, name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'Standard'),
  (select action, name from UNIFIED_MISC_AUDITED_ACTIONS)
/* 3. Non-configurable RMAN actions */
/* We select audit_type and component from v$unified_audit_record_format view
   and as we know all the RMAN's "action_name" are listed as "pl sql execute",
   we are selecting action number as 47 and including it as RMAN ACTION. So
   when we query unified_audit_trail, it would show RMAN ACTION as action_name
   instead of "pl sql execute". */
UNION ALL
select audit_type, component, action, name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'RMAN_AUDIT'),
  (select 47 action, 'RMAN ACTION' name from dual)
/* 4. FGA audit actions */
UNION ALL
select audit_type, component, action, name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'FineGrainedAudit'),
  (select  2 action, 'INSERT'  name from dual UNION ALL
   select  3 action, 'SELECT'  name from dual UNION ALL
   select  6 action, 'UPDATE'  name from dual UNION ALL
   select  7 action, 'DELETE'  name from dual UNION ALL
   select  189 action, 'MERGE' name from dual)
/* 5. KSACL audit action */
UNION ALL
select audit_type, component, action, name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'KACL_AUDIT'),
  (select 1 action, 'VALIDATE' name from dual)
/* 6. Database Vault Configuration Audit Actions */
UNION ALL
select audit_type, component, action, name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'Database Vault'),
  (select action, name from auditable_system_actions
                       where component ='Standard')
;
--------------------------------------------------------
--  DDL for View ALL_AUDIT_POLICIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AUDIT_POLICIES" ("OBJECT_SCHEMA", "OBJECT_NAME", "POLICY_OWNER", "POLICY_NAME", "POLICY_TEXT", "POLICY_COLUMN", "PF_SCHEMA", "PF_PACKAGE", "PF_FUNCTION", "ENABLED", "SEL", "INS", "UPD", "DEL", "AUDIT_TRAIL", "POLICY_COLUMN_OPTIONS", "COMMON", "INHERITED") AS 
  SELECT OBJECT_SCHEMA, OBJECT_NAME, POLICY_OWNER, POLICY_NAME, POLICY_TEXT,
       POLICY_COLUMN, PF_SCHEMA, PF_PACKAGE, PF_FUNCTION, ENABLED, SEL, INS,
       UPD, DEL, AUDIT_TRAIL, POLICY_COLUMN_OPTIONS, P.COMMON, P.INHERITED
FROM DBA_AUDIT_POLICIES p, ALL_TABLES t
WHERE
(OBJECT_SCHEMA = t.OWNER AND OBJECT_NAME = t.TABLE_NAME)
union
SELECT OBJECT_SCHEMA, OBJECT_NAME, POLICY_OWNER, POLICY_NAME, POLICY_TEXT,
       POLICY_COLUMN, PF_SCHEMA, PF_PACKAGE, PF_FUNCTION, ENABLED, SEL, INS,
       UPD, DEL, AUDIT_TRAIL, POLICY_COLUMN_OPTIONS, P.COMMON, P.INHERITED
FROM DBA_AUDIT_POLICIES p, ALL_VIEWS v
WHERE
(OBJECT_SCHEMA = v.OWNER AND OBJECT_NAME = v.VIEW_NAME);

   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."OBJECT_SCHEMA" IS 'Owner of the table or view';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."OBJECT_NAME" IS 'Name of the table or view';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."POLICY_OWNER" IS 'Owner of the policy';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."POLICY_NAME" IS 'Name of the policy';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."POLICY_TEXT" IS 'Audit condition';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."POLICY_COLUMN" IS 'Deprecated';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."PF_SCHEMA" IS 'Owner of the audit handler function';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."PF_PACKAGE" IS 'Name of the package containing the audit handler function';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."PF_FUNCTION" IS 'Name of the audit handler function';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."ENABLED" IS 'Is this policy is enabled?';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."SEL" IS 'If YES, policy is applied to query on the object';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."INS" IS 'If YES, policy is applied to insert on the object';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."UPD" IS 'If YES, policy is applied to update on the object';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."DEL" IS 'If YES, policy is applied to delete on the object';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."AUDIT_TRAIL" IS 'Whether to populate SQLTEXT and SQLBIND columns in audit trail for this policy. DB_EXTENDED -> Populate; DB -> Do not populate';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."POLICY_COLUMN_OPTIONS" IS 'If ALL_COLUMNS then all relevant columns apply else any of the relevant columns apply';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."COMMON" IS 'Does policy apply across multiple containers';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICIES"."INHERITED" IS 'Was policy inherited from another container';
   COMMENT ON TABLE "SYS"."ALL_AUDIT_POLICIES"  IS 'All fine grained auditing policies in the database'
;
--------------------------------------------------------
--  DDL for View ALL_AUDIT_POLICY_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AUDIT_POLICY_COLUMNS" ("OBJECT_SCHEMA", "OBJECT_NAME", "POLICY_NAME", "POLICY_COLUMN") AS 
  (select d.OBJECT_SCHEMA, d.OBJECT_NAME,
          d.POLICY_NAME, d.POLICY_COLUMN
from DBA_AUDIT_POLICY_COLUMNS d, ALL_TABLES t
where d.OBJECT_SCHEMA = t.OWNER AND d.OBJECT_NAME = t.TABLE_NAME)
union
(select d.OBJECT_SCHEMA, d.OBJECT_NAME,
          d.POLICY_NAME, d.POLICY_COLUMN
from DBA_AUDIT_POLICY_COLUMNS d, ALL_VIEWS v
where d.OBJECT_SCHEMA = v.OWNER AND d.OBJECT_NAME = v.VIEW_NAME);

   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICY_COLUMNS"."OBJECT_SCHEMA" IS 'Owner of the table or view';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICY_COLUMNS"."OBJECT_NAME" IS 'Object on which the policy is created';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICY_COLUMNS"."POLICY_NAME" IS 'Name of the Fine Grain Audit policy';
   COMMENT ON COLUMN "SYS"."ALL_AUDIT_POLICY_COLUMNS"."POLICY_COLUMN" IS 'Audit relevant column of the policy';
   COMMENT ON TABLE "SYS"."ALL_AUDIT_POLICY_COLUMNS"  IS 'All fine grained auditing policy columns in the database'
;
--------------------------------------------------------
--  DDL for View ALL_AW_AC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AW_AC" ("OWNER", "AW_NUMBER", "AW_NAME") AS 
  SELECT distinct u.name, a.awseq#, a.awname
FROM aw$ a, aw_prop$ p, sys.obj$ o, sys.user$ u
WHERE  a.owner#=u.user#
       and o.owner# = a.owner#
       and o.name = 'AW$' || a.awname and o.type#= 2 /* type for table */
       and a.awseq#=p.awseq#
       and (a.owner# in (userenv('SCHEMAID'), 1)   /* public objects */
            or
            o.obj# in ( select obj#  /* directly granted privileges */
                        from sys.objauth$
                        where grantee# in ( select kzsrorol from x$kzsro )
                      )
            or   /* user has system privilages */
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
        and p.propname = 'AW$ROLE';

   COMMENT ON TABLE "SYS"."ALL_AW_AC"  IS 'Active Catalog Analytic Workspaces accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_AW_AC_10G
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AW_AC_10G" ("OWNER", "AW_NUMBER", "AW_NAME") AS 
  SELECT distinct u.name, a.awseq#, a.awname
FROM aw$ a, aw_prop$ p, sys.obj$ o, sys.user$ u
WHERE  a.owner#=u.user#
       and o.owner# = a.owner#
       and o.name = 'AW$' || a.awname and o.type#= 2 /* type for table */
       and a.awseq#=p.awseq#
       and (a.owner# in (userenv('SCHEMAID'), 1)   /* public objects */
            or
            o.obj# in ( select obj#  /* directly granted privileges */
                        from sys.objauth$
                        where grantee# in ( select kzsrorol from x$kzsro )
                      )
            or   /* user has system privilages */
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
        and (p.propname = 'AW$VERSION10.1.0.3' or p.propname = 'AW$VERSION10.2')
;
--------------------------------------------------------
--  DDL for View ALL_AW_OBJ
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AW_OBJ" ("OWNER", "AW_NUMBER", "AW_NAME", "OBJ_ID", "OBJ_NAME", "OBJ_TYPE", "PART_NAME") AS 
  SELECT u.name, a.awseq#, a.awname, p.oid, p.objname, p.objtype, p.partname
FROM aw$ a, aw_obj$ p, sys.obj$ o, sys.user$ u,
     (select max(rowid) keep (dense_rank last order by gen#) rid
      from aw_obj$ group by awseq#, oid)
WHERE  a.owner#=u.user#
       and o.name = 'AW$' || a.awname and o.type#= 2 /* type for table */
       and a.awseq#=p.awseq#
       and (a.owner# in (userenv('SCHEMAID'), 1)   /* public objects */
            or
            o.obj# in ( select obj#  /* directly granted privileges */
                        from sys.objauth$
                        where grantee# in ( select kzsrorol from x$kzsro )
                      )
            or   /* user has system privilages */
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
       and p.rowid = rid and p.objtype IS NOT NULL;

   COMMENT ON COLUMN "SYS"."ALL_AW_OBJ"."OWNER" IS 'Owner of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_OBJ"."AW_NUMBER" IS 'Number of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_OBJ"."AW_NAME" IS 'Name of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_OBJ"."OBJ_ID" IS 'Object ID in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_OBJ"."OBJ_NAME" IS 'Object name in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_OBJ"."OBJ_TYPE" IS 'Type of the object in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_OBJ"."PART_NAME" IS 'Partition of the object in the Analytic Workspace';
   COMMENT ON TABLE "SYS"."ALL_AW_OBJ"  IS 'Objects in Analytic Workspaces accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_AW_PROP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AW_PROP" ("OWNER", "AW_NUMBER", "AW_NAME", "OBJ_ID", "OBJ_NAME", "PROPERTY_NAME", "PROPERTY_TYPE", "PROPERTY_VALUE", "FULL_PROPERTY_VALUE", "PROPERTY_VALUE_LENGTH") AS 
  SELECT u.name, a.awseq#, a.awname, p.oid, p.objname,
       p.propname, dbms_aw.olap_type( nvl(p.proptype, 0)),
       dbms_aw.prop_val(p.rowid), dbms_aw.prop_clob(p.rowid),
       dbms_aw.prop_len(p.rowid)
FROM aw$ a, aw_prop$ p, sys.obj$ o, sys.user$ u,
     (select max(rowid) keep (dense_rank last order by gen#) rid
           from aw_prop$ group by awseq#, oid, propname)
WHERE  a.owner#=u.user#
       and o.owner# = a.owner#
       and o.name = 'AW$' || a.awname and o.type#= 2 /* type for table */
       and a.awseq#=p.awseq#
       and (a.owner# in (userenv('SCHEMAID'), 1)   /* public objects */
            or
            o.obj# in ( select obj#  /* directly granted privileges */
                        from sys.objauth$
                        where grantee# in ( select kzsrorol from x$kzsro )
                      )
            or   /* user has system privilages */
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
        and p.rowid = rid and p.propval IS NOT NULL;

   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."OWNER" IS 'Owner of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."AW_NUMBER" IS 'Number of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."AW_NAME" IS 'Name of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."OBJ_ID" IS 'Object ID in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."OBJ_NAME" IS 'Object name in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."PROPERTY_NAME" IS 'Property name of the object in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."PROPERTY_TYPE" IS 'Type of the property in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."PROPERTY_VALUE" IS 'Value of the property in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."FULL_PROPERTY_VALUE" IS 'Complete value of the property in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PROP"."PROPERTY_VALUE_LENGTH" IS 'Length in bytes of the property in the Analytic Workspace';
   COMMENT ON TABLE "SYS"."ALL_AW_PROP"  IS 'Object properties in Analytic Workspaces accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_AW_PROP_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AW_PROP_NAME" ("OWNER", "AW_NUMBER", "AW_NAME", "OBJ_ID", "OBJ_NAME", "PROPERTY_NAME") AS 
  SELECT u.name, a.awseq#, a.awname, p.oid, p.objname,
       p.propname
FROM aw$ a, aw_prop$ p, sys.obj$ o, sys.user$ u,
     (select max(rowid) keep (dense_rank last order by gen#) rid
           from aw_prop$ group by awseq#, oid, propname)
WHERE  a.owner#=u.user#
       and o.owner# = a.owner#
       and o.name = 'AW$' || a.awname and o.type#= 2 /* type for table */
       and a.awseq#=p.awseq#
       and (a.owner# in (userenv('SCHEMAID'), 1)   /* public objects */
            or
            o.obj# in ( select obj#  /* directly granted privileges */
                        from sys.objauth$
                        where grantee# in ( select kzsrorol from x$kzsro )
                      )
            or   /* user has system privilages */
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
        and p.rowid = rid and p.propval IS NOT NULL;

   COMMENT ON TABLE "SYS"."ALL_AW_PROP_NAME"  IS 'Analytic Workspace property names accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_AW_PS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AW_PS" ("OWNER", "AW_NUMBER", "AW_NAME", "PSNUMBER", "GENERATIONS", "MAXPAGES") AS 
  SELECT u.name, a.awseq#, a.awname, p.psnumber, count(unique(p.psgen)), max(p.maxpages)
FROM aw$ a, ps$ p, user$ u, sys.obj$ o
WHERE  a.owner#=u.user#
       and o.owner# = a.owner#
       and o.name = 'AW$' || a.awname and o.type#= 2 /* type for table */
       and a.awseq#=p.awseq#
       and (a.owner# in (userenv('SCHEMAID'), 1)   /* public objects */
            or
            o.obj# in ( select obj#  /* directly granted privileges */
                        from sys.objauth$
                        where grantee# in ( select kzsrorol from x$kzsro )
                      )
            or   /* user has system privileges */
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
group by a.awseq#, a.awname, u.name, p.psnumber;

   COMMENT ON COLUMN "SYS"."ALL_AW_PS"."OWNER" IS 'Owner of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PS"."AW_NAME" IS 'Name of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PS"."PSNUMBER" IS 'Number of the pagespace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PS"."GENERATIONS" IS 'Number of active generations in the pagespace';
   COMMENT ON COLUMN "SYS"."ALL_AW_PS"."MAXPAGES" IS 'Maximum pages allocated in the pagespace';
   COMMENT ON TABLE "SYS"."ALL_AW_PS"  IS 'Pagespaces in Analytic Workspaces accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_AWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_AWS" ("OWNER", "AW_NUMBER", "AW_NAME", "AW_VERSION", "PAGESPACES", "GENERATIONS", "FROZEN") AS 
  SELECT u.name, a.awseq#, a.awname,
       decode(a.version,
              0, '9.1',
              1, '10.1', 2, '10.2',
              3, '11.1', 4, '11.2',
              5, '12.0', 6, '18.1',
              NULL),
        n.num, g.gen, f.frozen
FROM aw$ a, sys.obj$ o, sys.user$ u,
     (SELECT awseq#, COUNT(psgen) gen FROM ps$ WHERE psnumber IS NULL GROUP BY awseq#) g,
     (SELECT awseq#, COUNT(UNIQUE(psnumber)) num FROM ps$ WHERE psnumber IS NOT NULL GROUP BY awseq#) n ,
     (SELECT max(awseq#) awmax, decode(max(mapoffset), 1, 'Frozen',
         2, 'NoThaw', NULL) frozen from ps$ where psnumber is NULL
         group by awseq#) f
WHERE  a.owner#=u.user#
       and o.owner# = a.owner#
       and o.name = 'AW$' || a.awname and o.type#= 2 /* type for table */
       and a.awseq#=g.awseq# and a.awseq#=n.awseq# and a.awseq# = f.awmax
       and (a.owner# in (userenv('SCHEMAID'), 1)   /* public objects */
            or
            o.obj# in ( select obj#  /* directly granted privileges */
                        from sys.objauth$
                        where grantee# in ( select kzsrorol from x$kzsro )
                      )
            or   /* user has system privileges */
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_AWS"."OWNER" IS 'Owner of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AWS"."AW_NUMBER" IS 'Number of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AWS"."AW_NAME" IS 'Name of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AWS"."AW_VERSION" IS 'Format version of the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AWS"."PAGESPACES" IS 'Number of pagespaces in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AWS"."GENERATIONS" IS 'Number of active generations in the Analytic Workspace';
   COMMENT ON COLUMN "SYS"."ALL_AWS"."FROZEN" IS 'Freeze state of the Analytic Workspace';
   COMMENT ON TABLE "SYS"."ALL_AWS"  IS 'Analytic Workspaces accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_BASE_TABLE_MVIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_BASE_TABLE_MVIEWS" ("OWNER", "MASTER", "MVIEW_LAST_REFRESH_TIME", "MVIEW_ID") AS 
  select s."OWNER",s."MASTER",s."MVIEW_LAST_REFRESH_TIME",s."MVIEW_ID" from dba_base_table_mviews s, all_mview_logs a
where a.log_owner = s.owner
  and a.master = s.master;

   COMMENT ON COLUMN "SYS"."ALL_BASE_TABLE_MVIEWS"."OWNER" IS 'Owner of the master table which changes are logged';
   COMMENT ON COLUMN "SYS"."ALL_BASE_TABLE_MVIEWS"."MASTER" IS 'Name of the master table which changes are logged';
   COMMENT ON COLUMN "SYS"."ALL_BASE_TABLE_MVIEWS"."MVIEW_LAST_REFRESH_TIME" IS 'One date per materialized view -- the date the materialized view was last refreshed';
   COMMENT ON COLUMN "SYS"."ALL_BASE_TABLE_MVIEWS"."MVIEW_ID" IS 'Unique identifier of the materialized view';
   COMMENT ON TABLE "SYS"."ALL_BASE_TABLE_MVIEWS"  IS 'All materialized views with log(s) in the database that the user can see'
;
--------------------------------------------------------
--  DDL for View ALL_CAPTURE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CAPTURE" ("CAPTURE_NAME", "QUEUE_NAME", "QUEUE_OWNER", "RULE_SET_NAME", "RULE_SET_OWNER", "CAPTURE_USER", "START_SCN", "STATUS", "CAPTURED_SCN", "APPLIED_SCN", "USE_DATABASE_LINK", "FIRST_SCN", "SOURCE_DATABASE", "SOURCE_DBID", "SOURCE_RESETLOGS_SCN", "SOURCE_RESETLOGS_TIME", "LOGMINER_ID", "NEGATIVE_RULE_SET_NAME", "NEGATIVE_RULE_SET_OWNER", "MAX_CHECKPOINT_SCN", "REQUIRED_CHECKPOINT_SCN", "LOGFILE_ASSIGNMENT", "STATUS_CHANGE_TIME", "ERROR_NUMBER", "ERROR_MESSAGE", "VERSION", "CAPTURE_TYPE", "LAST_ENQUEUED_SCN", "CHECKPOINT_RETENTION_TIME", "START_TIME", "PURPOSE", "SOURCE_ROOT_NAME", "CLIENT_NAME", "CLIENT_STATUS", "OLDEST_SCN", "FILTERED_SCN") AS 
  select c."CAPTURE_NAME",c."QUEUE_NAME",c."QUEUE_OWNER",c."RULE_SET_NAME",c."RULE_SET_OWNER",c."CAPTURE_USER",c."START_SCN",c."STATUS",c."CAPTURED_SCN",c."APPLIED_SCN",c."USE_DATABASE_LINK",c."FIRST_SCN",c."SOURCE_DATABASE",c."SOURCE_DBID",c."SOURCE_RESETLOGS_SCN",c."SOURCE_RESETLOGS_TIME",c."LOGMINER_ID",c."NEGATIVE_RULE_SET_NAME",c."NEGATIVE_RULE_SET_OWNER",c."MAX_CHECKPOINT_SCN",c."REQUIRED_CHECKPOINT_SCN",c."LOGFILE_ASSIGNMENT",c."STATUS_CHANGE_TIME",c."ERROR_NUMBER",c."ERROR_MESSAGE",c."VERSION",c."CAPTURE_TYPE",c."LAST_ENQUEUED_SCN",c."CHECKPOINT_RETENTION_TIME",c."START_TIME",c."PURPOSE",c."SOURCE_ROOT_NAME",c."CLIENT_NAME",c."CLIENT_STATUS",c."OLDEST_SCN",c."FILTERED_SCN"
  from dba_capture c, all_queues q
 where c.queue_name = q.name
   and c.queue_owner = q.owner
   and ((c.rule_set_owner is null and c.rule_set_name is null) or
        ((c.rule_set_owner, c.rule_set_name) in
          (select r.rule_set_owner, r.rule_set_name
             from all_rule_sets r)))
   and ((c.negative_rule_set_owner is null and
         c.negative_rule_set_name is null) or
        ((c.negative_rule_set_owner, c.negative_rule_set_name) in
          (select r.rule_set_owner, r.rule_set_name
             from all_rule_sets r)));

   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."CAPTURE_NAME" IS 'Name of the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."QUEUE_NAME" IS 'Name of queue used for holding captured changes';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."QUEUE_OWNER" IS 'Owner of the queue used for holding captured changes';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."RULE_SET_NAME" IS 'Rule set used by capture process for filtering';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."START_SCN" IS 'The SCN from which capturing will be resumed';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."STATUS" IS 'Status of the capture process: DISABLED, ENABLED, ABORTED';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."CAPTURED_SCN" IS 'Everything up to this SCN has been captured';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."APPLIED_SCN" IS 'Everything up to this SCN has been applied';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."USE_DATABASE_LINK" IS 'Can use database_link from downstream to source database';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."FIRST_SCN" IS 'SCN from which the capture process can be restarted';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."SOURCE_DATABASE" IS 'Global name of the source database';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."SOURCE_DBID" IS 'DBID of the source database';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."SOURCE_RESETLOGS_SCN" IS 'Resetlogs_SCN of the source database';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."SOURCE_RESETLOGS_TIME" IS 'Resetlogs time of the source database';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."LOGMINER_ID" IS 'Session ID of LogMiner session associated with the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."NEGATIVE_RULE_SET_NAME" IS 'Negative rule set used by capture process for filtering';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."NEGATIVE_RULE_SET_OWNER" IS 'Owner of the negative rule set';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."MAX_CHECKPOINT_SCN" IS 'SCN at which the last check point was taken by the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."REQUIRED_CHECKPOINT_SCN" IS 'the safe SCN at which the meta-data for the capture process can be purged';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."LOGFILE_ASSIGNMENT" IS 'The logfile assignment type for the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."STATUS_CHANGE_TIME" IS 'The time that STATUS of the capture process was changed';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."ERROR_NUMBER" IS 'Error number if the capture process was aborted';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."ERROR_MESSAGE" IS 'Error message if the capture process was aborted';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."VERSION" IS 'Version number of the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."CAPTURE_TYPE" IS 'Type of the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."LAST_ENQUEUED_SCN" IS 'SCN of the last message enqueued by the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."CHECKPOINT_RETENTION_TIME" IS 'Number of days checkpoints will be retained by the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."SOURCE_ROOT_NAME" IS 'Global name of the source root database';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."CLIENT_NAME" IS 'Name of the client process of the capture';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."CLIENT_STATUS" IS 'Status of the client process of the capture';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."OLDEST_SCN" IS 'Oldest SCN of the transaction currently being applied';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE"."FILTERED_SCN" IS 'SCN of the low watermark transaction processed';
   COMMENT ON TABLE "SYS"."ALL_CAPTURE"  IS 'Details about each capture process that stores the captured changes in a queue visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_CAPTURE_EXTRA_ATTRIBUTES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CAPTURE_EXTRA_ATTRIBUTES" ("CAPTURE_NAME", "ATTRIBUTE_NAME", "INCLUDE", "ROW_ATTRIBUTE", "DDL_ATTRIBUTE") AS 
  select e."CAPTURE_NAME",e."ATTRIBUTE_NAME",e."INCLUDE",e."ROW_ATTRIBUTE",e."DDL_ATTRIBUTE"
  from dba_capture_extra_attributes e, all_capture c
 where e.capture_name = c.capture_name;

   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_EXTRA_ATTRIBUTES"."CAPTURE_NAME" IS 'Name of the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_EXTRA_ATTRIBUTES"."ATTRIBUTE_NAME" IS 'Name of the extra attribute';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_EXTRA_ATTRIBUTES"."INCLUDE" IS 'YES if the extra attribute is included';
   COMMENT ON TABLE "SYS"."ALL_CAPTURE_EXTRA_ATTRIBUTES"  IS 'Extra attributes for a capture process that is visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_CAPTURE_PARAMETERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CAPTURE_PARAMETERS" ("CAPTURE_NAME", "PARAMETER", "VALUE", "SET_BY_USER", "SOURCE_DATABASE") AS 
  select cp.capture_name, cp.parameter, cp.value, cp.set_by_user,
  cp.source_database
  from dba_capture_parameters cp, all_capture ac
 where cp.capture_name = ac.capture_name;

   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PARAMETERS"."CAPTURE_NAME" IS 'Name of the capture process';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PARAMETERS"."PARAMETER" IS 'Name of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PARAMETERS"."VALUE" IS 'Either the default value or the value set by the user for the parameter';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PARAMETERS"."SET_BY_USER" IS 'YES if the value is set by the user, NO otherwise';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PARAMETERS"."SOURCE_DATABASE" IS 'The global name of the container for which the parameter is defined.';
   COMMENT ON TABLE "SYS"."ALL_CAPTURE_PARAMETERS"  IS 'Details about parameters for each capture process that stores the captured changes in a queue visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_CAPTURE_PREPARED_DATABASE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CAPTURE_PREPARED_DATABASE" ("TIMESTAMP", "SUPPLEMENTAL_LOG_DATA_PK", "SUPPLEMENTAL_LOG_DATA_UI", "SUPPLEMENTAL_LOG_DATA_FK", "SUPPLEMENTAL_LOG_DATA_ALL") AS 
  select "TIMESTAMP","SUPPLEMENTAL_LOG_DATA_PK","SUPPLEMENTAL_LOG_DATA_UI","SUPPLEMENTAL_LOG_DATA_FK","SUPPLEMENTAL_LOG_DATA_ALL" from DBA_CAPTURE_PREPARED_DATABASE;

   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_DATABASE"."TIMESTAMP" IS 'Time at which the database was ready to be instantiated';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_DATABASE"."SUPPLEMENTAL_LOG_DATA_PK" IS 'Status of database-level PRIMARY KEY COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_DATABASE"."SUPPLEMENTAL_LOG_DATA_UI" IS 'Status of database-level UNIQUE INDEX COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_DATABASE"."SUPPLEMENTAL_LOG_DATA_FK" IS 'Status of database-level FOREIGN KEY COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_DATABASE"."SUPPLEMENTAL_LOG_DATA_ALL" IS 'Status of database-level ALL COLUMNS supplemental logging';
   COMMENT ON TABLE "SYS"."ALL_CAPTURE_PREPARED_DATABASE"  IS 'Is the local database prepared for instantiation?'
;
--------------------------------------------------------
--  DDL for View ALL_CAPTURE_PREPARED_SCHEMAS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CAPTURE_PREPARED_SCHEMAS" ("SCHEMA_NAME", "TIMESTAMP", "SUPPLEMENTAL_LOG_DATA_PK", "SUPPLEMENTAL_LOG_DATA_UI", "SUPPLEMENTAL_LOG_DATA_FK", "SUPPLEMENTAL_LOG_DATA_ALL") AS 
  select s.schema_name, s.timestamp, s.supplemental_log_data_pk,
       s.supplemental_log_data_ui, s.supplemental_log_data_fk,
       s.supplemental_log_data_all
  from dba_capture_prepared_schemas s, all_users u
 where s.schema_name = u.username;

   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_SCHEMAS"."SCHEMA_NAME" IS 'Name of schema prepared for instantiation';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_SCHEMAS"."TIMESTAMP" IS 'Time at which the schema was ready to be instantiated';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_SCHEMAS"."SUPPLEMENTAL_LOG_DATA_PK" IS 'Status of schema-level PRIMARY KEY COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_SCHEMAS"."SUPPLEMENTAL_LOG_DATA_UI" IS 'Status of schema-level UNIQUE INDEX COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_SCHEMAS"."SUPPLEMENTAL_LOG_DATA_FK" IS 'Status of schema-level FOREIGN KEY COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_SCHEMAS"."SUPPLEMENTAL_LOG_DATA_ALL" IS 'Status of schema-level ALL COLUMNS supplemental logging';
   COMMENT ON TABLE "SYS"."ALL_CAPTURE_PREPARED_SCHEMAS"  IS 'All user schemas at the local database that are prepared for instantiation'
;
--------------------------------------------------------
--  DDL for View ALL_CAPTURE_PREPARED_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CAPTURE_PREPARED_TABLES" ("TABLE_OWNER", "TABLE_NAME", "SCN", "TIMESTAMP", "SUPPLEMENTAL_LOG_DATA_PK", "SUPPLEMENTAL_LOG_DATA_UI", "SUPPLEMENTAL_LOG_DATA_FK", "SUPPLEMENTAL_LOG_DATA_ALL") AS 
  select pt.table_owner, pt.table_name, pt.scn, pt.timestamp,
       pt.supplemental_log_data_pk, pt.supplemental_log_data_ui,
       pt.supplemental_log_data_fk, pt.supplemental_log_data_all
  from all_tables at, dba_capture_prepared_tables pt
  where pt.table_name = at.table_name
    and pt.table_owner = at.owner;

   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_TABLES"."TABLE_OWNER" IS 'Owner of the table prepared for instantiation';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_TABLES"."TABLE_NAME" IS 'Name of the table prepared for instantiation';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_TABLES"."SCN" IS 'SCN from which changes can be captured';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_TABLES"."TIMESTAMP" IS 'Time at which the table was ready to be instantiated';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_TABLES"."SUPPLEMENTAL_LOG_DATA_PK" IS 'Status of table-level PRIMARY KEY COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_TABLES"."SUPPLEMENTAL_LOG_DATA_UI" IS 'Status of table-level UNIQUE INDEX COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_TABLES"."SUPPLEMENTAL_LOG_DATA_FK" IS 'Status of table-level FOREIGN KEY COLUMNS supplemental logging';
   COMMENT ON COLUMN "SYS"."ALL_CAPTURE_PREPARED_TABLES"."SUPPLEMENTAL_LOG_DATA_ALL" IS 'Status of table-level ALL COLUMNS supplemental logging';
   COMMENT ON TABLE "SYS"."ALL_CAPTURE_PREPARED_TABLES"  IS 'All tables visible to the current user that are prepared for instantiation'
;
--------------------------------------------------------
--  DDL for View ALL_CATALOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CATALOG" ("OWNER", "TABLE_NAME", "TABLE_TYPE") AS 
  select u.name, o.name,
       decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE', 'UNDEFINED')
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o
where o.owner# = u.user#
  and ((o.type# in (4, 5, 6))
       or
       (o.type# = 2     /* tables, excluding iot - overflow and nested tables */
        and
        not exists (select null
                      from sys.tab$ t
                     where t.obj# = o.obj#
                       and (bitand(t.property, 512) = 512 or
                            bitand(t.property, 8192) = 8192))))
  and o.linkname is null
  and (o.owner# in (userenv('SCHEMAID'), 1)   /* public objects */
       or
       obj# in ( select obj#  /* directly granted privileges */
                 from sys.objauth$
                 where grantee# in ( select kzsrorol
                                      from x$kzsro
                                    )
                )
       or
       (
          o.type# in (2, 4, 5, 6) /* table, view, synonym and sequence */
          and
          /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
       )
      );

   COMMENT ON COLUMN "SYS"."ALL_CATALOG"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_CATALOG"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_CATALOG"."TABLE_TYPE" IS 'Type of the object';
   COMMENT ON TABLE "SYS"."ALL_CATALOG"  IS 'All tables, views, synonyms, sequences accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CLUSTER_HASH_EXPRESSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CLUSTER_HASH_EXPRESSIONS" ("OWNER", "CLUSTER_NAME", "HASH_EXPRESSION") AS 
  select us.name, o.name, c.condition
from sys.cdef$ c, sys.user$ us, sys.obj$ o
where c.type#   = 8
and   c.obj#   = o.obj#
and   us.user# = o.owner#
and   ( us.user# = userenv('SCHEMAID')
        or  /* user has system privileges */
        ora_check_sys_privilege ( o.owner#, o.type# ) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_CLUSTER_HASH_EXPRESSIONS"."OWNER" IS 'Name of owner of cluster';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTER_HASH_EXPRESSIONS"."CLUSTER_NAME" IS 'Name of cluster';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTER_HASH_EXPRESSIONS"."HASH_EXPRESSION" IS 'Text of hash function of cluster';
   COMMENT ON TABLE "SYS"."ALL_CLUSTER_HASH_EXPRESSIONS"  IS 'Hash functions for all accessible clusters'
;
--------------------------------------------------------
--  DDL for View ALL_CLUSTERING_DIMENSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CLUSTERING_DIMENSIONS" ("OWNER", "TABLE_NAME", "DIMENSION_OWNER", "DIMENSION_NAME") AS 
  select d.OWNER, d.TABLE_NAME, d.DIMENSION_OWNER, d.DIMENSION_NAME
from   DBA_CLUSTERING_DIMENSIONS d, ALL_TABLES t
WHERE  d.OWNER = t.OWNER
AND    d.TABLE_NAME = t.TABLE_NAME;

   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_DIMENSIONS"."OWNER" IS 'Owner of the clustering table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_DIMENSIONS"."TABLE_NAME" IS 'Name of the clustering table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_DIMENSIONS"."DIMENSION_OWNER" IS 'Owner of the dimension table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_DIMENSIONS"."DIMENSION_NAME" IS 'Name of the dimension table';
   COMMENT ON TABLE "SYS"."ALL_CLUSTERING_DIMENSIONS"  IS 'All dimension details about clustering tables the user owns or has system privileges'
;
--------------------------------------------------------
--  DDL for View ALL_CLUSTERING_JOINS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CLUSTERING_JOINS" ("OWNER", "TABLE_NAME", "TAB1_OWNER", "TAB1_NAME", "TAB1_COLUMN", "TAB2_OWNER", "TAB2_NAME", "TAB2_COLUMN") AS 
  select j.OWNER, j.TABLE_NAME, j.TAB1_OWNER, j.TAB1_NAME,
       j.TAB1_COLUMN, j.TAB2_OWNER, j.TAB2_NAME,
       j.TAB2_COLUMN
from   DBA_CLUSTERING_JOINS j, ALL_TABLES t
WHERE  j.OWNER = t.OWNER
AND    j.TABLE_NAME = t.TABLE_NAME;

   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_JOINS"."OWNER" IS 'Owner of the clustering table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_JOINS"."TABLE_NAME" IS 'Name of the clustering table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_JOINS"."TAB1_OWNER" IS 'Owner of the first dimension table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_JOINS"."TAB1_NAME" IS 'Name of the first dimension table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_JOINS"."TAB1_COLUMN" IS 'Name of the first dimension table column';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_JOINS"."TAB2_OWNER" IS 'Owner of the second dimension table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_JOINS"."TAB2_NAME" IS 'Name of the second dimension table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_JOINS"."TAB2_COLUMN" IS 'Name of the second dimension table column';
   COMMENT ON TABLE "SYS"."ALL_CLUSTERING_JOINS"  IS 'All join details about clustering tables the user owns or has system privileges'
;
--------------------------------------------------------
--  DDL for View ALL_CLUSTERING_KEYS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CLUSTERING_KEYS" ("OWNER", "TABLE_NAME", "DETAIL_OWNER", "DETAIL_NAME", "DETAIL_COLUMN", "POSITION", "GROUPID") AS 
  select k.owner, k.table_name, k.detail_owner, k.detail_name, k.detail_column,
       k.position, k.groupid
from   DBA_CLUSTERING_KEYS k, ALL_TABLES t
WHERE  k.OWNER = t.OWNER
AND    k.TABLE_NAME = t.TABLE_NAME;

   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_KEYS"."OWNER" IS 'Owner of the table on which clustering clause is defined';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_KEYS"."TABLE_NAME" IS 'Name of the table on which clustering clause is defined';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_KEYS"."DETAIL_OWNER" IS 'Owner of the detailed table contributing to the clustering keys';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_KEYS"."DETAIL_NAME" IS 'Name of the detailed table contributing to the clustering keys';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_KEYS"."POSITION" IS 'Position of the column in the clustering clause';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_KEYS"."GROUPID" IS 'Group of the column in the clustering clause';
   COMMENT ON TABLE "SYS"."ALL_CLUSTERING_KEYS"  IS 'Description of the keys of the clustering clause of tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CLUSTERING_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CLUSTERING_TABLES" ("OWNER", "TABLE_NAME", "CLUSTERING_TYPE", "ON_LOAD", "ON_DATAMOVEMENT", "VALID", "WITH_ZONEMAP", "LAST_LOAD_CLST", "LAST_DATAMOVE_CLST") AS 
  select c.owner, c.table_name, c.clustering_type, c.on_load, c.on_datamovement,
       c.valid, c.with_zonemap, c.last_load_clst, c.last_datamove_clst
from   DBA_CLUSTERING_TABLES c, ALL_TABLES t
WHERE  c.OWNER = t.OWNER
AND    c.TABLE_NAME = t.TABLE_NAME;

   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."CLUSTERING_TYPE" IS 'Clustering type';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."ON_LOAD" IS 'Will Oracle cluster data on load';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."ON_DATAMOVEMENT" IS 'Will Oracle cluster data on data movement, for example partition move';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."VALID" IS 'Is clustering valid. It is invalid if dimension does not have pk/uk constraint';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."WITH_ZONEMAP" IS 'Is a zonemap also created with clustering';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."LAST_LOAD_CLST" IS 'Last time the clustering occured on load';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERING_TABLES"."LAST_DATAMOVE_CLST" IS 'Last time the clustering occured on data movement, for example partition move';
   COMMENT ON TABLE "SYS"."ALL_CLUSTERING_TABLES"  IS 'Description of the clustering clause of tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CLUSTERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CLUSTERS" ("OWNER", "CLUSTER_NAME", "TABLESPACE_NAME", "PCT_FREE", "PCT_USED", "KEY_SIZE", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENTS", "MAX_EXTENTS", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "AVG_BLOCKS_PER_KEY", "CLUSTER_TYPE", "FUNCTION", "HASHKEYS", "DEGREE", "INSTANCES", "CACHE", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "SINGLE_TABLE", "DEPENDENCIES") AS 
  select OWNER, CLUSTER_NAME, TABLESPACE_NAME,
          PCT_FREE, PCT_USED, KEY_SIZE,
          INI_TRANS, MAX_TRANS,
          INITIAL_EXTENT, NEXT_EXTENT,
          MIN_EXTENTS, MAX_EXTENTS, PCT_INCREASE,
          FREELISTS, FREELIST_GROUPS,
          AVG_BLOCKS_PER_KEY,
          CLUSTER_TYPE, FUNCTION, HASHKEYS,
          DEGREE, INSTANCES, CACHE, BUFFER_POOL, FLASH_CACHE,
          CELL_FLASH_CACHE, SINGLE_TABLE, DEPENDENCIES
from INT$DBA_CLUSTERS
where (OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or  /* user has system privileges */
       (
        /* 3 is the type# for CLUSTER. See kgl.h for more info */
        ora_check_sys_privilege ( ownerid, 3 ) = 1
       )
      );

   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."OWNER" IS 'Owner of the cluster';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."CLUSTER_NAME" IS 'Name of the cluster';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."TABLESPACE_NAME" IS 'Name of the tablespace containing the cluster';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."PCT_FREE" IS 'Minimum percentage of free space in a block';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."PCT_USED" IS 'Minimum percentage of used space in a block';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."KEY_SIZE" IS 'Estimated size of cluster key plus associated rows';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."INI_TRANS" IS 'Initial number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."MAX_TRANS" IS 'Maximum number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."INITIAL_EXTENT" IS 'Size of the initial extent in bytes';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."NEXT_EXTENT" IS 'Size of secondary extents in bytes';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."MIN_EXTENTS" IS 'Minimum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."MAX_EXTENTS" IS 'Maximum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."PCT_INCREASE" IS 'Percentage increase in extent size';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."FREELISTS" IS 'Number of process freelists allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."FREELIST_GROUPS" IS 'Number of freelist groups allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."AVG_BLOCKS_PER_KEY" IS 'Average number of blocks containing rows with a given cluster key';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."CLUSTER_TYPE" IS 'Type of cluster: b-tree index or hash';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."FUNCTION" IS 'If a hash cluster, the hash function';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."HASHKEYS" IS 'If a hash cluster, the number of hash keys (hash buckets)';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."DEGREE" IS 'The number of threads per instance for scanning the cluster';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."INSTANCES" IS 'The number of instances across which the cluster is to be scanned';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."CACHE" IS 'Whether the cluster is to be cached in the buffer cache';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."BUFFER_POOL" IS 'The default buffer pool to be used for cluster blocks';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."FLASH_CACHE" IS 'The default flash cache hint to be used for cluster blocks';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."CELL_FLASH_CACHE" IS 'The default cell flash cache hint to be used for cluster blocks';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."SINGLE_TABLE" IS 'Whether the cluster can contain only a single table';
   COMMENT ON COLUMN "SYS"."ALL_CLUSTERS"."DEPENDENCIES" IS 'Should we keep track of row level dependencies?';
   COMMENT ON TABLE "SYS"."ALL_CLUSTERS"  IS 'Description of clusters accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CODE_ROLE_PRIVS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CODE_ROLE_PRIVS" ("OWNER", "OBJECT_NAME", "OBJECT_TYPE", "ROLE") AS 
  (
select u.name, o.name, decode(o.type#, 7,  'PROCEDURE',
                               8,  'FUNCTION',
                               9,  'PACKAGE',
                               13, 'TYPE',
                                   'UNDEFINED'),
       r.name
  from sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ r,
       sys.codeauth$ c
 where o.obj# = c.obj#
   and c.privilege# = r.user#
   and u.user# = o.owner#
   and (o.owner# = userenv('SCHEMAID')
    or
    (
      o.obj# in (select obj# from sys.objauth$
                 where grantee# in (select kzsrorol from x$kzsro)
                 and privilege# in (3 /* DELETE */,   6 /* INSERT */,
                                    7 /* LOCK */,     9 /* SELECT */,
                                    10 /* UPDATE */, 12 /* EXECUTE */,
                                    11 /* USAGE */,  16 /* CREATE */,
                                    17 /* READ */,   18 /* WRITE  */))
    )
    or
      ora_check_sys_privilege (o.owner#, o.type#) = 1
  )
);

   COMMENT ON COLUMN "SYS"."ALL_CODE_ROLE_PRIVS"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_CODE_ROLE_PRIVS"."OBJECT_NAME" IS 'Object name';
   COMMENT ON COLUMN "SYS"."ALL_CODE_ROLE_PRIVS"."OBJECT_TYPE" IS 'Object type';
   COMMENT ON COLUMN "SYS"."ALL_CODE_ROLE_PRIVS"."ROLE" IS 'Attached role name';
   COMMENT ON TABLE "SYS"."ALL_CODE_ROLE_PRIVS"  IS 'Roles attached to the program units accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_COL_COMMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_COL_COMMENTS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "COMMENTS", "ORIGIN_CON_ID") AS 
  select OWNER, TABLE_NAME, COLUMN_NAME, COMMENTS, ORIGIN_CON_ID
from INT$DBA_COL_COMMENTS
where (OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OBJ_ID(OWNER, TABLE_NAME, OBJECT_TYPE#, OBJECT_ID) in
         (select obj#
          from sys.objauth$
          where grantee# in ( select kzsrorol
                              from x$kzsro
                            )
          )
       or
       /* 2 is the type# for Table. See kgl.h for more info */
       ora_check_sys_privilege ( ownerid, 2 ) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_COL_COMMENTS"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_COL_COMMENTS"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_COL_COMMENTS"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_COMMENTS"."COMMENTS" IS 'Comment on the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_COMMENTS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_COL_COMMENTS"  IS 'Comments on columns of accessible tables and views'
;
--------------------------------------------------------
--  DDL for View ALL_COLL_TYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_COLL_TYPES" ("OWNER", "TYPE_NAME", "COLL_TYPE", "UPPER_BOUND", "ELEM_TYPE_MOD", "ELEM_TYPE_OWNER", "ELEM_TYPE_NAME", "LENGTH", "PRECISION", "SCALE", "CHARACTER_SET_NAME", "ELEM_STORAGE", "NULLS_STORED", "CHAR_USED") AS 
  select u.name, o.name, co.name, c.upper_bound,
       decode(bitand(c.properties, 32768), 32768, 'REF',
              decode(bitand(c.properties, 16384), 16384, 'POINTER')),
       nvl2(c.synobj#, (select u.name from user$ u, "_CURRENT_EDITION_OBJ" o
            where o.owner#=u.user# and o.obj#=c.synobj#),
            decode(bitand(et.properties, 64), 64, null, eu.name)),
       nvl2(c.synobj#, (select o.name from "_CURRENT_EDITION_OBJ" o where o.obj#=c.synobj#),
            decode(et.typecode,
                   9, decode(c.charsetform, 2, 'NVARCHAR2', eo.name),
                   96, decode(c.charsetform, 2, 'NCHAR', eo.name),
                   112, decode(c.charsetform, 2, 'NCLOB', eo.name),
                   eo.name)),
       c.length, c.precision, c.scale,
       decode(c.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(c.charsetid),
                             4, 'ARG:'||c.charsetid),
       decode(bitand(c.properties, 131072), 131072, 'FIXED',
              decode(bitand(c.properties, 262144), 262144, 'VARYING')),
       decode(bitand(c.properties, 65536), 65536, 'NO', 'YES'),
       decode(bitand(c.properties, 4096), 4096, 'C', 'B')
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.collection$ c, sys."_CURRENT_EDITION_OBJ" co,
     sys."_CURRENT_EDITION_OBJ" eo, sys.user$ eu, sys.type$ et
where o.owner# = u.user#
  and o.type# <> 10 -- must not be invalid
  and o.oid$ = c.toid
  and o.subname IS NULL -- only the most recent version
  and c.coll_toid = co.oid$
  and c.elem_toid = eo.oid$
  and eo.owner# = eu.user#
  and c.elem_toid = et.tvoid
  and c.package_obj# IS NULL -- filter out plsql types
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
         ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."COLL_TYPE" IS 'Collection type';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."UPPER_BOUND" IS 'Size of the FIXED ARRAY type or maximum size of the VARYING ARRAY type';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."ELEM_TYPE_MOD" IS 'Type modifier of the element';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."ELEM_TYPE_OWNER" IS 'Owner of the type of the element';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."ELEM_TYPE_NAME" IS 'Name of the type of the element';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."LENGTH" IS 'Length of the CHAR element or maximum length of the VARCHAR
or VARCHAR2 element';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."PRECISION" IS 'Decimal precision of the NUMBER or DECIMAL element or
binary precision of the FLOAT element';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."SCALE" IS 'Scale of the NUMBER or DECIMAL element';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."CHARACTER_SET_NAME" IS 'Character set name of the element';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."ELEM_STORAGE" IS 'Storage optimization specification for VARRAY of numeric elements';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."NULLS_STORED" IS 'Is null information stored with each VARRAY element?';
   COMMENT ON COLUMN "SYS"."ALL_COLL_TYPES"."CHAR_USED" IS 'C if the width was specified in characters, B if in bytes';
   COMMENT ON TABLE "SYS"."ALL_COLL_TYPES"  IS 'Description of named collection types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_COL_PENDING_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_COL_PENDING_STATS" ("OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "COLUMN_NAME", "NUM_DISTINCT", "LOW_VALUE", "HIGH_VALUE", "DENSITY", "NUM_NULLS", "AVG_COL_LEN", "SAMPLE_SIZE", "LAST_ANALYZED") AS 
  select u.name, o.name, null, null, c.name, h.distcnt,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.lowval
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.hival
              else null
         end,
         h.density, h.null_cnt, h.avgcln, h.sample_size, h.TIMESTAMP#
  from   sys.user$ u, sys.obj$ o, sys.col$ c,
         sys."_OPTSTAT_HISTHEAD_HISTORY_DEC" h
  where  h.obj# = c.obj#
    and  h.intcol# = c.intcol#
    and  h.obj# = o.obj#
    and  o.owner# = u.user#
    and  o.type# = 2
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  -- partitions
  select u.name, o.name, o.subname, null, c.name, h.distcnt,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.lowval
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.hival
         else null
         end,
         h.density, h.null_cnt, h.avgcln, h.sample_size, h.TIMESTAMP#
  from   sys.user$ u, sys.obj$ o, sys.col$ c, sys.tabpart$ t,
         sys."_OPTSTAT_HISTHEAD_HISTORY_DEC" h
  where  t.bo# = c.obj#
    and  t.obj# = o.obj#
    and  h.intcol# = c.intcol#
    and  h.obj# = o.obj#
    and  o.type# = 19
    and  o.owner# = u.user#
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  select u.name, o.name, o.subname, null, c.name, h.distcnt,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.lowval
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.hival
            else null
         end,
         h.density, h.null_cnt, h.avgcln, h.sample_size, h.TIMESTAMP#
  from   sys.user$ u, sys.obj$ o, sys.col$ c, sys.tabcompart$ t,
         sys."_OPTSTAT_HISTHEAD_HISTORY_DEC" h
  where  t.bo# = c.obj#
    and  t.obj# = o.obj#
    and  h.intcol# = c.intcol#
    and  h.obj# = o.obj#
    and  o.type# = 19
    and  o.owner# = u.user#
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  -- sub partitions
  select u.name, op.name, op.subname, os.subname, c.name, h.distcnt,
         case when SYS_OP_DV_CHECK(op.name, op.owner#) = 1
              then h.lowval
              else null
         end,
         case when SYS_OP_DV_CHECK(op.name, op.owner#) = 1
            then h.hival
            else null
         end,
         h.density, h.null_cnt, h.avgcln, h.sample_size,
         h.timestamp#
  from  sys.obj$ os, sys.tabsubpart$ tsp, sys.tabcompart$ tcp,
        sys.user$ u, sys.col$ c, sys.obj$ op,
        sys."_OPTSTAT_HISTHEAD_HISTORY_DEC" h
  where os.obj# = tsp.obj#
    and os.owner# = u.user#
    and h.obj#  = tsp.obj#
    and h.intcol#= c.intcol#
    and tsp.pobj#= tcp.obj#
    and tcp.bo#  = c.obj#
    and tcp.obj# = op.obj#
    and os.type# = 34
    and h.savtime > systimestamp
    and (os.owner# = userenv('SCHEMAID')
        or os.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
        );

   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."OWNER" IS 'Table owner name';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."TABLE_NAME" IS 'Table name';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."PARTITION_NAME" IS 'Partition name';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."SUBPARTITION_NAME" IS 'Subpartition name';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."COLUMN_NAME" IS 'Column name';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."NUM_DISTINCT" IS 'The number of distinct values in the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."LOW_VALUE" IS 'The low value in the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."HIGH_VALUE" IS 'The high value in the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."DENSITY" IS 'The density of the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."NUM_NULLS" IS 'The number rows with value in the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."AVG_COL_LEN" IS 'The average length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."SAMPLE_SIZE" IS 'The sample size used in analyzing this column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PENDING_STATS"."LAST_ANALYZED" IS 'The date of the most recent time this column was analyzed';
   COMMENT ON TABLE "SYS"."ALL_COL_PENDING_STATS"  IS 'Pending statistics of tables, partitions, and subpartitions'
;
--------------------------------------------------------
--  DDL for View ALL_COL_PRIVS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_COL_PRIVS" ("GRANTOR", "GRANTEE", "TABLE_SCHEMA", "TABLE_NAME", "COLUMN_NAME", "PRIVILEGE", "GRANTABLE", "COMMON", "INHERITED") AS 
  select ur.name, ue.name, u.name, o.name, c.name, tpm.name,
       decode(mod(oa.option$,2), 1, 'YES', 'NO'), 'NO', 'NO'
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and (oa.grantor# = userenv('SCHEMAID') or
       oa.grantee# in (select kzsrorol from x$kzsro) or
       o.owner# = userenv('SCHEMAID'))
  and bitand(nvl(oa.option$, 0), 4) = 0
union all
/* Commonly granted Privileges */
select ur.name, ue.name, u.name, o.name, c.name, tpm.name,
       decode(bitand(oa.option$,16), 16, 'YES', 'NO'), 'YES',
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and (oa.grantor# = userenv('SCHEMAID') or
       oa.grantee# in (select kzsrorol from x$kzsro) or
       o.owner# = userenv('SCHEMAID'))
  and bitand(oa.option$,8) = 8
union all
/* Federationally granted Privileges */
select ur.name, ue.name, u.name, o.name, c.name, tpm.name,
       decode(bitand(oa.option$,128), 128, 'YES', 'NO'), 'YES',
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and (oa.grantor# = userenv('SCHEMAID') or
       oa.grantee# in (select kzsrorol from x$kzsro) or
       o.owner# = userenv('SCHEMAID'))
  and bitand(oa.option$,64) = 64;

   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."GRANTOR" IS 'Name of the user who performed the grant';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."GRANTEE" IS 'Name of the user to whom access was granted';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."TABLE_SCHEMA" IS 'Schema of the object';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."PRIVILEGE" IS 'Column Privilege';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."GRANTABLE" IS 'Privilege is grantable';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."COMMON" IS 'Privilege was granted commonly';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS"."INHERITED" IS 'Was privilege grant inherited from another container';
   COMMENT ON TABLE "SYS"."ALL_COL_PRIVS"  IS 'Grants on columns for which the user is the grantor, grantee, owner,
 or an enabled role or PUBLIC is the grantee'
;
--------------------------------------------------------
--  DDL for View ALL_COL_PRIVS_MADE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_COL_PRIVS_MADE" ("GRANTEE", "OWNER", "TABLE_NAME", "COLUMN_NAME", "GRANTOR", "PRIVILEGE", "GRANTABLE", "COMMON", "INHERITED") AS 
  select ue.name, u.name, o.name, c.name, ur.name, tpm.name,
       decode(mod(oa.option$,2), 1, 'YES', 'NO'), 'NO', 'NO'
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and userenv('SCHEMAID') in (o.owner#, oa.grantor#)
  and bitand(nvl(oa.option$, 0), 4) = 0
union all
/* Commonly granted Privileges */
select ue.name, u.name, o.name, c.name, ur.name, tpm.name,
       decode(bitand(oa.option$,16), 16, 'YES', 'NO'), 'YES',
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and userenv('SCHEMAID') in (o.owner#, oa.grantor#)
  and bitand(oa.option$,8) = 8
union all
/* Federationally granted Privileges */
select ue.name, u.name, o.name, c.name, ur.name, tpm.name,
       decode(bitand(oa.option$,128), 128, 'YES', 'NO'), 'YES',
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and userenv('SCHEMAID') in (o.owner#, oa.grantor#)
  and bitand(oa.option$,64) = 64;

   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."GRANTEE" IS 'Name of the user to whom access was granted';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."GRANTOR" IS 'Name of the user who performed the grant';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."PRIVILEGE" IS 'Column Privilege';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."GRANTABLE" IS 'Privilege is grantable';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."COMMON" IS 'Privilege was granted commonly';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_MADE"."INHERITED" IS 'Was privilege grant inherited from another container';
   COMMENT ON TABLE "SYS"."ALL_COL_PRIVS_MADE"  IS 'Grants on columns for which the user is owner or grantor'
;
--------------------------------------------------------
--  DDL for View ALL_COL_PRIVS_RECD
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_COL_PRIVS_RECD" ("GRANTEE", "OWNER", "TABLE_NAME", "COLUMN_NAME", "GRANTOR", "PRIVILEGE", "GRANTABLE", "COMMON", "INHERITED") AS 
  select ue.name, u.name, o.name, c.name, ur.name, tpm.name,
       decode(mod(oa.option$,2), 1, 'YES', 'NO'), 'NO', 'NO'
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and oa.grantee# in (select kzsrorol from x$kzsro)
  and bitand(nvl(oa.option$, 0), 4) = 0
union all
/* Commonly granted Privileges */
select ue.name, u.name, o.name, c.name, ur.name, tpm.name,
       decode(bitand(oa.option$,16), 16, 'YES', 'NO'), 'YES',
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and oa.grantee# in (select kzsrorol from x$kzsro)
  and bitand(oa.option$,8) = 8
union all
/* Federationally granted Privileges */
select ue.name, u.name, o.name, c.name, ur.name, tpm.name,
       decode(bitand(oa.option$,128), 128, 'YES', 'NO'), 'YES',
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.col$ c, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.obj# = c.obj#
  and oa.col# = c.col#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and oa.col# is not null
  and oa.privilege# = tpm.privilege
  and oa.grantee# in (select kzsrorol from x$kzsro)
  and bitand(oa.option$,64) = 64;

   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."GRANTEE" IS 'Name of the user to whom access was granted';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."GRANTOR" IS 'Name of the user who performed the grant';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."PRIVILEGE" IS 'Column privilege';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."GRANTABLE" IS 'Privilege is grantable';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."COMMON" IS 'Privilege was granted commonly';
   COMMENT ON COLUMN "SYS"."ALL_COL_PRIVS_RECD"."INHERITED" IS 'Was privilege grant inherited from another container';
   COMMENT ON TABLE "SYS"."ALL_COL_PRIVS_RECD"  IS 'Grants on columns for which the user, PUBLIC or enabled role is the grantee'
;
--------------------------------------------------------
--  DDL for View ALL_COMPARISON_SCAN_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_COMPARISON_SCAN_SUMMARY" ("OWNER", "COMPARISON_NAME", "SCAN_ID", "PARENT_SCAN_ID", "ROOT_SCAN_ID", "STATUS", "CURRENT_DIF_COUNT", "INITIAL_DIF_COUNT", "COUNT_ROWS", "SCAN_NULLS", "LAST_UPDATE_TIME") AS 
  SELECT css."OWNER",css."COMPARISON_NAME",css."SCAN_ID",css."PARENT_SCAN_ID",css."ROOT_SCAN_ID",css."STATUS",css."CURRENT_DIF_COUNT",css."INITIAL_DIF_COUNT",css."COUNT_ROWS",css."SCAN_NULLS",css."LAST_UPDATE_TIME"
FROM dba_comparison_scan_summary css, ALL_APPLY aa, ALL_CAPTURE ca
  where (aa.apply_user = css.owner) or (ca.capture_user = css.owner);

   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."OWNER" IS 'Owner of comparison';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."COMPARISON_NAME" IS 'Name of comparison';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."SCAN_ID" IS 'Scan id of scan';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."PARENT_SCAN_ID" IS 'Immediate parent scan''s scan id';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."ROOT_SCAN_ID" IS 'Scan_id of the root (top-most) parent';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."STATUS" IS 'Status of scan: SUC, BUCKET DIF, FINAL BUCKET DIF, ROW DIF';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."CURRENT_DIF_COUNT" IS 'Current cumulative (incl children) dif count of scan';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."INITIAL_DIF_COUNT" IS 'Initial cumulative (incl children) dif count of scan';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."COUNT_ROWS" IS 'Number of rows in the scan';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."SCAN_NULLS" IS 'Whether NULLs are part of this scan';
   COMMENT ON COLUMN "SYS"."ALL_COMPARISON_SCAN_SUMMARY"."LAST_UPDATE_TIME" IS 'The time that this row was updated';
   COMMENT ON TABLE "SYS"."ALL_COMPARISON_SCAN_SUMMARY"  IS 'Details about a comparison scan for the user'
;
--------------------------------------------------------
--  DDL for View ALL_CONS_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CONS_COLUMNS" ("OWNER", "CONSTRAINT_NAME", "TABLE_NAME", "COLUMN_NAME", "POSITION") AS 
  select u.name, c.name, o.name,
       decode(ac.name, null, col.name, ac.name), cc.pos#
from sys.user$ u, sys.con$ c, sys.col$ col, sys.ccol$ cc, sys.cdef$ cd,
     sys."_CURRENT_EDITION_OBJ" o, sys.attrcol$ ac
where c.owner# = u.user#
  and c.con# = cd.con#
  and (cd.type# < 14 or cd.type# > 17)   /* don't include supplog cons   */
  and (cd.type# != 12)                   /* don't include log group cons */
  and cd.con# = cc.con#
  and cc.obj# = col.obj#
  and cc.intcol# = col.intcol#
  and cc.obj# = o.obj#
  and (c.owner# = userenv('SCHEMAID')
       or cd.obj# in (select obj#
                      from sys.objauth$
                      where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                     )
        or /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
  and col.obj# = ac.obj#(+)
  and col.intcol# = ac.intcol#(+);

   COMMENT ON COLUMN "SYS"."ALL_CONS_COLUMNS"."OWNER" IS 'Owner of the constraint definition';
   COMMENT ON COLUMN "SYS"."ALL_CONS_COLUMNS"."CONSTRAINT_NAME" IS 'Name associated with the constraint definition';
   COMMENT ON COLUMN "SYS"."ALL_CONS_COLUMNS"."TABLE_NAME" IS 'Name associated with table with constraint definition';
   COMMENT ON COLUMN "SYS"."ALL_CONS_COLUMNS"."COLUMN_NAME" IS 'Name associated with column or attribute of object column specified in the constraint definition';
   COMMENT ON COLUMN "SYS"."ALL_CONS_COLUMNS"."POSITION" IS 'Original position of column or attribute in definition';
   COMMENT ON TABLE "SYS"."ALL_CONS_COLUMNS"  IS 'Information about accessible columns in constraint definitions'
;
--------------------------------------------------------
--  DDL for View ALL_CONS_OBJ_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CONS_OBJ_COLUMNS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "CONS_TYPE_OWNER", "CONS_TYPE_NAME", "CONS_TYPE_ONLY") AS 
  select uc.name, oc.name, c.name, ut.name, ot.name,
       lpad(decode(bitand(sc.flags, 2), 2, 'Y', 'N'), 15)
from sys.user$ uc, sys."_CURRENT_EDITION_OBJ" oc, sys.col$ c, sys."_BASE_USER" ut,
     sys.obj$ ot, sys.subcoltype$ sc
where oc.owner# = uc.user#
  and bitand(sc.flags, 1) = 1      /* Type is specified in the IS OF clause */
  and oc.obj#=sc.obj#
  and oc.obj#=c.obj#
  and c.intcol#=sc.intcol#
  and sc.toid=ot.oid$
  and ot.owner#=ut.user#
  and bitand(c.property,32768) != 32768                /* not unused column */
  and not exists (select null                  /* Doesn't exist in attrcol$ */
                  from sys.attrcol$ ac
                  where ac.intcol#=sc.intcol#
                        and ac.obj#=sc.obj#)
  and (oc.owner# = userenv('SCHEMAID')
       or oc.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege (oc.owner#, oc.type#) = 1
      )
union all
select uc.name, oc.name, ac.name, ut.name, ot.name,
       lpad(decode(bitand(sc.flags, 2), 2, 'Y', 'N'), 15)
from sys.user$ uc, sys."_CURRENT_EDITION_OBJ" oc, sys.col$ c, sys."_BASE_USER" ut,
     sys.obj$ ot, sys.subcoltype$ sc, sys.attrcol$ ac
where oc.owner# = uc.user#
  and bitand(sc.flags, 1) = 1      /* Type is specified in the IS OF clause */
  and oc.obj#=sc.obj#
  and oc.obj#=c.obj#
  and oc.obj#=ac.obj#
  and c.intcol#=sc.intcol#
  and ac.intcol#=sc.intcol#
  and sc.toid=ot.oid$
  and ot.owner#=ut.user#
  and bitand(c.property,32768) != 32768                /* not unused column */
  and (oc.owner# = userenv('SCHEMAID')
       or oc.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege (oc.owner#, oc.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_CONS_OBJ_COLUMNS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_CONS_OBJ_COLUMNS"."TABLE_NAME" IS 'Name of the table containing the object column or attribute';
   COMMENT ON COLUMN "SYS"."ALL_CONS_OBJ_COLUMNS"."COLUMN_NAME" IS 'Fully qualified name of the object column or attribute';
   COMMENT ON COLUMN "SYS"."ALL_CONS_OBJ_COLUMNS"."CONS_TYPE_OWNER" IS 'Owner of the type that the column is constrained to';
   COMMENT ON COLUMN "SYS"."ALL_CONS_OBJ_COLUMNS"."CONS_TYPE_NAME" IS 'Name of the type that the column is constrained to';
   COMMENT ON COLUMN "SYS"."ALL_CONS_OBJ_COLUMNS"."CONS_TYPE_ONLY" IS 'Indication of whether the column is constrained to ONLY type';
   COMMENT ON TABLE "SYS"."ALL_CONS_OBJ_COLUMNS"  IS 'List of types an object column or attribute is constrained to in the tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CONSTRAINTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CONSTRAINTS" ("OWNER", "CONSTRAINT_NAME", "CONSTRAINT_TYPE", "TABLE_NAME", "SEARCH_CONDITION", "SEARCH_CONDITION_VC", "R_OWNER", "R_CONSTRAINT_NAME", "DELETE_RULE", "STATUS", "DEFERRABLE", "DEFERRED", "VALIDATED", "GENERATED", "BAD", "RELY", "LAST_CHANGE", "INDEX_OWNER", "INDEX_NAME", "INVALID", "VIEW_RELATED", "ORIGIN_CON_ID") AS 
  select OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE,
       TABLE_NAME, SEARCH_CONDITION, SEARCH_CONDITION_VC,
       R_OWNER, R_CONSTRAINT_NAME, DELETE_RULE, STATUS,
       DEFERRABLE, DEFERRED, VALIDATED, GENERATED,
       BAD, RELY, LAST_CHANGE, INDEX_OWNER, INDEX_NAME,
       INVALID, VIEW_RELATED, ORIGIN_CON_ID
from INT$DBA_CONSTRAINTS
where (OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OBJ_ID(OWNER, TABLE_NAME, OBJECT_TYPE#, OBJECT_ID) in
          (select obj# from sys.objauth$
                       where grantee# in ( select kzsrorol
                                           from x$kzsro
                                         )
          )
        or /* user has system privileges */
        ora_check_sys_privilege ( ownerid, object_type# ) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."CONSTRAINT_NAME" IS 'Name associated with constraint definition';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."CONSTRAINT_TYPE" IS 'Type of constraint definition';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."TABLE_NAME" IS 'Name associated with table with constraint definition';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."SEARCH_CONDITION" IS 'Text of search condition for table check';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."SEARCH_CONDITION_VC" IS 'Possibly truncated text of search condition for table check';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."R_OWNER" IS 'Owner of table used in referential constraint';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."R_CONSTRAINT_NAME" IS 'Name of unique constraint definition for referenced table';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."DELETE_RULE" IS 'The delete rule for a referential constraint';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."STATUS" IS 'Enforcement status of constraint - ENABLED or DISABLED';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."DEFERRABLE" IS 'Is the constraint deferrable - DEFERRABLE or NOT DEFERRABLE';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."DEFERRED" IS 'Is the constraint deferred by default -  DEFERRED or IMMEDIATE';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."VALIDATED" IS 'Was this constraint system validated? -  VALIDATED or NOT VALIDATED';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."GENERATED" IS 'Was the constraint name system generated? -  GENERATED NAME or USER NAME';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."BAD" IS 'Creating this constraint should give ORA-02436.  Rewrite it before 2000 AD.';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."RELY" IS 'If set, this flag will be used in optimizer';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."LAST_CHANGE" IS 'The date when this column was last enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."INDEX_OWNER" IS 'The owner of the index used by this constraint';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."INDEX_NAME" IS 'The index used by this constraint';
   COMMENT ON COLUMN "SYS"."ALL_CONSTRAINTS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_CONSTRAINTS"  IS 'Constraint definitions on accessible tables'
;
--------------------------------------------------------
--  DDL for View ALL_CONTEXT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CONTEXT" ("NAMESPACE", "SCHEMA", "PACKAGE") AS 
  select o.name, c.schema, c.package
from  context$ c, obj$ o
where o.obj# = c.obj# and
      o.type# = 44 and
      exists ( select null
               from v$context  v
               where v.namespace = o.name
             );

   COMMENT ON COLUMN "SYS"."ALL_CONTEXT"."NAMESPACE" IS 'Namespace of the active context';
   COMMENT ON COLUMN "SYS"."ALL_CONTEXT"."SCHEMA" IS 'Schema of the designated package';
   COMMENT ON COLUMN "SYS"."ALL_CONTEXT"."PACKAGE" IS 'Name of the designated package';
   COMMENT ON TABLE "SYS"."ALL_CONTEXT"  IS 'Description of all active context namespaces under the current session'
;
--------------------------------------------------------
--  DDL for View ALL_CREDENTIALS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CREDENTIALS" ("OWNER", "CREDENTIAL_NAME", "USERNAME", "WINDOWS_DOMAIN", "COMMENTS", "ENABLED") AS 
  SELECT u.name, o.name, c.username,
  c.domain, c.comments,
  DECODE(bitand(c.flags,4), 0, 'FALSE', 4, 'TRUE')
  FROM obj$ o, user$ u, sys.scheduler$_credential c
  WHERE c.obj# = o.obj# AND u.user# = o.owner# AND
    (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-388 /* CREATE ANY CREDENTIAL*/)
                 )
          and o.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_CREDENTIALS"."OWNER" IS 'Owner of the credential';
   COMMENT ON COLUMN "SYS"."ALL_CREDENTIALS"."CREDENTIAL_NAME" IS 'Name of the credential';
   COMMENT ON COLUMN "SYS"."ALL_CREDENTIALS"."USERNAME" IS 'User to run as';
   COMMENT ON COLUMN "SYS"."ALL_CREDENTIALS"."WINDOWS_DOMAIN" IS 'Windows domain to use when logging in';
   COMMENT ON COLUMN "SYS"."ALL_CREDENTIALS"."COMMENTS" IS 'Comments on the credential';
   COMMENT ON COLUMN "SYS"."ALL_CREDENTIALS"."ENABLED" IS 'Is this credential enabled';
   COMMENT ON TABLE "SYS"."ALL_CREDENTIALS"  IS 'All credentials visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_ATTRIBUTES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_ATTRIBUTES" ("OWNER", "DIMENSION_NAME", "ATTRIBUTE_NAME", "ATTRIBUTE_ID", "TARGET_DIMENSION_NAME", "ATTRIBUTE_ROLE", "DESCRIPTION", "ATTRIBUTE_GROUP_NAME", "DATA_TYPE", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "CREATE_INDEX", "IS_MULTI_LINGUAL") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  a.attribute_id ATTRIBUTE_ID,
  tdo.name TARGET_DIMENSION_NAME,
  (CASE a.attribute_role_mask
     WHEN 1 THEN 'SHORT_DESCRIPTION'
     WHEN 2 THEN 'LONG_DESCRIPTION'
     WHEN 3 THEN 'DESCRIPTION'
     WHEN 4 THEN 'TIME_SPAN'
     WHEN 8 THEN 'END_DATE'
     WHEN 16 THEN 'START_DATE'
     ELSE null END) ATTRIBUTE_ROLE,
  d.description_value DESCRIPTION,
  i.option_value ATTRIBUTE_GROUP_NAME,
  DECODE(a.type#, 1, decode(a.charsetform, 2, 'NVARCHAR2', 'VARCHAR2'),
                  2, decode(a.scale, null,
                            decode(a.precision#, null, 'NUMBER', 'FLOAT'),
                            'NUMBER'),
                  8, 'LONG',
                  9, decode(a.charsetform, 2, 'NCHAR VARYING', 'VARCHAR'),
                  12, 'DATE',
                  23, 'RAW', 24, 'LONG RAW',
                  69, 'ROWID',
                  96, decode(a.charsetform, 2, 'NCHAR', 'CHAR'),
                  100, 'BINARY_FLOAT',
                  101, 'BINARY_DOUBLE',
                  105, 'MLSLABEL',
                  106, 'MLSLABEL',
                  112, decode(a.charsetform, 2, 'NCLOB', 'CLOB'),
                  113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
                  178, 'TIME(' ||a.scale|| ')',
                  179, 'TIME(' ||a.scale|| ')' || ' WITH TIME ZONE',
                  180, 'TIMESTAMP(' ||a.scale|| ')',
                  181, 'TIMESTAMP(' ||a.scale|| ')' || ' WITH TIME ZONE',
                  231, 'TIMESTAMP(' ||a.scale|| ')' || ' WITH LOCAL TIME ZONE',
                  182, 'INTERVAL YEAR(' ||a.precision#||') TO MONTH',
                  183, 'INTERVAL DAY(' ||a.precision#||') TO SECOND(' ||
                        a.scale || ')',
                  208, 'UROWID',
                  'UNDEFINED') DATA_TYPE,
  a.length DATA_LENGTH,
  a.precision# DATA_PRECISION,
  a.scale DATA_SCALE,
  DECODE(i2.option_num_value, 1, 'YES', NULL, 'NO') CREATE_INDEX,
  DECODE(i3.option_num_value, 1, 'YES', NULL, 'NO') IS_MULTI_LINGUAL
FROM
  olap_attributes$ a,
  obj$ o,
  obj$ tdo,
  user$ u,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 15 --ATTRIBUTE
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d,
  olap_syntax$ s,
  olap_impl_options$ i,  -- For ATTRIBUTE_GROUP_NAME
  olap_impl_options$ i2, -- For CREATE_INDEX
  olap_impl_options$ i3  -- For IS_MULTI_LINGUAL
WHERE
  o.obj#=a.dim_obj#
  AND o.owner#=u.user#
  AND a.target_dim#=tdo.obj#(+)
  AND a.attribute_id=s.owner_id(+)
  AND s.owner_type(+) = 15 --ATTRIBUTE
  AND s.ref_role(+) = 2 --ATTRIBUTE_ROLE
  AND a.attribute_id = d.owning_object_id(+)
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND a.attribute_id = i.owning_objectid(+)
  AND i.object_type(+) = 15
  AND i.option_type(+) = 35
  AND a.attribute_id = i2.owning_objectid(+)
  AND i2.object_type(+) = 15 --ATTRIBUTE
  AND i2.option_type(+) = 3  --CREATE_INDEX
  AND a.attribute_id = i3.owning_objectid(+)
  AND i3.object_type(+) = 15 --ATTRIBUTE
  AND i3.option_type(+) = 2  --IS_MULTI_LINGUAL;

   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."OWNER" IS 'Owner of OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."DIMENSION_NAME" IS 'Name of owning Cube Dimension of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."ATTRIBUTE_NAME" IS 'Name of OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."ATTRIBUTE_ID" IS 'Dictionary Id of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."TARGET_DIMENSION_NAME" IS 'Name of Target Dimension of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."ATTRIBUTE_ROLE" IS 'Special role this attribute plays (e.g. ShortDescription), or null if none';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."DESCRIPTION" IS 'Long Description of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."ATTRIBUTE_GROUP_NAME" IS 'Name of attribute group of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."DATA_TYPE" IS 'Data Type of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."DATA_LENGTH" IS 'Data Length of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."DATA_PRECISION" IS 'Data Precision of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."DATA_SCALE" IS 'Data Scale of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."CREATE_INDEX" IS 'Create Index flag of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTRIBUTES"."IS_MULTI_LINGUAL" IS 'Is MultiLingual flag of the OLAP Attribute';
   COMMENT ON TABLE "SYS"."ALL_CUBE_ATTRIBUTES"  IS 'OLAP Attributes in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_ATTR_MAPPINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_ATTR_MAPPINGS" ("OWNER", "DIMENSION_NAME", "ATTRIBUTE_NAME", "OWNER_MAP_DIMENSION_TYPE", "OWNER_MAP_HIERARCHY_NAME", "OWNER_MAP_LEVEL_NAME", "OWNER_MAP_NAME", "MAP_NAME", "MAP_ID", "ATTRIBUTE_EXPRESSION", "LANGUAGE") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  decode(owner_map.mapping_owner_type, '12', 'DIMENSION LEVEL',
                            '11', 'PRIMARY DIMENSION',
                            '14', 'HIERARCHY LEVEL',
                            '13', 'HIERARCHY') OWNER_MAP_DIMENSION_TYPE,
  CASE owner_map.mapping_owner_type
  WHEN 14  -- hier_level
  THEN (select h.hierarchy_name
        from olap_dim_levels$ dl,
             olap_hier_levels$ hl, olap_hierarchies$ h
        where owner_map.mapping_owner_id = hl.hierarchy_level_id
              AND hl.dim_level_id = dl.level_id
              AND hl.hierarchy_id = h.hierarchy_id)
  WHEN 13 -- hierarchy
  THEN (select h.hierarchy_name
        from olap_hierarchies$ h
        where owner_map.mapping_owner_id = h.hierarchy_id)
  ELSE NULL
  END AS OWNER_MAP_HIERARCHY_NAME,
  CASE owner_map.mapping_owner_type
  WHEN 12 -- dim_level
  THEN (select dl.level_name
        from olap_dim_levels$ dl
        where owner_map.mapping_owner_id = dl.level_id)
  WHEN 14  -- hier_level
  THEN (select dl.level_name
        from olap_dim_levels$ dl, olap_hier_levels$ hl
        where owner_map.mapping_owner_id = hl.hierarchy_level_id
              AND hl.dim_level_id = dl.level_id)
  ELSE NULL
  END AS OWNER_MAP_LEVEL_NAME,
  owner_map.map_name OWNER_MAP_NAME,
  m.map_name MAP_NAME,
  m.map_id MAP_ID,
  s1.syntax_clob ATTRIBUTE_EXPRESSION,
  i1.option_value LANGUAGE
FROM
  olap_mappings$ m,
  olap_mappings$ owner_map,
  obj$ o,
  user$ u,
  olap_attributes$ a,
  olap_syntax$ s1,
  olap_impl_options$ i1
WHERE
  m.map_type = 17
  AND m.mapping_owner_id = owner_map.map_id
  AND m.mapped_object_id = a.attribute_id
  AND a.dim_obj# = o.obj#
  AND o.owner#=u.user#
  AND m.map_id = s1.owner_id(+)
  AND m.map_type = s1.owner_type(+)
  AND s1.ref_role(+) = 2
  AND m.map_id = i1.owning_objectid(+)
  AND i1.option_type(+) = 12
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."OWNER" IS 'Owner of the OLAP Cube Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."DIMENSION_NAME" IS 'Name of the Cube Dimension of the Cube Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."ATTRIBUTE_NAME" IS 'Name of the Cube Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."OWNER_MAP_DIMENSION_TYPE" IS 'Text value indicating the type of the Cube Dimenension that owns the map
that contains the Cube Attribute Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."OWNER_MAP_HIERARCHY_NAME" IS 'Name of the Hierarchy of the Cube Dimension that owns the map
that contains the Cube Attribute Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."OWNER_MAP_LEVEL_NAME" IS 'Name of the Level of the Cube Dimension or Cube Hierarchy that owns the map
that contains the Cube Attribute Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."OWNER_MAP_NAME" IS 'Name of the map that contains the Cube Attribute Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."MAP_NAME" IS 'Name of the Cube Attribute Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."MAP_ID" IS 'Dictionary Id of the Cube Attribute Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."ATTRIBUTE_EXPRESSION" IS 'Expression of the Cube Attribute Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_MAPPINGS"."LANGUAGE" IS 'Language of the Cube Attribute Mapping';
   COMMENT ON TABLE "SYS"."ALL_CUBE_ATTR_MAPPINGS"  IS 'OLAP Cube Attribute Mappings in the database that are accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_ATTR_UNIQUE_KEYS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_ATTR_UNIQUE_KEYS" ("OWNER", "DIMENSION_NAME", "ATTRIBUTE_NAME", "UNIQUE_KEY_LEVEL_NAME") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  dl.level_name UNIQUE_KEY_LEVEL_NAME
FROM
  olap_attributes$ a,
  obj$ o,
  user$ u,
  olap_dim_levels$ dl,
  olap_attribute_visibility$ av
WHERE
  o.obj#=a.dim_obj#
  AND o.owner#=u.user#
  AND a.attribute_id = av.attribute_id
  AND av.is_unique_key = 1
  AND av.owning_dim_id = dl.level_id
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_UNIQUE_KEYS"."OWNER" IS 'Owner of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_UNIQUE_KEYS"."DIMENSION_NAME" IS 'Name of owning Cube Dimension of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_UNIQUE_KEYS"."ATTRIBUTE_NAME" IS 'Name of the Olap Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_UNIQUE_KEYS"."UNIQUE_KEY_LEVEL_NAME" IS 'Name of Dimension Level where the OLAP Attribute is unique key attribute';
   COMMENT ON TABLE "SYS"."ALL_CUBE_ATTR_UNIQUE_KEYS"  IS 'OLAP Unique Key Attributes in the database that are accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_ATTR_VISIBILITY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_ATTR_VISIBILITY" ("OWNER", "DIMENSION_NAME", "ATTRIBUTE_NAME", "HIERARCHY_NAME", "LEVEL_NAME", "FROM_TYPE", "TO_TYPE") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  null HIERARCHY_NAME,
  null LEVEL_NAME,
  'DIMENSION' FROM_TYPE,
  'DIMENSION' TO_TYPE
FROM
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 11 -- DIMENSION
  AND av.owning_dim_id = o.obj#
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  null LEVEL_NAME,
  'DIMENSION' FROM_TYPE,
  'HIERARCHY' TO_TYPE
FROM
  olap_hierarchies$ h,
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 11 -- DIMENSION
  AND av.owning_dim_id = o.obj#
  AND h.dim_obj# = o.obj#
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  null HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  'DIMENSION' FROM_TYPE,
  'DIM_LEVEL' TO_TYPE
FROM
  olap_dim_levels$ dl,
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 11 -- DIMENSION
  AND av.owning_dim_id = o.obj#
  AND dl.dim_obj# = o.obj#
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  'DIMENSION' FROM_TYPE,
  'HIER_LEVEL' TO_TYPE
FROM
  olap_hierarchies$ h,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 11 -- DIMENSION
  AND av.owning_dim_id = o.obj#
  AND h.dim_obj# = o.obj#
  AND hl.hierarchy_id = h.hierarchy_id
  AND dl.level_id = hl.dim_level_id
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  null LEVEL_NAME,
  'HIERARCHY' FROM_TYPE,
  'HIERARCHY' TO_TYPE
FROM
  olap_hierarchies$ h,
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 13 -- HIERARCHY
  AND av.owning_dim_id = h.hierarchy_id
  AND h.dim_obj# = o.obj#
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  'HIERARCHY' FROM_TYPE,
  'HIER_LEVEL' TO_TYPE
FROM
  olap_hierarchies$ h,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 13 -- HIERARCHY
  AND av.owning_dim_id = h.hierarchy_id
  AND h.dim_obj# = o.obj#
  AND hl.hierarchy_id = h.hierarchy_id
  AND dl.level_id = hl.dim_level_id
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  'HIER_LEVEL' FROM_TYPE,
  'HIER_LEVEL' TO_TYPE
FROM
  olap_hierarchies$ h,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 14 -- HIER_LEVEL
  AND av.owning_dim_id = hl.hierarchy_level_id
  AND hl.hierarchy_id = h.hierarchy_id
  AND dl.level_id = hl.dim_level_id
  AND h.dim_obj# = o.obj#
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  null HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  'DIM_LEVEL' FROM_TYPE,
  'DIM_LEVEL' TO_TYPE
FROM
  olap_dim_levels$ dl,
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 12 -- DIM_LEVEL
  AND av.owning_dim_id = dl.level_id
  AND dl.dim_obj# = o.obj#
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  a.attribute_name ATTRIBUTE_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  'DIM_LEVEL' FROM_TYPE,
  'HIER_LEVEL' TO_TYPE
FROM
  olap_hierarchies$ h,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_attributes$ a,
  olap_attribute_visibility$ av,
  obj$ o,
  user$ u
WHERE
  av.is_unique_key = 0
  AND av.attribute_id = a.attribute_id
  AND av.owning_dim_type = 12 -- DIM_LEVEL
  AND av.owning_dim_id = dl.level_id
  AND dl.level_id = hl.dim_level_id
  AND hl.hierarchy_id = h.hierarchy_id
  AND h.dim_obj# = o.obj#
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_VISIBILITY"."OWNER" IS 'Owner of OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_VISIBILITY"."DIMENSION_NAME" IS 'Name of the OLAP Cube Dimension that owns the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_VISIBILITY"."ATTRIBUTE_NAME" IS 'Name of the OLAP Attribute';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_VISIBILITY"."HIERARCHY_NAME" IS 'Name of the OLAP Hierarchy for which the Attribute is visible';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_VISIBILITY"."LEVEL_NAME" IS 'Name of the OLAP Level for which the Attribute is visible';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_VISIBILITY"."FROM_TYPE" IS 'Object type on which the visibility has been explicitly set';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_ATTR_VISIBILITY"."TO_TYPE" IS 'Object type on which the visibility has been implicitly derived';
   COMMENT ON TABLE "SYS"."ALL_CUBE_ATTR_VISIBILITY"  IS 'OLAP Attributes visible for Dimensions, Hierarchies, and Levels'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_BUILD_PROCESSES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_BUILD_PROCESSES" ("OWNER", "BUILD_PROCESS_NAME", "BUILD_PROCESS_ID", "BUILD_PROCESS", "DESCRIPTION") AS 
  SELECT
  u.name OWNER,
  o.name BUILD_PROCESS_NAME,
  ia.obj# BUILD_PROCESS_ID,
  syn.syntax_clob BUILD_PROCESS,
  d.description_value DESCRIPTION
FROM
  olap_cube_build_processes$ ia,
  obj$ o,
  user$ u,
  olap_syntax$ syn,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 8 --BUILD_PROCESS
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d
WHERE
  ia.obj# = o.obj#
  AND o.owner# = u.user#
  AND ia.obj# = d.owning_object_id(+)
  AND syn.owner_id(+)=ia.obj#
  AND syn.owner_type(+)=8
  AND syn.ref_role(+)=13 -- build process
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_BUILD_PROCESSES"."OWNER" IS 'Owner of the OLAP Build Processes';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_BUILD_PROCESSES"."BUILD_PROCESS_NAME" IS 'Name of the OLAP Build Process';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_BUILD_PROCESSES"."BUILD_PROCESS_ID" IS 'Dictionary Id of the OLAP Build Process';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_BUILD_PROCESSES"."BUILD_PROCESS" IS 'The Build Process syntax text for the OLAP Build Process';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_BUILD_PROCESSES"."DESCRIPTION" IS 'Long Description of the OLAP Build Process';
   COMMENT ON TABLE "SYS"."ALL_CUBE_BUILD_PROCESSES"  IS 'OLAP Build Processes in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_CALCULATED_MEMBERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_CALCULATED_MEMBERS" ("OWNER", "DIMENSION_NAME", "MEMBER_NAME", "IS_CUSTOM_AGGREGATE", "STORAGE_TYPE", "EXPRESSION") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  cm.member_name MEMBER_NAME,
  DECODE(cm.is_customaggregate, 1, 'YES', 0, 'NO') IS_CUSTOM_AGGREGATE,
  DECODE(cm.storage_type, 1, 'DYNAMIC', 2, 'PRECOMPUTE') STORAGE_TYPE,
  syn.syntax_clob EXPRESSION
FROM
  olap_calculated_members$ cm,
  obj$ o,
  user$ u,
  olap_syntax$ syn
WHERE
  cm.dim_obj#=o.obj#
  AND o.owner#=u.user#
  AND cm.member_id = syn.owner_id(+)
  AND syn.owner_type = 6 --CALC_MEMBER
  AND syn.ref_role=19 -- MEMBER_EXPRESSION_ROLE
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_CALCULATED_MEMBERS"."OWNER" IS 'Owner of the OLAP Calculated Member';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CALCULATED_MEMBERS"."DIMENSION_NAME" IS 'Name of owning dimension of the OLAP Calculated Member';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CALCULATED_MEMBERS"."MEMBER_NAME" IS 'Member Name of the OLAP Calculated Member';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CALCULATED_MEMBERS"."IS_CUSTOM_AGGREGATE" IS 'Custom Aggregate flag of the OLAP Calculated Member';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CALCULATED_MEMBERS"."STORAGE_TYPE" IS 'Storage Type of the OLAP Calculated Member';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CALCULATED_MEMBERS"."EXPRESSION" IS 'Expression of the OLAP Calculated Member';
   COMMENT ON TABLE "SYS"."ALL_CUBE_CALCULATED_MEMBERS"  IS 'OLAP Calculated Members in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_CLASSIFICATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_CLASSIFICATIONS" ("OWNER", "OBJECT_NAME", "OBJECT_TYPE", "LANGUAGE", "CLASSIFICATION", "ORDER_NUM") AS 
  SELECT
  u.name OWNER,
  CASE d.owning_object_type
  WHEN 4 -- ASSIGNMENT
  THEN (SELECT o.name || '.' || m.model_name || '.' || a.member_name
        FROM olap_model_assignments$ a, olap_models$ m, obj$ o
        WHERE d.owning_object_id = a.assignment_id
              AND m.model_id = a.model_id
              AND m.owning_obj_type = 11
              AND m.owning_obj_id = o.obj#
        )
  WHEN 3 -- model
  THEN (SELECT o.name || '.' || m.model_name
        FROM olap_models$ m, obj$ o
        WHERE d.owning_object_id = m.model_id
              AND m.owning_obj_type = 11
              AND m.owning_obj_id = o.obj#
        )
  WHEN 14 -- hier_level
  THEN (SELECT o.name || '.' || h.hierarchy_name || '.' || dl.level_name
        FROM olap_hier_levels$ hl, olap_dim_levels$ dl,
             olap_hierarchies$ h, obj$ o
        WHERE d.owning_object_id = hl.hierarchy_level_id
              AND hl.dim_level_id = dl.level_id
              AND hl.hierarchy_id = h.hierarchy_id
              AND h.dim_obj# = o.obj#
        )
  WHEN 13 -- hierarchy
  THEN (SELECT o.name || '.' || h.hierarchy_name
        FROM olap_hierarchies$ h, obj$ o
        WHERE d.owning_object_id = h.hierarchy_id
              AND h.dim_obj# = o.obj#
       )
  WHEN 12 -- dim_level
  THEN (SELECT o.name || '.' || dl.level_name
        FROM olap_dim_levels$ dl, obj$ o
        WHERE d.owning_object_id = dl.level_id
              AND dl.dim_obj# = o.obj#
       )
  WHEN 15 -- attribute
  THEN (SELECT o.name || '.' || a.attribute_name
        FROM olap_attributes$ a, obj$ o
        WHERE d.owning_object_id = a.attribute_id
              AND a.dim_obj# = o.obj#
       )
  WHEN 6 -- calc_member
  THEN (SELECT o.name || '.' || c.member_name
        FROM OLAP_CALCULATED_MEMBERS$ c, obj$ o
        WHERE d.owning_object_id = c.member_id
              AND c.dim_obj# = o.obj#
       )
  WHEN 11 -- dimension
  THEN (SELECT o.name
        FROM obj$ o
        WHERE d.owning_object_id = o.obj#
       )
  ELSE null
  END AS OBJECT_NAME,
  decode(d.owning_object_type, '4', 'ASSIGNMENT',
                               '3', 'MODEL',
                               '14', 'HIERARCHY LEVEL',
                               '13', 'HIERARCHY',
                               '12', 'DIMENSION LEVEL',
                               '15', 'ATTRIBUTE',
                               '6', 'CALCULATION MEMBER',
                               '11', 'DIMENSION') OBJECT_TYPE,
  d.language LANGUAGE,
  d.description_value CLASSIFICATION,
  d.description_order ORDER_NUM
FROM
  olap_descriptions$ d,
  obj$ o,
  user$ u
WHERE
  d.description_class = 1
  AND d.obj# = o.obj#
  AND o.owner#=u.user#
  AND d.owning_object_type in (3, 4, 6, 11, 12, 13, 14, 15)
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  CASE d.owning_object_type
  WHEN 2 -- measure
  THEN (SELECT o.name || '.' || m.measure_name
        FROM olap_measures$ m, olap_cubes$ c, obj$ o
        WHERE d.owning_object_id = m.measure_id
              AND m.cube_obj# = c.obj#
              AND c.obj# = o.obj#
        )
  WHEN 1 -- cube
  THEN (SELECT o.name
        FROM obj$ o
        WHERE d.owning_object_id = o.obj#
       )
  ELSE null
  END AS OBJECT_NAME,
  decode(d.owning_object_type, '1', 'CUBE',
                               '2', 'MEASURE') OBJECT_TYPE,
  d.language LANGUAGE,
  d.description_value CLASSIFICATION,
  d.description_order ORDER_NUM
FROM
  olap_descriptions$ d,
  obj$ o,
  user$ u,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  d.description_class = 1
  AND d.obj# = o.obj#
  AND o.owner#=u.user#
  AND o.obj#=da.obj#(+)
  AND d.owning_object_type in (1, 2)
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL))
UNION ALL
SELECT
  u.name OWNER,
  o2.name OBJECT_NAME,
  'MEASURE FOLDER' OBJECT_TYPE,
  d.language LANGUAGE,
  d.description_value CLASSIFICATION,
  d.description_order ORDER_NUM
FROM
  olap_descriptions$ d,
  obj$ o,
  user$ u,
  obj$ o2
WHERE
  d.description_class = 1
  AND d.obj# = o.obj#
  AND o.owner#=u.user#
  AND d.owning_object_id = o2.obj#
  AND d.owning_object_type = 10 -- MEASURE FOLDER
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
       or   -- user has access to cubes in measure folder
              ( exists (select null from olap_meas_folder_contents$ mfc, olap_measures$ m
                        where mfc.measure_folder_obj# = o2.obj#
                          and m.measure_id  = mfc.object_id
                          and (
                              m.cube_obj# in
                                ( select obj#  -- directly granted authorization
                                  from sys.objauth$
                                  where grantee# in ( select kzsrorol from x$kzsro )
                                )
                              )
                       )
              )
            )
UNION ALL
SELECT
  u.name OWNER,
  o2.name OBJECT_NAME,
  'BUILD PROCESS' OBJECT_TYPE,
  d.language LANGUAGE,
  d.description_value CLASSIFICATION,
  d.description_order ORDER_NUM
FROM
  olap_descriptions$ d,
  obj$ o,
  user$ u,
  obj$ o2
WHERE
  d.description_class = 1
  AND d.obj# = o.obj#
  AND o.owner#=u.user#
  AND d.owning_object_id = o2.obj#
  AND d.owning_object_type = 8 --BUILD_PROCESS
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_CLASSIFICATIONS"."OWNER" IS 'Owner of the OLAP Classification';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CLASSIFICATIONS"."OBJECT_NAME" IS 'Name of the OLAP Object that has the classification';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CLASSIFICATIONS"."OBJECT_TYPE" IS 'Type of the OLAP Object that has the classification';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CLASSIFICATIONS"."LANGUAGE" IS 'Language of the OLAP Classification';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_CLASSIFICATIONS"."ORDER_NUM" IS 'Order number of the OLAP Classification';
   COMMENT ON TABLE "SYS"."ALL_CUBE_CLASSIFICATIONS"  IS 'OLAP Object Classifications in the database that are accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DEPENDENCIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DEPENDENCIES" ("OWNER", "D_TOP_OBJ_NAME", "D_SUB_OBJ_NAME1", "D_SUB_OBJ_NAME2", "D_SUB_OBJ_NAME3", "D_SUB_OBJ_NAME4", "D_OBJ_TYPE", "P_OBJ_OWNER", "P_TOP_OBJ_NAME", "P_SUB_OBJ_NAME1", "P_SUB_OBJ_NAME2", "P_SUB_OBJ_NAME3", "P_SUB_OBJ_NAME4", "P_OBJ_TYPE", "DEPENDENCY_TYPE") AS 
  SELECT
  u.name OWNER,
  o.name as D_TOP_OBJ_NAME,
  case md.D_OBJ_TYPE                          /* BEGIN COLUMN D_SUB_OBJ_NAME1 */
  WHEN 4 -- ASSIGNMENT
  THEN (SELECT m.model_name
	FROM olap_model_assignments$ a, olap_models$ m
	WHERE md.d_sub_obj# = a.assignment_id
	      AND m.model_id = a.model_id
	      AND m.owning_obj_type = 11
	      AND m.owning_obj_id = md.d_top_obj#
	)
  WHEN 3 -- model
  THEN (SELECT m.model_name
	FROM olap_models$ m
	WHERE md.d_sub_obj# = m.model_id
	      AND m.owning_obj_type = 11
	      AND m.owning_obj_id = md.d_top_obj#
	)
  WHEN 14 -- hier_level
  THEN (SELECT h.hierarchy_name
	FROM olap_hier_levels$ hl, olap_hierarchies$ h
	WHERE md.d_sub_obj# = hl.hierarchy_level_id
	      AND hl.hierarchy_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 13 -- hierarchy
  THEN (SELECT h.hierarchy_name
	FROM olap_hierarchies$ h
	WHERE md.d_sub_obj# = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
       )
  WHEN 12 -- dim_level
  THEN (SELECT dl.level_name
	FROM olap_dim_levels$ dl
	WHERE md.d_sub_obj# = dl.level_id
	      AND dl.dim_obj# = md.d_top_obj#
       )
  WHEN 15 -- attribute
  THEN (SELECT a.attribute_name
	FROM olap_attributes$ a
	WHERE md.d_sub_obj# = a.attribute_id
	      AND a.dim_obj# = md.d_top_obj#
       )
  WHEN 6 -- calc_member
  THEN (SELECT c.member_name
	FROM OLAP_CALCULATED_MEMBERS$ c
	WHERE md.d_sub_obj# = c.member_id
	      AND c.dim_obj# = md.d_top_obj#
       )
  WHEN 18 -- hier_level_map
  THEN (SELECT h.hierarchy_name
	FROM olap_mappings$ m, olap_hierarchies$ h, olap_hier_levels$ hl
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = hl.hierarchy_level_id
	      AND hl.hierarchy_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 19 -- solved_level_hier_map
  THEN (SELECT h.hierarchy_name
	FROM olap_mappings$ m, olap_hierarchies$ h
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 20 -- solved_value_hier_map
  THEN (SELECT h.hierarchy_name
	FROM olap_mappings$ m, olap_hierarchies$ h
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 21 -- member_list_map
  THEN (SELECT
          (CASE m.mapping_owner_type
           WHEN 11 -- primary_dim
           THEN (select m.map_name
                 from olap_cube_dimensions$ d
                 where d.obj# = md.d_top_obj#
                       AND d.obj# = m.mapping_owner_id)
           WHEN 12 -- dim_level
           THEN (select dl.level_name
                 from olap_dim_levels$ dl
                 where m.mapping_owner_id = dl.level_id
                       AND dl.dim_obj# = md.d_top_obj#)
           WHEN 14 -- hier_level
           THEN (select h.hierarchy_name
                 from olap_hier_levels$ hl, olap_hierarchies$ h
                 where m.mapping_owner_id = hl.hierarchy_level_id
 	               AND hl.hierarchy_id = h.hierarchy_id
   	               AND h.dim_obj# = md.d_top_obj#)
           WHEN 13 -- hierarchy
           THEN (select h.hierarchy_name
                 from olap_hierarchies$ h
                 where m.mapping_owner_id = h.hierarchy_id
                       AND h.dim_obj# = md.d_top_obj#)
           ELSE null
           END) AS D_SUB_OBJ_NAME1
 	FROM olap_mappings$ m
 	WHERE m.map_id = md.d_sub_obj#
 	)
  WHEN 17 -- attribute_map
  THEN (SELECT
	  (CASE owner_map.mapping_owner_type
	  WHEN 14 -- hier_level
	  THEN (select h.hierarchy_name
		from olap_hier_levels$ hl, olap_hierarchies$ h
		where owner_map.mapping_owner_id = hl.hierarchy_level_id
		      AND hl.hierarchy_id = h.hierarchy_id
		      AND h.dim_obj# = md.d_top_obj#)
	  WHEN 13 -- hierarchy
	  THEN (select h.hierarchy_name
		from olap_hierarchies$ h
		where owner_map.mapping_owner_id = h.hierarchy_id
		      AND h.dim_obj# = md.d_top_obj#)
	  WHEN 12 -- dim_level
	  THEN (select dl.level_name
		from olap_dim_levels$ dl
		where owner_map.mapping_owner_id = dl.level_id
		      AND dl.dim_obj# = md.d_top_obj#)
	  WHEN 11 -- primary dimension
          THEN (select owner_map.map_name
		from olap_cube_dimensions$ d
		where d.obj# = md.d_top_obj#
		      AND owner_map.mapping_owner_id = d.obj#)
	  ELSE null
	  END) AS D_SUB_OBJ_NAME1
	FROM olap_mappings$ m, olap_mappings$ owner_map
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = owner_map.map_id
       )
  WHEN 27 -- aw_dim_org
  THEN '$AW_ORGANIZATION'
  ELSE null
  END AS D_SUB_OBJ_NAME1,                       /* END COLUMN D_SUB_OBJ_NAME1 */
  case md.D_OBJ_TYPE                          /* BEGIN COLUMN D_SUB_OBJ_NAME2 */
  WHEN 4 -- ASSIGNMENT
  THEN (SELECT a.member_name
	FROM olap_model_assignments$ a, olap_models$ m
	WHERE md.d_sub_obj# = a.assignment_id
	      AND m.model_id = a.model_id
	      AND m.owning_obj_type = 11
	      AND m.owning_obj_id = md.d_top_obj#
	)
  WHEN 14 -- hier_level
  THEN (SELECT dl.level_name
	FROM olap_hier_levels$ hl, olap_dim_levels$ dl,
	     olap_hierarchies$ h
	WHERE md.d_sub_obj# = hl.hierarchy_level_id
	      AND hl.dim_level_id = dl.level_id
	      AND hl.hierarchy_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 18 -- hier_level_map
  THEN (SELECT dl.level_name
	FROM olap_mappings$ m, olap_hierarchies$ h, olap_hier_levels$ hl,
	     olap_dim_levels$ dl
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = hl.hierarchy_level_id
	      AND hl.dim_level_id = dl.level_id
	      AND hl.hierarchy_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 19 -- solved_level_hier_map
  THEN (SELECT m.map_name
	FROM olap_mappings$ m, olap_hierarchies$ h
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 20 -- solved_value_hier_map
  THEN (SELECT m.map_name
	FROM olap_mappings$ m, olap_hierarchies$ h
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 21 -- member_list_map
  THEN (SELECT
          (CASE m.mapping_owner_type
           WHEN 12 -- dim_level
           THEN (select m.map_name
                 from olap_dim_levels$ dl
                 where m.mapping_owner_id = dl.level_id
                       AND dl.dim_obj# = md.d_top_obj#)
           WHEN 14 -- hier_level
           THEN (select dl.level_name
                 from olap_hier_levels$ hl, olap_hierarchies$ h,
                      olap_dim_levels$ dl
       	         where m.mapping_owner_id = hl.hierarchy_level_id
	               AND hl.hierarchy_id = h.hierarchy_id
                       AND hl.dim_level_id = dl.level_id
   	               AND h.dim_obj# = md.d_top_obj#)
           WHEN 13 -- hierarchy
           THEN (select m.map_name
                 from olap_hierarchies$ h
                 where m.mapping_owner_id = h.hierarchy_id
                       AND h.dim_obj# = md.d_top_obj#)
           ELSE null
           END) AS D_SUB_OBJ_NAME1
 	FROM olap_mappings$ m
 	WHERE m.map_id = md.d_sub_obj#
 	)
  WHEN 17 -- attribute_map
  THEN (SELECT
	  (CASE owner_map.mapping_owner_type
	  WHEN 14 -- hier_level
	  THEN (select dl.level_name
		from olap_hier_levels$ hl, olap_hierarchies$ h,
		     olap_dim_levels$ dl
		where owner_map.mapping_owner_id = hl.hierarchy_level_id
		      AND hl.hierarchy_id = h.hierarchy_id
		      AND hl.dim_level_id = dl.level_id
		      AND h.dim_obj# = md.d_top_obj#)
	  WHEN 13 -- hierarchy
	  THEN (select owner_map.map_name
		from olap_hierarchies$ h
		where owner_map.mapping_owner_id = h.hierarchy_id
		      AND h.dim_obj# = md.d_top_obj#)
	  WHEN 12 -- dim_level
	  THEN (select owner_map.map_name
		from olap_dim_levels$ dl
		where owner_map.mapping_owner_id = dl.level_id
		      AND dl.dim_obj# = md.d_top_obj#)
	  WHEN 11 -- primary dimension
	  THEN (select m.map_name
		from olap_cube_dimensions$ d
		where d.obj# = md.d_top_obj#
		      AND owner_map.mapping_owner_id = d.obj#)
	  ELSE null
	  END) AS D_SUB_OBJ_NAME2
	FROM olap_mappings$ m, olap_mappings$ owner_map
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = owner_map.map_id
       )
  ELSE null
  END AS D_SUB_OBJ_NAME2,                       /* END COLUMN D_SUB_OBJ_NAME2 */
  case md.D_OBJ_TYPE                          /* BEGIN COLUMN D_SUB_OBJ_NAME3 */
  WHEN 18 -- hier_level_map
  THEN (SELECT m.map_name
	FROM olap_mappings$ m, olap_hierarchies$ h, olap_hier_levels$ hl
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = hl.hierarchy_level_id
	      AND hl.hierarchy_id = h.hierarchy_id
	      AND h.dim_obj# = md.d_top_obj#
	)
  WHEN 21 -- member_list_map
  THEN (SELECT
          (CASE m.mapping_owner_type
           WHEN 14 -- hier_level
           THEN (select m.map_name
                 from olap_hier_levels$ hl, olap_hierarchies$ h,
                      olap_dim_levels$ dl
                  where m.mapping_owner_id = hl.hierarchy_level_id
	                AND hl.hierarchy_id = h.hierarchy_id
                        AND hl.dim_level_id = dl.level_id
   	                AND h.dim_obj# = md.d_top_obj#)
           ELSE null
           END) AS D_SUB_OBJ_NAME1
 	FROM olap_mappings$ m
 	WHERE m.map_id = md.d_sub_obj#
 	)
  WHEN 17 -- attribute_map
  THEN (SELECT
	  (CASE owner_map.mapping_owner_type
	  WHEN 14 -- hier_level
	  THEN (select owner_map.map_name
		from olap_hier_levels$ hl, olap_hierarchies$ h
		where owner_map.mapping_owner_id = hl.hierarchy_level_id
		      AND hl.hierarchy_id = h.hierarchy_id
		      AND h.dim_obj# = md.d_top_obj#)
	  WHEN 13 -- hierarchy
	  THEN (select m.map_name
		from olap_hierarchies$ h
		where owner_map.mapping_owner_id = h.hierarchy_id
		      AND h.dim_obj# = md.d_top_obj#)
	  WHEN 12 -- dim_level
	  THEN (select m.map_name
		from olap_dim_levels$ dl
		where owner_map.mapping_owner_id = dl.level_id
		      AND dl.dim_obj# = md.d_top_obj#)
	  ELSE null
	  END) AS D_SUB_OBJ_NAME3
	FROM olap_mappings$ m, olap_mappings$ owner_map
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = owner_map.map_id
       )
  ELSE null
  END AS D_SUB_OBJ_NAME3,                       /* END COLUMN D_SUB_OBJ_NAME3 */
  case md.D_OBJ_TYPE                          /* BEGIN COLUMN D_SUB_OBJ_NAME4 */
  WHEN 17 -- attribute_map
  THEN (SELECT
	  (CASE owner_map.mapping_owner_type
	  WHEN 14 -- hier_level
	  THEN (select m.map_name
		from olap_hier_levels$ hl, olap_hierarchies$ h
		where owner_map.mapping_owner_id = hl.hierarchy_level_id
		      AND hl.hierarchy_id = h.hierarchy_id
		      AND h.dim_obj# = md.d_top_obj#)
	  ELSE null
	  END) AS D_SUB_OBJ_NAME3
	FROM olap_mappings$ m, olap_mappings$ owner_map
	WHERE m.map_id = md.d_sub_obj#
	      AND m.mapping_owner_id = owner_map.map_id
       )
  ELSE null
  END AS D_SUB_OBJ_NAME4,                       /* END COLUMN D_SUB_OBJ_NAME4 */
  decode(md.d_obj_type, '3', 'MODEL',
			'4', 'ASSIGNMENT',
			'6', 'CALCULATION MEMBER',
                        '11', 'DIMENSION',
			'12', 'DIMENSION LEVEL',
			'13', 'HIERARCHY',
			'14', 'HIERARCHY LEVEL',
			'15', 'ATTRIBUTE',
			'17', 'ATTRIBUTE MAP',
			'18', 'HIER LEVEL MAP',
			'19', 'SOLVED LEVEL HIER MAP',
			'20', 'SOLVED VALUE HIER MAP',
			'21', 'MEMBER LIST MAP',
                        '27', 'AW DIM ORGANIZATION',
                        '29', 'AW') D_OBJ_TYPE,
  md.P_OWNER P_OBJ_OWNER,
  md.P_TOP_OBJ_NAME P_TOP_OBJ_NAME,
  md.P_SUB_OBJ_NAME1 P_SUB_OBJ_NAME1,
  md.P_SUB_OBJ_NAME2 P_SUB_OBJ_NAME2,
  md.P_SUB_OBJ_NAME3 P_SUB_OBJ_NAME3,
  md.P_SUB_OBJ_NAME4 P_SUB_OBJ_NAME4,
  case md.p_obj_type
  WHEN 25 -- TABLE OR VIEW
       THEN (SELECT decode(o.type#, '4', 'VIEW', 'TABLE')
             FROM obj$ o
             WHERE o.obj# = md.p_obj#
            )
       ELSE decode(md.p_obj_type, '1', 'CUBE',
			'2', 'MEASURE',
			'3', 'MODEL',
			'4', 'ASSIGNMENT',
			'6', 'CALCULATION MEMBER',
                        '8',  'BUILD PROCESS',
                        '10', 'MEASURE FOLDER',
			'11', 'DIMENSION',
			'12', 'DIMENSION LEVEL',
			'13', 'HIERARCHY',
			'14', 'HIERARCHY LEVEL',
			'15', 'ATTRIBUTE',
                        '16', 'DIMENSIONALITY',
			'17', 'ATTRIBUTE MAP',
			'18', 'HIER LEVEL MAP',
			'19', 'SOLVED LEVEL HIER MAP',
			'20', 'SOLVED VALUE HIER MAP',
			'21', 'MEMBER LIST MAP',
			'22', 'CUBE MAP',
			'23', 'CUBE DIMENSIONALITY MAP',
			'24', 'MEASURE MAP',
			'26', 'COLUMN',
                        '27', 'AW DIM ORGANIZATION',
                        '28', 'AW CUBE ORGANIZATION',
                        '29', 'AW') END AS P_OBJ_TYPE,
  decode(md.dep_type, '1', 'CONSISTENT SOLVE SPEC',
                      '2', 'DEFAULT BUILD SPEC',
                      '3', 'BUILD SPEC',
                      '4', 'BUILD PROCESS',
                      '6', 'MEASURE IN MEASURE DIM',
                      '7', 'CUSTOM ORDER',
                      '9', 'TARGET ATTRIBUTE',
                      '10', 'TARGET DIMENSION',
                      '11', 'MEMBER EXPRESSION',
                      '12', 'EXPLICIT DIMENSION',
                      '13', 'PRIMARY DIMENSION',
                      '15', 'MEASURE IN MEASURE FOLDER',
                      '16', 'MEASURE FOLDER SUBFOLDER',
                      '17', 'MAPPED DIMENSION',
                      '18', 'QUERY',
                      '19', 'FROM CLAUSE',
                      '20', 'WHERE CLAUSE',
                      '21', 'JOIN CONDITION',
                      '22', 'LEVEL_ID EXPRESSION',
                      '23', 'KEY EXPRESSION',
                      '24', 'VALUE MAP EXPRESSION',
                      '25', 'LEVEL EXPRESSION',
                      '26', 'PARENT KEY EXPRESSION',
                      '27', 'PARENT LEVEL_ID EXPRESSION',
                      '28', 'MEASURE EXPRESSION',
                      '29', 'NVL EXPRESSION',
                      '30', 'AW',
                      '31', 'AW TABLE',
                      '32', 'PARTITION LEVEL',
                      '33', 'SECONDARY PARTITION LEVEL',
                      '34', 'PRECOMPUTE CONDITION'
                      ) DEPENDENCY_TYPE
FROM
  olap_metadata_dependencies$ md,
  obj$ o,
  user$ u
WHERE
  o.obj# = md.d_top_obj#
  AND o.owner# = u.user#
  AND md.d_obj_type in (3, 4, 6, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 27, 29)
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name as D_TOP_OBJ_NAME,
  case md.D_OBJ_TYPE                          /* BEGIN COLUMN D_SUB_OBJ_NAME1 */
  WHEN 2 -- measure
  THEN (SELECT meas.measure_name
        FROM olap_measures$ meas
        WHERE md.d_sub_obj# = meas.measure_id
              AND meas.cube_obj# = md.d_top_obj#
       )
  WHEN 22 -- cube_map
  THEN (SELECT m.map_name
	FROM olap_mappings$ m
	WHERE m.mapping_owner_id = md.d_top_obj#
	      AND m.map_id = md.d_sub_obj#
       )
  WHEN 23 -- cube_dimnl_map
  THEN (SELECT owner_map.map_name
	FROM olap_mappings$ owner_map, olap_mappings$ m
	WHERE m.mapping_owner_id = owner_map.map_id
	      AND m.map_id = md.d_sub_obj#
	      AND owner_map.mapping_owner_id = md.d_top_obj#
       )
  WHEN 24 -- cube_meas_map
  THEN (SELECT owner_map.map_name
	FROM olap_mappings$ owner_map, olap_mappings$ m
	WHERE m.mapping_owner_id = owner_map.map_id
	      AND m.map_id = md.d_sub_obj#
	      AND owner_map.mapping_owner_id = md.d_top_obj#
       )
  WHEN 16 -- dimensionality
  THEN (SELECT io_diml.option_value
        FROM olap_dimensionality$ diml, olap_impl_options$ io_diml
        WHERE diml.DIMENSIONED_OBJECT_ID = md.d_top_obj#
              AND diml.DIMENSIONALITY_ID = md.d_sub_obj#
              AND io_diml.object_type = 16 -- DIMENSIONALITY
              AND io_diml.owning_objectid = diml.dimensionality_id
              AND io_diml.option_type = 33 -- DIMENSIONALITY NAME
       )
  WHEN 28 -- aw_cube_org
  THEN '$AW_ORGANIZATION'
  WHEN 30 -- secondary_partition_level
  THEN '$AW_ORGANIZATION'
  ELSE null
  END AS D_SUB_OBJ_NAME1,                       /* END COLUMN D_SUB_OBJ_NAME1 */
  case md.D_OBJ_TYPE                          /* BEGIN COLUMN D_SUB_OBJ_NAME2 */
  WHEN 23 -- cube_dimnl_map
  THEN (SELECT m.map_name
	FROM olap_mappings$ owner_map, olap_mappings$ m
	WHERE m.mapping_owner_id = owner_map.map_id
	      AND m.map_id = md.d_sub_obj#
	      AND owner_map.mapping_owner_id = md.d_top_obj#
       )
  WHEN 24 -- cube_meas_map
  THEN (SELECT m.map_name
	FROM olap_mappings$ owner_map, olap_mappings$ m
	WHERE m.mapping_owner_id = owner_map.map_id
	      AND m.map_id = md.d_sub_obj#
	      AND owner_map.mapping_owner_id = md.d_top_obj#
       )
  WHEN 30 -- secondary_partition_level
  THEN (SELECT
	  CASE
	  WHEN md.d_sub_obj# < 3
	  THEN (SELECT io.option_value
	  FROM olap_impl_options$ io
	  WHERE io.owning_objectid = md.d_top_obj#
	        AND io.object_type = 1
	        AND io.option_type =
                    (case when d_sub_obj# = 0 then 38
                          when d_sub_obj# = 1 then 41
                          else 44 end))
	  ELSE (SELECT mo.option_value
	  FROM olap_multi_options$ mo
	  WHERE mo.owning_objectid = md.d_top_obj#
	        AND mo.object_type = 1
	        AND mo.option_type = 5
	        AND mo.option_order = md.d_sub_obj#)
	  END
	FROM dual
	)
  ELSE null
  END AS D_SUB_OBJ_NAME2,                       /* END COLUMN D_SUB_OBJ_NAME2 */
  null AS D_SUB_OBJ_NAME3,
  null AS D_SUB_OBJ_NAME4,
  decode(md.d_obj_type, '1', 'CUBE',
			'2', 'MEASURE',
                        '16', 'DIMENSIONALITY',
			'22', 'CUBE MAP',
			'23', 'CUBE DIMENSIONALITY MAP',
			'24', 'MEASURE MAP',
                        '28', 'AW CUBE ORGANIZATION',
                        '30', 'SECONDARY PARTITION LEVEL',
                        '29', 'AW') D_OBJ_TYPE,
  md.P_OWNER P_OBJ_OWNER,
  md.P_TOP_OBJ_NAME P_TOP_OBJ_NAME,
  md.P_SUB_OBJ_NAME1 P_SUB_OBJ_NAME1,
  md.P_SUB_OBJ_NAME2 P_SUB_OBJ_NAME2,
  md.P_SUB_OBJ_NAME3 P_SUB_OBJ_NAME3,
  md.P_SUB_OBJ_NAME4 P_SUB_OBJ_NAME4,
  case md.p_obj_type
  WHEN 25 -- TABLE OR VIEW
       THEN (SELECT decode(o.type#, '4', 'VIEW', 'TABLE')
             FROM obj$ o
             WHERE o.obj# = md.p_obj#
            )
       ELSE decode(md.p_obj_type, '1', 'CUBE',
			'2', 'MEASURE',
			'3', 'MODEL',
			'4', 'ASSIGNMENT',
			'6', 'CALCULATION MEMBER',
                        '8',  'BUILD PROCESS',
                        '10', 'MEASURE FOLDER',
			'11', 'DIMENSION',
			'12', 'DIMENSION LEVEL',
			'13', 'HIERARCHY',
			'14', 'HIERARCHY LEVEL',
			'15', 'ATTRIBUTE',
                        '16', 'DIMENSIONALITY',
			'17', 'ATTRIBUTE MAP',
			'18', 'HIER LEVEL MAP',
			'19', 'SOLVED LEVEL HIER MAP',
			'20', 'SOLVED VALUE HIER MAP',
			'21', 'MEMBER LIST MAP',
			'22', 'CUBE MAP',
			'23', 'CUBE DIMENSIONALITY MAP',
			'24', 'MEASURE MAP',
			'26', 'COLUMN',
                        '27', 'AW DIM ORGANIZATION',
                        '28', 'AW CUBE ORGANIZATION',
                        '29', 'AW') END AS P_OBJ_TYPE,
  decode(md.dep_type, '1', 'CONSISTENT SOLVE SPEC',
                      '2', 'DEFAULT BUILD SPEC',
                      '3', 'BUILD SPEC',
                      '4', 'BUILD PROCESS',
                      '6', 'MEASURE IN MEASURE DIM',
                      '7', 'CUSTOM ORDER',
                      '9', 'TARGET ATTRIBUTE',
                      '10', 'TARGET DIMENSION',
                      '11', 'MEMBER EXPRESSION',
                      '12', 'EXPLICIT DIMENSION',
                      '13', 'PRIMARY DIMENSION',
                      '15', 'MEASURE IN MEASURE FOLDER',
                      '16', 'MEASURE FOLDER SUBFOLDER',
                      '17', 'MAPPED DIMENSION',
                      '18', 'QUERY',
                      '19', 'FROM CLAUSE',
                      '20', 'WHERE CLAUSE',
                      '21', 'JOIN CONDITION',
                      '22', 'LEVEL_ID EXPRESSION',
                      '23', 'KEY EXPRESSION',
                      '24', 'VALUE MAP EXPRESSION',
                      '25', 'LEVEL EXPRESSION',
                      '26', 'PARENT KEY EXPRESSION',
                      '27', 'PARENT LEVEL_ID EXPRESSION',
                      '28', 'MEASURE EXPRESSION',
                      '29', 'NVL EXPRESSION',
                      '30', 'AW',
                      '31', 'AW TABLE',
                      '32', 'PARTITION LEVEL',
                      '33', 'SECONDARY PARTITION LEVEL',
                      '34', 'PRECOMPUTE CONDITION'
                      ) DEPENDENCY_TYPE
FROM
  olap_metadata_dependencies$ md,
  obj$ o,
  user$ u,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  o.obj# = md.d_top_obj#
  AND o.owner# = u.user#
  AND o.obj#=da.obj#(+)
  AND md.d_obj_type in (1, 2, 16, 22, 23, 24, 28, 29, 30)
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL))
UNION ALL
SELECT
  u.name OWNER,
  o.name as D_TOP_OBJ_NAME,
  null AS D_SUB_OBJ_NAME1,
  null AS D_SUB_OBJ_NAME2,
  null AS D_SUB_OBJ_NAME3,
  null AS D_SUB_OBJ_NAME4,
  'MEASURE FOLDER' D_OBJ_TYPE,
  md.P_OWNER P_OBJ_OWNER,
  md.P_TOP_OBJ_NAME P_TOP_OBJ_NAME,
  md.P_SUB_OBJ_NAME1 P_SUB_OBJ_NAME1,
  md.P_SUB_OBJ_NAME2 P_SUB_OBJ_NAME2,
  md.P_SUB_OBJ_NAME3 P_SUB_OBJ_NAME3,
  md.P_SUB_OBJ_NAME4 P_SUB_OBJ_NAME4,
  case md.p_obj_type
  WHEN 25 -- TABLE OR VIEW
       THEN (SELECT decode(o.type#, '4', 'VIEW', 'TABLE')
             FROM obj$ o
             WHERE o.obj# = md.p_obj#
            )
       ELSE decode(md.p_obj_type, '1', 'CUBE',
			'2', 'MEASURE',
			'3', 'MODEL',
			'4', 'ASSIGNMENT',
			'6', 'CALCULATION MEMBER',
                        '8',  'BUILD PROCESS',
                        '10', 'MEASURE FOLDER',
			'11', 'DIMENSION',
			'12', 'DIMENSION LEVEL',
			'13', 'HIERARCHY',
			'14', 'HIERARCHY LEVEL',
			'15', 'ATTRIBUTE',
                        '16', 'DIMENSIONALITY',
			'17', 'ATTRIBUTE MAP',
			'18', 'HIER LEVEL MAP',
			'19', 'SOLVED LEVEL HIER MAP',
			'20', 'SOLVED VALUE HIER MAP',
			'21', 'MEMBER LIST MAP',
			'22', 'CUBE MAP',
			'23', 'CUBE DIMENSIONALITY MAP',
			'24', 'MEASURE MAP',
			'26', 'COLUMN',
                        '27', 'AW DIM ORGANIZATION',
                        '28', 'AW CUBE ORGANIZATION',
                        '29', 'AW') END AS P_OBJ_TYPE,
  decode(md.dep_type, '1', 'CONSISTENT SOLVE SPEC',
                      '2', 'DEFAULT BUILD SPEC',
                      '3', 'BUILD SPEC',
                      '4', 'BUILD PROCESS',
                      '6', 'MEASURE IN MEASURE DIM',
                      '7', 'CUSTOM ORDER',
                      '9', 'TARGET ATTRIBUTE',
                      '10', 'TARGET DIMENSION',
                      '11', 'MEMBER EXPRESSION',
                      '12', 'EXPLICIT DIMENSION',
                      '13', 'PRIMARY DIMENSION',
                      '15', 'MEASURE IN MEASURE FOLDER',
                      '16', 'MEASURE FOLDER SUBFOLDER',
                      '17', 'MAPPED DIMENSION',
                      '18', 'QUERY',
                      '19', 'FROM CLAUSE',
                      '20', 'WHERE CLAUSE',
                      '21', 'JOIN CONDITION',
                      '22', 'LEVEL_ID EXPRESSION',
                      '23', 'KEY EXPRESSION',
                      '24', 'VALUE MAP EXPRESSION',
                      '25', 'LEVEL EXPRESSION',
                      '26', 'PARENT KEY EXPRESSION',
                      '27', 'PARENT LEVEL_ID EXPRESSION',
                      '28', 'MEASURE EXPRESSION',
                      '29', 'NVL EXPRESSION',
                      '30', 'AW',
                      '31', 'AW TABLE',
                      '32', 'PARTITION LEVEL',
                      '33', 'SECONDARY PARTITION LEVEL',
                      '34', 'PRECOMPUTE CONDITION'
                      ) DEPENDENCY_TYPE
FROM
  olap_metadata_dependencies$ md,
  obj$ o,
  user$ u
WHERE
  o.obj# = md.d_top_obj#
  AND o.owner# = u.user#
  AND md.d_obj_type = 10
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
       or   -- user has access to cubes in measure folder
              ( exists (select null from olap_meas_folder_contents$ mfc,
                                         olap_measures$ m
                        where mfc.measure_folder_obj# = o.obj#
                          and m.measure_id  = mfc.object_id
                          and (
                              m.cube_obj# in
                                ( select obj#  -- directly granted authorization
                                  from sys.objauth$
                                  where grantee#
                                        in ( select kzsrorol from x$kzsro )
                                )
                              )
                       )
              )
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name as D_TOP_OBJ_NAME,
  null AS D_SUB_OBJ_NAME1,
  null AS D_SUB_OBJ_NAME2,
  null AS D_SUB_OBJ_NAME3,
  null AS D_SUB_OBJ_NAME4,
  'BUILD PROCESS' AS D_OBJ_TYPE,
  md.P_OWNER P_OBJ_OWNER,
  md.P_TOP_OBJ_NAME P_TOP_OBJ_NAME,
  md.P_SUB_OBJ_NAME1 P_SUB_OBJ_NAME1,
  md.P_SUB_OBJ_NAME2 P_SUB_OBJ_NAME2,
  md.P_SUB_OBJ_NAME3 P_SUB_OBJ_NAME3,
  md.P_SUB_OBJ_NAME4 P_SUB_OBJ_NAME4,
  case md.p_obj_type
  WHEN 25 -- TABLE OR VIEW
       THEN (SELECT decode(o.type#, '4', 'VIEW', 'TABLE')
             FROM obj$ o
             WHERE o.obj# = md.p_obj#
            )
       ELSE decode(md.p_obj_type, '1', 'CUBE',
			'2', 'MEASURE',
			'3', 'MODEL',
			'4', 'ASSIGNMENT',
			'6', 'CALCULATION MEMBER',
                        '8',  'BUILD PROCESS',
                        '10', 'MEASURE FOLDER',
			'11', 'DIMENSION',
			'12', 'DIMENSION LEVEL',
			'13', 'HIERARCHY',
			'14', 'HIERARCHY LEVEL',
			'15', 'ATTRIBUTE',
                        '16', 'DIMENSIONALITY',
			'17', 'ATTRIBUTE MAP',
			'18', 'HIER LEVEL MAP',
			'19', 'SOLVED LEVEL HIER MAP',
			'20', 'SOLVED VALUE HIER MAP',
			'21', 'MEMBER LIST MAP',
			'22', 'CUBE MAP',
			'23', 'CUBE DIMENSIONALITY MAP',
			'24', 'MEASURE MAP',
			'26', 'COLUMN',
                        '27', 'AW DIM ORGANIZATION',
                        '28', 'AW CUBE ORGANIZATION',
                        '29', 'AW') END AS P_OBJ_TYPE,
  decode(md.dep_type, '1', 'CONSISTENT SOLVE SPEC',
                      '2', 'DEFAULT BUILD SPEC',
                      '3', 'BUILD SPEC',
                      '4', 'BUILD PROCESS',
                      '6', 'MEASURE IN MEASURE DIM',
                      '7', 'CUSTOM ORDER',
                      '9', 'TARGET ATTRIBUTE',
                      '10', 'TARGET DIMENSION',
                      '11', 'MEMBER EXPRESSION',
                      '12', 'EXPLICIT DIMENSION',
                      '13', 'PRIMARY DIMENSION',
                      '15', 'MEASURE IN MEASURE FOLDER',
                      '16', 'MEASURE FOLDER SUBFOLDER',
                      '17', 'MAPPED DIMENSION',
                      '18', 'QUERY',
                      '19', 'FROM CLAUSE',
                      '20', 'WHERE CLAUSE',
                      '21', 'JOIN CONDITION',
                      '22', 'LEVEL_ID EXPRESSION',
                      '23', 'KEY EXPRESSION',
                      '24', 'VALUE MAP EXPRESSION',
                      '25', 'LEVEL EXPRESSION',
                      '26', 'PARENT KEY EXPRESSION',
                      '27', 'PARENT LEVEL_ID EXPRESSION',
                      '28', 'MEASURE EXPRESSION',
                      '29', 'NVL EXPRESSION',
                      '30', 'AW',
                      '31', 'AW TABLE',
                      '32', 'PARTITION LEVEL',
                      '33', 'SECONDARY PARTITION LEVEL',
                      '34', 'PRECOMPUTE CONDITION'
                      ) DEPENDENCY_TYPE
FROM
  olap_metadata_dependencies$ md,
  obj$ o,
  user$ u
WHERE
  o.obj# = md.d_top_obj#
  AND o.owner# = u.user#
  AND md.d_obj_type = 8 -- build process
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."OWNER" IS 'Owner of the dependent metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."D_TOP_OBJ_NAME" IS 'Name of the top-level object of the dependent metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."D_SUB_OBJ_NAME1" IS 'Name of the first sub-object of the dependent metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."D_SUB_OBJ_NAME2" IS 'Name of the second sub-object of the dependent metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."D_SUB_OBJ_NAME3" IS 'Name of the third sub-object of the dependent metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."D_SUB_OBJ_NAME4" IS 'Name of the fourth sub-object of the dependent metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."D_OBJ_TYPE" IS 'Type of the dependent metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."P_OBJ_OWNER" IS 'Owner of the referenced metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."P_TOP_OBJ_NAME" IS 'Name of the top-level object of the referenced metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."P_SUB_OBJ_NAME1" IS 'Name of the first sub-object of the referenced metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."P_SUB_OBJ_NAME2" IS 'Name of the second sub-object of the referenced metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."P_SUB_OBJ_NAME3" IS 'Name of the third sub-object of the referenced metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."P_SUB_OBJ_NAME4" IS 'Name of the fourth sub-object of the referenced metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."P_OBJ_TYPE" IS 'Type of the referenced metadata object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DEPENDENCIES"."DEPENDENCY_TYPE" IS 'Type of the dependency relationship';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DEPENDENCIES"  IS 'OLAP metadata dependencies in the database that are accessible to the current
user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DESCRIPTIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DESCRIPTIONS" ("OWNER", "OBJECT_NAME", "OBJECT_TYPE", "DESCRIPTION_TYPE", "DESCRIPTION_VALUE", "LANGUAGE") AS 
  SELECT
  u.name OWNER,
  CASE d.owning_object_type
  WHEN 4 -- ASSIGNMENT
  THEN (SELECT o.name || '.' || m.model_name || '.' || a.member_name
        FROM olap_model_assignments$ a, olap_models$ m, obj$ o
        WHERE d.owning_object_id = a.assignment_id
              AND m.model_id = a.model_id
              AND m.owning_obj_type = 11
              AND m.owning_obj_id = o.obj#
        )
  WHEN 3 -- model
  THEN (SELECT o.name || '.' || m.model_name
        FROM olap_models$ m, obj$ o
        WHERE d.owning_object_id = m.model_id
              AND m.owning_obj_type = 11
              AND m.owning_obj_id = o.obj#
        )
  WHEN 14 -- hier_level
  THEN (SELECT o.name || '.' || h.hierarchy_name || '.' || dl.level_name
        FROM olap_hier_levels$ hl, olap_dim_levels$ dl,
             olap_hierarchies$ h, obj$ o
        WHERE d.owning_object_id = hl.hierarchy_level_id
              AND hl.dim_level_id = dl.level_id
              AND hl.hierarchy_id = h.hierarchy_id
              AND h.dim_obj# = o.obj#
        )
  WHEN 13 -- hierarchy
  THEN (SELECT o.name || '.' || h.hierarchy_name
        FROM olap_hierarchies$ h, obj$ o
        WHERE d.owning_object_id = h.hierarchy_id
              AND h.dim_obj# = o.obj#
       )
  WHEN 12 -- dim_level
  THEN (SELECT o.name || '.' || dl.level_name
        FROM olap_dim_levels$ dl, obj$ o
        WHERE d.owning_object_id = dl.level_id
              AND dl.dim_obj# = o.obj#
       )
  WHEN 15 -- attribute
  THEN (SELECT o.name || '.' || a.attribute_name
        FROM olap_attributes$ a, obj$ o
        WHERE d.owning_object_id = a.attribute_id
              AND a.dim_obj# = o.obj#
       )
  WHEN 6 -- calc_member
  THEN (SELECT o.name || '.' || c.member_name
        FROM OLAP_CALCULATED_MEMBERS$ c, obj$ o
        WHERE d.owning_object_id = c.member_id
              AND c.dim_obj# = o.obj#
       )
  WHEN 11 -- dimension
  THEN (SELECT o.name
        FROM obj$ o
        WHERE d.owning_object_id = o.obj#
       )
  ELSE null
  END AS OBJECT_NAME,
  decode(d.owning_object_type, '4', 'ASSIGNMENT',
                               '3', 'MODEL',
                               '14', 'HIERARCHY LEVEL',
                               '13', 'HIERARCHY',
                               '12', 'DIMENSION LEVEL',
                               '15', 'ATTRIBUTE',
                               '6', 'CALCULATION MEMBER',
                               '11', 'DIMENSION') OBJECT_TYPE,
  d.description_type DESCRIPTION_TYPE,
  d.description_value DESCRIPTION_VALUE,
  d.language LANGUAGE
FROM
  olap_descriptions$ d,
  user$ u,
  obj$ o
WHERE
  d.description_class is null
  AND d.obj# = o.obj#
  AND o.owner# = u.user#
  AND d.owning_object_type in (3, 4, 6, 11, 12, 13, 14, 15)
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  CASE d.owning_object_type
  WHEN 2 -- measure
  THEN (SELECT o.name || '.' || m.measure_name
        FROM olap_measures$ m, olap_cubes$ c, obj$ o
        WHERE d.owning_object_id = m.measure_id
              AND m.cube_obj# = c.obj#
              AND c.obj# = o.obj#
        )
  WHEN 1 -- cube
  THEN (SELECT o.name
        FROM obj$ o
        WHERE d.owning_object_id = o.obj#
       )
  ELSE null
  END AS OBJECT_NAME,
  decode(d.owning_object_type, '1', 'CUBE',
                               '2', 'MEASURE') OBJECT_TYPE,
  d.description_type DESCRIPTION_TYPE,
  d.description_value DESCRIPTION_VALUE,
  d.language LANGUAGE
FROM
  olap_descriptions$ d,
  user$ u,
  obj$ o,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  d.description_class is null
  AND d.obj# = o.obj#
  AND o.owner# = u.user#
  AND o.obj#=da.obj#(+)
  AND d.owning_object_type in (1, 2)
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL))
UNION ALL
SELECT
  u.name OWNER,
  o2.name OBJECT_NAME,
  'MEASURE FOLDER' OBJECT_TYPE,
  d.description_type DESCRIPTION_TYPE,
  d.description_value DESCRIPTION_VALUE,
  d.language LANGUAGE
FROM
  olap_descriptions$ d,
  user$ u,
  obj$ o,
  obj$ o2
WHERE
  d.description_class is null
  AND d.obj# = o.obj#
  AND o.owner# = u.user#
  AND d.owning_object_id = o2.obj#
  AND d.owning_object_type = 10 -- MEASURE FOLDER
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
       or   -- user has access to cubes in measure folder
              ( exists (select null from olap_meas_folder_contents$ mfc, olap_measures$ m
                        where mfc.measure_folder_obj# = o2.obj#
                          and m.measure_id  = mfc.object_id
                          and (
                              m.cube_obj# in
                                ( select obj#  -- directly granted authorization
                                  from sys.objauth$
                                  where grantee# in ( select kzsrorol from x$kzsro )
                                )
                              )
                       )
              )
            )
UNION ALL
SELECT
  u.name OWNER,
  o2.name OBJECT_NAME,
  'BUILD PROCESS' OBJECT_TYPE,
  d.description_type DESCRIPTION_TYPE,
  d.description_value DESCRIPTION_VALUE,
  d.language LANGUAGE
FROM
  olap_descriptions$ d,
  user$ u,
  obj$ o,
  obj$ o2
WHERE
  d.description_class is null
  AND d.obj# = o.obj#
  AND o.owner# = u.user#
  AND d.owning_object_id = o2.obj#
  AND d.owning_object_type = 8 --BUILD_PROCESS
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DESCRIPTIONS"."OWNER" IS 'Owner of the OLAP Description';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DESCRIPTIONS"."OBJECT_NAME" IS 'NAME of the OLAP object that has the description';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DESCRIPTIONS"."OBJECT_TYPE" IS 'Text value indicating the type of the OLAP object that has the description';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DESCRIPTIONS"."DESCRIPTION_TYPE" IS 'Text value indicating the type the of OLAP Description';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DESCRIPTIONS"."DESCRIPTION_VALUE" IS 'Text of the OLAP Description';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DESCRIPTIONS"."LANGUAGE" IS 'Language of the OLAP Description';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DESCRIPTIONS"  IS 'OLAP Descriptions in the database that are accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DIMENSIONALITY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DIMENSIONALITY" ("OWNER", "CUBE_NAME", "DIMENSION_NAME", "DIMENSIONALITY_NAME", "DIMENSIONALITY_ID", "ORDER_NUM", "IS_SPARSE", "ET_ATTR_PREFIX") AS 
  SELECT
   cu.name OWNER,
   co.name CUBE_NAME,
   do.name DIMENSION_NAME,
   io_diml.option_value DIMENSIONALITY_NAME,
   diml.dimensionality_id DIMENSIONALITY_ID,
   diml.order_num ORDER_NUM,
   (case
     when io.option_num_value is null then 0
     else io.option_num_value
    end) IS_SPARSE,
   io_eap.option_value ET_ATTR_PREFIX
FROM
  olap_cubes$ c,
  user$ cu,
  obj$ co,
  olap_dimensionality$ diml,
  obj$ do,
  olap_impl_options$ io,
  olap_impl_options$ io_eap,
  olap_impl_options$ io_diml,
 (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      olap_dimensionality$ diml,
      olap_cube_dimensions$ dim,
      obj$ do
    WHERE
      do.obj# = dim.obj#
      AND diml.dimensioned_object_type = 1 --CUBE
      AND diml.dimensioned_object_id = c.obj#
      AND diml.dimension_type = 11 --DIMENSION
      AND diml.dimension_id = do.obj#
    )
    GROUP BY obj# ) da
WHERE
  co.obj# = c.obj#
  AND c.obj#=da.obj#(+)
  AND co.owner# = cu.user#
  AND diml.dimensioned_object_type = 1 --CUBE
  AND diml.dimensioned_object_id = c.obj#
  AND diml.dimension_type = 11 --DIMENSION
  AND diml.dimension_id = do.obj#
  AND io.object_type(+) = 16 -- DIMENSIONALITY
  AND io.owning_objectid(+) = diml.dimensionality_id
  AND io.option_type(+) = 10 -- IS_SPARSE_DIM
  AND io_eap.object_type(+) = 16 -- DIMENSIONALITY
  AND io_eap.owning_objectid(+) = diml.dimensionality_id
  AND io_eap.option_type(+) =  36 -- ET_ATTR_PREFIX
  AND io_diml.object_type(+) = 16 -- DIMENSIONALITY
  AND io_diml.owning_objectid(+) = diml.dimensionality_id
  AND io_diml.option_type(+) =  33 -- DIMENSIONALITY NAME
  AND (co.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or co.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (co.owner#, co.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL));

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONALITY"."OWNER" IS 'Owner of the OLAP Cube Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONALITY"."CUBE_NAME" IS 'Name of the OLAP Cube of the Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONALITY"."DIMENSION_NAME" IS 'Name of the Dimension of the OLAP Cube Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONALITY"."ORDER_NUM" IS 'Order number of the OLAP Cube Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONALITY"."IS_SPARSE" IS 'Indication of whether or not the Dimension is Sparse in the Cube';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DIMENSIONALITY"  IS 'OLAP Cube Dimensionality in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DIMENSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DIMENSIONS" ("OWNER", "DIMENSION_NAME", "DIMENSION_ID", "DIMENSION_TYPE", "AW_NAME", "DEFAULT_HIERARCHY_NAME", "DESCRIPTION", "HIERARCHY_CONSISTENCY_RULE", "ADD_UNIQUE_KEY_PREFIX", "CUSTOM_ORDER") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  dim.obj# DIMENSION_ID,
  DECODE(dim.dimension_type,1, 'STANDARD',
                            2, 'TIME',
                            3, 'LINEITEM',
                            4, 'MEASURE',
                            5, 'LANGUAGE',
                            6, 'FINANCIAL_ELEMENT',
                            7, 'SPATIAL') DIMENSION_TYPE,
  a.awname AW_NAME,
  h.hierarchy_name DEFAULT_HIERARCHY_NAME,
  d.description_value DESCRIPTION,
  io.option_value HIERARCHY_CONSISTENCY_RULE,
  DECODE(io2.option_num_value, 1, 'YES', 'NO') ADD_UNIQUE_KEY_PREFIX,
  syn.syntax_clob CUSTOM_ORDER
FROM
   olap_cube_dimensions$ dim,
   user$ u,
   aw$ a,
   obj$ o,
   olap_hierarchies$ h,
   olap_syntax$ syn,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
	n.parameter = 'NLS_LANGUAGE'
	and d.description_type = 'Description'
	and d.owning_object_type = 11 --DIMENSION
	and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d,
  olap_impl_options$ io, -- For HIERARCHY_CONSISTENCY_RULE
  olap_impl_options$ io2 -- For ADD_UNIQUE_KEY_PREFIX
WHERE
   o.obj#=dim.obj# AND o.owner#=u.user#
   AND dim.awseq#=a.awseq#(+)
   AND h.hierarchy_id(+)=dim.default_hierarchy_id
   AND d.owning_object_id(+)=dim.obj#
   AND io.object_type(+) = 11 -- DIMENSION
   AND io.owning_objectid(+) = dim.obj#
   AND io.option_type(+) = 26 -- Hierarchy Consistency Rule
   AND dim.obj# = io2.owning_objectid(+)
   AND io2.object_type(+) = 11 -- DIMENSION
   AND io2.option_type(+) = 29 -- Add_Unique_Key_Prefix
   AND syn.owner_id(+) = dim.obj#
   AND syn.owner_type(+) = 11
   AND syn.ref_role(+) = 23 -- CustomOrder
   AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."OWNER" IS 'Owner of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."DIMENSION_NAME" IS 'Name of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."DIMENSION_ID" IS 'Dictionary Id of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."DIMENSION_TYPE" IS 'Type of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."AW_NAME" IS 'Name of the Analytic Workspace which owns the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."DEFAULT_HIERARCHY_NAME" IS 'Default Hierarchy name of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."DESCRIPTION" IS 'Long Description of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."HIERARCHY_CONSISTENCY_RULE" IS 'Hierarchy consistency rule of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."ADD_UNIQUE_KEY_PREFIX" IS 'Add_Unique_Key_Prefix flag of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMENSIONS"."CUSTOM_ORDER" IS 'Custom Order of the OLAP Cube Dimension';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DIMENSIONS"  IS 'OLAP Cube Dimensions in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DIM_LEVELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DIM_LEVELS" ("OWNER", "DIMENSION_NAME", "LEVEL_NAME", "LEVEL_ID", "DESCRIPTION") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  dl.level_name LEVEL_NAME,
  dl.level_id LEVEL_ID,
  d.description_value DESCRIPTION
FROM
  obj$ o,
  olap_dim_levels$ dl,
  user$ u,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 12 --DIM_LEVEL
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d
WHERE
  o.obj#=dl.dim_obj# AND o.owner#=u.user#
  AND d.owning_object_id(+)=dl.level_id
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_LEVELS"."OWNER" IS 'Owner of the OLAP Dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_LEVELS"."DIMENSION_NAME" IS 'Name of the dimension which owns the OLAP Dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_LEVELS"."LEVEL_NAME" IS 'Name of the OLAP Dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_LEVELS"."LEVEL_ID" IS 'Dictionary Id of the OLAP Dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_LEVELS"."DESCRIPTION" IS 'Long Description of the OLAP Dimension Level';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DIM_LEVELS"  IS 'OLAP Dimension Levels in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DIM_MAPPINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DIM_MAPPINGS" ("OWNER", "DIMENSION_NAME", "HIERARCHY_NAME", "LEVEL_NAME", "MAP_NAME", "MAP_ID", "MAPPED_DIMENSION_TYPE", "MAPPED_HIERARCHY_TYPE", "QUERY", "KEY_EXPRESSION", "FROM_CLAUSE", "WHERE_CLAUSE", "JOIN_CONDITION", "LEVEL_ID_EXPRESSION", "PARENT_EXPRESSION", "PARENT_LEVEL_ID_EXPRESSION", "LEVEL_EXPRESSION") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  null HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  m.map_name MAP_NAME,
  m.map_id MAP_ID,
  'DIMENSION LEVEL' MAPPED_DIMENSION_TYPE,
  null MAPPED_HIERARCHY_TYPE,
  s1.syntax_clob QUERY,
  s2.syntax_clob KEY_EXPRESSION,
  s3.syntax_clob FROM_CLAUSE,
  s4.syntax_clob WHERE_CLAUSE,
  null JOIN_CONDITION,
  null LEVEL_ID_EXPRESSION,
  null PARENT_EXPRESSION,
  null PARENT_LEVEL_ID_EXPRESSION,
  null LEVEL_EXPRESSION
FROM
  olap_mappings$ m,
  user$ u,
  obj$ o,
  olap_dim_levels$ dl,
  olap_syntax$ s1,
  olap_syntax$ s2,
  olap_syntax$ s3,
  olap_syntax$ s4
WHERE
  m.map_type in (18, 19, 20, 21)
  AND m.mapping_owner_type = 12 -- dim_level
  AND m.mapping_owner_id = dl.level_id
  AND dl.dim_obj# = o.obj#
  AND o.owner#=u.user#
  AND m.map_id = s1.owner_id(+)
  AND m.map_type = s1.owner_type(+)
  AND s1.ref_role(+) = 3
  AND m.map_id = s2.owner_id(+)
  AND m.map_type = s2.owner_type(+)
  AND s2.ref_role(+) = 6
  AND m.map_id = s3.owner_id(+)
  AND m.map_type = s3.owner_type(+)
  AND s3.ref_role(+) = 22
  AND m.map_id = s4.owner_id(+)
  AND m.map_type = s4.owner_type(+)
  AND s4.ref_role(+) = 21
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  m.map_name MAP_NAME,
  m.map_id MAP_ID,
  'HIERARCHY LEVEL' MAPPED_DIMENSION_TYPE,
  DECODE(h.hierarchy_type, 1, 'LEVEL', 2, 'VALUE') MAPPED_HIERARCHY_TYPE,
  s1.syntax_clob QUERY,
  s2.syntax_clob KEY_EXPRESSION,
  s3.syntax_clob FROM_CLAUSE,
  s4.syntax_clob WHERE_CLAUSE,
  s5.syntax_clob JOIN_CONDITION,
  null LEVEL_ID_EXPRESSION,
  null PARENT_EXPRESSION,
  null PARENT_LEVEL_ID_EXPRESSION,
  null LEVEL_EXPRESSION
FROM
  olap_mappings$ m,
  user$ u,
  obj$ o,
  olap_dim_levels$ dl,
  olap_hier_levels$ hl,
  olap_hierarchies$ h,
  olap_syntax$ s1,
  olap_syntax$ s2,
  olap_syntax$ s3,
  olap_syntax$ s4,
  olap_syntax$ s5
WHERE
  m.map_type in (18, 19, 20, 21)
  AND m.mapping_owner_type = 14 -- hier_level
  AND m.mapping_owner_id = hl.hierarchy_level_id
  AND hl.dim_level_id = dl.level_id
  AND hl.hierarchy_id = h.hierarchy_id
  AND h.dim_obj# = o.obj#
  AND o.owner#=u.user#
  AND m.map_id = s1.owner_id(+)
  AND m.map_type = s1.owner_type(+)
  AND s1.ref_role(+) = 3
  AND m.map_id = s2.owner_id(+)
  AND m.map_type = s2.owner_type(+)
  AND s2.ref_role(+) = 6
  AND m.map_id = s3.owner_id(+)
  AND m.map_type = s3.owner_type(+)
  AND s3.ref_role(+) = 22
  AND m.map_id = s4.owner_id(+)
  AND m.map_type = s4.owner_type(+)
  AND s4.ref_role(+) = 21
  AND m.map_id = s5.owner_id(+)
  AND m.map_type = s5.owner_type(+)
  AND s5.ref_role(+) = 7
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  null LEVEL_NAME,
  m.map_name MAP_NAME,
  m.map_id MAP_ID,
  'HIERARCHY' MAPPED_DIMENSION_TYPE,
  DECODE(h.hierarchy_type, 1, 'LEVEL', 2, 'VALUE') MAPPED_HIERARCHY_TYPE,
  s1.syntax_clob QUERY,
  s2.syntax_clob KEY_EXPRESSION,
  s3.syntax_clob FROM_CLAUSE,
  s4.syntax_clob WHERE_CLAUSE,
  null JOIN_CONDITION,
  s5.syntax_clob LEVEL_ID_EXPRESSION,
  s6.syntax_clob PARENT_EXPRESSION,
  s7.syntax_clob PARENT_LEVEL_ID_EXPRESSION,
  s8.syntax_clob LEVEL_EXPRESSION
FROM
  olap_mappings$ m,
  user$ u,
  obj$ o,
  olap_hierarchies$ h,
  olap_syntax$ s1,
  olap_syntax$ s2,
  olap_syntax$ s3,
  olap_syntax$ s4,
  olap_syntax$ s5,
  olap_syntax$ s6,
  olap_syntax$ s7,
  olap_syntax$ s8
WHERE
  m.map_type in (18, 19, 20, 21)
  AND m.mapping_owner_type = 13 -- hierarchy
  AND m.mapping_owner_id = h.hierarchy_id
  AND h.dim_obj# = o.obj#
  AND o.owner#=u.user#
  AND m.map_id = s1.owner_id(+)
  AND m.map_type = s1.owner_type(+)
  AND s1.ref_role(+) = 3
  AND m.map_id = s2.owner_id(+)
  AND m.map_type = s2.owner_type(+)
  AND s2.ref_role(+) = 6
  AND m.map_id = s3.owner_id(+)
  AND m.map_type = s3.owner_type(+)
  AND s3.ref_role(+) = 22
  AND m.map_id = s4.owner_id(+)
  AND m.map_type = s4.owner_type(+)
  AND s4.ref_role(+) = 21
  AND m.map_id = s5.owner_id(+)
  AND m.map_type = s5.owner_type(+)
  AND s5.ref_role(+) = 8
  AND m.map_id = s6.owner_id(+)
  AND m.map_type = s6.owner_type(+)
  AND s6.ref_role(+) = 9
  AND m.map_id = s7.owner_id(+)
  AND m.map_type = s7.owner_type(+)
  AND s7.ref_role(+) = 10
  AND m.map_id = s8.owner_id(+)
  AND m.map_type = s8.owner_type(+)
  AND s8.ref_role(+) = 11
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  null HIERARCHY_NAME,
  null LEVEL_NAME,
  m.map_name MAP_NAME,
  m.map_id MAP_ID,
  'PRIMARY DIMENSION' MAPPED_DIMENSION_TYPE,
  null MAPPED_HIERARCHY_TYPE,
  s1.syntax_clob QUERY,
  s2.syntax_clob KEY_EXPRESSION,
  s3.syntax_clob FROM_CLAUSE,
  s4.syntax_clob WHERE_CLAUSE,
  null JOIN_CONDITION,
  null LEVEL_ID_EXPRESSION,
  null PARENT_EXPRESSION,
  null PARENT_LEVEL_ID_EXPRESSION,
  null LEVEL_EXPRESSION
FROM
  olap_mappings$ m,
  user$ u,
  obj$ o,
  olap_syntax$ s1,
  olap_syntax$ s2,
  olap_syntax$ s3,
  olap_syntax$ s4
WHERE
  m.map_type in (18, 19, 20, 21)
  AND m.mapping_owner_type = 11 -- dimension
  AND m.mapping_owner_id = o.obj#
  AND o.owner#=u.user#
  AND m.map_id = s1.owner_id(+)
  AND m.map_type = s1.owner_type(+)
  AND s1.ref_role(+) = 3
  AND m.map_id = s2.owner_id(+)
  AND m.map_type = s2.owner_type(+)
  AND s2.ref_role(+) = 6
  AND m.map_id = s3.owner_id(+)
  AND m.map_type = s3.owner_type(+)
  AND s3.ref_role(+) = 22
  AND m.map_id = s4.owner_id(+)
  AND m.map_type = s4.owner_type(+)
  AND s4.ref_role(+) = 21
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."OWNER" IS 'Owner of the OLAP Cube Dimension';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."DIMENSION_NAME" IS 'Name of the OLAP Cube Dimension that contains the mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."HIERARCHY_NAME" IS 'Name of the OLAP Cube Hierarchy that contains the mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."LEVEL_NAME" IS 'Name of the OLAP Cube Dimension Level that contains the mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."MAP_NAME" IS 'Name of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."MAP_ID" IS 'Dictionary Id of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."MAPPED_DIMENSION_TYPE" IS 'Text value indicating the type of the OLAP Dimension that contains the mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."MAPPED_HIERARCHY_TYPE" IS 'Text value indicating the type of the OLAP Hierarchy that contains the mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."QUERY" IS 'Query of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."KEY_EXPRESSION" IS 'Key expression of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."FROM_CLAUSE" IS 'From clause of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."WHERE_CLAUSE" IS 'Where clause of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."JOIN_CONDITION" IS 'Join condition of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."LEVEL_ID_EXPRESSION" IS 'Level ID expression of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."PARENT_EXPRESSION" IS 'Parent expression of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."PARENT_LEVEL_ID_EXPRESSION" IS 'Parent level ID expression of the OLAP Cube Dimension Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MAPPINGS"."LEVEL_EXPRESSION" IS 'Level expression of the OLAP Cube Dimension Mapping';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DIM_MAPPINGS"  IS 'OLAP Cube Dimension Mappings in the database that are accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DIM_MODELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DIM_MODELS" ("OWNER", "DIMENSION_NAME", "MODEL_NAME", "MODEL_ID", "DESCRIPTION") AS 
  SELECT
  du.name OWNER,
  do.name DIMENSION_NAME,
  m.model_name MODEL_NAME,
  m.model_id MODEL_ID,
  d.description_value DESCRIPTION
FROM
  olap_models$ m,
  obj$ do,
  user$ du,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 16 --MODEL
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d
WHERE
  m.owning_obj_type = 11 --DIMENSION
  AND m.owning_obj_id = do.obj#
  AND do.owner# = du.user#
  AND m.model_id = d.owning_object_id(+)
  AND (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or do.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (do.owner#, do.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MODELS"."OWNER" IS 'Owner of OLAP Dimension Model';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MODELS"."DIMENSION_NAME" IS 'Name of owning dimension of the OLAP Dimension Model';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MODELS"."MODEL_NAME" IS 'Name of the OLAP Dimension Model';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MODELS"."MODEL_ID" IS 'Dictionary Id of the OLAP Dimension Model';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_MODELS"."DESCRIPTION" IS 'Long Description of the OLAP Dimension Model';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DIM_MODELS"  IS 'OLAP Dimension Models in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DIMNL_MAPPINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DIMNL_MAPPINGS" ("OWNER", "CUBE_NAME", "CUBE_MAP_NAME", "MAP_NAME", "MAP_ID", "MAPPED_DIMENSION_NAME", "MAPPED_HIERARCHY_NAME", "MAPPED_LEVEL_NAME", "MAPPED_DIMENSION_TYPE", "JOIN_CONDITION", "LEVEL_ID_EXPRESSION", "DIMENSIONALITY_EXPRESSION") AS 
  SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  owner_map.map_name CUBE_MAP_NAME,
  m.map_name MAP_NAME,
  m.map_id MAP_ID,
  o2.name  MAPPED_DIMENSION_NAME,
  CASE m.mapped_dim_type
  WHEN 14 -- hier_level
  THEN (SELECT h.hierarchy_name
        FROM olap_hier_levels$ hl, olap_hierarchies$ h
        WHERE m.mapped_dim_id = hl.hierarchy_level_id
              AND hl.hierarchy_id = h.hierarchy_id
        )
  WHEN 13 -- hierarchy
  THEN (SELECT h.hierarchy_name
        FROM olap_hierarchies$ h
        WHERE m.mapped_dim_id = h.hierarchy_id
       )
  ELSE null END AS MAPPED_HIERARCHY_NAME,
  CASE m.mapped_dim_type
  WHEN 12 -- dim_level
  THEN (SELECT dl.level_name
        FROM olap_dim_levels$ dl
        WHERE m.mapped_dim_id = dl.level_id
        )
  WHEN 14 -- hier_level
  THEN (SELECT dl.level_name
        FROM olap_dim_levels$ dl, olap_hier_levels$ hl, olap_hierarchies$ h
        WHERE m.mapped_dim_id = hl.hierarchy_level_id
              AND hl.hierarchy_id = h.hierarchy_id
              AND hl.dim_level_id = dl.level_id
        )
  ELSE null END AS MAPPED_LEVEL_NAME,
  decode(m.mapped_dim_type, '12', 'DIMENSION LEVEL',
                            '11', 'PRIMARY DIMENSION',
                            '14', 'HIERARCHY LEVEL',
                            '13', 'HIERARCHY') MAPPED_DIMENSION_TYPE,
  s1.syntax_clob JOIN_CONDITION,
  s2.syntax_clob LEVEL_ID_EXPRESSION,
  s3.syntax_clob DIMENSIONALITY_EXPRESSION
FROM
  olap_mappings$ m,
  olap_mappings$ owner_map,
  user$ u,
  olap_dimensionality$ diml,
  obj$ o,
  obj$ o2,
  olap_syntax$ s1,
  olap_syntax$ s2,
  olap_syntax$ s3,
 (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  m.map_type = 23
  AND m.mapped_object_id = diml.dimensionality_id
  AND m.mapping_owner_id = owner_map.map_id
  AND diml.dimensioned_object_id = o.obj#
  AND o.obj# = da.obj#(+)
  AND o.owner# = u.user#
  AND diml.dimension_id = o2.obj#(+)
  AND m.map_id = s1.owner_id(+)
  AND m.map_type = s1.owner_type(+)
  AND s1.ref_role(+) = 7
  AND m.map_id = s2.owner_id(+)
  AND m.map_type = s2.owner_type(+)
  AND s2.ref_role(+) = 8
  AND m.map_id = s3.owner_id(+)
  AND m.map_type = s3.owner_type(+)
  AND s3.ref_role(+) = 15
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL));

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."OWNER" IS 'Owner of the OLAP Cube that contains the dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."CUBE_NAME" IS 'Name of the OLAP Cube that contains the dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."CUBE_MAP_NAME" IS 'Name of the OLAP Cube Map that contains the dimensionality mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."MAP_NAME" IS 'Name of the OLAP Cube Dimensionality Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."MAP_ID" IS 'Dictionary Id of the OLAP Cube Dimensionality Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."MAPPED_DIMENSION_NAME" IS 'Name of the mapped dimension of the OLAP Cube Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."MAPPED_HIERARCHY_NAME" IS 'Name of the mapped hierarchy of the OLAP Cube Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."MAPPED_LEVEL_NAME" IS 'Name of the mapped dimension level of the OLAP Cube Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."MAPPED_DIMENSION_TYPE" IS 'Text value indicating the type of the mapped dimension object';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."JOIN_CONDITION" IS 'Join condition of the OLAP Cube Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."LEVEL_ID_EXPRESSION" IS 'Level ID expression of the OLAP Cube Dimensionality';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIMNL_MAPPINGS"."DIMENSIONALITY_EXPRESSION" IS 'Dimensionality expression of the OLAP Cube Dimensionality';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DIMNL_MAPPINGS"  IS 'OLAP Cube Dimenisonality Mappings in the database that are accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DIM_VIEW_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DIM_VIEW_COLUMNS" ("OWNER", "DIMENSION_NAME", "VIEW_NAME", "COLUMN_NAME", "COLUMN_TYPE", "OBJECT_NAME") AS 
  SELECT
  du.name OWNER,
  do.name DIMENSION_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  DECODE(avc.column_type, 2, 'KEY',
                          4, 'LEVEL_NAME',
                          7, 'DIM_ORDER',
                          9, 'MEMBER_TYPE') COLUMN_TYPE,
  NULL OBJECT_NAME -- no object name for these column types
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  col$ col,
  obj$ do,
  user$ du,
  obj$ vo
WHERE
  avc.view_obj# = av.view_obj#
  AND av.olap_object_type = 11 --DIMENSION
  AND av.olap_object_id = do.obj#
  AND av.view_type = 1 -- ET
  AND avc.column_type IN (2, 4, 6, 7, 9)
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND do.owner# = du.user#
  AND avc.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=do.owner#
  AND (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or do.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (do.owner#, do.type#) = 1
            )
UNION ALL
SELECT
  du.name OWNER,
  do.name DIMENSION_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  'ATTRIBUTE' COLUMN_TYPE,
  a.attribute_name OBJECT_NAME
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  olap_attributes$ a,
  col$ col,
  obj$ do,
  user$ du,
  obj$ vo
WHERE
  avc.view_obj# = av.view_obj#
  AND av.olap_object_type = 11 --DIMENSION
  AND av.olap_object_id = do.obj#
  AND av.view_type = 1 -- ET
  AND avc.column_type = 1 -- OBJECT
  AND avc.referenced_object_type = 15 --ATTRIBUTE
  AND avc.referenced_object_id = a.attribute_id
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND a.dim_obj# = do.obj#
  AND do.owner# = du.user#
  AND avc.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=do.owner#
  AND (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or do.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (do.owner#, do.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEW_COLUMNS"."OWNER" IS 'Owner of the OLAP Dimension View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEW_COLUMNS"."DIMENSION_NAME" IS 'Name of owning dimension of the OLAP Dimension View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEW_COLUMNS"."VIEW_NAME" IS 'View Name of the OLAP Dimension View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEW_COLUMNS"."COLUMN_NAME" IS 'Name of the OLAP Dimension View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEW_COLUMNS"."COLUMN_TYPE" IS 'View Type of the OLAP Dimension View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEW_COLUMNS"."OBJECT_NAME" IS 'No object names for OLAP Dimension View Columns';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DIM_VIEW_COLUMNS"  IS 'OLAP Dimension View Columns in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_DIM_VIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_DIM_VIEWS" ("OWNER", "DIMENSION_NAME", "VIEW_NAME") AS 
  SELECT
  du.name OWNER,
  do.name DIMENSION_NAME,
  vo.name VIEW_NAME
FROM
  olap_aw_views$ av,
  obj$ do,
  user$ du,
  obj$ vo
WHERE
  av.olap_object_type = 11 --DIMENSION
  AND av.olap_object_id=do.obj#
  AND av.view_type = 1 -- ET
  AND do.owner#=du.user#
  AND av.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=do.owner#
  AND (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or do.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (do.owner#, do.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEWS"."OWNER" IS 'Owner of the OLAP Dimension View';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEWS"."DIMENSION_NAME" IS 'Name of owning dimension of the OLAP Dimension View';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_DIM_VIEWS"."VIEW_NAME" IS 'View Name of the OLAP Dimension View';
   COMMENT ON TABLE "SYS"."ALL_CUBE_DIM_VIEWS"  IS 'OLAP Dimension Views in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_HIERARCHIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_HIERARCHIES" ("OWNER", "DIMENSION_NAME", "HIERARCHY_NAME", "HIERARCHY_ID", "HIERARCHY_TYPE", "DESCRIPTION", "IS_RAGGED", "IS_SKIP_LEVEL", "REFRESH_MVIEW_NAME", "CUSTOM_ORDER") AS 
  SELECT
   u.name OWNER,
   o.name DIMENSION_NAME,
   h.hierarchy_name HIERARCHY_NAME,
   h.hierarchy_id HIERARCHY_ID,
   DECODE(h.hierarchy_type, 1, 'LEVEL', 2, 'VALUE') HIERARCHY_TYPE,
   d.description_value DESCRIPTION,
   (case
     when io.option_num_value is null then 0
     else io.option_num_value
    end) IS_RAGGED,
   (case
     when io2.option_num_value is null then 0
     else io2.option_num_value
    end) IS_SKIP_LEVEL,
   io3.option_value REFRESH_MVIEW_NAME,
   syn.syntax_clob CUSTOM_ORDER
FROM
  olap_hierarchies$ h,
  user$ u,
  obj$ o,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 13 --HIERARCHY
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d,
  olap_impl_options$ io,
  olap_impl_options$ io2,
  olap_impl_options$ io3,
  olap_syntax$ syn
WHERE
  h.dim_obj#=o.obj#
  AND o.owner#=u.user#
  AND d.owning_object_id(+)=h.hierarchy_id
  AND io.object_type(+) = 13 -- HIERARCHY
  AND io.owning_objectid(+) = h.hierarchy_id
  AND io.option_type(+) = 6 -- IS_RAGGED
  AND io2.object_type(+) = 13 -- HIERARCHY
  AND io2.owning_objectid(+) = h.hierarchy_id
  AND io2.option_type(+) = 1 -- IS_SKIP_LEVEL
  AND io3.object_type(+) = 13 -- HIERARCHY
  AND io3.owning_objectid(+) = h.hierarchy_id
  AND io3.option_type(+) = 30 -- refresh MV name
  AND syn.owner_id(+) = h.hierarchy_id
  AND syn.owner_type(+) = 13
  AND syn.ref_role(+) = 23 -- CustomOrder
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."OWNER" IS 'Owner of the OLAP Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."DIMENSION_NAME" IS 'Name of owning dimension of the OLAP Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."HIERARCHY_NAME" IS 'Name of the OLAP Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."HIERARCHY_ID" IS 'Dictionary Id of the OLAP Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."HIERARCHY_TYPE" IS 'Type of the OLAP Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."DESCRIPTION" IS 'Long Description of the OLAP Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."IS_RAGGED" IS 'Indication of whether the OLAP Hierarchy is Ragged';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."IS_SKIP_LEVEL" IS 'Indication of whether the OLAP Hierarchy is SkipLevel';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."REFRESH_MVIEW_NAME" IS 'Name of the refresh materialized view for the OLAP Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIERARCHIES"."CUSTOM_ORDER" IS 'Custom Order of the OLAP Hierarchy';
   COMMENT ON TABLE "SYS"."ALL_CUBE_HIERARCHIES"  IS 'OLAP Hierarchies in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_HIER_LEVELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_HIER_LEVELS" ("OWNER", "DIMENSION_NAME", "HIERARCHY_NAME", "LEVEL_NAME", "HIERARCHY_LEVEL_ID", "ORDER_NUM", "DESCRIPTION") AS 
  SELECT
  u.name OWNER,
  o.name DIMENSION_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  dl.level_name LEVEL_NAME,
  hl.hierarchy_level_id HIERARCHY_LEVEL_ID,
  hl.order_num ORDER_NUM,
  d.description_value DESCRIPTION
FROM
  olap_hier_levels$ hl,
  user$ u, obj$ o,
  olap_hierarchies$ h,
  olap_dim_levels$ dl,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 14 --HIER_LEVEL
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d
WHERE
  hl.hierarchy_id=h.hierarchy_id AND o.owner#=u.user#
  AND dl.level_id=hl.dim_level_id AND o.obj#=dl.dim_obj#
  AND d.owning_object_id(+)=hl.hierarchy_level_id
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_LEVELS"."OWNER" IS 'Owner of the OLAP Hierarchy Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_LEVELS"."DIMENSION_NAME" IS 'Name of the owning Dimension of the OLAP Hierarchy Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_LEVELS"."HIERARCHY_NAME" IS 'Name of the owning Hierarchy of the OLAP Hierarchy Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_LEVELS"."LEVEL_NAME" IS 'Name of the OLAP Dimension Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_LEVELS"."HIERARCHY_LEVEL_ID" IS 'Dictionary Id of the OLAP Hierarchy Level';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_LEVELS"."ORDER_NUM" IS 'Order number of the OLAP Hierarchy Level within the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_LEVELS"."DESCRIPTION" IS 'Long Description of the OLAP Hierarchy Level';
   COMMENT ON TABLE "SYS"."ALL_CUBE_HIER_LEVELS"  IS 'OLAP Hierarchy Levels in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_HIER_VIEW_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS" ("OWNER", "DIMENSION_NAME", "HIERARCHY_NAME", "VIEW_NAME", "COLUMN_NAME", "COLUMN_TYPE", "OBJECT_NAME") AS 
  SELECT
  du.name OWNER,
  do.name DIMENSION_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  DECODE(avc.column_type, 2, 'KEY',
                          3, 'PARENT',
                          4, 'LEVEL_NAME',
                          5, 'DEPTH',
                          8, 'HIER_ORDER',
                          9, 'MEMBER_TYPE') COLUMN_TYPE,
  NULL OBJECT_NAME
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  olap_hierarchies$ h,
  col$ col,
  obj$ do,
  user$ du,
  obj$ vo
WHERE
  avc.view_obj# = av.view_obj#
  AND avc.column_type IN (2, 3, 4, 5, 8, 9)
  AND av.olap_object_type = 13 --HIERARCHY
  AND av.olap_object_id = h.hierarchy_id
  AND av.view_type = 1 -- ET
  AND h.dim_obj# = do.obj#
  AND do.owner# = du.user#
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND av.view_obj# = vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner# = do.owner#
  AND (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or do.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (do.owner#, do.type#) = 1
            )
UNION ALL
SELECT
  du.name OWNER,
  do.name DIMENSION_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  'ATTRIBUTE' COLUMN_TYPE,
  a.attribute_name OBJECT_NAME
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  olap_hierarchies$ h,
  olap_attributes$ a,
  col$ col,
  obj$ do,
  user$ du,
  obj$ vo
WHERE
  avc.view_obj# = av.view_obj#
  AND av.olap_object_type = 13 --HIERARCHY
  AND avc.column_type = 1 -- OBJECT
  AND avc.referenced_object_type = 15 --ATTRIBUTE
  AND avc.referenced_object_id = a.attribute_id
  AND av.olap_object_id = h.hierarchy_id
  AND av.view_type = 1 -- ET
  AND h.dim_obj# = do.obj#
  AND do.owner# = du.user#
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND av.view_obj# = vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner# = do.owner#
  AND (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or do.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (do.owner#, do.type#) = 1
            )
UNION ALL
SELECT
  du.name OWNER,
  do.name DIMENSION_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  'LEVEL' COLUMN_TYPE,
  dl.level_name OBJECT_NAME
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  olap_hierarchies$ h,
  olap_hier_levels$ l,
  olap_dim_levels$ dl,
  col$ col,
  obj$ do,
  user$ du,
  obj$ vo
WHERE
  avc.view_obj# = av.view_obj#
  AND av.olap_object_type = 13 --HIERARCHY
  AND avc.column_type = 1 -- OBJECT
  AND avc.referenced_object_type = 12 --DIM_LEVEL
  AND avc.referenced_object_id = dl.level_id
  AND l.dim_level_id = dl.level_id
  AND l.hierarchy_id = h.hierarchy_id
  AND av.olap_object_id = h.hierarchy_id
  AND av.view_type = 1 -- ET
  AND h.dim_obj# = do.obj#
  AND do.owner# = du.user#
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND av.view_obj# = vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner# = do.owner#
  AND (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or do.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (do.owner#, do.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS"."OWNER" IS 'Owner of the OLAP Hierarchy View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS"."DIMENSION_NAME" IS 'Name of owning dimension of the OLAP Hierarchy View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS"."HIERARCHY_NAME" IS 'Name of hierarchy of the OLAP Hierarchy View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS"."VIEW_NAME" IS 'View Name of the OLAP Hierarchy View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS"."COLUMN_NAME" IS 'Name of the OLAP Hierarchy View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS"."COLUMN_TYPE" IS 'View Type of the OLAP Hierarchy View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS"."OBJECT_NAME" IS 'No object names for OLAP Hierarchy View Columns';
   COMMENT ON TABLE "SYS"."ALL_CUBE_HIER_VIEW_COLUMNS"  IS 'OLAP Hierarchy View Columns in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_HIER_VIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_HIER_VIEWS" ("OWNER", "DIMENSION_NAME", "HIERARCHY_NAME", "VIEW_NAME") AS 
  SELECT
  du.name OWNER,
  do.name DIMENSION_NAME,
  h.hierarchy_name HIERARCHY_NAME,
  vo.name VIEW_NAME
FROM
  olap_aw_views$ av,
  olap_hierarchies$ h,
  obj$ do,
  user$ du,
  obj$ vo
WHERE
  av.olap_object_type = 13 --HIERACHY
  AND av.olap_object_id = h.hierarchy_id
  AND av.view_type = 1 -- ET
  AND h.dim_obj# = do.obj#
  AND do.owner# = du.user#
  AND av.view_obj# = vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner# = do.owner#
  AND (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or do.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (do.owner#, do.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEWS"."OWNER" IS 'Owner of the OLAP Hierarchy View';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEWS"."DIMENSION_NAME" IS 'Name of owning dimension of the OLAP Hierarchy View';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEWS"."HIERARCHY_NAME" IS 'Name of hierarchy of the OLAP Hierarchy View';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_HIER_VIEWS"."VIEW_NAME" IS 'View Name of the OLAP Hierarchy View';
   COMMENT ON TABLE "SYS"."ALL_CUBE_HIER_VIEWS"  IS 'OLAP Hierarchy Views in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_MAPPINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_MAPPINGS" ("OWNER", "CUBE_NAME", "MAP_NAME", "MAP_ID", "QUERY", "WHERE_CLAUSE", "FROM_CLAUSE", "IS_SOLVED", "AGGREGATION_METHOD") AS 
  SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  m.map_name MAP_NAME,
  m.map_id MAP_ID,
  s1.syntax_clob QUERY,
  s2.syntax_clob WHERE_CLAUSE,
  s3.syntax_clob FROM_CLAUSE,
  decode(i1.option_num_value, '1', 'Y', 'N') IS_SOLVED,
  i2.option_value AGGREGATION_METHOD
FROM
  olap_mappings$ m,
  user$ u,
  obj$ o,
  olap_syntax$ s1,
  olap_syntax$ s2,
  olap_syntax$ s3,
  olap_impl_options$ i1,
  olap_impl_options$ i2,
 (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  m.map_type = 22
  AND m.mapping_owner_id = o.obj#
  AND o.obj# = da.obj#(+)
  AND o.owner# = u.user#
  AND m.map_id = s1.owner_id(+)
  AND m.map_type = s1.owner_type(+)
  AND s1.ref_role(+) = 3
  AND m.map_id = s2.owner_id(+)
  AND m.map_type = s2.owner_type(+)
  AND s2.ref_role(+) = 21
  AND m.map_id = s3.owner_id(+)
  AND m.map_type = s3.owner_type(+)
  AND s3.ref_role(+) = 22
  AND m.map_id = i1.owning_objectid(+)
  AND m.map_type = i1.object_type(+)
  AND i1.option_type(+) = 11
  AND m.map_id = i2.owning_objectid(+)
  AND m.map_type = i2.object_type(+)
  AND i2.option_type(+) = 21
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL));

   COMMENT ON COLUMN "SYS"."ALL_CUBE_MAPPINGS"."OWNER" IS 'Owner of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MAPPINGS"."MAP_NAME" IS 'Name of the OLAP Cube Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MAPPINGS"."MAP_ID" IS 'Dictionary Id of the OLAP Cube Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MAPPINGS"."QUERY" IS 'Query of the OLAP Cube Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MAPPINGS"."WHERE_CLAUSE" IS 'Where Clause of the OLAP Cube Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MAPPINGS"."FROM_CLAUSE" IS 'From Clause of the OLAP Cube Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MAPPINGS"."IS_SOLVED" IS 'Indication of whether or not the OLAP Cube Mapping is solved';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MAPPINGS"."AGGREGATION_METHOD" IS 'Aggregation method of the OLAP Cube Mapping';
   COMMENT ON TABLE "SYS"."ALL_CUBE_MAPPINGS"  IS 'OLAP Cube Mappings in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_MEAS_MAPPINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_MEAS_MAPPINGS" ("OWNER", "CUBE_NAME", "CUBE_MAP_NAME", "MAP_NAME", "MAP_ID", "MEASURE_NAME", "MEASURE_EXPRESSION") AS 
  SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  owner_map.map_name CUBE_MAP_NAME,
  m.map_name MAP_NAME,
  m.map_id MAP_ID,
  meas.measure_name MEASURE_NAME,
  s1.syntax_clob MEASURE_EXPRESSION
FROM
  olap_mappings$ m,
  olap_mappings$ owner_map,
  user$ u,
  obj$ o,
  olap_measures$ meas,
  olap_syntax$ s1,
 (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  m.map_type = 24
  AND m.mapped_object_id = meas.measure_id
  AND m.mapping_owner_id = owner_map.map_id
  AND meas.cube_obj# = o.obj#
  AND o.obj# = da.obj#(+)
  AND o.owner# = u.user#
  AND m.map_id = s1.owner_id(+)
  AND m.map_type = s1.owner_type(+)
  AND s1.ref_role(+) = 1
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL));

   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEAS_MAPPINGS"."OWNER" IS 'Owner of the OLAP Cube that contains the measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEAS_MAPPINGS"."CUBE_NAME" IS 'Name of the OLAP Cube that contains the measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEAS_MAPPINGS"."CUBE_MAP_NAME" IS 'Name of the map that contains the cube measure mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEAS_MAPPINGS"."MAP_NAME" IS 'Name of the OLAP Cube Measure Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEAS_MAPPINGS"."MAP_ID" IS 'Dictionary Id of the OLAP Cube Measure Mapping';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEAS_MAPPINGS"."MEASURE_NAME" IS 'Name of the OLAP Cube Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEAS_MAPPINGS"."MEASURE_EXPRESSION" IS 'Expression of the OLAP Cube Measure Mapping';
   COMMENT ON TABLE "SYS"."ALL_CUBE_MEAS_MAPPINGS"  IS 'OLAP Cube Measure Mappings in the database that are accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_MEASURES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_MEASURES" ("OWNER", "CUBE_NAME", "MEASURE_NAME", "MEASURE_ID", "OVERRIDE_SOLVE_SPEC", "MEASURE_TYPE", "EXPRESSION", "DESCRIPTION", "DATA_TYPE", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "LOOP_VAR_OVERRIDE", "LOOP_DENSE_OVERRIDE", "LOOP_TYPE") AS 
  SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  m.measure_name MEASURE_NAME,
  m.measure_id MEASURE_ID,
  ss.syntax_clob OVERRIDE_SOLVE_SPEC,
  DECODE(m.measure_type, 1, 'BASE', 2, 'DERIVED') MEASURE_TYPE,
  DECODE(m.measure_type, 2, s.syntax_clob) EXPRESSION,
  d.description_value DESCRIPTION,
  DECODE(m.type#, 1, decode(m.charsetform, 2, 'NVARCHAR2', 'VARCHAR2'),
                  2, decode(m.scale, null,
                            decode(m.precision#, null, 'NUMBER', 'FLOAT'),
                            'NUMBER'),
                  8, 'LONG',
                  9, decode(m.charsetform, 2, 'NCHAR VARYING', 'VARCHAR'),
                  12, 'DATE',
                  23, 'RAW', 24, 'LONG RAW',
                  69, 'ROWID',
                  96, decode(m.charsetform, 2, 'NCHAR', 'CHAR'),
                  100, 'BINARY_FLOAT',
                  101, 'BINARY_DOUBLE',
                  105, 'MLSLABEL',
                  106, 'MLSLABEL',
                  112, decode(m.charsetform, 2, 'NCLOB', 'CLOB'),
                  113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
                  178, 'TIME(' ||m.scale|| ')',
                  179, 'TIME(' ||m.scale|| ')' || ' WITH TIME ZONE',
                  180, 'TIMESTAMP(' ||m.scale|| ')',
                  181, 'TIMESTAMP(' ||m.scale|| ')' || ' WITH TIME ZONE',
                  231, 'TIMESTAMP(' ||m.scale|| ')' || ' WITH LOCAL TIME ZONE',
                  182, 'INTERVAL YEAR(' ||m.precision#||') TO MONTH',
                  183, 'INTERVAL DAY(' ||m.precision#||') TO SECOND(' ||
                        m.scale || ')',
                  208, 'UROWID',
                  'UNDEFINED') DATA_TYPE,
  m.length DATA_LENGTH,
  m.precision# DATA_PRECISION,
  m.scale DATA_SCALE,
  io.option_value LOOP_VAR_OVERRIDE,
  io2.option_value LOOP_DENSE_OVERRIDE,
  io3.option_value LOOP_TYPE
FROM
  olap_measures$ m,
  user$ u,
  obj$ o,
  olap_syntax$ ss,
  olap_syntax$ s,
  olap_impl_options$ io,
  olap_impl_options$ io2,
  olap_impl_options$ io3,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 2 --MEASURE
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d,
 (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  m.cube_obj#=o.obj#
  AND o.obj#=da.obj#(+)
  AND o.owner#=u.user#
  AND m.measure_id=s.owner_id(+)
  AND m.measure_id=ss.owner_id(+)
  AND m.is_hidden=0 --NOT HIDDEN
  AND s.owner_type(+)=2 --MEASURE
  AND s.ref_role(+)=14 --DERIVED_MEAS_EXPRESSION
  AND ss.owner_type(+)=2 --MEASURE
  AND ss.ref_role(+)=16 --CONSISTENT_SOLVE_SPEC
  AND m.measure_id=d.owning_object_id(+)
  AND io.owning_objectid(+)=m.measure_id
  AND io.object_type(+)=2
  AND io.option_type(+)=51 -- LOOP_VAR_OVERRIDE
  AND io2.owning_objectid(+)=m.measure_id
  AND io2.object_type(+)=2
  AND io2.option_type(+)=52 -- LOOP_DENSE_OVERRIDE
  AND io3.owning_objectid(+)=m.measure_id
  AND io3.object_type(+)=2
  AND io3.option_type(+)=53 -- LOOP_TYPE
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL));

   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."OWNER" IS 'Owner of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."CUBE_NAME" IS 'Name of the OLAP Cube which owns the Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."MEASURE_NAME" IS 'Name of Measure in the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."OVERRIDE_SOLVE_SPEC" IS 'Override solve specification of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."MEASURE_TYPE" IS 'Type of Measure in the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."EXPRESSION" IS 'Expression of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."DESCRIPTION" IS 'Description of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."DATA_TYPE" IS 'Data Type of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."DATA_LENGTH" IS 'Data Length of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."DATA_PRECISION" IS 'Data Precision of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."DATA_SCALE" IS 'Data Scale of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."LOOP_VAR_OVERRIDE" IS 'Override $LOOP_VAR of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."LOOP_DENSE_OVERRIDE" IS 'Override $LOOP_DENSE of the OLAP Measure';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_MEASURES"."LOOP_TYPE" IS '$LOOP_TYPE of the OLAP Measure';
   COMMENT ON TABLE "SYS"."ALL_CUBE_MEASURES"  IS 'OLAP Measures in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_NAMED_BUILD_SPECS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_NAMED_BUILD_SPECS" ("OWNER", "CUBE_NAME", "NAMED_BUILD_SPEC") AS 
  SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  syn.syntax_clob NAMED_BUILD_SPEC
FROM
  olap_cubes$ c,
  user$ u,
  obj$ o,
  olap_syntax$ syn,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
   FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      olap_dimensionality$ diml,
      olap_cube_dimensions$ dim,
      obj$ do
    WHERE
      do.obj# = dim.obj#
      AND diml.dimensioned_object_type = 1 --CUBE
      AND diml.dimensioned_object_id = c.obj#
      AND diml.dimension_type = 11 --DIMENSION
      AND diml.dimension_id = do.obj#
    )
    GROUP BY obj# ) da
WHERE
  o.obj#=c.obj#
  AND o.obj#=da.obj#(+)
  AND o.owner#=u.user#
  AND syn.owner_id(+)=c.obj#
  AND syn.owner_type(+)=1
  AND syn.ref_role = 18 -- named build spec
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL));

   COMMENT ON COLUMN "SYS"."ALL_CUBE_NAMED_BUILD_SPECS"."OWNER" IS 'Owner of the OLAP Named Build Specification';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_NAMED_BUILD_SPECS"."CUBE_NAME" IS 'Name of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_NAMED_BUILD_SPECS"."NAMED_BUILD_SPEC" IS 'Name of the OLAP Cube Named Build Specification';
   COMMENT ON TABLE "SYS"."ALL_CUBE_NAMED_BUILD_SPECS"  IS 'OLAP Cube Named Build Specifications in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBES" ("OWNER", "CUBE_NAME", "CUBE_ID", "AW_NAME", "CONSISTENT_SOLVE_SPEC", "DESCRIPTION", "SPARSE_TYPE", "PRECOMPUTE_CONDITION", "PRECOMPUTE_PERCENT", "PRECOMPUTE_PERCENT_TOP", "PARTITION_DIMENSION_NAME", "PARTITION_HIERARCHY_NAME", "PARTITION_LEVEL_NAME", "REFRESH_MVIEW_NAME", "REWRITE_MVIEW_NAME", "DEFAULT_BUILD_SPEC", "MEASURE_STORAGE", "SQL_CUBE_STORAGE_TYPE", "CUBE_STORAGE_TYPE") AS 
  SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  c.obj# CUBE_ID,
  a.awname AW_NAME,
  syn.syntax_clob CONSISTENT_SOLVE_SPEC,
  d.description_value DESCRIPTION,
  io.option_value SPARSE_TYPE,
  syn2.syntax_clob PRECOMPUTE_CONDITION,
  io2.option_num_value PRECOMPUTE_PERCENT,
  io3.option_num_value PRECOMPUTE_PERCENT_TOP,
  od.name PARTITION_DIMENSION_NAME,
  h.hierarchy_name PARTITION_HIERARCHY_NAME,
  dl.level_name PARTITION_LEVEL_NAME,
  io5.option_value REFRESH_MVIEW_NAME,
  io6.option_value REWRITE_MVIEW_NAME,
  syn3.syntax_clob DEFAULT_BUILD_SPEC,
  io7.option_value MEASURE_STORAGE,
  syn4.syntax_clob SQL_CUBE_STORAGE_TYPE,
  io8.option_value CUBE_STORAGE_TYPE
FROM
  olap_cubes$ c,
  user$ u,
  aw$ a,
  obj$ o,
  olap_syntax$ syn,
  olap_syntax$ syn2,
  olap_syntax$ syn3,
  olap_syntax$ syn4,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 1 --CUBE
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d,
  olap_impl_options$ io,
  olap_impl_options$ io2,
  olap_impl_options$ io3,
  olap_impl_options$ io4,
  olap_impl_options$ io5,
  olap_impl_options$ io6,
  olap_impl_options$ io7,
  olap_impl_options$ io8,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_hierarchies$ h,
  obj$ od,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  o.obj#=c.obj#
  AND c.obj#=da.obj#(+)
  AND o.owner#=u.user#(+)
  AND c.awseq#=a.awseq#(+)
  AND c.obj#=d.owning_object_id(+)
  AND syn.owner_id(+)=c.obj#
  AND syn.owner_type(+)=1
  AND syn.ref_role(+)=16 -- consistent solve spec
  AND syn2.owner_id(+)=c.obj#
  AND syn2.owner_type(+)=1
  AND syn2.ref_role(+)=20 -- precompute condition
  AND syn3.owner_id(+)=c.obj#
  AND syn3.owner_type(+)=1
  AND syn3.ref_role(+)=17 -- default build spec
  AND syn4.owner_id(+)=c.obj#
  AND syn4.owner_type(+)=1
  AND syn4.ref_role(+)=24 -- sql cube storage type
  AND io.owning_objectid(+)=c.obj#
  AND io.object_type(+)=1
  AND io.option_type(+)=7 -- sparse type
  AND io2.owning_objectid(+)=c.obj#
  AND io2.object_type(+)=1
  AND io2.option_type(+)=24 -- precompute percent
  AND io3.owning_objectid(+)=c.obj#
  AND io3.object_type(+)=1
  AND io3.option_type(+)=25 -- precompute percent top
  AND io4.owning_objectid(+)=c.obj#
  AND io4.object_type(+)=1
  AND io4.option_type(+)=9 -- partition level
  AND io4.option_num_value=hl.hierarchy_level_id(+)
  AND io5.owning_objectid(+)=c.obj#
  AND io5.object_type(+)=1
  AND io5.option_type(+)=30 -- refresh MV name
  AND io6.owning_objectid(+)=c.obj#
  AND io6.object_type(+)=1
  AND io6.option_type(+)=31 -- rewrite MV name
  AND io7.owning_objectid(+)=c.obj#
  AND io7.object_type(+)=1
  AND io7.option_type(+)=17 -- measure storage
  AND io8.owning_objectid(+)=c.obj#
  AND io8.object_type(+)=1
  AND io8.option_type(+)=20 -- cube storage type
  AND hl.hierarchy_id=h.hierarchy_id(+)
  AND hl.dim_level_id=dl.level_id(+)
  AND h.dim_obj#=od.obj#(+)
  and (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL));

   COMMENT ON COLUMN "SYS"."ALL_CUBES"."OWNER" IS 'Owner of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."CUBE_NAME" IS 'Name of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."CUBE_ID" IS 'Dictionary Id of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."AW_NAME" IS 'Name of the Analytic Workspace which owns the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."CONSISTENT_SOLVE_SPEC" IS 'The Consistent Solve Specification for the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."DESCRIPTION" IS 'Long Description of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."SPARSE_TYPE" IS 'Text value indicating type of sparsity for the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."PRECOMPUTE_CONDITION" IS 'Condition syntax representing precompute condition of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."PRECOMPUTE_PERCENT" IS 'Precompute percent of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."PRECOMPUTE_PERCENT_TOP" IS 'Top precompute percent of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."PARTITION_DIMENSION_NAME" IS 'Name of the Cube Dimension for which there is a partition on the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."PARTITION_HIERARCHY_NAME" IS 'Name of the Hierarchy for which there is a partition on the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."PARTITION_LEVEL_NAME" IS 'Name of the HierarchyLevel for which there is a partition on the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."REFRESH_MVIEW_NAME" IS 'Name of the refresh materialized view for the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."REWRITE_MVIEW_NAME" IS 'Name of the rewrite materialized view for the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."DEFAULT_BUILD_SPEC" IS 'The Default Build Specification for the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."MEASURE_STORAGE" IS 'The Measure Storage for the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."SQL_CUBE_STORAGE_TYPE" IS 'The SQL Cube Storage Type for the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBES"."CUBE_STORAGE_TYPE" IS 'The Cube Storage Type for the OLAP Cube';
   COMMENT ON TABLE "SYS"."ALL_CUBES"  IS 'OLAP Cubes in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_SUB_PARTITION_LEVELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_SUB_PARTITION_LEVELS" ("OWNER", "CUBE_NAME", "SUB_PARTITION_LEVEL_NAME", "PRECOMPUTE_PERCENT", "PARTITION_DIMENSION_NAME", "PARTITION_HIERARCHY_NAME", "PARTITION_LEVEL_NAME", "SUB_PARTITION_LEVEL_ORDER") AS 
  SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  io.option_value SUB_PARTITION_LEVEL_NAME,
  io2.option_num_value PRECOMPUTE_PERCENT,
  od.name PARTITION_DIMENSION_NAME,
  h.hierarchy_name PARTITION_HIERARCHY_NAME,
  dl.level_name PARTITION_LEVEL_NAME,
  1 SUB_PARTITION_LEVEL_ORDER
FROM
  olap_cubes$ c,
  obj$ o,
  olap_impl_options$ io,
  olap_impl_options$ io2,
  olap_impl_options$ io3,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_hierarchies$ h,
  obj$ od,
  user$ u,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
   FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      olap_dimensionality$ diml,
      olap_cube_dimensions$ dim,
      obj$ do
    WHERE
      do.obj# = dim.obj#
      AND diml.dimensioned_object_type = 1 --CUBE
      AND diml.dimensioned_object_id = c.obj#
      AND diml.dimension_type = 11 --DIMENSION
      AND diml.dimension_id = do.obj#
    )
    GROUP BY obj# ) da
WHERE
  o.obj#=c.obj#
  AND c.obj#=da.obj#(+)
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL))
  AND io.owning_objectid(+)=c.obj#
  AND io.object_type(+)=1 -- CUBE
  AND io.option_type(+) = 38 -- sub partition1 name
  AND io2.owning_objectid(+)=c.obj#
  AND io2.object_type(+)=1 -- CUBE
  AND io2.option_type(+) = 39 -- sub partition1 precompute percent
  AND io3.owning_objectid(+)=c.obj#
  AND io3.object_type(+)=1 --CUBE
  AND io3.option_type(+) = 37 -- sub partition level1
  AND io3.option_num_value=hl.hierarchy_level_id(+)
  AND hl.hierarchy_id=h.hierarchy_id
  AND hl.dim_level_id=dl.level_id
  AND h.dim_obj#=od.obj#
UNION ALL
SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  io.option_value SUB_PARTITION_LEVEL_NAME,
  io2.option_num_value PRECOMPUTE_PERCENT,
  od.name PARTITION_DIMENSION_NAME,
  h.hierarchy_name PARTITION_HIERARCHY_NAME,
  dl.level_name PARTITION_LEVEL_NAME,
  2 SUB_PARTITION_LEVEL_ORDER
FROM
  olap_cubes$ c,
  obj$ o,
  olap_impl_options$ io,
  olap_impl_options$ io2,
  olap_impl_options$ io3,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_hierarchies$ h,
  obj$ od,
  user$ u,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      olap_dimensionality$ diml,
      olap_cube_dimensions$ dim,
      obj$ do
    WHERE
      do.obj# = dim.obj#
      AND diml.dimensioned_object_type = 1 --CUBE
      AND diml.dimensioned_object_id = c.obj#
      AND diml.dimension_type = 11 --DIMENSION
      AND diml.dimension_id = do.obj#
    )
    GROUP BY obj# ) da
WHERE
  o.obj#=c.obj#
  AND c.obj#=da.obj#(+)
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL))
  AND io.owning_objectid(+)=c.obj#
  AND io.object_type(+)=1 -- CUBE
  AND io.option_type(+) = 41 -- sub partition2 name
  AND io2.owning_objectid(+)=c.obj#
  AND io2.object_type(+)=1 -- CUBE
  AND io2.option_type(+) = 42 -- sub partition2 precompute percent
  AND io3.owning_objectid(+)=c.obj#
  AND io3.object_type(+)=1 --CUBE
  AND io3.option_type(+) = 40 -- sub partition level2
  AND io3.option_num_value=hl.hierarchy_level_id(+)
  AND hl.hierarchy_id=h.hierarchy_id
  AND hl.dim_level_id=dl.level_id
  AND h.dim_obj#=od.obj#
UNION ALL
SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  io.option_value SUB_PARTITION_LEVEL_NAME,
  io2.option_num_value PRECOMPUTE_PERCENT,
  od.name PARTITION_DIMENSION_NAME,
  h.hierarchy_name PARTITION_HIERARCHY_NAME,
  dl.level_name PARTITION_LEVEL_NAME,
  3 SUB_PARTITION_LEVEL_ORDER
FROM
  olap_cubes$ c,
  obj$ o,
  olap_impl_options$ io,
  olap_impl_options$ io2,
  olap_impl_options$ io3,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_hierarchies$ h,
  obj$ od,
  user$ u,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
   FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      olap_dimensionality$ diml,
      olap_cube_dimensions$ dim,
      obj$ do
    WHERE
      do.obj# = dim.obj#
      AND diml.dimensioned_object_type = 1 --CUBE
      AND diml.dimensioned_object_id = c.obj#
      AND diml.dimension_type = 11 --DIMENSION
      AND diml.dimension_id = do.obj#
    )
    GROUP BY obj# ) da
WHERE
  o.obj#=c.obj#
  AND c.obj#=da.obj#(+)
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL))
  AND io.owning_objectid(+)=c.obj#
  AND io.object_type(+)=1 -- CUBE
  AND io.option_type(+) = 44 -- sub partition3 name
  AND io2.owning_objectid(+)=c.obj#
  AND io2.object_type(+)=1 -- CUBE
  AND io2.option_type(+) = 45 -- sub partition3 precompute percent
  AND io3.owning_objectid(+)=c.obj#
  AND io3.object_type(+)=1 --CUBE
  AND io3.option_type(+) = 43 -- sub partition level3
  AND io3.option_num_value=hl.hierarchy_level_id(+)
  AND hl.hierarchy_id=h.hierarchy_id
  AND hl.dim_level_id=dl.level_id
  AND h.dim_obj#=od.obj#
UNION ALL
SELECT
  u.name OWNER,
  o.name CUBE_NAME,
  mo.option_value SUB_PARTITION_LEVEL_NAME,
  mo2.option_num_value PRECOMPUTE_PERCENT,
  od.name PARTITION_DIMENSION_NAME,
  h.hierarchy_name PARTITION_HIERARCHY_NAME,
  dl.level_name PARTITION_LEVEL_NAME,
  mo.OPTION_ORDER + 1 SUB_PARTITION_LEVEL_ORDER
FROM
  olap_cubes$ c,
  obj$ o,
  olap_multi_options$ mo,
  olap_multi_options$ mo2,
  olap_multi_options$ mo3,
  olap_hier_levels$ hl,
  olap_dim_levels$ dl,
  olap_hierarchies$ h,
  obj$ od,
  user$ u,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
   FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      olap_dimensionality$ diml,
      olap_cube_dimensions$ dim,
      obj$ do
    WHERE
      do.obj# = dim.obj#
      AND diml.dimensioned_object_type = 1 --CUBE
      AND diml.dimensioned_object_id = c.obj#
      AND diml.dimension_type = 11 --DIMENSION
      AND diml.dimension_id = do.obj#
    )
    GROUP BY obj# ) da
WHERE
  o.obj#=c.obj#
  AND c.obj#=da.obj#(+)
  AND o.owner# = u.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL))
  AND mo.owning_objectid(+)=c.obj#
  AND mo.object_type(+)=1 -- CUBE
  AND mo.option_type(+) = 5 -- sub partition name
  AND mo2.owning_objectid(+)=c.obj#
  AND mo2.object_type=1 -- CUBE
  AND mo2.option_type = 6 -- sub partition precompute percent
  AND mo3.owning_objectid=c.obj#
  AND mo3.object_type(+)=1 --CUBE
  AND mo3.option_type(+) = 4 -- sub partition level
  AND mo.OPTION_ORDER = mo2.OPTION_ORDER
  AND mo2.OPTION_ORDER = mo3.OPTION_ORDER
  AND mo3.option_num_value=hl.hierarchy_level_id
  AND hl.hierarchy_id=h.hierarchy_id
  AND hl.dim_level_id=dl.level_id
  AND h.dim_obj#=od.obj#;

   COMMENT ON COLUMN "SYS"."ALL_CUBE_SUB_PARTITION_LEVELS"."CUBE_NAME" IS 'Name of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_SUB_PARTITION_LEVELS"."SUB_PARTITION_LEVEL_NAME" IS 'Name of the secondary partition level of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_SUB_PARTITION_LEVELS"."PRECOMPUTE_PERCENT" IS 'Precompute percent of the secondary partition level of the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_SUB_PARTITION_LEVELS"."PARTITION_DIMENSION_NAME" IS 'Name of the Cube Dimension for which there is a secondary partition level on the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_SUB_PARTITION_LEVELS"."PARTITION_HIERARCHY_NAME" IS 'Name of the Hierarchy for which there is a secondary partition level on the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_SUB_PARTITION_LEVELS"."PARTITION_LEVEL_NAME" IS 'Name of the HierarchyLevel for which there is a secondary partition level on the OLAP Cube';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_SUB_PARTITION_LEVELS"."SUB_PARTITION_LEVEL_ORDER" IS 'Order number of the secondary partition level on the OLAP cube'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_VIEW_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_VIEW_COLUMNS" ("OWNER", "CUBE_NAME", "VIEW_NAME", "COLUMN_NAME", "COLUMN_TYPE", "OBJECT_NAME") AS 
  SELECT OWNER, CUBE_NAME, VIEW_NAME, COLUMN_NAME, COLUMN_TYPE, OBJECT_NAME
FROM
(SELECT
  co.obj# obj#,
  co.owner# owner#,
  co.type# type#,
  cu.name OWNER,
  co.name CUBE_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  'MEASURE' COLUMN_TYPE,
  m.measure_name OBJECT_NAME -- name of measure
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  olap_measures$ m,
  col$ col,
  obj$ co,
  user$ cu,
  obj$ vo
WHERE
  av.olap_object_type = 1 -- CUBE
  AND av.olap_object_id = co.obj#
  AND av.view_type = 1 -- ET
  AND co.owner# = cu.user#
  AND av.view_obj# = avc.view_obj#
  AND avc.column_type = 1 -- OBJECT
  AND avc.referenced_object_type = 2 -- MEASURE
  AND avc.referenced_object_id = m.measure_id
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND avc.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=co.owner#
  AND (co.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or co.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privilages
              ora_check_SYS_privilege (co.owner#, co.type#) = 1
            )
UNION ALL
SELECT -- dimensioned by dimension
  co.obj# obj#,
  co.owner# owner#,
  co.type# type#,
  cu.name OWNER,
  co.name CUBE_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  'KEY' COLUMN_TYPE,
  do.name OBJECT_NAME -- name of dimension
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  col$ col,
  obj$ co,
  user$ cu,
  obj$ vo,
  obj$ do,
  olap_dimensionality$ d
WHERE
  av.olap_object_type = 1 -- CUBE
  AND av.olap_object_id = co.obj#
  AND av.view_type = 1 -- ET
  AND co.owner# = cu.user#
  AND av.view_obj# = avc.view_obj#
  AND avc.column_type = 2 -- KEY
  AND avc.referenced_object_type = 16 -- DIMENSIONALITY
  AND avc.referenced_object_id = d.dimensionality_id
  AND d.dimension_type = 11 -- DIMENSION
  AND d.dimension_id = do.obj#
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND avc.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=co.owner#
  AND (co.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or co.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privilages
              ora_check_SYS_privilege (co.owner#, co.type#) = 1
            )
UNION ALL
SELECT -- dimensioned by dimension level
  co.obj# obj#,
  co.owner# owner#,
  co.type# type#,
  cu.name OWNER,
  co.name CUBE_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  'KEY' COLUMN_TYPE,
  do.name OBJECT_NAME -- name of dimension
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  col$ col,
  obj$ co,
  user$ cu,
  obj$ vo,
  obj$ do,
  olap_dimensionality$ d,
  olap_dim_levels$ dl
WHERE
  av.olap_object_type = 1 -- CUBE
  AND av.olap_object_id = co.obj#
  AND av.view_type = 1 -- ET
  AND co.owner# = cu.user#
  AND av.view_obj# = avc.view_obj#
  AND avc.column_type = 2 -- KEY
  AND avc.referenced_object_type = 16 -- DIMENSIONALITY
  AND avc.referenced_object_id = d.dimensionality_id
  AND d.dimension_type = 12 -- DIM_LEVEL
  AND d.dimension_id = dl.level_id
  AND dl.dim_obj# = do.obj#
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND avc.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=co.owner#
  AND (co.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or co.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privilages
              ora_check_SYS_privilege (co.owner#, co.type#) = 1
            )
UNION ALL
SELECT -- dimensioned by hierarchy
  co.obj# obj#,
  co.owner# owner#,
  co.type# type#,
  cu.name OWNER,
  co.name CUBE_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  'KEY' COLUMN_TYPE,
  do.name OBJECT_NAME -- name of dimension
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  col$ col,
  obj$ co,
  user$ cu,
  obj$ vo,
  obj$ do,
  olap_dimensionality$ d,
  olap_hierarchies$ h
WHERE
  av.olap_object_type = 1 -- CUBE
  AND av.olap_object_id = co.obj#
  AND av.view_type = 1 -- ET
  AND co.owner# = cu.user#
  AND av.view_obj# = avc.view_obj#
  AND avc.column_type = 2 -- KEY
  AND avc.referenced_object_type = 16 -- DIMENSIONALITY
  AND avc.referenced_object_id = d.dimensionality_id
  AND d.dimension_type = 13 -- HIERARCHY
  AND d.dimension_id = h.hierarchy_id
  AND h.dim_obj# = do.obj#
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND avc.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=co.owner#
  AND (co.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or co.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privilages
              ora_check_SYS_privilege (co.owner#, co.type#) = 1
            )
UNION ALL
SELECT -- dimensioned by hierarchy level
  co.obj# obj#,
  co.owner# owner#,
  co.type# type#,
  cu.name OWNER,
  co.name CUBE_NAME,
  vo.name VIEW_NAME,
  col.name COLUMN_NAME,
  'KEY' COLUMN_TYPE,
  do.name OBJECT_NAME -- name of dimension
FROM
  olap_aw_view_columns$ avc,
  olap_aw_views$ av,
  col$ col,
  obj$ co,
  user$ cu,
  obj$ vo,
  obj$ do,
  olap_dimensionality$ d,
  olap_hierarchies$ h,
  olap_hier_levels$ hl
WHERE
  av.olap_object_type = 1 -- CUBE
  AND av.olap_object_id = co.obj#
  AND av.view_type = 1 -- ET
  AND co.owner# = cu.user#
  AND av.view_obj# = avc.view_obj#
  AND avc.column_type = 2 -- KEY
  AND avc.referenced_object_type = 16 -- DIMENSIONALITY
  AND avc.referenced_object_id = d.dimensionality_id
  AND d.dimension_type = 14 -- HIER_LEVEL
  AND d.dimension_id = hl.hierarchy_level_id
  AND hl.hierarchy_id = h.hierarchy_id
  AND h.dim_obj# = do.obj#
  AND avc.view_obj# = col.obj#
  AND avc.column_obj# = col.col#
  AND avc.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=co.owner#
  AND (co.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or co.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privilages
              ora_check_SYS_privilege (co.owner#, co.type#) = 1
            )
) u,
 (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE u.obj#=da.obj#(+)
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL)
         or   -- user has system privileges
                ora_check_SYS_privilege (owner#, type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEW_COLUMNS"."OWNER" IS 'Owner of the OLAP Cube View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEW_COLUMNS"."CUBE_NAME" IS 'Name of owning cube of the OLAP Cube View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEW_COLUMNS"."VIEW_NAME" IS 'View Name of the OLAP Cube View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEW_COLUMNS"."COLUMN_NAME" IS 'Name of the OLAP Cube View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEW_COLUMNS"."COLUMN_TYPE" IS 'View Type of the OLAP Cube View Column';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEW_COLUMNS"."OBJECT_NAME" IS 'Name of Measure of the OLAP Cube View Column';
   COMMENT ON TABLE "SYS"."ALL_CUBE_VIEW_COLUMNS"  IS 'OLAP Cube View Columns in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_CUBE_VIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_CUBE_VIEWS" ("OWNER", "CUBE_NAME", "VIEW_NAME") AS 
  SELECT
  cu.name OWNER,
  co.name CUBE_NAME,
  vo.name VIEW_NAME
FROM
  olap_aw_views$ av,
  obj$ co,
  user$ cu,
  obj$ vo,
 (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  av.olap_object_type = 1 -- CUBE
  AND av.olap_object_id=co.obj#
  AND co.obj#=da.obj#(+)
  AND av.view_type = 1 -- ET
  AND co.owner#=cu.user#
  AND av.view_obj#=vo.obj#
  AND vo.type# != 10 -- not NON-EXISTENT
  AND vo.owner#=cu.user#
  AND (co.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or co.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privilages
              ora_check_SYS_privilege (co.owner#, co.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL));

   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEWS"."OWNER" IS 'Owner of the OLAP Cube View';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEWS"."CUBE_NAME" IS 'Name of owning cube of the OLAP Cube View';
   COMMENT ON COLUMN "SYS"."ALL_CUBE_VIEWS"."VIEW_NAME" IS 'View Name of the OLAP Cube View';
   COMMENT ON TABLE "SYS"."ALL_CUBE_VIEWS"  IS 'OLAP Cube Views in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_DB_LINKS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DB_LINKS" ("OWNER", "DB_LINK", "USERNAME", "HOST", "CREATED", "HIDDEN", "SHARD_INTERNAL", "VALID") AS 
  select u.name, l.name, l.userid, l.host, l.ctime,
       decode(bitand(l.flag, 4), 4, 'YES', 'NO'),
       decode(bitand(l.flag, 8), 8, 'YES', 'NO'),
       decode(bitand(l.flag, 16), 16, 'NO', 'YES')
from sys.link$ l, sys.user$ u
where l.owner# in ( select kzsrorol from x$kzsro )
  and l.owner# = u.user#;

   COMMENT ON COLUMN "SYS"."ALL_DB_LINKS"."DB_LINK" IS 'Name of the database link';
   COMMENT ON COLUMN "SYS"."ALL_DB_LINKS"."USERNAME" IS 'Name of user to log on as';
   COMMENT ON COLUMN "SYS"."ALL_DB_LINKS"."HOST" IS 'SQL*Net string for connect';
   COMMENT ON COLUMN "SYS"."ALL_DB_LINKS"."CREATED" IS 'Creation time of the database link';
   COMMENT ON COLUMN "SYS"."ALL_DB_LINKS"."HIDDEN" IS 'Whether database link is hidden or not';
   COMMENT ON COLUMN "SYS"."ALL_DB_LINKS"."SHARD_INTERNAL" IS 'Whether database link is internally managed for sharding';
   COMMENT ON COLUMN "SYS"."ALL_DB_LINKS"."VALID" IS 'Whether database link is usable or not';
   COMMENT ON TABLE "SYS"."ALL_DB_LINKS"  IS 'Database links accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_DEF_AUDIT_OPTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DEF_AUDIT_OPTS" ("ALT", "AUD", "COM", "DEL", "GRA", "IND", "INS", "LOC", "REN", "SEL", "UPD", "REF", "EXE", "FBK", "REA") AS 
  select substr(t.audit$, 1, 1) || '/' || substr(t.audit$, 2, 1),
       substr(t.audit$, 3, 1) || '/' || substr(t.audit$, 4, 1),
       substr(t.audit$, 5, 1) || '/' || substr(t.audit$, 6, 1),
       substr(t.audit$, 7, 1) || '/' || substr(t.audit$, 8, 1),
       substr(t.audit$, 9, 1) || '/' || substr(t.audit$, 10, 1),
       substr(t.audit$, 11, 1) || '/' || substr(t.audit$, 12, 1),
       substr(t.audit$, 13, 1) || '/' || substr(t.audit$, 14, 1),
       substr(t.audit$, 15, 1) || '/' || substr(t.audit$, 16, 1),
       substr(t.audit$, 17, 1) || '/' || substr(t.audit$, 18, 1),
       substr(t.audit$, 19, 1) || '/' || substr(t.audit$, 20, 1),
       substr(t.audit$, 21, 1) || '/' || substr(t.audit$, 22, 1),
       '-/-',                                            /* dummy REF column */
       substr(t.audit$, 25, 1) || '/' || substr(t.audit$, 26, 1),
       substr(t.audit$, 23, 1) || '/' || substr(t.audit$, 24, 1),
       substr(t.audit$, 29, 1) || '/' || substr(t.audit$, 30, 1)
from sys.obj$ o, sys.tab$ t
where o.obj# = t.obj#
  and o.owner# = 0
  and o.name = '_default_auditing_options_';

   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."ALT" IS 'Auditing ALTER WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."AUD" IS 'Auditing AUDIT WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."COM" IS 'Auditing COMMENT WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."DEL" IS 'Auditing DELETE WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."GRA" IS 'Auditing GRANT WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."IND" IS 'Auditing INDEX WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."INS" IS 'Auditing INSERT WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."LOC" IS 'Auditing LOCK WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."REN" IS 'Auditing RENAME WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."SEL" IS 'Auditing SELECT WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."UPD" IS 'Auditing UPDATE WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."REF" IS 'Dummy REF column. Maintained for backward compatibility of the view';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."EXE" IS 'Auditing EXECUTE WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."FBK" IS 'Auditing FLASHBACK WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON COLUMN "SYS"."ALL_DEF_AUDIT_OPTS"."REA" IS 'Auditing READ WHENEVER SUCCESSFUL / UNSUCCESSFUL';
   COMMENT ON TABLE "SYS"."ALL_DEF_AUDIT_OPTS"  IS 'Auditing options for newly created objects'
;
--------------------------------------------------------
--  DDL for View ALL_DEPENDENCIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DEPENDENCIES" ("OWNER", "NAME", "TYPE", "REFERENCED_OWNER", "REFERENCED_NAME", "REFERENCED_TYPE", "REFERENCED_LINK_NAME", "DEPENDENCY_TYPE") AS 
  select u.name, o.name,
       decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE', 7, 'PROCEDURE',
                      8, 'FUNCTION', 9, 'PACKAGE', 10, 'NON-EXISTENT',
                      11, 'PACKAGE BODY', 12, 'TRIGGER',
                      13, 'TYPE', 14, 'TYPE BODY', 22, 'LIBRARY',
                      23, 'DIRECTORY',
                      28, 'JAVA SOURCE', 29, 'JAVA CLASS',
                      32, 'INDEXTYPE', 33, 'OPERATOR',
                      42, 'MATERIALIZED VIEW', 43, 'DIMENSION',
                      46, 'RULE SET', 55, 'XML SCHEMA', 56, 'JAVA DATA',
                      59, 'RULE', 62, 'EVALUATION CONTXT', 87, 'ASSEMBLY',
                      90, 'CREDENTIAL',
                      92, 'CUBE DIMENSION', 93, 'CUBE',
                      94, 'MEASURE FOLDER', 95, 'CUBE BUILD PROCESS',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW',
                      'UNDEFINED'),
       decode(po.linkname, null, pu.name, po.remoteowner), po.name,
       decode(po.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE', 7, 'PROCEDURE',
                      8, 'FUNCTION', 9, 'PACKAGE', 10, 'NON-EXISTENT',
                      11, 'PACKAGE BODY', 12, 'TRIGGER',
                      13, 'TYPE', 14, 'TYPE BODY', 22, 'LIBRARY',
                      23, 'DIRECTORY',
                      28, 'JAVA SOURCE', 29, 'JAVA CLASS',
                      32, 'INDEXTYPE', 33, 'OPERATOR',
                      42, 'MATERIALIZED VIEW', 43, 'DIMENSION',
                      46, 'RULE SET', 55, 'XML SCHEMA', 56, 'JAVA DATA',
                      59, 'RULE', 62, 'EVALUATION CONTXT', 87, 'ASSEMBLY',
                      90, 'CREDENTIAL',
                      92, 'CUBE DIMENSION', 93, 'CUBE',
                      94, 'MEASURE FOLDER', 95, 'CUBE BUILD PROCESS',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW',
                      'UNDEFINED'),
       po.linkname,
       decode(bitand(d.property, 3), 2, 'REF', 'HARD')
from sys."_CURRENT_EDITION_OBJ" o, sys.disk_and_fixed_objects po, sys.dependency$ d, sys.user$ u,
  sys.user$ pu
where o.obj# = d.d_obj#
  and o.owner# = u.user#
  and po.obj# = d.p_obj#
  and po.owner# = pu.user#
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
         (
          (o.type# = 7 or o.type# = 8 or o.type# = 9 or
           o.type# = 28 or o.type# = 29 or o.type# = 56)
          and
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        (
          o.type# = 4
          and
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (3 /* DELETE */,   6 /* INSERT */,
                                                7 /* LOCK */,     9 /* SELECT */,
                                          10 /* UPDATE */, 17 /* READ */))
        )
        or
        (
          o.type# = 2
          and
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (0 /* ALTER */, 3 /* DELETE */,
                                          6 /* INSERT */, 7 /* LOCK */,
                                          9 /* SELECT */, 10 /* UPDATE */,
                                          17 /* READ */))
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (o.type# = 7 or o.type# = 8 or o.type# = 9 or
               o.type# = 28 or o.type# = 29 or o.type# = 56)
              and
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
            or
            (
              /* trigger */
              o.type# = 12 and
              privilege# = -152 /* CREATE ANY TRIGGER */
            )
            or
            (
              /* package body */
              o.type# = 11 and
              privilege# = -141 /* CREATE ANY PROCEDURE */
            )
            or
            (
              /* view */
              o.type# = 4
              and
              (
                privilege# in     ( -91 /* CREATE ANY VIEW */,
                                    -45 /* LOCK ANY TABLE */,
                                    -47 /* SELECT ANY TABLE */,
                                    -397/* READ ANY TABLE */,
                                    -48 /* INSERT ANY TABLE */,
                                    -49 /* UPDATE ANY TABLE */,
                                    -50 /* DELETE ANY TABLE */)
              )
            )
            or
            (
              /* table */
              o.type# = 2
              and
              (
                privilege# in     ( -41 /* CREATE ANY TABLE */,
                                    -42 /* ALTER ANY TABLE */,
                                    -45 /* LOCK ANY TABLE */,
                                    -47 /* SELECT ANY TABLE */,
                                    -397/* READ ANY TABLE */,
                                    -48 /* INSERT ANY TABLE */,
                                    -49 /* UPDATE ANY TABLE */,
                                    -50 /* DELETE ANY TABLE */)
              )
            )
            or
            (
              /* synonym */
              o.type# = 5 and
              privilege# = -81 /* CREATE ANY SYNONYM */
            )
            or
            (
              /* type */
              o.type# = 13
              and
              (
                privilege# = -184 /* EXECUTE ANY TYPE */
                or
                privilege# = -181 /* CREATE ANY TYPE */
              )
            )
            or
            (
              /* type body */
              o.type# = 14 and
              privilege# = -181 /* CREATE ANY TYPE */
            )
          )
        )
      )
    )
    /* don't worry about sequences since they cannot depend on anything */
  );

   COMMENT ON COLUMN "SYS"."ALL_DEPENDENCIES"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_DEPENDENCIES"."NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_DEPENDENCIES"."TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_DEPENDENCIES"."REFERENCED_OWNER" IS 'Owner of referenced object (remote owner if remote object)';
   COMMENT ON COLUMN "SYS"."ALL_DEPENDENCIES"."REFERENCED_NAME" IS 'Name of referenced object';
   COMMENT ON COLUMN "SYS"."ALL_DEPENDENCIES"."REFERENCED_TYPE" IS 'Type of referenced object';
   COMMENT ON COLUMN "SYS"."ALL_DEPENDENCIES"."REFERENCED_LINK_NAME" IS 'Name of dblink if this is a remote object';
   COMMENT ON TABLE "SYS"."ALL_DEPENDENCIES"  IS 'Dependencies to and from objects accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_DEQUEUE_QUEUES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DEQUEUE_QUEUES" ("OWNER", "NAME", "QUEUE_TABLE", "QID", "QUEUE_TYPE", "MAX_RETRIES", "RETRY_DELAY", "ENQUEUE_ENABLED", "DEQUEUE_ENABLED", "RETENTION", "USER_COMMENT", "NETWORK_NAME", "SHARDED") AS 
  select u.name OWNER, q.name NAME, t.name QUEUE_TABLE, q.eventid QID,
       decode(q.usage, 1, 'EXCEPTION_QUEUE', 2, 'NON_PERSISTENT_QUEUE',
              'NORMAL_QUEUE') QUEUE_TYPE,
       q.max_retries MAX_RETRIES, q.retry_delay RETRY_DELAY,
       decode(bitand(q.enable_flag, 1), 1 , '  YES  ', '  NO  ')ENQUEUE_ENABLED,
       decode(bitand(q.enable_flag, 2), 2 , '  YES  ', '  NO  ')DEQUEUE_ENABLED,
       decode(q.ret_time, -1, ' FOREVER', q.ret_time) RETENTION,
       substrb(q.queue_comment, 1, 50) USER_COMMENT,
       s.network_name NETWORK_NAME,
       decode(q.sharded, 1, 'TRUE', 'FALSE') SHARDED
from system.aq$_queues q, system.aq$_queue_tables t, sys.user$ u, sys.obj$ ro,
dba_services s
where u.name  = t.schema
and   q.table_objno = t.objno
and   ro.owner# = u.user#
and   ro.obj# = q.eventid
and  (ro.owner# = userenv('SCHEMAID')
      or ro.obj# in
           (select oa.obj#
            from sys.objauth$ oa
            where oa.privilege# in (21, 41) and
                  grantee# in (select kzsrorol from x$kzsro))
      or ((ro.owner# !=0) and exists (select null from v$enabledprivs
                 where priv_number in (-218 /* MANAGE ANY QUEUE */,
                                       -220 /* DEQUEUE ANY QUEUE */)))
      or ro.obj# in
           (select q.eventid from system.aq$_queues q,
                                  system.aq$_queue_tables t
              where q.table_objno = t.objno
              and bitand(t.flags, 8) = 0
              and exists (select null from sys.objauth$ oa, sys.obj$ o
                          where oa.obj# = o.obj#
                          and (o.name = 'DBMS_AQ' or o.name = 'DBMS_AQADM')
                          and o.owner# = 0
                          and o.type# = 9
                          and oa.grantee# = userenv('SCHEMAID')))
     )
and   q.service_name = s.name (+);

   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."OWNER" IS 'Owner of the queue';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."NAME" IS 'Name of the queue';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."QUEUE_TABLE" IS 'Name of the table the queue data resides in';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."QID" IS 'Object number of the queue';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."QUEUE_TYPE" IS 'Type of the queue';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."MAX_RETRIES" IS 'Maximum number of retries allowed when dequeuing from the queue';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."RETRY_DELAY" IS 'Time interval between retries';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."ENQUEUE_ENABLED" IS 'Queue is enabled for enqueue';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."DEQUEUE_ENABLED" IS 'Queue is enabled for dequeue';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."RETENTION" IS 'Time interval processed messages retained in the queue';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."USER_COMMENT" IS 'User specified comment';
   COMMENT ON COLUMN "SYS"."ALL_DEQUEUE_QUEUES"."NETWORK_NAME" IS 'Network name of queue service';
   COMMENT ON TABLE "SYS"."ALL_DEQUEUE_QUEUES"  IS 'All queues accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_DIM_ATTRIBUTES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DIM_ATTRIBUTES" ("OWNER", "DIMENSION_NAME", "ATTRIBUTE_NAME", "LEVEL_NAME", "COLUMN_NAME", "INFERRED") AS 
  select u.name, o.name, da.attname, dl.levelname, c.name, 'N'
from sys.dimattr$ da, sys.obj$ o, sys.user$ u, sys.dimlevel$ dl, sys.col$ c
where da.dimobj# = o.obj#
  and o.owner# = u.user#
  and da.dimobj# = dl.dimobj#
  and da.levelid# = dl.levelid#
  and da.detailobj# = c.obj#
  and da.col# = c.intcol#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_DIM_ATTRIBUTES"."OWNER" IS 'Owner of the dimentsion';
   COMMENT ON COLUMN "SYS"."ALL_DIM_ATTRIBUTES"."DIMENSION_NAME" IS 'Name of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_ATTRIBUTES"."ATTRIBUTE_NAME" IS 'Name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_DIM_ATTRIBUTES"."LEVEL_NAME" IS 'Name of the hierarchy level';
   COMMENT ON COLUMN "SYS"."ALL_DIM_ATTRIBUTES"."COLUMN_NAME" IS 'Name of the dependent column';
   COMMENT ON COLUMN "SYS"."ALL_DIM_ATTRIBUTES"."INFERRED" IS 'Whether this attribute is inferred from a JOIN KEY specification';
   COMMENT ON TABLE "SYS"."ALL_DIM_ATTRIBUTES"  IS 'Representation of the relationship between a dimension level and
 a functionally dependent column'
;
--------------------------------------------------------
--  DDL for View ALL_DIM_CHILD_OF
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DIM_CHILD_OF" ("OWNER", "DIMENSION_NAME", "HIERARCHY_NAME", "POSITION", "CHILD_LEVEL_NAME", "JOIN_KEY_ID", "PARENT_LEVEL_NAME") AS 
  select d."OWNER",d."DIMENSION_NAME",d."HIERARCHY_NAME",d."POSITION",d."CHILD_LEVEL_NAME",d."JOIN_KEY_ID",d."PARENT_LEVEL_NAME" from dba_dim_child_of d, sys.obj$ o, sys.user$ u
where o.owner#         = u.user#
  and d.dimension_name = o.name
  and d.owner          = u.name
  and o.type#          = 43                     /* dimension */
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_DIM_CHILD_OF"."OWNER" IS 'Owner of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_CHILD_OF"."DIMENSION_NAME" IS 'Name of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_CHILD_OF"."HIERARCHY_NAME" IS 'Name of the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_DIM_CHILD_OF"."POSITION" IS 'Hierarchical position within this hierarchy, position 1 being
 the most detailed';
   COMMENT ON COLUMN "SYS"."ALL_DIM_CHILD_OF"."CHILD_LEVEL_NAME" IS 'Name of the child-side level of this 1:n relationship';
   COMMENT ON COLUMN "SYS"."ALL_DIM_CHILD_OF"."JOIN_KEY_ID" IS 'Keys that join child to the parent';
   COMMENT ON COLUMN "SYS"."ALL_DIM_CHILD_OF"."PARENT_LEVEL_NAME" IS 'Name of the parent-side level of this 1:n relationship';
   COMMENT ON TABLE "SYS"."ALL_DIM_CHILD_OF"  IS 'Representaion of a 1:n hierarchical relationship between a pair of levels in
 a dimension'
;
--------------------------------------------------------
--  DDL for View ALL_DIMENSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DIMENSIONS" ("OWNER", "DIMENSION_NAME", "INVALID", "COMPILE_STATE", "REVISION") AS 
  select u.name, o.name,
       decode(o.status, 5, 'Y', 'N'),
       decode(o.status, 1, 'VALID', 5, 'NEEDS_COMPILE', 'ERROR'),
       1                  /* Metadata revision number */
from sys.dim$ d, sys.obj$ o, sys.user$ u
where o.owner# = u.user#
  and o.obj# = d.obj#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_DIMENSIONS"."OWNER" IS 'Owner of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIMENSIONS"."DIMENSION_NAME" IS 'Name of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIMENSIONS"."INVALID" IS 'Invalidity of the dimension, Y = INVALID, N = VALID.
 The column is deprecated, please use COMPILE_STATE instead.';
   COMMENT ON COLUMN "SYS"."ALL_DIMENSIONS"."COMPILE_STATE" IS 'Compile status of the dimension, VALID/NEEDS_COMPILE/ERROR';
   COMMENT ON COLUMN "SYS"."ALL_DIMENSIONS"."REVISION" IS 'Revision levle of the dimension';
   COMMENT ON TABLE "SYS"."ALL_DIMENSIONS"  IS 'Description of the dimension objects accessible to the DBA'
;
--------------------------------------------------------
--  DDL for View ALL_DIM_HIERARCHIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DIM_HIERARCHIES" ("OWNER", "DIMENSION_NAME", "HIERARCHY_NAME") AS 
  select u.name, o.name, h.hiername
from sys.hier$ h, sys.obj$ o, sys.user$ u
where h.dimobj# = o.obj#
  and o.owner# = u.user#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_DIM_HIERARCHIES"."OWNER" IS 'Owner of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_HIERARCHIES"."DIMENSION_NAME" IS 'Name of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_HIERARCHIES"."HIERARCHY_NAME" IS 'Name of the hierarchy';
   COMMENT ON TABLE "SYS"."ALL_DIM_HIERARCHIES"  IS 'Representation of a dimension hierarchy'
;
--------------------------------------------------------
--  DDL for View ALL_DIM_JOIN_KEY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DIM_JOIN_KEY" ("OWNER", "DIMENSION_NAME", "DIM_KEY_ID", "LEVEL_NAME", "KEY_POSITION", "HIERARCHY_NAME", "CHILD_JOIN_OWNER", "CHILD_JOIN_TABLE", "CHILD_JOIN_COLUMN", "CHILD_LEVEL_NAME") AS 
  select d."OWNER",d."DIMENSION_NAME",d."DIM_KEY_ID",d."LEVEL_NAME",d."KEY_POSITION",d."HIERARCHY_NAME",d."CHILD_JOIN_OWNER",d."CHILD_JOIN_TABLE",d."CHILD_JOIN_COLUMN",d."CHILD_LEVEL_NAME" from dba_dim_join_key d, sys.obj$ o, sys.user$ u
where o.owner#         = u.user#
  and d.dimension_name = o.name
  and d.owner          = u.name
  and o.type#          = 43                     /* dimension */
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."OWNER" IS 'Owner of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."DIMENSION_NAME" IS 'Name of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."DIM_KEY_ID" IS 'Join key ID (unique within a dimension)';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."LEVEL_NAME" IS 'Name of the hierarchy level';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."KEY_POSITION" IS 'Position of the key column within the level';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."HIERARCHY_NAME" IS 'Name of the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."CHILD_JOIN_OWNER" IS 'Owner of the join column table';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."CHILD_JOIN_TABLE" IS 'Name of the join column table';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."CHILD_JOIN_COLUMN" IS 'Name of the join column';
   COMMENT ON COLUMN "SYS"."ALL_DIM_JOIN_KEY"."CHILD_LEVEL_NAME" IS 'Name of the child hierarchy level of the join key';
   COMMENT ON TABLE "SYS"."ALL_DIM_JOIN_KEY"  IS 'Representation of a join between two dimension tables. '
;
--------------------------------------------------------
--  DDL for View ALL_DIM_LEVEL_KEY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DIM_LEVEL_KEY" ("OWNER", "DIMENSION_NAME", "LEVEL_NAME", "KEY_POSITION", "COLUMN_NAME") AS 
  select u.name, o.name, dl.levelname, dlk.keypos#, c.name
from sys.dimlevelkey$ dlk, sys.obj$ o, sys.user$ u, sys.dimlevel$ dl,
     sys.col$ c
where dlk.dimobj# = o.obj#
  and o.owner# = u.user#
  and dlk.dimobj# = dl.dimobj#
  and dlk.levelid# = dl.levelid#
  and dlk.detailobj# = c.obj#
  and dlk.col# = c.intcol#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVEL_KEY"."OWNER" IS 'Owner of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVEL_KEY"."DIMENSION_NAME" IS 'Name of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVEL_KEY"."LEVEL_NAME" IS 'Name of the hierarchy level';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVEL_KEY"."KEY_POSITION" IS 'Ordinal position of the key column within the level';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVEL_KEY"."COLUMN_NAME" IS 'Name of the key column';
   COMMENT ON TABLE "SYS"."ALL_DIM_LEVEL_KEY"  IS 'Representations of columns of a dimension level'
;
--------------------------------------------------------
--  DDL for View ALL_DIM_LEVELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DIM_LEVELS" ("OWNER", "DIMENSION_NAME", "LEVEL_NAME", "NUM_COLUMNS", "DETAILOBJ_OWNER", "DETAILOBJ_NAME", "SKIP_WHEN_NULL") AS 
  select u.name, o.name, dl.levelname,
       temp.num_col,
       u1.name, o1.name, decode (dl.flags, 1, 'Y', 'N')
from (select dlk.dimobj#, dlk.levelid#, dlk.detailobj#,
             COUNT(*) as num_col
      from sys.dimlevelkey$ dlk
      group by dlk.dimobj#, dlk.levelid#, dlk.detailobj#) temp,
      sys.dimlevel$ dl, sys.obj$ o, sys.user$ u,
      sys.obj$ o1, sys.user$ u1
where dl.dimobj# = o.obj#   and
      o.owner# = u.user#    and
      dl.dimobj# = temp.dimobj# and
      dl.levelid# = temp.levelid# and
      temp.detailobj# = o1.obj# and
      o1.owner# = u1.user# and
      (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVELS"."OWNER" IS 'Owner of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVELS"."DIMENSION_NAME" IS 'Name of the dimension';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVELS"."LEVEL_NAME" IS 'Name of the dimension level (unique within a dimension)';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVELS"."NUM_COLUMNS" IS 'Number of columns in the level definition';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVELS"."DETAILOBJ_OWNER" IS 'Owner of the detail object that the keys of this level come from';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVELS"."DETAILOBJ_NAME" IS 'Name of the table that the keys of this level come from';
   COMMENT ON COLUMN "SYS"."ALL_DIM_LEVELS"."SKIP_WHEN_NULL" IS 'Is the level declared with SKIP WHEN NULL clause? (Y/N)';
   COMMENT ON TABLE "SYS"."ALL_DIM_LEVELS"  IS 'Description of dimension levels visible to DBA'
;
--------------------------------------------------------
--  DDL for View ALL_DIRECTORIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_DIRECTORIES" ("OWNER", "DIRECTORY_NAME", "DIRECTORY_PATH", "ORIGIN_CON_ID") AS 
  select OWNER, DIRECTORY_NAME, DIRECTORY_PATH, ORIGIN_CON_ID
from INT$DBA_DIRECTORIES
where ( OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
        or OBJ_ID(OWNER, DIRECTORY_NAME, OBJECT_TYPE#, OBJECT_ID) in
           (select oa.obj#
            from sys.objauth$ oa
            where grantee# in (select kzsrorol
                               from x$kzsro
                              )
           )
        or
          ora_check_sys_privilege (0, OBJECT_TYPE#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_DIRECTORIES"."OWNER" IS 'Owner of the directory (always SYS)';
   COMMENT ON COLUMN "SYS"."ALL_DIRECTORIES"."DIRECTORY_NAME" IS 'Name of the directory';
   COMMENT ON COLUMN "SYS"."ALL_DIRECTORIES"."DIRECTORY_PATH" IS 'Operating system pathname for the directory';
   COMMENT ON COLUMN "SYS"."ALL_DIRECTORIES"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_DIRECTORIES"  IS 'Description of all directories accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_EDITION_COMMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EDITION_COMMENTS" ("EDITION_NAME", "COMMENTS") AS 
  select o.name, c.comment$
from sys.obj$ o, sys.com$ c
where o.obj# = c.obj# (+)
  and o.type# = 57;

   COMMENT ON COLUMN "SYS"."ALL_EDITION_COMMENTS"."EDITION_NAME" IS 'Name of the edition';
   COMMENT ON COLUMN "SYS"."ALL_EDITION_COMMENTS"."COMMENTS" IS 'Edition comments';
   COMMENT ON TABLE "SYS"."ALL_EDITION_COMMENTS"  IS 'Describes comments on all editions in the database'
;
--------------------------------------------------------
--  DDL for View ALL_EDITIONING_VIEW_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EDITIONING_VIEW_COLS" ("OWNER", "VIEW_NAME", "VIEW_COLUMN_ID", "VIEW_COLUMN_NAME", "TABLE_COLUMN_ID", "TABLE_COLUMN_NAME") AS 
  select ev_user.name,
       ev_obj.name,
       view_col.col#,
       view_col.name,
       tbl_col.col#,
       tbl_col.name
       
from   sys."_CURRENT_EDITION_OBJ" ev_obj, sys.obj$ base_tbl_obj,
       sys.ev$ ev, sys.evcol$ ev_col, sys.col$ view_col, sys.col$ tbl_col,
       sys.user$ ev_user
where  /* get all columns of a given EV */
       ev.ev_obj# = ev_col.ev_obj#
       /* join EVCOL$ to COL$ on EV id and column id to obtain EV column */
       /* name */
  and  ev_col.ev_obj# = view_col.obj#
  and  ev_col.ev_col_id = view_col.col#
       /* join EV$ to OBJ$ on base table owner id and base table name so we */
       /* can determine base table id */
  and  ev.base_tbl_owner# = base_tbl_obj.owner#
  and  ev.base_tbl_name   = base_tbl_obj.name
       /* exclude [sub]partitions by restricting base_tbl_obj.type# to */
       /* "table"; since COL$ will not contain rows for [sub]partitions, */
       /* this restriction is not, strictly speaking, necessary, but it */
       /* does ensure that the above join will return exactly one row */
  and base_tbl_obj.type# = 2
       /* join EVCOL$ row and OBJ$ row describing the EV's base table to */
       /* COL$ to obtain base table column id */
  and  base_tbl_obj.obj# = tbl_col.obj#
  and  ev_col.base_tbl_col_name = tbl_col.name
       /* join EV$ to _*_EDITION_OBJ on EV id so we can determine */
       /* name of the EV and id of its owner */
  and  ev_obj.obj# = ev.ev_obj#
       /* join _*_EDITION_OBJ row describing the EV to USER$ to get */
       /* owner name */
   and ev_obj.owner# = ev_user.user#
       /* make sure the EV is visible to the current user */
   and (ev_obj.owner# = userenv('SCHEMAID')
        or ev_obj.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
         ora_check_sys_privilege (ev_obj.owner#, ev_obj.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS"."OWNER" IS 'Owner of an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS"."VIEW_NAME" IS 'Name of an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS"."VIEW_COLUMN_ID" IS 'Column number within the Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS"."VIEW_COLUMN_NAME" IS 'Name of the column in the Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS"."TABLE_COLUMN_ID" IS 'Column number of a table column to which this EV column maps';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS"."TABLE_COLUMN_NAME" IS 'Name of a table column to which this EV column maps';
   COMMENT ON TABLE "SYS"."ALL_EDITIONING_VIEW_COLS"  IS 'Relationship between columns of Editioning Views accessible to the user and the table columns to which they map'
;
--------------------------------------------------------
--  DDL for View ALL_EDITIONING_VIEW_COLS_AE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EDITIONING_VIEW_COLS_AE" ("OWNER", "VIEW_NAME", "VIEW_COLUMN_ID", "VIEW_COLUMN_NAME", "TABLE_COLUMN_ID", "TABLE_COLUMN_NAME", "EDITION_NAME") AS 
  select ev_user.name,
       ev_obj.name,
       view_col.col#,
       view_col.name,
       tbl_col.col#,
       tbl_col.name
       , ev_obj.defining_edition
from   sys."_ACTUAL_EDITION_OBJ" ev_obj, sys.obj$ base_tbl_obj,
       sys.ev$ ev, sys.evcol$ ev_col, sys.col$ view_col, sys.col$ tbl_col,
       sys.user$ ev_user
where  /* get all columns of a given EV */
       ev.ev_obj# = ev_col.ev_obj#
       /* join EVCOL$ to COL$ on EV id and column id to obtain EV column */
       /* name */
  and  ev_col.ev_obj# = view_col.obj#
  and  ev_col.ev_col_id = view_col.col#
       /* join EV$ to OBJ$ on base table owner id and base table name so we */
       /* can determine base table id */
  and  ev.base_tbl_owner# = base_tbl_obj.owner#
  and  ev.base_tbl_name   = base_tbl_obj.name
       /* exclude [sub]partitions by restricting base_tbl_obj.type# to */
       /* "table"; since COL$ will not contain rows for [sub]partitions, */
       /* this restriction is not, strictly speaking, necessary, but it */
       /* does ensure that the above join will return exactly one row */
  and base_tbl_obj.type# = 2
       /* join EVCOL$ row and OBJ$ row describing the EV's base table to */
       /* COL$ to obtain base table column id */
  and  base_tbl_obj.obj# = tbl_col.obj#
  and  ev_col.base_tbl_col_name = tbl_col.name
       /* join EV$ to _*_EDITION_OBJ on EV id so we can determine */
       /* name of the EV and id of its owner */
  and  ev_obj.obj# = ev.ev_obj#
       /* join _*_EDITION_OBJ row describing the EV to USER$ to get */
       /* owner name */
   and ev_obj.owner# = ev_user.user#
       /* make sure the EV is visible to the current user */
   and (ev_obj.owner# = userenv('SCHEMAID')
        or ev_obj.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
         ora_check_sys_privilege (ev_obj.owner#, ev_obj.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS_AE"."OWNER" IS 'Owner of an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS_AE"."VIEW_NAME" IS 'Name of an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS_AE"."VIEW_COLUMN_ID" IS 'Column number within the Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS_AE"."VIEW_COLUMN_NAME" IS 'Name of the column in the Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS_AE"."TABLE_COLUMN_ID" IS 'Column number of a table column to which this EV column maps';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS_AE"."TABLE_COLUMN_NAME" IS 'Name of a table column to which this EV column maps';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEW_COLS_AE"."EDITION_NAME" IS 'Name of the Application Edition where the Editioning View is defined';
   COMMENT ON TABLE "SYS"."ALL_EDITIONING_VIEW_COLS_AE"  IS 'Relationship between columns of Editioning Views accessible to the user and the table columns to which they map'
;
--------------------------------------------------------
--  DDL for View ALL_EDITIONING_VIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EDITIONING_VIEWS" ("OWNER", "VIEW_NAME", "TABLE_NAME") AS 
  select ev_user.name, ev_obj.name, ev.base_tbl_name 
from   sys."_CURRENT_EDITION_OBJ" ev_obj, sys.ev$ ev, sys.user$ ev_user
where
       /* join EV$ to _*_EDITION_OBJ on EV id so we can determine */
       /* name of the EV and id of its owner */
       ev_obj.obj# = ev.ev_obj#
       /* join _*_EDITION_OBJ row pertaining to EV to USER$ to get */
       /* EV owner name */
  and  ev_obj.owner# = ev_user.user#
       /* make sure the EV is visible to the current user */
  and  (ev_obj.owner# = userenv('SCHEMAID')
        or ev_obj.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
         ora_check_sys_privilege (ev_obj.owner#, ev_obj.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEWS"."OWNER" IS 'Owner of an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEWS"."VIEW_NAME" IS 'Name of an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEWS"."TABLE_NAME" IS 'Name of an Editioning View''s base table';
   COMMENT ON TABLE "SYS"."ALL_EDITIONING_VIEWS"  IS 'Description of Editioning Views accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_EDITIONING_VIEWS_AE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EDITIONING_VIEWS_AE" ("OWNER", "VIEW_NAME", "TABLE_NAME", "EDITION_NAME") AS 
  select ev_user.name, ev_obj.name, ev.base_tbl_name , ev_obj.defining_edition
from   sys."_ACTUAL_EDITION_OBJ" ev_obj, sys.ev$ ev, sys.user$ ev_user
where
       /* join EV$ to _*_EDITION_OBJ on EV id so we can determine */
       /* name of the EV and id of its owner */
       ev_obj.obj# = ev.ev_obj#
       /* join _*_EDITION_OBJ row pertaining to EV to USER$ to get */
       /* EV owner name */
  and  ev_obj.owner# = ev_user.user#
       /* make sure the EV is visible to the current user */
  and  (ev_obj.owner# = userenv('SCHEMAID')
        or ev_obj.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
         ora_check_sys_privilege (ev_obj.owner#, ev_obj.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEWS_AE"."OWNER" IS 'Owner of an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEWS_AE"."VIEW_NAME" IS 'Name of an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEWS_AE"."TABLE_NAME" IS 'Name of an Editioning View''s base table';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONING_VIEWS_AE"."EDITION_NAME" IS 'Name of the Application Edition where the Editioning View is defined';
   COMMENT ON TABLE "SYS"."ALL_EDITIONING_VIEWS_AE"  IS 'Description of Editioning Views accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_EDITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EDITIONS" ("EDITION_NAME", "PARENT_EDITION_NAME", "USABLE") AS 
  select o.name, po.name, decode(bitand(e.flags,1),1,'NO','YES')
from sys.obj$ o, sys.edition$ e, sys.obj$ po
where o.obj# = e.obj#
  and po.obj# (+)= e.p_obj#;

   COMMENT ON COLUMN "SYS"."ALL_EDITIONS"."EDITION_NAME" IS 'Name of the edition';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONS"."PARENT_EDITION_NAME" IS 'Name of the parent edition for this edition';
   COMMENT ON COLUMN "SYS"."ALL_EDITIONS"."USABLE" IS 'A value of ''YES'' means edition is usable and ''NO'' means unusable';
   COMMENT ON TABLE "SYS"."ALL_EDITIONS"  IS 'Describes all editions in the database'
;
--------------------------------------------------------
--  DDL for View ALL_ENCRYPTED_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ENCRYPTED_COLUMNS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "ENCRYPTION_ALG", "SALT", "INTEGRITY_ALG") AS 
  select u.name, o.name, c.name,
          case e.ENCALG when 1 then '3 Key Triple DES 168 bits key'
                        when 2 then 'AES 128 bits key'
                        when 3 then 'AES 192 bits key'
                        when 4 then 'AES 256 bits key'
                        when 5 then 'ARIA 128 bits key'
                        when 6 then 'ARIA 192 bits key'
                        when 7 then 'ARIA 256 bits key'
                        when 8 then 'SEED 128 bits key'
                        when 9 then 'GOST 256 bits key'
                        else 'Internal Err'
          end,
          decode(bitand(c.property, 536870912), 0, 'YES', 'NO'),
          case e.INTALG when 1 then 'SHA-1'
                        when 2 then 'NOMAC'
                        else 'Internal Err'
          end
   from user$ u, obj$ o, col$ c, enc$ e
   where e.obj#=o.obj# and o.owner#=u.user# and bitand(flags, 128)=0 and
         e.obj#=c.obj# and bitand(c.property, 67108864) = 67108864 and
         (o.owner# = userenv('SCHEMAID')
          or
          e.obj# in (select obj# from sys.objauth$ where grantee# in
                        (select kzsrorol from x$kzsro))
          or
          /* user has system privileges */
          ora_check_sys_privilege ( o.owner#, o.type#) = 1
         );

   COMMENT ON COLUMN "SYS"."ALL_ENCRYPTED_COLUMNS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_ENCRYPTED_COLUMNS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_ENCRYPTED_COLUMNS"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON COLUMN "SYS"."ALL_ENCRYPTED_COLUMNS"."ENCRYPTION_ALG" IS 'Encryption algorithm used for the column';
   COMMENT ON COLUMN "SYS"."ALL_ENCRYPTED_COLUMNS"."SALT" IS 'Is this column encrypted with salt? YES or NO';
   COMMENT ON COLUMN "SYS"."ALL_ENCRYPTED_COLUMNS"."INTEGRITY_ALG" IS 'Integrity algorithm used for the column';
   COMMENT ON TABLE "SYS"."ALL_ENCRYPTED_COLUMNS"  IS 'Encryption information on all accessible columns'
;
--------------------------------------------------------
--  DDL for View ALL_ERRORS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ERRORS" ("OWNER", "NAME", "TYPE", "SEQUENCE", "LINE", "POSITION", "TEXT", "ATTRIBUTE", "MESSAGE_NUMBER") AS 
  select u.name, o.name,
decode(o.type#, 4, 'VIEW', 7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
               11, 'PACKAGE BODY', 12, 'TRIGGER', 13, 'TYPE', 14, 'TYPE BODY',
               22, 'LIBRARY', 28, 'JAVA SOURCE', 29, 'JAVA CLASS',
               43, 'DIMENSION', 87, 'ASSEMBLY', 150, 'HIERARCHY',
               151, 'ATTRIBUTE DIMENSION', 152, 'ANALYTIC VIEW', 'UNDEFINED'),
  e.sequence#, e.line, e.position#, e.text,
   decode(e.property, 0,'ERROR', 1, 'WARNING', 'UNDEFINED'), e.error#
  
from sys."_CURRENT_EDITION_OBJ" o, sys.error$ e, sys.user$ u
where o.obj# = e.obj#
  and o.owner# = u.user#
  and o.type# in (4, 7, 8, 9, 11, 12, 13, 14, 22, 28, 29, 43, 87, 150, 151,
                  152)
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          (o.type# = 7 or o.type# = 8 or o.type# = 9 or o.type# = 13 or
           o.type# = 28 or o.type# = 29)
          and
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        (
          o.type# = 4
          and
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (3 /* DELETE */,   6 /* INSERT */,
                                          7 /* LOCK */,     9 /* SELECT */,
                                          10 /* UPDATE */, 17 /* READ */))
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (o.type# = 7 or o.type# = 8 or o.type# = 9 or
               o.type# = 28 or o.type# = 29)
              and
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -142 /* ALTER ANY PROCEDURE */
              )
            )
            or
            (
              /* trigger */
              o.type# = 12 and
              (
                privilege# = -152 /* CREATE ANY TRIGGER */
                or
                privilege# = -153 /* ALTER ANY TRIGGER */
              )
            )
            or
            (
              /* package body */
              o.type# = 11 and
              (
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -142 /* ALTER ANY PROCEDURE */
              )
            )
            or
            (
              /* dimension */
              o.type# = 11 and
              (
                privilege# = -215 /* CREATE ANY DIMENSION */
                or
                privilege# = -216 /* ALTER ANY DIMENSION */
              )
            )
            or
            (
              /* view */
              o.type# = 4
              and
              (
                privilege# in     ( -91 /* CREATE ANY VIEW */,
                                    -45 /* LOCK ANY TABLE */,
                                    -47 /* SELECT ANY TABLE */,
                                    -397/* READ ANY TABLE */,
                                    -48 /* INSERT ANY TABLE */,
                                    -49 /* UPDATE ANY TABLE */,
                                    -50 /* DELETE ANY TABLE */)
              )
            )
            or
            (
              /* type */
              o.type# = 13
              and
              (
                privilege# = -184 /* EXECUTE ANY TYPE */
                or
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -182 /* ALTER ANY TYPE */
              )
            )
            or
            (
              /* type body */
              o.type# = 14 and
              (
               privilege# = -181 /* CREATE ANY TYPE */
               or
               privilege# = -182 /* ALTER ANY TYPE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_ERRORS"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS"."NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS"."TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS"."SEQUENCE" IS 'Sequence number used for ordering purposes';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS"."LINE" IS 'Line number at which this error occurs';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS"."POSITION" IS 'Position in the line at which this error occurs';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS"."TEXT" IS 'Text of the error';
   COMMENT ON TABLE "SYS"."ALL_ERRORS"  IS 'Current errors on stored objects that user is allowed to create'
;
--------------------------------------------------------
--  DDL for View ALL_ERRORS_AE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ERRORS_AE" ("OWNER", "NAME", "TYPE", "SEQUENCE", "LINE", "POSITION", "TEXT", "ATTRIBUTE", "MESSAGE_NUMBER", "EDITION_NAME") AS 
  select u.name, o.name,
decode(o.type#, 4, 'VIEW', 7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
               11, 'PACKAGE BODY', 12, 'TRIGGER', 13, 'TYPE', 14, 'TYPE BODY',
               22, 'LIBRARY', 28, 'JAVA SOURCE', 29, 'JAVA CLASS',
               43, 'DIMENSION', 87, 'ASSEMBLY', 150, 'HIERARCHY',
               151, 'ATTRIBUTE DIMENSION', 152, 'ANALYTIC VIEW', 'UNDEFINED'),
  e.sequence#, e.line, e.position#, e.text,
   decode(e.property, 0,'ERROR', 1, 'WARNING', 'UNDEFINED'), e.error#
  , o.defining_edition
from sys."_ACTUAL_EDITION_OBJ" o, sys.error$ e, sys.user$ u
where o.obj# = e.obj#
  and o.owner# = u.user#
  and o.type# in (4, 7, 8, 9, 11, 12, 13, 14, 22, 28, 29, 43, 87, 150, 151,
                  152)
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          (o.type# = 7 or o.type# = 8 or o.type# = 9 or o.type# = 13 or
           o.type# = 28 or o.type# = 29)
          and
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        (
          o.type# = 4
          and
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (3 /* DELETE */,   6 /* INSERT */,
                                          7 /* LOCK */,     9 /* SELECT */,
                                          10 /* UPDATE */, 17 /* READ */))
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (o.type# = 7 or o.type# = 8 or o.type# = 9 or
               o.type# = 28 or o.type# = 29)
              and
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -142 /* ALTER ANY PROCEDURE */
              )
            )
            or
            (
              /* trigger */
              o.type# = 12 and
              (
                privilege# = -152 /* CREATE ANY TRIGGER */
                or
                privilege# = -153 /* ALTER ANY TRIGGER */
              )
            )
            or
            (
              /* package body */
              o.type# = 11 and
              (
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -142 /* ALTER ANY PROCEDURE */
              )
            )
            or
            (
              /* dimension */
              o.type# = 11 and
              (
                privilege# = -215 /* CREATE ANY DIMENSION */
                or
                privilege# = -216 /* ALTER ANY DIMENSION */
              )
            )
            or
            (
              /* view */
              o.type# = 4
              and
              (
                privilege# in     ( -91 /* CREATE ANY VIEW */,
                                    -45 /* LOCK ANY TABLE */,
                                    -47 /* SELECT ANY TABLE */,
                                    -397/* READ ANY TABLE */,
                                    -48 /* INSERT ANY TABLE */,
                                    -49 /* UPDATE ANY TABLE */,
                                    -50 /* DELETE ANY TABLE */)
              )
            )
            or
            (
              /* type */
              o.type# = 13
              and
              (
                privilege# = -184 /* EXECUTE ANY TYPE */
                or
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -182 /* ALTER ANY TYPE */
              )
            )
            or
            (
              /* type body */
              o.type# = 14 and
              (
               privilege# = -181 /* CREATE ANY TYPE */
               or
               privilege# = -182 /* ALTER ANY TYPE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_ERRORS_AE"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS_AE"."NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS_AE"."TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS_AE"."SEQUENCE" IS 'Sequence number used for ordering purposes';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS_AE"."LINE" IS 'Line number at which this error occurs';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS_AE"."POSITION" IS 'Position in the line at which this error occurs';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS_AE"."TEXT" IS 'Text of the error';
   COMMENT ON COLUMN "SYS"."ALL_ERRORS_AE"."EDITION_NAME" IS 'Name of the edition in which the object is actual';
   COMMENT ON TABLE "SYS"."ALL_ERRORS_AE"  IS 'Current errors on stored objects that user is allowed to create'
;
--------------------------------------------------------
--  DDL for View ALL_ERROR_TRANSLATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ERROR_TRANSLATIONS" ("OWNER", "PROFILE_NAME", "ERROR_CODE", "TRANSLATED_CODE", "TRANSLATED_SQLSTATE", "ENABLED", "REGISTRATION_TIME", "COMMENTS") AS 
  select u.name, o.name, s.errcode#, s.txlcode#, s.txlsqlstate,
       decode(bitand(s.flags, 1), 1, 'TRUE', 0, 'FALSE'), s.rtime, s.comment$
  from sys.sqltxl_err$ s, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u
 where s.obj# = o.obj# and
       o.owner# = u.user# and
       (
         o.owner# = userenv('SCHEMAID')
         or
         exists (select null from sys.objauth$ oa
                  where oa.obj# = o.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# in (0 /* ALTER */, 29 /* USE */))
         or
         exists (select null from v$enabledprivs
                 where priv_number in (
                                -335 /* CREATE ANY SQL TRANSLATION PROFILE */,
                                -336 /* ALTER ANY SQL TRANSLATION PROFILE  */,
                                -337 /* USE ANY SQL TRANSLATION PROFILE    */,
                                -338 /* DROP ANY SQL TRANSLATION PROFILE   */
                                      )
                )
       );

   COMMENT ON COLUMN "SYS"."ALL_ERROR_TRANSLATIONS"."OWNER" IS 'Owner of the SQL translation profile';
   COMMENT ON COLUMN "SYS"."ALL_ERROR_TRANSLATIONS"."PROFILE_NAME" IS 'Name of the SQL translation profile';
   COMMENT ON COLUMN "SYS"."ALL_ERROR_TRANSLATIONS"."ERROR_CODE" IS 'The error code';
   COMMENT ON COLUMN "SYS"."ALL_ERROR_TRANSLATIONS"."TRANSLATED_CODE" IS 'The translated error code';
   COMMENT ON COLUMN "SYS"."ALL_ERROR_TRANSLATIONS"."TRANSLATED_SQLSTATE" IS 'The translated SQLSTATE';
   COMMENT ON COLUMN "SYS"."ALL_ERROR_TRANSLATIONS"."ENABLED" IS 'Is the translation enabled?';
   COMMENT ON COLUMN "SYS"."ALL_ERROR_TRANSLATIONS"."REGISTRATION_TIME" IS 'Time the translation was registered';
   COMMENT ON COLUMN "SYS"."ALL_ERROR_TRANSLATIONS"."COMMENTS" IS 'Comment on the translation';
   COMMENT ON TABLE "SYS"."ALL_ERROR_TRANSLATIONS"  IS 'Describes all error translations accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_EVALUATION_CONTEXTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EVALUATION_CONTEXTS" ("EVALUATION_CONTEXT_OWNER", "EVALUATION_CONTEXT_NAME", "EVALUATION_FUNCTION", "EVALUATION_CONTEXT_COMMENT") AS 
  SELECT /*+ all_rows */
       u.name, o.name, ec.eval_func, ec.ec_comment
FROM   rule_ec$ ec, obj$ o, user$ u
WHERE  ec.obj# = o.obj# and
       (o.owner# in (USERENV('SCHEMAID'), 1 /* PUBLIC */) or
        o.obj# in (select oa.obj# from sys.objauth$ oa
                   where grantee# in (select kzsrorol from x$kzsro)) or
        -- bug 20339374,V$ENABLEDPRIVS replaced with
        -- ora_check_sys_privilege operator to protect sys owned object
        ora_check_sys_privilege (o.owner#, o.type#) = 1) and
        o.owner# = u.user#;

   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXTS"."EVALUATION_CONTEXT_OWNER" IS 'Owner of the evaluation context';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXTS"."EVALUATION_CONTEXT_NAME" IS 'Name of the evaluation context';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXTS"."EVALUATION_FUNCTION" IS 'User supplied function to evaluate rules';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXTS"."EVALUATION_CONTEXT_COMMENT" IS 'user description of the evaluation context';
   COMMENT ON TABLE "SYS"."ALL_EVALUATION_CONTEXTS"  IS 'rule evaluation contexts seen by user'
;
--------------------------------------------------------
--  DDL for View ALL_EVALUATION_CONTEXT_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EVALUATION_CONTEXT_TABLES" ("EVALUATION_CONTEXT_OWNER", "EVALUATION_CONTEXT_NAME", "TABLE_ALIAS", "TABLE_NAME") AS 
  SELECT /*+ all_rows */
       u.name, o.name, ect.tab_alias, ect.tab_name
FROM   rec_tab$ ect, obj$ o, user$ u
WHERE  ect.ec_obj# = o.obj# and
       (o.owner# in (USERENV('SCHEMAID'), 1 /* PUBLIC */) or
        o.obj# in (select oa.obj# from sys.objauth$ oa
                   where grantee# in (select kzsrorol from x$kzsro)) or
       -- bug 20339374,V$ENABLEDPRIVS replaced with
       -- ora_check_sys_privilege operator to protect sys owned object
       ora_check_sys_privilege (o.owner#, o.type#) = 1) and
       o.owner# = u.user#;

   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_TABLES"."EVALUATION_CONTEXT_OWNER" IS 'Owner of the evaluation context';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_TABLES"."EVALUATION_CONTEXT_NAME" IS 'Name of the evaluation context';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_TABLES"."TABLE_ALIAS" IS 'Alias of the table';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_TABLES"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON TABLE "SYS"."ALL_EVALUATION_CONTEXT_TABLES"  IS 'tables in all rule evaluation contexts seen by the user'
;
--------------------------------------------------------
--  DDL for View ALL_EVALUATION_CONTEXT_VARS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EVALUATION_CONTEXT_VARS" ("EVALUATION_CONTEXT_OWNER", "EVALUATION_CONTEXT_NAME", "VARIABLE_NAME", "VARIABLE_TYPE", "VARIABLE_VALUE_FUNCTION", "VARIABLE_METHOD_FUNCTION") AS 
  SELECT /*+ all_rows */
       u.name, o.name, ecv.var_name, ecv.var_type, ecv.var_val_func,
       ecv.var_mthd_func
FROM   rec_var$ ecv, obj$ o, user$ u
WHERE  ecv.ec_obj# = o.obj# and
       (o.owner# in (USERENV('SCHEMAID'), 1 /* PUBLIC */) or
        o.obj# in (select oa.obj# from sys.objauth$ oa
                   where grantee# in (select kzsrorol from x$kzsro)) or
       -- bug 20339374,V$ENABLEDPRIVS replaced with
       -- ora_check_sys_privilege operator to protect sys owned object
       ora_check_sys_privilege (o.owner#, o.type#) = 1) and
       o.owner# = u.user#;

   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_VARS"."EVALUATION_CONTEXT_OWNER" IS 'Owner of the evaluation context';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_VARS"."EVALUATION_CONTEXT_NAME" IS 'Name of the evaluation context';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_VARS"."VARIABLE_NAME" IS 'Name of the variable';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_VARS"."VARIABLE_VALUE_FUNCTION" IS 'Function to provide variable value';
   COMMENT ON COLUMN "SYS"."ALL_EVALUATION_CONTEXT_VARS"."VARIABLE_METHOD_FUNCTION" IS 'Function to provide variable method return value';
   COMMENT ON TABLE "SYS"."ALL_EVALUATION_CONTEXT_VARS"  IS 'variables in all rule evaluation contexts seen by the user'
;
--------------------------------------------------------
--  DDL for View ALL_EXPRESSION_STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EXPRESSION_STATISTICS" ("OWNER", "TABLE_NAME", "EXPRESSION_ID", "SNAPSHOT", "EVALUATION_COUNT", "FIXED_COST", "DYNAMIC_COST", "EXPRESSION_TEXT", "CREATED", "LAST_MODIFIED") AS 
  select u.name, o.name, v.expid, decode(v.snapshot_id, 0, 'CUMULATIVE',
                                                      1, 'LATEST',
                                                      'WINDOW'),
       v.evaluation_count, h.fixed_cost,
       v.dynamic_cost, h.text, h.ctime, v.last_modified
from obj$ o, user$ u, exp_head$ h,
  -- latest expressions
  ((select nvl(ds.exp_id, ms.expid) expid,
           nvl(ds.objn, ms.objnum) objn, 1 snapshot_id,
           (nvl(ds.eval_count, 0) + nvl(ms.evalcnt, 0)) evaluation_count,
           nvl(ms.dyncost, ds.dynamic_cost) dynamic_cost,
           decode(ms.expid, null, ds.last_modified, systimestamp) last_modified
  from (select * from exp_stat$ where snapshot_id = 1) ds full outer join
  (select expid, objnum, dyncost, evalcnt
   from gv$exp_stats where evalcnt > 0) ms
  on ds.exp_id = ms.expid and ds.objn = ms.objnum)
  union all
  -- window expression if window capture mode is OPEN
  (select nvl(ds.exp_id, ms.expid) expid,
           nvl(ds.objn, ms.objnum) objn, 2 snapshot_id,
           (nvl(ds.eval_count, 0) + nvl(ms.evalcnt, 0)) evaluation_count,
           nvl(ms.dyncost, ds.dynamic_cost) dynamic_cost,
           decode(ms.expid, null, ds.last_modified, systimestamp) last_modified
  from (select * from exp_stat$ where snapshot_id = 2) ds full outer join
  (select expid, objnum, dyncost, evalcnt
   from gv$exp_stats where evalcnt > 0) ms
  on ds.exp_id = ms.expid and ds.objn = ms.objnum
  where dbms_stats_internal.check_window_capture_mode() = 1)
  union all
  -- window expressions if window capture mode is CLOSED
  (select exp_id expid, objn, snapshot_id, eval_count evaluation_count,
          dynamic_cost, last_modified
   from exp_stat$ where snapshot_id = 2 and
        dbms_stats_internal.check_window_capture_mode() = 0)
  union all
  -- cumulative expressions
  (select exp_id expid, objn, snapshot_id, eval_count evaluation_count,
          dynamic_cost, last_modified
  from exp_stat$ where snapshot_id = 0)) v
where v.objn = o.obj# and v.expid = h.exp_id and o.owner# = u.user#
  and o.subname is null
  -- checks for privileges
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and (o.owner# = userenv('SCHEMAID')
        or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      );

   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."EXPRESSION_ID" IS 'Expression ID of the current expression';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."SNAPSHOT" IS 'Type of Snapshot (cumulative, latest or window) for the expression';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."EVALUATION_COUNT" IS 'Number of times the expressions has been evaluated';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."FIXED_COST" IS 'Optimizer Fixed Cost of evaluating the expression';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."DYNAMIC_COST" IS 'Optimizer Dynamic Cost of evaluating the expression';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."EXPRESSION_TEXT" IS 'Text of the expression';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."CREATED" IS 'Time this expression is first evaluated';
   COMMENT ON COLUMN "SYS"."ALL_EXPRESSION_STATISTICS"."LAST_MODIFIED" IS 'Time this expression is last evaluated';
   COMMENT ON TABLE "SYS"."ALL_EXPRESSION_STATISTICS"  IS 'Expression Usage Tracking Statistics'
;
--------------------------------------------------------
--  DDL for View ALL_EXTERNAL_LOCATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EXTERNAL_LOCATIONS" ("OWNER", "TABLE_NAME", "LOCATION", "DIRECTORY_OWNER", "DIRECTORY_NAME") AS 
  select u.name, o.name, xl.name, 'SYS', nvl(xl.dir, xt.default_dir)
from sys.external_location$ xl, sys.user$ u, sys.obj$ o, sys.external_tab$ xt
where o.owner# = u.user#
  and o.subname IS NULL
  and o.obj#   = xl.obj#
  and o.obj#   = xt.obj#
  and ( o.owner# = userenv('SCHEMAID')
        or o.obj# in
        ( select oa.obj# from sys.objauth$ oa
          where grantee# in (select kzsrorol from x$kzsro)
        )
        or    /* user has system privileges */
          exists ( select null from v$enabledprivs
                   where priv_number in (-45 /* LOCK ANY TABLE */,
                                         -47 /* SELECT ANY TABLE */,
                                         -397/* READ ANY TABLE */)
                 )
      );

   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_LOCATIONS"."OWNER" IS 'Owner of the external table location';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_LOCATIONS"."TABLE_NAME" IS 'Name of the corresponding external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_LOCATIONS"."LOCATION" IS 'External table location clause';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_LOCATIONS"."DIRECTORY_OWNER" IS 'Owner of the directory containing the external table location';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_LOCATIONS"."DIRECTORY_NAME" IS 'Name of the directory containing the location';
   COMMENT ON TABLE "SYS"."ALL_EXTERNAL_LOCATIONS"  IS 'Description of the external tables locations accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_EXTERNAL_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_EXTERNAL_TABLES" ("OWNER", "TABLE_NAME", "TYPE_OWNER", "TYPE_NAME", "DEFAULT_DIRECTORY_OWNER", "DEFAULT_DIRECTORY_NAME", "REJECT_LIMIT", "ACCESS_TYPE", "ACCESS_PARAMETERS", "PROPERTY", "INMEMORY", "INMEMORY_COMPRESSION") AS 
  select u.name, o.name, 'SYS', xt.type$, 'SYS', xt.default_dir,
       decode(xt.reject_limit, 2147483647, 'UNLIMITED', xt.reject_limit),
       decode(xt.par_type, 1, 'BLOB', 2, 'CLOB',       'UNKNOWN'),
       case when xt.par_type = 2 then xt.param_clob else NULL end,
       decode(bitand(xt.property, 3), 2, 'REFERENCED', 1, 'ALL',     'UNKNOWN'),
       case when bitand(xt.property,16)=16 then 'ENABLED' else 'DISABLED' end,
       decode(bitand(xt.property, (16+32+64+128)),
                         (16+32), 'NO MEMCOMPRESS',
                         (16+64), 'FOR DML',
                      (16+32+64), 'FOR QUERY LOW',
                        (16+128), 'FOR QUERY HIGH',
                     (16+128+32), 'FOR CAPACITY LOW',
                     (16+128+64), 'FOR CAPACITY HIGH', NULL)
from sys.external_tab$ xt, sys.obj$ o, sys.user$ u
where o.owner# = u.user#
  and o.subname IS NULL
  and o.obj#   = xt.obj#
  and ( o.owner# = userenv('SCHEMAID')
        or o.obj# in
            ( select oa.obj# from sys.objauth$ oa
              where grantee# in (select kzsrorol from x$kzsro)
            )
        or    /* user has system privileges */
          exists ( select null from v$enabledprivs
                   where priv_number in (-45 /* LOCK ANY TABLE */,
                                         -47 /* SELECT ANY TABLE */,
                                         -397/* READ ANY TABLE */)
                 )
      );

   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."OWNER" IS 'Owner of the external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."TABLE_NAME" IS 'Name of the external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."TYPE_OWNER" IS 'Owner of the implementation type for the external table access driver';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."TYPE_NAME" IS 'Name of the implementation type for the external table access driver';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."DEFAULT_DIRECTORY_OWNER" IS 'Owner of the default directory for the external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."DEFAULT_DIRECTORY_NAME" IS 'Name of the default directory for the external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."REJECT_LIMIT" IS 'Reject limit for the external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."ACCESS_TYPE" IS 'Type of access parameters for the external table (CLOB/BLOB)';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."ACCESS_PARAMETERS" IS 'Access parameters for the external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."PROPERTY" IS 'Property of the external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."INMEMORY" IS 'Whether inmemory is enabled on the external table';
   COMMENT ON COLUMN "SYS"."ALL_EXTERNAL_TABLES"."INMEMORY_COMPRESSION" IS 'Compression level for the in-memory column store option';
   COMMENT ON TABLE "SYS"."ALL_EXTERNAL_TABLES"  IS 'Description of the external tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View _ALL_FILE_GROUP_EXPORT_INFO
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_FILE_GROUP_EXPORT_INFO" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION_ID", "VERSION_GUID", "EXPORT_VERSION", "PLATFORM_NAME", "EXPORT_TIME", "EXPORT_SCN", "SOURCE_GLOBAL_NAME") AS 
  select g.file_group_owner, g.file_group_name, v.version_name, v.version_id,
       v.version_guid, i.export_version, i.export_platform, i.export_time,
       i.export_scn, i.source_db_name
from "_ALL_FILE_GROUPS" g, sys.fgr$_file_group_export_info i,
     sys.fgr$_file_group_versions v
where i.version_guid = v.version_guid and v.file_group_id = g.file_group_id
;
--------------------------------------------------------
--  DDL for View ALL_FILE_GROUP_EXPORT_INFO
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_FILE_GROUP_EXPORT_INFO" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION", "EXPORT_VERSION", "PLATFORM_NAME", "EXPORT_TIME", "EXPORT_SCN", "SOURCE_GLOBAL_NAME") AS 
  select file_group_owner, file_group_name, version_name, version_id,
       export_version, platform_name, export_time, export_scn,
       source_global_name
from "_ALL_FILE_GROUP_EXPORT_INFO";

   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."FILE_GROUP_OWNER" IS 'Owner of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."FILE_GROUP_NAME" IS 'Name of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."VERSION_NAME" IS 'Name of the version';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."VERSION" IS 'Internal version number';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."EXPORT_VERSION" IS 'Compatibility level of export dump';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."PLATFORM_NAME" IS 'Platform export was done on';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."EXPORT_TIME" IS 'Export job start time';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."EXPORT_SCN" IS 'Export job scn';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_EXPORT_INFO"."SOURCE_GLOBAL_NAME" IS 'Global name of the exporting database';
   COMMENT ON TABLE "SYS"."ALL_FILE_GROUP_EXPORT_INFO"  IS 'Details about export information of file group versions'
;
--------------------------------------------------------
--  DDL for View _ALL_FILE_GROUP_FILES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_FILE_GROUP_FILES" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION_ID", "VERSION_GUID", "FILE_NAME", "FILE_DIRECTORY", "FILE_TYPE", "FILE_SIZE", "FILE_BLOCKSIZE", "COMMENTS", "CREATOR", "CREATED") AS 
  select g.file_group_owner, g.file_group_name, v.version_name,
     v.version_id, v.version_guid, f.file_name, f.file_dir_obj, f.file_type,
     f.file_size, f.file_blocksize, f.user_comment, f.creator, f.creation_time
from "_ALL_FILE_GROUPS" g, sys.fgr$_file_group_files f,
     sys.fgr$_file_group_versions v
where f.version_guid = v.version_guid and v.file_group_id = g.file_group_id
;
--------------------------------------------------------
--  DDL for View ALL_FILE_GROUP_FILES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_FILE_GROUP_FILES" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION", "FILE_NAME", "FILE_DIRECTORY", "FILE_TYPE", "FILE_SIZE", "FILE_BLOCK_SIZE", "COMMENTS") AS 
  select file_group_owner, file_group_name, version_name,
     version_id, file_name, file_directory, file_type, file_size,
     file_blocksize, comments
from "_ALL_FILE_GROUP_FILES";

   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."FILE_GROUP_OWNER" IS 'Owner of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."FILE_GROUP_NAME" IS 'Name of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."VERSION_NAME" IS 'Name of the version';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."VERSION" IS 'Internal version number';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."FILE_NAME" IS 'Name of the file';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."FILE_DIRECTORY" IS 'Directory object for the file';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."FILE_TYPE" IS 'File type';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."FILE_SIZE" IS 'File size';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."FILE_BLOCK_SIZE" IS 'File block size';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_FILES"."COMMENTS" IS 'User specified comment';
   COMMENT ON TABLE "SYS"."ALL_FILE_GROUP_FILES"  IS 'Details about file group files'
;
--------------------------------------------------------
--  DDL for View _ALL_FILE_GROUPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_FILE_GROUPS" ("FILE_GROUP_ID", "FILE_GROUP_OWNER", "FILE_GROUP_NAME", "KEEP_FILES", "MIN_VERSIONS", "MAX_VERSIONS", "RETENTION_DAYS", "CREATED", "COMMENTS", "DEFAULT_DIRECTORY", "CREATOR") AS 
  select g.file_group_id, u.name, o.name, g.keep_files, g.min_versions,
       g.max_versions, g.retention_days, g.creation_time, g.user_comment,
       g.default_dir_obj, g.creator
from sys.obj$ o, sys.user$ u, sys.fgr$_file_groups g
where o.owner# = u.user# and o.obj# = g.file_group_id and
      (o.owner# in (USERENV('SCHEMAID'), 1 /* PUBLIC */) or
       o.obj# in (select oa.obj# from sys.objauth$ oa
                  where grantee# in (select kzsrorol from x$kzsro)) or
       exists (select null from v$enabledprivs where priv_number in (
                                                         -277, -278)))
;
--------------------------------------------------------
--  DDL for View ALL_FILE_GROUPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_FILE_GROUPS" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "KEEP_FILES", "MIN_VERSIONS", "MAX_VERSIONS", "RETENTION_DAYS", "CREATED", "COMMENTS", "DEFAULT_DIRECTORY") AS 
  select file_group_owner, file_group_name, keep_files, min_versions,
       max_versions, retention_days, created, comments,
       default_directory
from "_ALL_FILE_GROUPS";

   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."FILE_GROUP_OWNER" IS 'Owner of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."FILE_GROUP_NAME" IS 'Name of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."KEEP_FILES" IS 'Should on-disk files be purged when removed?';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."MIN_VERSIONS" IS 'Minimum number of versions to keep';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."MAX_VERSIONS" IS 'Maximum number of versions to keep';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."RETENTION_DAYS" IS 'Keep versions at least this number of days';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."CREATED" IS 'When the file group was created';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."COMMENTS" IS 'User specified comment';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUPS"."DEFAULT_DIRECTORY" IS 'Default directory object';
   COMMENT ON TABLE "SYS"."ALL_FILE_GROUPS"  IS 'Details about file groups'
;
--------------------------------------------------------
--  DDL for View _ALL_FILE_GROUP_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_FILE_GROUP_TABLES" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION_ID", "VERSION_GUID", "OWNER", "TABLE_NAME", "TABLESPACE_NAME", "SCN") AS 
  select g.file_group_owner, g.file_group_name, v.version_name, v.version_id,
       ti.version_guid, ti.schema_name, ti.table_name, ti.tablespace_name,
       ti.scn
from "_ALL_FILE_GROUPS" g, sys.fgr$_table_info ti,
     sys.fgr$_file_group_versions v
where ti.version_guid = v.version_guid and v.file_group_id = g.file_group_id
;
--------------------------------------------------------
--  DDL for View ALL_FILE_GROUP_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_FILE_GROUP_TABLES" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION", "OWNER", "TABLE_NAME", "TABLESPACE_NAME", "SCN") AS 
  select file_group_owner, file_group_name, version_name, version_id,
       owner, table_name, tablespace_name, scn
from "_ALL_FILE_GROUP_TABLES";

   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLES"."FILE_GROUP_OWNER" IS 'Owner of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLES"."FILE_GROUP_NAME" IS 'Name of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLES"."VERSION_NAME" IS 'Name of the version';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLES"."VERSION" IS 'Internal version number';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLES"."OWNER" IS 'Schema table belongs to';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLES"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLES"."TABLESPACE_NAME" IS 'Name of the tablespace containing the table';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLES"."SCN" IS 'SCN table was exported at';
   COMMENT ON TABLE "SYS"."ALL_FILE_GROUP_TABLES"  IS 'Details about the tables in the file group repository'
;
--------------------------------------------------------
--  DDL for View _ALL_FILE_GROUP_TABLESPACES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_FILE_GROUP_TABLESPACES" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION_ID", "VERSION_GUID", "TABLESPACE_NAME") AS 
  select g.file_group_owner, g.file_group_name, v.version_name, v.version_id,
       v.version_guid, ti.tablespace_name
from "_ALL_FILE_GROUPS" g, sys.fgr$_tablespace_info ti,
     sys.fgr$_file_group_versions v
where ti.version_guid = v.version_guid and v.file_group_id = g.file_group_id
;
--------------------------------------------------------
--  DDL for View ALL_FILE_GROUP_TABLESPACES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_FILE_GROUP_TABLESPACES" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION", "TABLESPACE_NAME") AS 
  select file_group_owner, file_group_name, version_name, version_id,
       tablespace_name
from "_ALL_FILE_GROUP_TABLESPACES";

   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLESPACES"."FILE_GROUP_OWNER" IS 'Owner of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLESPACES"."FILE_GROUP_NAME" IS 'Name of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLESPACES"."VERSION_NAME" IS 'Name of the version';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLESPACES"."VERSION" IS 'Internal version number';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_TABLESPACES"."TABLESPACE_NAME" IS 'Name of the tablespace';
   COMMENT ON TABLE "SYS"."ALL_FILE_GROUP_TABLESPACES"  IS 'Details about the transportable tablespaces in the file group repository'
;
--------------------------------------------------------
--  DDL for View _ALL_FILE_GROUP_VERSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_FILE_GROUP_VERSIONS" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION_ID", "VERSION_GUID", "CREATOR", "CREATED", "COMMENTS", "DEFAULT_DIRECTORY") AS 
  select g.file_group_owner, g.file_group_name, v.version_name, v.version_id,
       v.version_guid, v.creator, v.creation_time, v.user_comment,
       v.default_dir_obj
from "_ALL_FILE_GROUPS" g, sys.fgr$_file_group_versions v
where g.file_group_id = v.file_group_id
;
--------------------------------------------------------
--  DDL for View ALL_FILE_GROUP_VERSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_FILE_GROUP_VERSIONS" ("FILE_GROUP_OWNER", "FILE_GROUP_NAME", "VERSION_NAME", "VERSION", "CREATOR", "CREATED", "COMMENTS", "DEFAULT_DIRECTORY") AS 
  select v.file_group_owner, v.file_group_name, v.version_name, v.version_id,
       v.creator, v.created, v.comments, v.default_directory
from "_ALL_FILE_GROUP_VERSIONS" v;

   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_VERSIONS"."FILE_GROUP_OWNER" IS 'Owner of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_VERSIONS"."FILE_GROUP_NAME" IS 'Name of the file group';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_VERSIONS"."VERSION_NAME" IS 'Name of the version';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_VERSIONS"."VERSION" IS 'Internal version number';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_VERSIONS"."CREATOR" IS 'Creator of the version';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_VERSIONS"."CREATED" IS 'When the version was created';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_VERSIONS"."COMMENTS" IS 'User specified comment';
   COMMENT ON COLUMN "SYS"."ALL_FILE_GROUP_VERSIONS"."DEFAULT_DIRECTORY" IS 'Default directory object';
   COMMENT ON TABLE "SYS"."ALL_FILE_GROUP_VERSIONS"  IS 'Details about file group versions'
;
--------------------------------------------------------
--  DDL for View ALL_GG_AUTO_CDR_COLUMN_GROUPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_GG_AUTO_CDR_COLUMN_GROUPS" ("TABLE_OWNER", "TABLE_NAME", "COLUMN_GROUP_NAME", "RESOLUTION_COLUMN") AS 
  select cg."TABLE_OWNER",cg."TABLE_NAME",cg."COLUMN_GROUP_NAME",cg."RESOLUTION_COLUMN"
from DBA_GG_AUTO_CDR_COLUMN_GROUPS cg , all_tables at
where cg.table_owner = at.owner and cg.table_name = at.table_name;

   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_COLUMN_GROUPS"."TABLE_OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_COLUMN_GROUPS"."TABLE_NAME" IS 'Table name';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_COLUMN_GROUPS"."COLUMN_GROUP_NAME" IS 'Column group name';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_COLUMN_GROUPS"."RESOLUTION_COLUMN" IS 'Timestamp resolution column';
   COMMENT ON TABLE "SYS"."ALL_GG_AUTO_CDR_COLUMN_GROUPS"  IS 'Details about goldengate auto cdr column groups'
;
--------------------------------------------------------
--  DDL for View ALL_GG_AUTO_CDR_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_GG_AUTO_CDR_COLUMNS" ("TABLE_OWNER", "TABLE_NAME", "COLUMN_GROUP_NAME", "COLUMN_NAME", "RESOLUTION_COLUMN") AS 
  select c."TABLE_OWNER",c."TABLE_NAME",c."COLUMN_GROUP_NAME",c."COLUMN_NAME",c."RESOLUTION_COLUMN"
from DBA_GG_AUTO_CDR_COLUMNS c, ALL_TABLES at
where c.table_owner = at.owner and c.table_name = at.table_name;

   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_COLUMNS"."TABLE_OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_COLUMNS"."TABLE_NAME" IS 'Table name';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_COLUMNS"."COLUMN_NAME" IS 'Column name';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_COLUMNS"."RESOLUTION_COLUMN" IS 'Timestamp resolution column';
   COMMENT ON TABLE "SYS"."ALL_GG_AUTO_CDR_COLUMNS"  IS 'Details about goldengate auto cdr columns'
;
--------------------------------------------------------
--  DDL for View _ALL_GG_AUTO_CDR_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_GG_AUTO_CDR_TABLES" ("TABLE_OWNER", "TABLE_NAME", "ACDRFLAGS", "TOMBSTONE_TABLE", "ROW_RESOLUTION_COLUMN", "ACDRDEFAULTTIME") AS 
  select t."TABLE_OWNER",t."TABLE_NAME",t."ACDRFLAGS",t."TOMBSTONE_TABLE",t."ROW_RESOLUTION_COLUMN",t."ACDRDEFAULTTIME"
from sys."_DBA_GG_AUTO_CDR_TABLES" t, all_tables at
where t.table_owner = at.owner and t.table_name = at.table_name
;
--------------------------------------------------------
--  DDL for View ALL_GG_AUTO_CDR_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_GG_AUTO_CDR_TABLES" ("TABLE_OWNER", "TABLE_NAME", "RESOLUTION_GRANULARITY", "FETCHCOLS", "RECORD_CONFLICTS", "USE_CUSTOM_HANDLERS", "TOMBSTONE_TABLE", "ROW_RESOLUTION_COLUMN", "EXISTING_DATA_TIMESTAMP") AS 
  select t."TABLE_OWNER",t."TABLE_NAME",t."RESOLUTION_GRANULARITY",t."FETCHCOLS",t."RECORD_CONFLICTS",t."USE_CUSTOM_HANDLERS",t."TOMBSTONE_TABLE",t."ROW_RESOLUTION_COLUMN",t."EXISTING_DATA_TIMESTAMP"
from DBA_GG_AUTO_CDR_TABLES t, ALL_TABLES at
where t.table_owner = at.owner and t.table_name = at.table_name;

   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."TABLE_OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."TABLE_NAME" IS 'Table name';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."RESOLUTION_GRANULARITY" IS 'Resolution granularity';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."FETCHCOLS" IS 'Extract fetchcols configuration';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."RECORD_CONFLICTS" IS 'Yes, to record conflict info.  No, to not record conflict info';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."USE_CUSTOM_HANDLERS" IS 'All, if using custom handlers. None, if using automatic handlers';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."TOMBSTONE_TABLE" IS 'Tombstone table name if table has delete tombstoning enabled';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."ROW_RESOLUTION_COLUMN" IS 'Name of row-level timestamp column';
   COMMENT ON COLUMN "SYS"."ALL_GG_AUTO_CDR_TABLES"."EXISTING_DATA_TIMESTAMP" IS 'Timestamp to give exising rows when a new timestamp column is added';
   COMMENT ON TABLE "SYS"."ALL_GG_AUTO_CDR_TABLES"  IS 'Details about goldengate auto cdr tables'
;
--------------------------------------------------------
--  DDL for View ALL_GG_INBOUND_PROGRESS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_GG_INBOUND_PROGRESS" ("SERVER_NAME", "PROCESSED_LOW_POSITION", "APPLIED_LOW_POSITION", "APPLIED_HIGH_POSITION", "SPILL_POSITION", "OLDEST_POSITION", "APPLIED_LOW_SCN", "APPLIED_TIME", "APPLIED_MESSAGE_CREATE_TIME", "SOURCE_DATABASE", "SOURCE_ROOT_NAME", "LOGBSN") AS 
  select xp."SERVER_NAME",xp."PROCESSED_LOW_POSITION",xp."APPLIED_LOW_POSITION",xp."APPLIED_HIGH_POSITION",xp."SPILL_POSITION",xp."OLDEST_POSITION",xp."APPLIED_LOW_SCN",xp."APPLIED_TIME",xp."APPLIED_MESSAGE_CREATE_TIME",xp."SOURCE_DATABASE",xp."SOURCE_ROOT_NAME",xp."LOGBSN"
  from dba_gg_inbound_progress xp, all_apply ap
    where ap.apply_name = xp.server_name;

   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."SERVER_NAME" IS 'Name of the outbound server';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."PROCESSED_LOW_POSITION" IS 'Position of processed low transaction';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."APPLIED_LOW_POSITION" IS 'All messages with commit position less than this value have been applied';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."APPLIED_HIGH_POSITION" IS 'Highest commit position of a transaction that has been applied';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."SPILL_POSITION" IS 'Position of the spill low watermark';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."OLDEST_POSITION" IS 'Earliest position of the transactions currently being applied';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."APPLIED_LOW_SCN" IS 'All SCN below this number have been successfully applied';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."APPLIED_TIME" IS 'Time at which the APPLIED_MESSAGE_NUMBER message was applied';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."APPLIED_MESSAGE_CREATE_TIME" IS 'Time at which the APPLIED_MESSAGE_NUMBER message was created';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."SOURCE_DATABASE" IS 'Database where the transaction originated';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."SOURCE_ROOT_NAME" IS 'Root database where all transactions originated';
   COMMENT ON COLUMN "SYS"."ALL_GG_INBOUND_PROGRESS"."LOGBSN" IS 'Log BSN value from the GoldenGate trail file'
;
--------------------------------------------------------
--  DDL for View ALL_GOLDENGATE_CONTAINER_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_GOLDENGATE_CONTAINER_RULES" ("RULE_ID", "CAPTURE_NAME", "FILTER_RULE", "INCLUDE_RULE", "ESCAPE_CHAR") AS 
  select r."RULE_ID",r."CAPTURE_NAME",r."FILTER_RULE",r."INCLUDE_RULE",r."ESCAPE_CHAR"
  from dba_goldengate_container_rules r, all_capture c
 where r.capture_name = c.capture_name;

   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_CONTAINER_RULES"."RULE_ID" IS 'Rule identifier';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_CONTAINER_RULES"."CAPTURE_NAME" IS 'Capture instance name';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_CONTAINER_RULES"."FILTER_RULE" IS 'Wilcard card expression for inclusion or exclusion';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_CONTAINER_RULES"."INCLUDE_RULE" IS 'Whether an inclusion or exclusion rule';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_CONTAINER_RULES"."ESCAPE_CHAR" IS 'Escape character used in the filter rule';
   COMMENT ON TABLE "SYS"."ALL_GOLDENGATE_CONTAINER_RULES"  IS 'Details about goldengate container inclusion/exclusion rules visible to user'
;
--------------------------------------------------------
--  DDL for View ALL_GOLDENGATE_INBOUND
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_GOLDENGATE_INBOUND" ("REPLICAT_NAME", "SERVER_NAME", "APPLY_USER", "USER_COMMENT", "CREATE_DATE", "STATUS") AS 
  select ib."REPLICAT_NAME",ib."SERVER_NAME",ib."APPLY_USER",ib."USER_COMMENT",ib."CREATE_DATE",ib."STATUS"
from dba_goldengate_inbound ib, all_apply a
   where a.apply_name = ib.server_name;

   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_INBOUND"."SERVER_NAME" IS 'Name of the inbound server';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_INBOUND"."APPLY_USER" IS 'Name of the user who is applying the messages';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_INBOUND"."USER_COMMENT" IS 'User comment';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_INBOUND"."CREATE_DATE" IS 'Date when inbound server was created';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_INBOUND"."STATUS" IS 'Status of the apply process: DISABLED, ABORTED, ATTACHED, DETACHED';
   COMMENT ON TABLE "SYS"."ALL_GOLDENGATE_INBOUND"  IS 'Details about the XStream inbound server visible to user'
;
--------------------------------------------------------
--  DDL for View ALL_GOLDENGATE_PRIVILEGES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_GOLDENGATE_PRIVILEGES" ("USERNAME", "PRIVILEGE_TYPE", "GRANT_SELECT_PRIVILEGES", "CREATE_TIME") AS 
  (select gp."USERNAME",gp."PRIVILEGE_TYPE",gp."GRANT_SELECT_PRIVILEGES",gp."CREATE_TIME"
  from DBA_GOLDENGATE_PRIVILEGES gp, sys.user$ u, dba_role_privs rp
  where ((gp.username = u.name) and  (u.user# = userenv('SCHEMAID')))
union
select gp."USERNAME",gp."PRIVILEGE_TYPE",gp."GRANT_SELECT_PRIVILEGES",gp."CREATE_TIME"
  from DBA_GOLDENGATE_PRIVILEGES gp, sys.user$ u, dba_role_privs rp
  where (u.name = rp.grantee
        and rp.granted_role = 'SELECT_CATALOG_ROLE'
        and u.user# = userenv('SCHEMAID')));

   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_PRIVILEGES"."USERNAME" IS 'Name of the user that is granted the privilege';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_PRIVILEGES"."PRIVILEGE_TYPE" IS 'Type of privilege granted';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_PRIVILEGES"."GRANT_SELECT_PRIVILEGES" IS 'Whether to grant select privileges';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_PRIVILEGES"."CREATE_TIME" IS 'Timestamp for the granted privilege';
   COMMENT ON TABLE "SYS"."ALL_GOLDENGATE_PRIVILEGES"  IS 'Details about goldengate privileges for the user'
;
--------------------------------------------------------
--  DDL for View ALL_GOLDENGATE_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_GOLDENGATE_RULES" ("COMPONENT_NAME", "COMPONENT_TYPE", "COMPONENT_RULE_TYPE", "RULE_SET_OWNER", "RULE_SET_NAME", "RULE_SET_TYPE", "RULE_OWNER", "RULE_NAME", "RULE_TYPE", "RULE_CONDITION", "SCHEMA_NAME", "OBJECT_NAME", "INCLUDE_TAGGED_LCR", "SUBSETTING_OPERATION", "DML_CONDITION", "SOURCE_DATABASE", "ORIGINAL_RULE_CONDITION", "SAME_RULE_CONDITION", "SOURCE_ROOT_NAME", "SOURCE_CONTAINER_NAME") AS 
  select r."COMPONENT_NAME",r."COMPONENT_TYPE",r."COMPONENT_RULE_TYPE",r."RULE_SET_OWNER",r."RULE_SET_NAME",r."RULE_SET_TYPE",r."RULE_OWNER",r."RULE_NAME",r."RULE_TYPE",r."RULE_CONDITION",r."SCHEMA_NAME",r."OBJECT_NAME",r."INCLUDE_TAGGED_LCR",r."SUBSETTING_OPERATION",r."DML_CONDITION",r."SOURCE_DATABASE",r."ORIGINAL_RULE_CONDITION",r."SAME_RULE_CONDITION",r."SOURCE_ROOT_NAME",r."SOURCE_CONTAINER_NAME"
  from dba_goldengate_rules r, "_ALL_STREAMS_PROCESSES" p
where r.component_type = p.streams_type
  and r.component_name = p.streams_name;

   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."COMPONENT_NAME" IS 'Name of the GoldenGate process';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."COMPONENT_TYPE" IS 'Type of the GoldenGate process: CAPTURE or APPLY';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."COMPONENT_RULE_TYPE" IS 'For global, schema or table rules, type of rule: TABLE, SCHEMA or GLOBAL';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."RULE_SET_NAME" IS 'Name of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."RULE_SET_TYPE" IS 'Type of the rule set: POSITIVE or NEGATIVE';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."RULE_TYPE" IS 'For global, schema or table rules, type of rule: DML, DDL or PROCEDURE';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."RULE_CONDITION" IS 'Current rule condition';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."SCHEMA_NAME" IS 'For table and schema rules, the schema name';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."OBJECT_NAME" IS 'For table rules, the table name';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."INCLUDE_TAGGED_LCR" IS 'For global, schema or table rules, whether or not to include tagged LCRs';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."SUBSETTING_OPERATION" IS 'For subset rules, the type of operation: INSERT, UPDATE, or DELETE';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."DML_CONDITION" IS 'For subset rules, the row subsetting condition';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."SOURCE_DATABASE" IS 'For global, schema or table rules, the name of the database where the LCRs originated';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."ORIGINAL_RULE_CONDITION" IS 'For rules created by GoldenGate administrative APIs, the original rule condition when the rule was created';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."SAME_RULE_CONDITION" IS 'For rules created by GoldenGate administrative APIs, whether or not the current rule condition is the same as the original rule condition';
   COMMENT ON COLUMN "SYS"."ALL_GOLDENGATE_RULES"."SOURCE_ROOT_NAME" IS 'Root Database where the transactions originated';
   COMMENT ON TABLE "SYS"."ALL_GOLDENGATE_RULES"  IS 'Details about the GoldenGate server rules visible to user'
;
--------------------------------------------------------
--  DDL for View ALL_HEAT_MAP_SEG_HISTOGRAM
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HEAT_MAP_SEG_HISTOGRAM" ("OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "TRACK_TIME", "SEGMENT_WRITE", "FULL_SCAN", "LOOKUP_SCAN") AS 
  select u.name, o.name, o.subname, s.track_time,
          s.segment_write, s.full_scan, s.lookup_scan
from sys.obj$ o, sys.user$ u, sys."_SYS_HEAT_MAP_SEG_HISTOGRAM" s
where o.owner# = u.user#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or ora_check_SYS_privilege (o.owner#, o.type#) = 1
       )
  and o.obj# = s.obj#
order by s.obj#;

   COMMENT ON COLUMN "SYS"."ALL_HEAT_MAP_SEG_HISTOGRAM"."TRACK_TIME" IS 'System time when the segment access was tracked';
   COMMENT ON COLUMN "SYS"."ALL_HEAT_MAP_SEG_HISTOGRAM"."SEGMENT_WRITE" IS 'Segment has write access YES/NO';
   COMMENT ON COLUMN "SYS"."ALL_HEAT_MAP_SEG_HISTOGRAM"."FULL_SCAN" IS 'Segment has full scan YES/NO';
   COMMENT ON COLUMN "SYS"."ALL_HEAT_MAP_SEG_HISTOGRAM"."LOOKUP_SCAN" IS 'Segment has lookup scan YES/NO';
   COMMENT ON TABLE "SYS"."ALL_HEAT_MAP_SEG_HISTOGRAM"  IS 'Segment access information for all segments visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_HEAT_MAP_SEGMENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HEAT_MAP_SEGMENT" ("OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "SEGMENT_WRITE_TIME", "SEGMENT_READ_TIME", "FULL_SCAN", "LOOKUP_SCAN") AS 
  select u.name, o.name, o.subname,
    max (decode (hm.segment_write, 'YES', track_time, null)) SEGMENT_WRITE_TIME,
    max (decode (hm.segment_read, 'YES', track_time, null)) SEGMENT_READ_TIME,
    max (decode (hm.full_scan, 'YES', track_time, null)) FULL_SCAN,
    max (decode (hm.lookup_scan, 'YES', track_time, null)) LOOKUP_SCAN
from obj$ o, user$ u, sys."_SYS_HEAT_MAP_SEG_HISTOGRAM" hm
where o.obj# = hm.obj#
and   o.owner# = u.user#
and   (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or ora_check_SYS_privilege (o.owner#, o.type#) = 1
       )
group by u.name, o.name, o.subname;

   COMMENT ON COLUMN "SYS"."ALL_HEAT_MAP_SEGMENT"."SEGMENT_WRITE_TIME" IS 'Last segment write access time';
   COMMENT ON COLUMN "SYS"."ALL_HEAT_MAP_SEGMENT"."SEGMENT_READ_TIME" IS 'Last segment read access time';
   COMMENT ON COLUMN "SYS"."ALL_HEAT_MAP_SEGMENT"."FULL_SCAN" IS 'Last full scan time';
   COMMENT ON COLUMN "SYS"."ALL_HEAT_MAP_SEGMENT"."LOOKUP_SCAN" IS 'Last range scan or point scan access time';
   COMMENT ON TABLE "SYS"."ALL_HEAT_MAP_SEGMENT"  IS 'Users segment last access time'
;
--------------------------------------------------------
--  DDL for View ALL_HIERARCHIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HIERARCHIES" ("OWNER", "HIER_NAME", "DIMENSION_OWNER", "DIMENSION_NAME", "PARENT_ATTR", "COMPILE_STATE", "ORIGIN_CON_ID") AS 
  select OWNER,
       HIER_NAME,
       DIMENSION_OWNER,
       DIMENSION_NAME,
       --da.attr_name PARENT_ATTR,
       PARENT_ATTR,
       COMPILE_STATE,
     --DECODE(h.val_state, 1, 'VALID', 2, 'NEEDS_VALIDATE', 3, 'ERROR') VALID_STATE,
     origin_con_id
from INT$DBA_HIERARCHIES
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, HIER_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_HIERARCHIES"."OWNER" IS 'Owner of the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_HIERARCHIES"."HIER_NAME" IS 'Name of the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_HIERARCHIES"."DIMENSION_OWNER" IS 'Owner of the base attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_HIERARCHIES"."DIMENSION_NAME" IS 'Name of the base attribute dimension';
   COMMENT ON COLUMN "SYS"."ALL_HIERARCHIES"."PARENT_ATTR" IS 'Name of the attribute representing parent for a parent-child hierarchy,
 NULL for level hierarchies';
   COMMENT ON COLUMN "SYS"."ALL_HIERARCHIES"."COMPILE_STATE" IS 'Compile state of the Hierarchy: N/A, VALID, or INVALID';
   COMMENT ON COLUMN "SYS"."ALL_HIERARCHIES"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_HIERARCHIES"  IS 'Hierarchies in the database'
;
--------------------------------------------------------
--  DDL for View ALL_HIER_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HIER_CLASS" ("OWNER", "HIER_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       hier_name,
       classification,
       value,
       language,
       order_num,
       ORIGIN_CON_ID
from INT$DBA_HIER_CLASS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, HIER_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_HIER_CLASS"."OWNER" IS 'Owner of the Hierarchy  classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_CLASS"."HIER_NAME" IS 'Hierarchy name of owning Hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_CLASS"."CLASSIFICATION" IS 'Name of Hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_CLASS"."VALUE" IS 'Value of Hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_CLASS"."LANGUAGE" IS 'Language of Hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_CLASS"."ORDER_NUM" IS 'Order number of Hierarchy classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_HIER_CLASS"  IS 'Hierarchy classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_HIER_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HIER_COLUMNS" ("OWNER", "HIER_NAME", "COLUMN_NAME", "ROLE", "DATA_TYPE", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "NULLABLE", "CHARACTER_SET_NAME", "CHAR_COL_DECL_LENGTH", "CHAR_USED", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       HIER_NAME,
       COLUMN_NAME,
       ROLE,
       DATA_TYPE,
       DATA_LENGTH,
       DATA_PRECISION,
       DATA_SCALE,
       NULLABLE,
       CHARACTER_SET_NAME,
       CHAR_COL_DECL_LENGTH,
       CHAR_USED,
       --DATA_TYPE_MOD,
       --DATA_TYPE_OWNER,
       --CHAR_LENGTH,
       --COLLATION,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_HIER_COLUMNS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, HIER_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."OWNER" IS 'Owner of hierarchy in the database';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."HIER_NAME" IS 'Name of hierarchy in the database';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."ROLE" IS 'The role the attribute plays in the hierarchy.  One of: KEY, AKEY, or PROP';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."DATA_TYPE" IS 'Datatype of the column';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."DATA_LENGTH" IS 'Length of the column (in bytes)';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."DATA_PRECISION" IS 'Decimal precision for NUMBER datatype; binary precision for
 FLOAT datatype, NULL for all other datatypes';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."DATA_SCALE" IS 'Digits to right of decimal point in a number';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."CHARACTER_SET_NAME" IS 'Name of the character set: CHAR_CS or NCHAR_CS';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."CHAR_COL_DECL_LENGTH" IS 'Declaration length of character type column';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."CHAR_USED" IS 'B or C.  B indicates that the column uses BYTE length semantics.
 C indicates that the column uses CHAR length semantics. NULL indicates
 the datatype is not any of the following: CHAR, VARCHAR2, NCHAR, NVARCHAR2';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."ORDER_NUM" IS 'Order of the column, with attributes first in the order of creation
 followed by hierarchical attributes.';
   COMMENT ON COLUMN "SYS"."ALL_HIER_COLUMNS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_HIER_COLUMNS"  IS 'Hierarchy columns in the database'
;
--------------------------------------------------------
--  DDL for View ALL_HIER_HIER_ATTR_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HIER_HIER_ATTR_CLASS" ("OWNER", "HIER_NAME", "HIER_ATTR_NAME", "CLASSIFICATION", "VALUE", "LANGUAGE", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       hier_name,
       HIER_ATTR_NAME,
       classification,
       value,
       language,
       order_num,
       origin_con_id
from INT$DBA_HIER_HIER_ATTR_CLASS
where  OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, HIER_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTR_CLASS"."OWNER" IS 'Owner of the hierarchical attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTR_CLASS"."HIER_NAME" IS 'Name of owning hierarchy of the hierarchical attribute';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTR_CLASS"."HIER_ATTR_NAME" IS 'Name of owning hierarchical attribute of the classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTR_CLASS"."CLASSIFICATION" IS 'Name of hierarchical attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTR_CLASS"."VALUE" IS 'Value of hierarchical attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTR_CLASS"."LANGUAGE" IS 'Language of hierarchical attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTR_CLASS"."ORDER_NUM" IS 'Order number of hierarchical attribute classification';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTR_CLASS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_HIER_HIER_ATTR_CLASS"  IS 'Hierarchical attribute classifications in the database'
;
--------------------------------------------------------
--  DDL for View ALL_HIER_HIER_ATTRIBUTES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HIER_HIER_ATTRIBUTES" ("OWNER", "HIER_NAME", "HIER_ATTR_NAME", "EXPRESSION", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select owner,
       hier_name,
       HIER_ATTR_NAME,
       EXPRESSION,
       ORDER_NUM,
       origin_con_id
from INT$DBA_HIER_HIER_ATTRIBUTES
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, HIER_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTRIBUTES"."OWNER" IS 'Owner of the Hierarchical Attribute';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTRIBUTES"."HIER_NAME" IS 'Name of the owning Hierarchy of the Hierarchical Attribute';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTRIBUTES"."HIER_ATTR_NAME" IS 'Name of the Hierarchical Attribute';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTRIBUTES"."EXPRESSION" IS 'Expression defining the hierarchical attribute';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTRIBUTES"."ORDER_NUM" IS 'Order number of Hierarchical Attribute within the Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_HIER_HIER_ATTRIBUTES"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_HIER_HIER_ATTRIBUTES"  IS 'attribute dimension Attributes in the database'
;
--------------------------------------------------------
--  DDL for View ALL_HIER_JOIN_PATHS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HIER_JOIN_PATHS" ("OWNER", "HIER_NAME", "JOIN_PATH_NAME", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       HIER_NAME,
       JOIN_PATH_NAME,
       ORDER_NUM,
       ORIGIN_CON_ID
from   INT$DBA_HIER_JOIN_PATHS
where  OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, HIER_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_HIER_JOIN_PATHS"."OWNER" IS 'Owner of the hierarchy join path';
   COMMENT ON COLUMN "SYS"."ALL_HIER_JOIN_PATHS"."HIER_NAME" IS 'Name of the owning hierarchy join path';
   COMMENT ON COLUMN "SYS"."ALL_HIER_JOIN_PATHS"."JOIN_PATH_NAME" IS 'Name of the hierarchy join path';
   COMMENT ON COLUMN "SYS"."ALL_HIER_JOIN_PATHS"."ORDER_NUM" IS 'Order number of join path within the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_HIER_JOIN_PATHS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_HIER_JOIN_PATHS"  IS 'Hierarchy join paths in the database'
;
--------------------------------------------------------
--  DDL for View ALL_HIER_LEVEL_ID_ATTRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HIER_LEVEL_ID_ATTRS" ("OWNER", "HIER_NAME", "LEVEL_NAME", "ATTRIBUTE_NAME", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       HIER_NAME,
       LEVEL_NAME,
       ATTRIBUTE_NAME,
       ORDER_NUM,
       ORIGIN_CON_ID
from INT$DBA_HIER_LEVEL_ID_ATTRS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, HIER_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVEL_ID_ATTRS"."OWNER" IS 'Owner of the Hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVEL_ID_ATTRS"."HIER_NAME" IS 'Name of owning Hierarchy in the database';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVEL_ID_ATTRS"."LEVEL_NAME" IS 'Name of Hierarchy Level in the database';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVEL_ID_ATTRS"."ATTRIBUTE_NAME" IS 'Name of Attribute in the database';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVEL_ID_ATTRS"."ORDER_NUM" IS 'Order number of Attribute in the sequence';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVEL_ID_ATTRS"."ORIGIN_CON_ID" IS 'Original CON_ID of Attribute in the sequence';
   COMMENT ON TABLE "SYS"."ALL_HIER_LEVEL_ID_ATTRS"  IS 'Hierarchy Level ID Attributes in the database'
;
--------------------------------------------------------
--  DDL for View ALL_HIER_LEVELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_HIER_LEVELS" ("OWNER", "HIER_NAME", "LEVEL_NAME", "ORDER_NUM", "ORIGIN_CON_ID") AS 
  select OWNER,
       HIER_NAME,
       LEVEL_NAME,
       ORDER_NUM,
       origin_con_id
from INT$DBA_HIER_LEVELS
where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER='PUBLIC'
       or OBJ_ID(OWNER, HIER_NAME, OBJECT_TYPE, OBJECT_ID) in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or ora_check_sys_privilege(owner_id, object_type) = 1;

   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVELS"."OWNER" IS 'Owner of the hierarchy';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVELS"."HIER_NAME" IS 'Name of owning hierarchy in the database';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVELS"."LEVEL_NAME" IS 'Name of hierarchy level in the database';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVELS"."ORDER_NUM" IS 'Order number of hierarchy level in the sequence';
   COMMENT ON COLUMN "SYS"."ALL_HIER_LEVELS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_HIER_LEVELS"  IS 'Hierarchy levels in the database'
;
--------------------------------------------------------
--  DDL for View ALL_IDENTIFIERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_IDENTIFIERS" ("OWNER", "NAME", "SIGNATURE", "TYPE", "OBJECT_NAME", "OBJECT_TYPE", "USAGE", "USAGE_ID", "LINE", "COL", "USAGE_CONTEXT_ID", "CHARACTER_SET", "ATTRIBUTE", "CHAR_USED", "LENGTH", "PRECISION", "PRECISION2", "SCALE", "LOWER_RANGE", "UPPER_RANGE", "NULL_CONSTRAINT", "SQL_BUILTIN", "ORIGIN_CON_ID") AS 
  select OWNER, NAME, SIGNATURE, TYPE, OBJECT_NAME, OBJECT_TYPE,
       USAGE, USAGE_ID, LINE, COL, USAGE_CONTEXT_ID, CHARACTER_SET,
       ATTRIBUTE, CHAR_USED, LENGTH, PRECISION, PRECISION2, SCALE,
       LOWER_RANGE, UPPER_RANGE, NULL_CONSTRAINT, SQL_BUILTIN,
       ORIGIN_CON_ID
from INT$DBA_IDENTIFIERS
where
  (
    OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
    or OWNER = 'PUBLIC'
    or
    (
      (
         (
          (OBJECT_TYPE#
           in (7 /* proc */, 8 /* func */, 9 /* pkg */, 13 /* type */,
               22 /* library */))
          and
          OBJ_ID(OWNER, OBJECT_NAME, OBJECT_TYPE#, OBJECT_ID) in
          (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        )
        or
        (
          (OBJECT_TYPE# in (2 /* table */, 4 /* view */))
          and
          OBJ_ID(OWNER, OBJECT_NAME, OBJECT_TYPE#, OBJECT_ID) in
          (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (0 /* ALTER */, 6 /* INSERT */,
                                          9 /* SELECT */, 10 /* UPDATE */))
        )
        or
        (
          (OBJECT_TYPE# in (6 /* sequence */))
          and
          OBJ_ID(OWNER, OBJECT_NAME, OBJECT_TYPE#, OBJECT_ID) in
          (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (0 /* ALTER */, 9 /* SELECT */))
        )
        or
        (
          (OBJECT_TYPE# in (11 /* package body */, 14 /* type body */))
          and
          exists
          (
            select null from sys.obj$ specobj, sys.objauth$ oa, sys.user$ u
            where specobj.owner# = u.user#
              and u.name = OWNER
              and specobj.name = OBJECT_NAME
              and specobj.type# = decode(OBJECT_TYPE#,
                                         11 /* pkg body */, 9 /* pkg */,
                                         14 /* type body */, 13 /* type */,
                                         null)
              and oa.obj# = specobj.obj#
              and oa.grantee# in (select kzsrorol from x$kzsro)
              and oa.privilege# = 26 /* DEBUG */)
        )
        or
        (
          (OBJECT_TYPE# = 12 /* trigger */)
          and
          exists
          (
            select null
            from sys.trigger$ t, sys.obj$ tabobj, sys.objauth$ oa, sys.user$ u
            where t.obj# = OBJ_ID(OWNER, OBJECT_NAME, 12, OBJECT_ID)
              and tabobj.obj# = t.baseobject
              and tabobj.owner# = u.user#
              and u.name = OWNER
              and oa.obj# = tabobj.obj#
              and oa.grantee# in (select kzsrorol from x$kzsro)
              and oa.privilege# = 26 /* DEBUG */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (OBJECT_TYPE# = 7 or OBJECT_TYPE# = 8 or OBJECT_TYPE# = 9)
              and
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* package body */
              OBJECT_TYPE# = 11 and
              (
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type */
              OBJECT_TYPE# = 13
              and
              (
                privilege# = -184 /* EXECUTE ANY TYPE */
                or
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type body */
              OBJECT_TYPE# = 14 and
              (
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* triggers */
              OBJECT_TYPE# = 12 and
              (
                privilege# = -152 /* CREATE ANY TRIGGER */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* library */
              OBJECT_TYPE# = 22 and
              (
                privilege# = -189 /* CREATE ANY LIBRARY */
                or
                privilege# = -192 /* EXECUTE ANY LIBRARY */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."NAME" IS 'Name of the identifier';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."SIGNATURE" IS 'Signature of the identifier';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."TYPE" IS 'Type of the identifier';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."OBJECT_NAME" IS 'Name of the object where the identifier usage occurred';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."OBJECT_TYPE" IS 'Type of the object where the identifier usage occurred';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."USAGE" IS 'Type of the identifier usage';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."USAGE_ID" IS 'Unique key for an identifier usage within the object';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."LINE" IS 'Line number of the identifier usage';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."COL" IS 'Column number of the identifier usage';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."USAGE_CONTEXT_ID" IS 'Context USAGE_ID of an identifier usage';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."CHARACTER_SET" IS 'Character set of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."ATTRIBUTE" IS 'Attribute of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."CHAR_USED" IS 'When applicable, CHAR if a length was specified in characters, BTYE otherwise';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."LENGTH" IS 'Length constraint of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."PRECISION" IS 'Precision constraint of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."PRECISION2" IS 'Second precision constraint of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."SCALE" IS 'Scale precision constraint of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."LOWER_RANGE" IS 'Lower range constraint of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."UPPER_RANGE" IS 'Upper range constraint of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."NULL_CONSTRAINT" IS 'NULL/NOT_NULL constraint of the identifier when supplied';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."SQL_BUILTIN" IS 'Is the identifier a SQL builtin mapped to a STANDARD function';
   COMMENT ON COLUMN "SYS"."ALL_IDENTIFIERS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_IDENTIFIERS"  IS 'All identifiers in stored objects accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_IND_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_IND_COLUMNS" ("INDEX_OWNER", "INDEX_NAME", "TABLE_OWNER", "TABLE_NAME", "COLUMN_NAME", "COLUMN_POSITION", "COLUMN_LENGTH", "CHAR_LENGTH", "DESCEND", "COLLATED_COLUMN_ID") AS 
  select
     INDEX_OWNER, INDEX_NAME,
     TABLE_OWNER, TABLE_NAME,
     COLUMN_NAME, COLUMN_POSITION, COLUMN_LENGTH,
     CHAR_LENGTH, DESCEND, COLLATED_COLUMN_ID
from all_ind_columns_v$;

   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."INDEX_OWNER" IS 'Index owner';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."INDEX_NAME" IS 'Index name';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."TABLE_OWNER" IS 'Table or cluster owner';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."TABLE_NAME" IS 'Table or cluster name';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."COLUMN_NAME" IS 'Column name or attribute of object column';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."COLUMN_POSITION" IS 'Position of column or attribute within index';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."COLUMN_LENGTH" IS 'Maximum length of the column or attribute, in bytes';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."CHAR_LENGTH" IS 'Maximum length of the column or attribute, in characters';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."DESCEND" IS 'DESC if this column is sorted in descending order on disk, otherwise ASC';
   COMMENT ON COLUMN "SYS"."ALL_IND_COLUMNS"."COLLATED_COLUMN_ID" IS 'Reference to the actual collated column''s internal sequence number';
   COMMENT ON TABLE "SYS"."ALL_IND_COLUMNS"  IS 'COLUMNs comprising INDEXes on accessible TABLES'
;
--------------------------------------------------------
--  DDL for View ALL_IND_COLUMNS_V$
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_IND_COLUMNS_V$" ("INDEX_OWNER", "INDEX_NAME", "TABLE_OWNER", "TABLE_NAME", "COLUMN_NAME", "COLUMN_POSITION", "COLUMN_LENGTH", "CHAR_LENGTH", "DESCEND", "COLLATED_COLUMN_ID") AS 
  select io.name, idx.name, bo.name, base.name,
       decode(bitand(c.property, 1024), 1024,
              (select decode(bitand(tc.property, 1), 1, ac.name, tc.name)
              from sys.col$ tc, attrcol$ ac
              where tc.intcol# = c.intcol#-1
                and tc.obj# = c.obj#
                and tc.obj# = ac.obj#(+)
                and tc.intcol# = ac.intcol#(+)),
              decode(ac.name, null, c.name, ac.name)),
       ic.pos#, c.length, c.spare3,
       decode(bitand(c.property, 131072), 131072, 'DESC', 'ASC'),
  c.collintcol#
from sys.col$ c, sys.obj$ idx, sys.obj$ base, sys.icol$ ic,
     sys.user$ io, sys.user$ bo, sys.ind$ i, sys.attrcol$ ac
where ic.bo# = c.obj#
  and decode(bitand(i.property,1024),0,ic.intcol#,ic.spare2) = c.intcol#
  and ic.bo# = base.obj#
  and io.user# = idx.owner#
  and bo.user# = base.owner#
  and ic.obj# = idx.obj#
  and idx.obj# = i.obj#
  and i.type# in (1, 2, 3, 4, 6, 7, 9)
  and c.obj# = ac.obj#(+)
  and c.intcol# = ac.intcol#(+)
  and (base.type# != 2 or 1 = (select 1 /* Exclude Binary XML Token set indexes */
           from sys.tab$ t
           where base.obj# = t.obj#
             and (bitand(t.property, power(2,65)) = 0 or t.property is null)))
  and (idx.owner# = userenv('SCHEMAID') or
       base.owner# = userenv('SCHEMAID')
       or
       base.obj# in ( select obj#
                     from sys.objauth$
                     where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                   )
        or
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       )
  
;
--------------------------------------------------------
--  DDL for View ALL_INDEXES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_INDEXES" ("OWNER", "INDEX_NAME", "INDEX_TYPE", "TABLE_OWNER", "TABLE_NAME", "TABLE_TYPE", "UNIQUENESS", "COMPRESSION", "PREFIX_LENGTH", "TABLESPACE_NAME", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENTS", "MAX_EXTENTS", "PCT_INCREASE", "PCT_THRESHOLD", "INCLUDE_COLUMN", "FREELISTS", "FREELIST_GROUPS", "PCT_FREE", "LOGGING", "BLEVEL", "LEAF_BLOCKS", "DISTINCT_KEYS", "AVG_LEAF_BLOCKS_PER_KEY", "AVG_DATA_BLOCKS_PER_KEY", "CLUSTERING_FACTOR", "STATUS", "NUM_ROWS", "SAMPLE_SIZE", "LAST_ANALYZED", "DEGREE", "INSTANCES", "PARTITIONED", "TEMPORARY", "GENERATED", "SECONDARY", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "USER_STATS", "DURATION", "PCT_DIRECT_ACCESS", "ITYP_OWNER", "ITYP_NAME", "PARAMETERS", "GLOBAL_STATS", "DOMIDX_STATUS", "DOMIDX_OPSTATUS", "FUNCIDX_STATUS", "JOIN_INDEX", "IOT_REDUNDANT_PKEY_ELIM", "DROPPED", "VISIBILITY", "DOMIDX_MANAGEMENT", "SEGMENT_CREATED", "ORPHANED_ENTRIES", "INDEXING") AS 
  select u.name, o.name,
       decode(bitand(i.property, 16), 0, '', 'FUNCTION-BASED ') ||
        decode(i.type#, 1, 'NORMAL'||
                          decode(bitand(i.property, 4), 0, '', 4, '/REV'),
                      2, 'BITMAP', 3, 'CLUSTER', 4, 'IOT - TOP',
                      5, 'IOT - NESTED', 6, 'SECONDARY', 7, 'ANSI', 8, 'LOB',
                      9, 'DOMAIN'),
       iu.name, io.name, 'TABLE',
       decode(bitand(i.property, 1), 0, 'NONUNIQUE', 1, 'UNIQUE', 'UNDEFINED'),
       decode(bitand(i.flags, 1073741824), 1073741824, 'ADVANCED HIGH',
              decode(bitand(i.flags, 32), 0, 'DISABLED',
                     decode(bitand(i.flags, 2147483648), 0, 'ENABLED',
                            2147483648, 'ADVANCED LOW'))),
       i.spare2,
       decode(bitand(i.property, 34), 0, decode(i.type#, 9, null, ts.name),
           2, null, decode(i.ts#, 0, null, ts.name)),
       decode(bitand(i.property, 2),0, i.initrans, null),
       decode(bitand(i.property, 2),0, i.maxtrans, null),
       decode(bitand(i.flags, 67108864), 67108864,
                     ds.initial_stg * ts.blocksize,
                     s.iniexts * ts.blocksize),
       decode(bitand(i.flags, 67108864), 67108864,
              ds.next_stg * ts.blocksize,
              s.extsize * ts.blocksize),
       decode(bitand(i.flags, 67108864), 67108864,
              ds.minext_stg, s.minexts),
       decode(bitand(i.flags, 67108864), 67108864,
              ds.maxext_stg, s.maxexts),
       decode(bitand(ts.flags, 3), 1, to_number(NULL),
              decode(bitand(i.flags, 67108864), 67108864,
                            ds.pctinc_stg, s.extpct)),
       decode(i.type#, 4, mod(i.pctthres$,256), NULL), i.trunccnt,
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
       decode(bitand(o.flags, 2), 2, 1,
              decode(bitand(i.flags, 67108864), 67108864,
                     decode(ds.frlins_stg, 0, 1, ds.frlins_stg),
                     decode(s.lists, 0, 1, s.lists)))),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(o.flags, 2), 2, 1,
                     decode(bitand(i.flags, 67108864), 67108864,
                            decode(ds.maxins_stg, 0, 1, ds.maxins_stg),
                            decode(s.groups, 0, 1, s.groups)))),
       decode(bitand(i.property, 2),0,i.pctfree$,null),
       decode(bitand(i.property, 2), 2, NULL,
                decode(bitand(i.flags, 4), 0, 'YES', 'NO')),
       i.blevel, i.leafcnt, i.distkey, i.lblkkey, i.dblkkey, i.clufac,
       decode(bitand(i.property, 2), 2,
                   decode(i.type#, 9, decode(bitand(i.flags, 8),
                                        8, 'INPROGRS', 'VALID'), 'N/A'),
                     decode(bitand(i.flags, 1), 1, 'UNUSABLE',
                            decode(bitand(i.flags, 8), 8, 'INRPOGRS',
                                                            'VALID'))),
       rowcnt, samplesize, analyzetime,
       decode(i.degree, 32767, 'DEFAULT', nvl(i.degree,1)),
       decode(i.instances, 32767, 'DEFAULT', nvl(i.instances,1)),
       decode(bitand(i.property, 2), 2, 'YES', 'NO'),
       decode(bitand(o.flags, 2), 0, 'N', 2, 'Y', 'N'),
       decode(bitand(o.flags, 4), 0, 'N', 4, 'Y', 'N'),
       decode(bitand(o.flags, 16), 0, 'N', 16, 'Y', 'N'),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
              decode(bitand(decode(bitand(i.flags, 67108864), 67108864,
                            ds.bfp_stg, s.cachehint), 3),
                            1, 'KEEP', 2, 'RECYCLE', 'DEFAULT')),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
              decode(bitand(decode(bitand(i.flags, 67108864), 67108864,
                            ds.bfp_stg, s.cachehint), 12)/4,
                            1, 'KEEP', 2, 'NONE', 'DEFAULT')),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
              decode(bitand(decode(bitand(i.flags, 67108864), 67108864,
                            ds.bfp_stg, s.cachehint), 48)/16,
                            1, 'KEEP', 2, 'NONE', 'DEFAULT')),
       decode(bitand(i.flags, 64), 0, 'NO', 'YES'),
       decode(bitand(o.flags, 2), 0, NULL,
           decode(bitand(i.property, 64), 64, 'SYS$SESSION', 'SYS$TRANSACTION')),
       decode(bitand(i.flags, 128), 128, mod(trunc(i.pctthres$/256),256),
              decode(i.type#, 4, mod(trunc(i.pctthres$/256),256), NULL)),
       itu.name, ito.name, i.spare4,
       decode(bitand(i.flags, 2048), 0, 'NO', 'YES'),
       decode(i.type#, 9, decode(o.status, 5, 'IDXTYP_INVLD',
                                           1, 'VALID'),  ''),
       decode(i.type#, 9, decode(bitand(i.flags, 16), 16, 'FAILED', 'VALID'), ''),
       decode(bitand(i.property, 16), 0, '',
              decode(bitand(i.flags, 1024), 0, 'ENABLED', 'DISABLED')),
       decode(bitand(i.property, 1024), 1024, 'YES', 'NO'),
       decode(bitand(i.property, 16384), 16384, 'YES', 'NO'),
       decode(bitand(o.flags, 128), 128, 'YES', 'NO'),
       decode(bitand(i.flags,2097152),2097152,'INVISIBLE','VISIBLE'),
       decode(i.type#, 9, decode(bitand(i.property, 2048), 2048,
                               'SYSTEM_MANAGED', 'USER_MANAGED'), ''),
       decode(bitand(i.flags, 67108864), 67108864, 'NO',
              decode(bitand(i.property, 2), 2, 'N/A', 'YES')),
       decode(bitand(i.flags, 268435456), 268435456, 'YES', 'NO'),
       decode(bitand(i.flags, 8388608), 8388608, 'PARTIAL', 'FULL')
from sys.ts$ ts, sys.seg$ s, sys.user$ iu, sys.obj$ io,
     sys.user$ u, sys.ind$ i, sys.obj$ o, sys.user$ itu, sys.obj$ ito,
     sys.deferred_stg$ ds
where u.user# = o.owner#
  and o.obj# = i.obj#
  and i.bo# = io.obj#
  and io.owner# = iu.user#
  and io.type# = 2 /* tables */
  and bitand(i.flags, 4096) = 0
  and bitand(o.flags, 128) = 0
  and i.ts# = ts.ts# (+)
  and i.file# = s.file# (+)
  and i.block# = s.block# (+)
  and i.ts# = s.ts# (+)
  and i.obj# = ds.obj# (+)
  and i.type# in (1, 2, 3, 4, 6, 7, 9)
  and (io.type# != 2 or 1 = (select 1 /* Exclude Binary XML Token set indexes */
           from sys.tab$ t
           where i.bo# = t.obj#
             and (bitand(t.property, power(2,65)) = 0 or t.property is null)))
  and i.indmethod# = ito.obj# (+)
  and ito.owner# = itu.user# (+)
  and (io.owner# = userenv('SCHEMAID')
        or
       io.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
        or
          /* user has system privileges */
        ora_check_sys_privilege ( io.owner#, io.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."OWNER" IS 'Username of the owner of the index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."INDEX_NAME" IS 'Name of the index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."TABLE_OWNER" IS 'Owner of the indexed object';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."TABLE_NAME" IS 'Name of the indexed object';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."TABLE_TYPE" IS 'Type of the indexed object';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."UNIQUENESS" IS 'Uniqueness status of the index: "UNIQUE",  "NONUNIQUE", or "BITMAP"';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."COMPRESSION" IS 'Compression property of the index: "ENABLED",  "DISABLED", or NULL';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."PREFIX_LENGTH" IS 'Number of key columns in the prefix used for compression';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."TABLESPACE_NAME" IS 'Name of the tablespace containing the index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."INI_TRANS" IS 'Initial number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."MAX_TRANS" IS 'Maximum number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."INITIAL_EXTENT" IS 'Size of the initial extent';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."NEXT_EXTENT" IS 'Size of secondary extents';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."MIN_EXTENTS" IS 'Minimum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."MAX_EXTENTS" IS 'Maximum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."PCT_INCREASE" IS 'Percentage increase in extent size';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."PCT_THRESHOLD" IS 'Threshold percentage of block space allowed per index entry';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."INCLUDE_COLUMN" IS 'User column-id for last column to be included in index-organized table top index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."FREELISTS" IS 'Number of process freelists allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."FREELIST_GROUPS" IS 'Number of freelist groups allocated to this segment';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."PCT_FREE" IS 'Minimum percentage of free space in a block';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."LOGGING" IS 'Logging attribute';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."BLEVEL" IS 'B-Tree level';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."LEAF_BLOCKS" IS 'The number of leaf blocks in the index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."DISTINCT_KEYS" IS 'The number of distinct keys in the index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."AVG_LEAF_BLOCKS_PER_KEY" IS 'The average number of leaf blocks per key';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."AVG_DATA_BLOCKS_PER_KEY" IS 'The average number of data blocks per key';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."CLUSTERING_FACTOR" IS 'A measurement of the amount of (dis)order of the table this index is for';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."STATUS" IS 'Whether the non-partitioned index is in USABLE or not';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."SAMPLE_SIZE" IS 'The sample size used in analyzing this index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."LAST_ANALYZED" IS 'The date of the most recent time this index was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."DEGREE" IS 'The number of threads per instance for scanning the partitioned index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."INSTANCES" IS 'The number of instances across which the partitioned index is to be scanned';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."PARTITIONED" IS 'Is this index partitioned? YES or NO';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."TEMPORARY" IS 'Can the current session only see data that it place in this object itself?';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."GENERATED" IS 'Was the name of this index system generated?';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."SECONDARY" IS 'Is the index object created as part of icreate for domain indexes?';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."BUFFER_POOL" IS 'The default buffer pool to be used for index blocks';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."FLASH_CACHE" IS 'The default flash cache hint to be used for index blocks';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."CELL_FLASH_CACHE" IS 'The default cell flash cache hint to be used for index blocks';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."DURATION" IS 'If index on temporary table, then duration is sys$session or sys$transaction else NULL';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."PCT_DIRECT_ACCESS" IS 'If index on IOT, then this is percentage of rows with Valid guess';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."ITYP_OWNER" IS 'If domain index, then this is the indextype owner';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."ITYP_NAME" IS 'If domain index, then this is the name of the associated indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."PARAMETERS" IS 'If domain index, then this is the parameter string';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."DOMIDX_STATUS" IS 'Is the indextype of the domain index valid';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."DOMIDX_OPSTATUS" IS 'Status of the operation on the domain index';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."FUNCIDX_STATUS" IS 'Is the Function-based Index DISABLED or ENABLED?';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."JOIN_INDEX" IS 'Is this index a join index?';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."IOT_REDUNDANT_PKEY_ELIM" IS 'Were redundant primary key columns eliminated from iot secondary index?';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."DROPPED" IS 'Whether index is dropped and is in Recycle Bin';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."VISIBILITY" IS 'Whether the index is VISIBLE or INVISIBLE to the optimizer';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."DOMIDX_MANAGEMENT" IS 'If this a domain index, then whether it is system managed or user managed';
   COMMENT ON COLUMN "SYS"."ALL_INDEXES"."SEGMENT_CREATED" IS 'Whether the index segment has been created';
   COMMENT ON TABLE "SYS"."ALL_INDEXES"  IS 'Descriptions of indexes on tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_IND_EXPRESSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_IND_EXPRESSIONS" ("INDEX_OWNER", "INDEX_NAME", "TABLE_OWNER", "TABLE_NAME", "COLUMN_EXPRESSION", "COLUMN_POSITION") AS 
  select io.name, idx.name, bo.name, base.name, c.default$, ic.pos#
from sys.col$ c, sys.obj$ idx, sys.obj$ base, sys.icol$ ic,
     sys.user$ io, sys.user$ bo, sys.ind$ i
where bitand(ic.spare1,1) = 1       /* an expression */
  and (bitand(i.property,1024) = 0) /* not bmji */
  and ic.bo# = c.obj#
  and ic.intcol# = c.intcol#
  and ic.bo# = base.obj#
  and io.user# = idx.owner#
  and bo.user# = base.owner#
  and ic.obj# = idx.obj#
  and idx.obj# = i.obj#
  and i.type# in (1, 2, 3, 4, 6, 7, 9)
  and (base.type# != 2 or 1 = (select 1 /* Exclude Binary XML Token set indexes */
           from sys.tab$ t
           where i.bo# = t.obj#
             and bitand(t.property, power(2,65)) = 0 or t.property is null))
  and (idx.owner# = userenv('SCHEMAID') or
       base.owner# = userenv('SCHEMAID')
       or
       base.obj# in ( select obj#
                     from sys.objauth$
                     where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                   )
        or
          /* user has system privileges */
        ora_check_sys_privilege ( base.owner#, base.type#) = 1
        or
        ora_check_sys_privilege ( idx.owner#, idx.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_IND_EXPRESSIONS"."INDEX_OWNER" IS 'Index owner';
   COMMENT ON COLUMN "SYS"."ALL_IND_EXPRESSIONS"."INDEX_NAME" IS 'Index name';
   COMMENT ON COLUMN "SYS"."ALL_IND_EXPRESSIONS"."TABLE_OWNER" IS 'Table or cluster owner';
   COMMENT ON COLUMN "SYS"."ALL_IND_EXPRESSIONS"."TABLE_NAME" IS 'Table or cluster name';
   COMMENT ON COLUMN "SYS"."ALL_IND_EXPRESSIONS"."COLUMN_EXPRESSION" IS 'Functional index expression defining the column';
   COMMENT ON COLUMN "SYS"."ALL_IND_EXPRESSIONS"."COLUMN_POSITION" IS 'Position of column or attribute within index';
   COMMENT ON TABLE "SYS"."ALL_IND_EXPRESSIONS"  IS 'FUNCTIONAL INDEX EXPRESSIONs on accessible TABLES'
;
--------------------------------------------------------
--  DDL for View ALL_INDEXTYPE_ARRAYTYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_INDEXTYPE_ARRAYTYPES" ("OWNER", "INDEXTYPE_NAME", "BASE_TYPE_SCHEMA", "BASE_TYPE_NAME", "BASE_TYPE", "ARRAY_TYPE_SCHEMA", "ARRAY_TYPE_NAME") AS 
  select indtypu.name, indtypo.name,
decode(i.type, 121, (select baseu.name from user$ baseu
       where baseo.owner#=baseu.user#), null),
decode(i.type, 121, baseo.name, null),
decode(i.type,  /* DATA_TYPE */
0, null,
1, 'VARCHAR2',
2, 'NUMBER',
3, 'NATIVE INTEGER',
8, 'LONG',
9, 'VARCHAR',
11, 'ROWID',
12, 'DATE',
23, 'RAW',
24, 'LONG RAW',
29, 'BINARY_INTEGER',
69, 'ROWID',
96, 'CHAR',
100, 'BINARY_FLOAT',
101, 'BINARY_DOUBLE',
102, 'REF CURSOR',
104, 'UROWID',
105, 'MLSLABEL',
106, 'MLSLABEL',
110, 'REF',
111, 'REF',
112, 'CLOB',
113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
121, 'OBJECT',
122, 'TABLE',
123, 'VARRAY',
178, 'TIME',
179, 'TIME WITH TIME ZONE',
180, 'TIMESTAMP',
181, 'TIMESTAMP WITH TIME ZONE',
231, 'TIMESTAMP WITH LOCAL TIME ZONE',
182, 'INTERVAL YEAR TO MONTH',
183, 'INTERVAL DAY TO SECOND',
250, 'PL/SQL RECORD',
251, 'PL/SQL TABLE',
252, 'PL/SQL BOOLEAN',
'UNDEFINED'),
arrayu.name, arrayo.name
from sys.user$ indtypu, sys.indarraytype$ i, sys.obj$ indtypo,
sys.obj$ baseo, sys.obj$ arrayo, sys.user$ arrayu
where i.obj# = indtypo.obj# and  indtypu.user# = indtypo.owner# and
      i.basetypeobj# = baseo.obj#(+) and i.arraytypeobj# = arrayo.obj# and
      arrayu.user# = arrayo.owner# and
      ( indtypo.owner# = userenv ('SCHEMAID')
        or
        indtypo.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or
           ora_check_sys_privilege (indtypo.owner#, indtypo.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_ARRAYTYPES"."OWNER" IS 'Owner of the indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_ARRAYTYPES"."INDEXTYPE_NAME" IS 'Name of the indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_ARRAYTYPES"."BASE_TYPE_SCHEMA" IS 'Name of the base type schema';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_ARRAYTYPES"."BASE_TYPE_NAME" IS 'Name of the base type name';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_ARRAYTYPES"."BASE_TYPE" IS 'Datatype of the base type';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_ARRAYTYPES"."ARRAY_TYPE_SCHEMA" IS 'Name of the array type schema';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_ARRAYTYPES"."ARRAY_TYPE_NAME" IS 'Name of the array type name';
   COMMENT ON TABLE "SYS"."ALL_INDEXTYPE_ARRAYTYPES"  IS 'All array types specified by the indextype'
;
--------------------------------------------------------
--  DDL for View ALL_INDEXTYPE_COMMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_INDEXTYPE_COMMENTS" ("OWNER", "INDEXTYPE_NAME", "COMMENTS") AS 
  select  u.name, o.name, c.comment$
from    sys.obj$ o, sys.user$ u, sys.indtypes$ i, sys.com$ c
where   o.obj# = i.obj# and u.user# = o.owner# and c.obj# = i.obj# and
( o.owner# = userenv ('SCHEMAID')
    or
    o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or ora_check_sys_privilege (o.owner#, o.type#) = 1
 );

   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_COMMENTS"."OWNER" IS 'Owner of the user-defined indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_COMMENTS"."INDEXTYPE_NAME" IS 'Name of the user-defined indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_COMMENTS"."COMMENTS" IS 'Comment for the user-defined indextype';
   COMMENT ON TABLE "SYS"."ALL_INDEXTYPE_COMMENTS"  IS 'Comments for user-defined indextypes'
;
--------------------------------------------------------
--  DDL for View ALL_INDEXTYPE_OPERATORS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_INDEXTYPE_OPERATORS" ("OWNER", "INDEXTYPE_NAME", "OPERATOR_SCHEMA", "OPERATOR_NAME", "BINDING#") AS 
  select u.name, o.name, u1.name, op.name, i.bind#
from sys.user$ u, sys.indop$ i, sys.obj$ o,
sys.obj$ op, sys.user$ u1
where i.obj# = o.obj# and i.oper# = op.obj# and
      u.user# = o.owner# and bitand(i.property, 4) != 4 and u1.user#=op.owner# and
      ( o.owner# = userenv ('SCHEMAID')
      or
      o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_OPERATORS"."OWNER" IS 'Owner of the indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_OPERATORS"."INDEXTYPE_NAME" IS 'Name of the indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_OPERATORS"."OPERATOR_SCHEMA" IS 'Name of the operator schema';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_OPERATORS"."OPERATOR_NAME" IS 'Name of the operator for which the indextype is defined';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPE_OPERATORS"."BINDING#" IS 'Binding# associated with the operator';
   COMMENT ON TABLE "SYS"."ALL_INDEXTYPE_OPERATORS"  IS 'All operators available to the user'
;
--------------------------------------------------------
--  DDL for View ALL_INDEXTYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_INDEXTYPES" ("OWNER", "INDEXTYPE_NAME", "IMPLEMENTATION_SCHEMA", "IMPLEMENTATION_NAME", "INTERFACE_VERSION", "IMPLEMENTATION_VERSION", "NUMBER_OF_OPERATORS", "PARTITIONING", "ARRAY_DML", "MAINTENANCE_TYPE") AS 
  select u.name, o.name, u1.name, o1.name, i.interface_version#, t.version#,
io.opcount, decode(bitand(i.property, 48), 0, 'NONE', 16, 'RANGE', 32, 'LOCAL     '),
decode(bitand(i.property, 2), 0, 'NO', 2, 'YES'),
decode(bitand(i.property, 1024), 0, 'USER_MANAGED', 1024, 'SYSTEM_MANAGED')
from sys.indtypes$ i, sys.user$ u, sys.obj$ o,
sys.user$ u1, (select it.obj#, count(*) opcount from
sys.indop$ io1, sys.indtypes$ it where
io1.obj# = it.obj# and bitand(io1.property, 4) != 4
group by it.obj#) io, sys.obj$ o1,
sys.type$ t
where i.obj# = o.obj# and o.owner# = u.user# and
u1.user# = o.owner# and io.obj# = i.obj# and
o1.obj# = i.implobj# and o1.oid$ = t.toid and
( o.owner# = userenv ('SCHEMAID')
    or
    o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
         ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."OWNER" IS 'Owner of the indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."INDEXTYPE_NAME" IS 'Name of the indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."IMPLEMENTATION_SCHEMA" IS 'Name of the schema for indextype implementation';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."IMPLEMENTATION_NAME" IS 'Name of indextype implementation';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."INTERFACE_VERSION" IS 'Version of indextype interface';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."IMPLEMENTATION_VERSION" IS 'Version of indextype implementation';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."NUMBER_OF_OPERATORS" IS 'Number of operators associated with the indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."PARTITIONING" IS 'Kinds of local partitioning supported by the indextype';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."ARRAY_DML" IS 'Does this indextype support array dml';
   COMMENT ON COLUMN "SYS"."ALL_INDEXTYPES"."MAINTENANCE_TYPE" IS 'An indicator of whether the indextype is system managed or user managed';
   COMMENT ON TABLE "SYS"."ALL_INDEXTYPES"  IS 'All indextypes available to the user'
;
--------------------------------------------------------
--  DDL for View ALL_IND_PARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_IND_PARTITIONS" ("INDEX_OWNER", "INDEX_NAME", "COMPOSITE", "PARTITION_NAME", "SUBPARTITION_COUNT", "HIGH_VALUE", "HIGH_VALUE_LENGTH", "PARTITION_POSITION", "STATUS", "TABLESPACE_NAME", "PCT_FREE", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENT", "MAX_EXTENT", "MAX_SIZE", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "COMPRESSION", "BLEVEL", "LEAF_BLOCKS", "DISTINCT_KEYS", "AVG_LEAF_BLOCKS_PER_KEY", "AVG_DATA_BLOCKS_PER_KEY", "CLUSTERING_FACTOR", "NUM_ROWS", "SAMPLE_SIZE", "LAST_ANALYZED", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "USER_STATS", "PCT_DIRECT_ACCESS", "GLOBAL_STATS", "DOMIDX_OPSTATUS", "PARAMETERS", "INTERVAL", "SEGMENT_CREATED", "ORPHANED_ENTRIES") AS 
  select u.name, io.name, 'NO', io.subname, 0,
       ip.hiboundval, ip.hiboundlen,
       row_number() over (partition by u.name, io.name order by ip.part#),
       decode(bitand(ip.flags, 1), 1, 'UNUSABLE', 'USABLE'),ts.name,
       ip.pctfree$, ip.initrans, ip.maxtrans,
       decode(bitand(ip.flags, 65536), 65536,
              ds.initial_stg * ts.blocksize, s.iniexts * ts.blocksize),
       decode(bitand(ip.flags, 65536), 65536,
              ds.next_stg * ts.blocksize, s.extsize * ts.blocksize),
       decode(bitand(ip.flags, 65536), 65536, ds.minext_stg, s.minexts),
       decode(bitand(ip.flags, 65536), 65536, ds.maxext_stg, s.maxexts),
       decode(bitand(ip.flags, 65536), 65536,
              ds.maxsiz_stg * ts.blocksize,
              decode(bitand(s.spare1, 4194304), 4194304, bitmapranges, NULL)),
       decode(bitand(ts.flags, 3), 1, to_number(NULL),
              decode(bitand(ip.flags, 65536), 65536, ds.pctinc_stg, s.extpct)),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(ip.flags, 65536), 65536,
                     decode(ds.frlins_stg, 0, 1, ds.frlins_stg),
                     decode(s.lists, 0, 1, s.lists))),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(ip.flags, 65536), 65536,
                     decode(ds.maxins_stg, 0, 1, ds.maxins_stg),
                     decode(s.groups, 0, 1, s.groups))),
       decode(mod(trunc(ip.flags / 4), 2), 0, 'YES', 'NO'),
       case
         when bitand(ip.flags, 1024) = 1024 then 'ENABLED'
       else
         case when (bitand(ip.flags, 65536) = 65536) then
           decode(bitand(ds.flags_stg, 4), 4,
                  decode(bitand(ds.cmpflag_stg, 6),
                         4, 'ADVANCED LOW',
                         2, 'ADVANCED HIGH',
                         NULL),
                  'DISABLED')
         else
           decode(bitand(s.spare1, 2048), 2048,
                  decode(bitand(s.spare1, 16777216 + 1048576),
                         16777216, 'ADVANCED HIGH',
                         1048576, 'ADVANCED LOW',
                         NULL),
                  'DISABLED')
         end
       end,
       ip.blevel, ip.leafcnt, ip.distkey, ip.lblkkey, ip.dblkkey,
       ip.clufac, ip.rowcnt, ip.samplesize, ip.analyzetime,
       decode(bitand(decode(bitand(ip.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 3),
              1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(decode(bitand(ip.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 12)/4,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(decode(bitand(ip.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 48)/16,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(ip.flags, 8), 0, 'NO', 'YES'), ip.pctthres$,
       decode(bitand(ip.flags, 16), 0, 'NO', 'YES'), '','',
       decode(bitand(ip.flags, 32768), 32768, 'YES', 'NO'),
       decode(bitand(ip.flags, 65536), 65536, 'NO', 'YES'),
       decode(bitand(ip.flags, 262144), 262144, 'YES', 'NO')
from obj$ io, indpart$ ip, ts$ ts, sys.seg$ s, ind$ i, sys.user$ u, tab$ t,
     sys.deferred_stg$ ds
where io.obj# = ip.obj# and ts.ts# = ip.ts# and ip.file#=s.file#(+) and
      ip.block#=s.block#(+) and ip.ts#=s.ts#(+) and io.owner# = u.user# and
      i.obj# = ip.bo# and i.bo# = t.obj# and ip.obj# = ds.obj#(+) and
      bitand(ip.flags, 8388608) = 0 and    /* filter out hidden partitions */
      bitand(t.trigflag, 1073741824) != 1073741824 and
      i.type# != 8 and      /* not LOB index */
      i.type# != 9 and      /* not DOMAIN index */
      io.namespace = 4 and io.remoteowner IS NULL and io.linkname IS NULL and
        (io.owner# = userenv('SCHEMAID')
        or
        i.bo# in (select obj#
                    from objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
        or
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       )
union all
select u.name, io.name, 'YES', io.subname, icp.subpartcnt,
       icp.hiboundval, icp.hiboundlen,
       row_number() over (partition by u.name, io.name order by icp.part#) ,
       'N/A', ts.name,
       icp.defpctfree, icp.definitrans, icp.defmaxtrans,
       icp.definiexts, icp.defextsize, icp.defminexts, icp.defmaxexts,
       icp.defmaxsize, icp.defextpct, icp.deflists, icp.defgroups,
       decode(icp.deflogging, 0, 'NONE', 1, 'YES', 2, 'NO', 'UNKNOWN'),
       case
         when bitand(icp.spare3, 8) = 8 then 'ADVANCED LOW'
         when bitand(icp.spare3, 4) = 4 then 'ADVANCED HIGH'
       else
         decode(bitand(icp.flags, 1024), 1024, 'ENABLED', 'DISABLED')
       end,
       icp.blevel, icp.leafcnt, icp.distkey, icp.lblkkey, icp.dblkkey,
       icp.clufac, icp.rowcnt, icp.samplesize, icp.analyzetime,
       decode(bitand(icp.defbufpool, 3), 1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(icp.defbufpool, 12)/4, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(icp.defbufpool, 48)/16, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(icp.flags, 8), 0, 'NO', 'YES'), TO_NUMBER(NULL),
       decode(bitand(icp.flags, 16), 0, 'NO', 'YES'), '','',
       decode(bitand(icp.flags, 32768), 32768, 'YES', 'NO'), 'N/A', 'N/A'
from   obj$ io, indcompart$ icp, ts$ ts, ind$ i, user$ u, tab$ t
where  io.obj# = icp.obj# and icp.defts# = ts.ts# (+) and io.owner# = u.user# and
       i.obj# = icp.bo# and i.bo# = t.obj# and
       bitand(t.trigflag, 1073741824) != 1073741824 and
       bitand(icp.flags, 8388608) = 0 and    /* filter out hidden partitions */
       i.type# != 8 and      /* not LOB index */
       i.type# != 9 and      /* not DOMAIN index */
       io.namespace = 4 and io.remoteowner IS NULL and io.linkname IS NULL and
       (io.owner# = userenv('SCHEMAID')
        or
        i.bo# in (select oa.obj#
                 from sys.objauth$ oa
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
union all
select u.name, io.name, 'NO', io.subname, 0,
       ip.hiboundval, ip.hiboundlen,
       row_number() over (partition by u.name, io.name order by ip.part#),
       decode(bitand(ip.flags, 1), 1, 'UNUSABLE',
               decode(bitand(ip.flags, 4096), 4096, 'INPROGRS', 'USABLE')),
       null, ip.pctfree$, ip.initrans, ip.maxtrans,
       0, 0, 0, 0, 0, 0, 0, 0,
       decode(mod(trunc(ip.flags / 4), 2), 0, 'YES', 'NO'),
       'N/A',
       ip.blevel, ip.leafcnt, ip.distkey, ip.lblkkey, ip.dblkkey,
       ip.clufac, ip.rowcnt, ip.samplesize, ip.analyzetime,
       'DEFAULT', 'DEFAULT', 'DEFAULT',
       decode(bitand(ip.flags, 8), 0, 'NO', 'YES'), ip.pctthres$,
       decode(bitand(ip.flags, 16), 0, 'NO', 'YES'),
       decode(i.type#,
             9, decode(bitand(ip.flags, 8192), 8192, 'FAILED', 'VALID'),
             ''),
       ipp.parameters,
       decode(bitand(ip.flags, 32768), 32768, 'YES', 'NO'),
       decode(bitand(ip.flags, 65536), 65536, 'NO', 'YES'),
       decode(bitand(ip.flags, 262144), 262144, 'YES', 'NO')
from obj$ io, indpart$ ip, ind$ i, sys.user$ u, indpart_param$ ipp, tab$ t
where io.obj# = ip.obj# and io.owner# = u.user# and
      i.obj# = ip.bo# and ip.obj# = ipp.obj# and
      i.bo# = t.obj# and bitand(t.trigflag, 1073741824) != 1073741824 and
      io.namespace = 4 and io.remoteowner IS NULL and io.linkname IS NULL and
        (io.owner# = userenv('SCHEMAID')
        or
        i.bo# in (select obj#
                    from objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
        or
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       )
union all
select u.name, io.name, 'YES', io.subname, icp.subpartcnt,
       icp.hiboundval, icp.hiboundlen,
       row_number() over (partition by u.name, io.name order by icp.part#),
       'N/A', null,
       icp.defpctfree, icp.definitrans, icp.defmaxtrans,
       0, 0, 0, 0, 0, 0, 0, 0,
       decode(icp.deflogging, 0, 'NONE', 1, 'YES', 2, 'NO', 'UNKNOWN'),
       'N/A',
       icp.blevel, icp.leafcnt, icp.distkey, icp.lblkkey, icp.dblkkey,
       icp.clufac, icp.rowcnt, icp.samplesize, icp.analyzetime,
       'DEFAULT', 'DEFAULT', 'DEFAULT',
       decode(bitand(icp.flags, 8), 0, 'NO', 'YES'), TO_NUMBER(NULL),
       decode(bitand(icp.flags, 16), 0, 'NO', 'YES'),
       decode(i.type#,
             9, decode(bitand(icp.flags, 8192), 8192, 'FAILED', 'VALID'),
             ''),
       ipp.parameters,
       decode(bitand(icp.flags, 32768), 32768, 'YES', 'NO'), 'N/A', 'N/A'
from obj$ io, indcompart$ icp, ind$ i, sys.user$ u, indpart_param$ ipp, tab$ t
where io.obj# = icp.obj# and io.owner# = u.user# and
      i.obj# = icp.bo# and icp.obj# = ipp.obj# and
      i.bo# = t.obj# and bitand(t.trigflag, 1073741824) != 1073741824 and
      io.namespace = 4 and io.remoteowner IS NULL and io.linkname IS NULL and
        (io.owner# = userenv('SCHEMAID')
        or
        i.bo# in (select obj#
                    from objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
        or
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       )
;
--------------------------------------------------------
--  DDL for View ALL_IND_PENDING_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_IND_PENDING_STATS" ("OWNER", "INDEX_NAME", "TABLE_OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "BLEVEL", "LEAF_BLOCKS", "DISTINCT_KEYS", "AVG_LEAF_BLOCKS_PER_KEY", "AVG_DATA_BLOCKS_PER_KEY", "CLUSTERING_FACTOR", "NUM_ROWS", "SAMPLE_SIZE", "LAST_ANALYZED") AS 
  select u.name, o.name, ut.name, ot.name, o.subname, null,
         h.blevel, h.leafcnt, h.distkey, h.lblkkey, h.dblkkey,
         h.clufac, h.rowcnt, h.samplesize, h.analyzetime
  from   sys.user$ u,  sys.obj$ o,  sys.ind$ i,
         sys.user$ ut, sys.obj$ ot, sys.wri$_optstat_ind_history h
  where  u.user# = o.owner#   -- user(i) X obj(i)
    and  o.obj#  = i.obj#     -- obj(i)  X ind
    and  h.obj#  = i.obj#     -- stat    X ind
    and  i.bo#   = ot.obj#    -- ind     X obj(t)
    and  ut.user# = ot.owner# -- user(t) X obj(t)
    and  o.namespace = 4 and o.remoteowner IS NULL and o.linkname IS NULL
    and  i.type# in (1, 2, 4, 6, 7, 8)
    and  bitand(i.flags, 4096) = 0  -- not a fake index
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  -- partitions
  select u.name, o.name, ut.name, ot.name, o.subname, null,
         h.blevel, h.leafcnt, h.distkey, h.lblkkey, h.dblkkey,
         h.clufac, h.rowcnt, h.samplesize, h.analyzetime
  from   sys.user$ u,  sys.obj$ o,  sys.ind$ i, indpart$ ip,
         sys.user$ ut, sys.obj$ ot, sys.wri$_optstat_ind_history h
  where  u.user# = o.owner#   -- user(i) X obj(i)
    and  ip.bo# = i.obj#
    and  h.obj# = ip.obj#
    and  i.bo#  = ot.obj#
    and  o.obj# = ip.obj#
    and  ut.user# = ot.owner#
    and  o.namespace = 4 and o.remoteowner IS NULL and o.linkname IS NULL
    and  i.type# in (1, 2, 3, 4, 6, 7, 8)
    and  bitand(i.flags, 4096) = 0  -- not a fake index
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  select u.name, o.name, ut.name, ot.name, o.subname, null,
         h.blevel, h.leafcnt, h.distkey, h.lblkkey, h.dblkkey,
         h.clufac, h.rowcnt, h.samplesize, h.analyzetime
  from   sys.user$ u,  sys.obj$ o,  sys.ind$ i, indcompart$ ip,
         sys.user$ ut, sys.obj$ ot, sys.wri$_optstat_ind_history h
  where  u.user# = o.owner#   -- user(i) X obj(i)
    and  ip.bo# = i.obj#
    and  h.obj# = ip.obj#
    and  i.bo#  = ot.obj#
    and  o.obj# = ip.obj#
    and  ut.user# = ot.owner#
    and  o.namespace = 4 and o.remoteowner IS NULL and o.linkname IS NULL
    and  i.type# in (1, 2, 3, 4, 6, 7, 8)
    and  bitand(i.flags, 4096) = 0  -- not a fake index
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  -- sub partitions
  select ui.name, oi.name, ut.name, ot.name, os.name, os.subname,
         h.blevel, h.leafcnt, h.distkey, h.lblkkey, h.dblkkey,
         h.clufac, h.rowcnt, h.samplesize, h.analyzetime
  from   sys.obj$ os, sys.indsubpart$ isp, sys.indcompart$ icp,
         sys.user$ ut, sys.obj$ ot,
         sys.obj$ oi,  sys.ind$ i, sys.user$ ui,
         sys.wri$_optstat_ind_history h
  where  ui.user# = oi.owner#
    and  os.obj#  = isp.obj#
    and  h.obj#   = isp.obj#
    and  isp.pobj#= icp.obj#
    and  icp.bo#  = i.obj#
    and  oi.obj#  = i.obj#
    and  i.bo#    = ot.obj#
    and  ut.user# = ot.owner#
    and  oi.type# = 1
    and  os.type# = 35
    and  ot.type# = 2
    and  os.namespace = 4 and os.remoteowner IS NULL and os.linkname IS NULL
    and  i.type# in (1, 2, 3, 4, 6, 7, 8)
    and  bitand(i.flags, 4096) = 0  -- not a fake index
    and  h.savtime > systimestamp
    and  (ot.owner# = userenv('SCHEMAID')
        or ot.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
        );

   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."OWNER" IS 'Index owner name';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."INDEX_NAME" IS 'Index name';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."TABLE_OWNER" IS 'Table owner name';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."TABLE_NAME" IS 'Table name';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."PARTITION_NAME" IS 'Partition name';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."SUBPARTITION_NAME" IS 'Subpartition name';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."BLEVEL" IS 'Number of levels in the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."LEAF_BLOCKS" IS 'Number of leaf blocks in the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."DISTINCT_KEYS" IS 'Number of distinct keys in the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."AVG_LEAF_BLOCKS_PER_KEY" IS 'Average number of leaf blocks per key';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."AVG_DATA_BLOCKS_PER_KEY" IS 'Average number of data blocks per key';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."CLUSTERING_FACTOR" IS 'Clustering factor';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."NUM_ROWS" IS 'Number of rows in the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."SAMPLE_SIZE" IS 'Sample size';
   COMMENT ON COLUMN "SYS"."ALL_IND_PENDING_STATS"."LAST_ANALYZED" IS 'Time of last analyze';
   COMMENT ON TABLE "SYS"."ALL_IND_PENDING_STATS"  IS 'Pending statistics of indexes, partitions, and subpartitions'
;
--------------------------------------------------------
--  DDL for View ALL_IND_STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_IND_STATISTICS" ("OWNER", "INDEX_NAME", "TABLE_OWNER", "TABLE_NAME", "PARTITION_NAME", "PARTITION_POSITION", "SUBPARTITION_NAME", "SUBPARTITION_POSITION", "OBJECT_TYPE", "BLEVEL", "LEAF_BLOCKS", "DISTINCT_KEYS", "AVG_LEAF_BLOCKS_PER_KEY", "AVG_DATA_BLOCKS_PER_KEY", "CLUSTERING_FACTOR", "NUM_ROWS", "AVG_CACHED_BLOCKS", "AVG_CACHE_HIT_RATIO", "SAMPLE_SIZE", "LAST_ANALYZED", "GLOBAL_STATS", "USER_STATS", "STATTYPE_LOCKED", "STALE_STATS", "SCOPE") AS 
  SELECT
    u.name, o.name, ut.name, ot.name,
    NULL,NULL, NULL, NULL, 'INDEX',
    i.blevel, i.leafcnt, i.distkey, i.lblkkey, i.dblkkey, i.clufac, i.rowcnt,
    ins.cachedblk, ins.cachehit, i.samplesize, i.analyzetime,
    decode(bitand(i.flags, 2048), 0, 'NO', 'YES'),
    decode(bitand(i.flags, 64), 0, 'NO', 'YES'),
    decode(bitand(t.trigflag, 67108864) + bitand(t.trigflag, 134217728),
           0, NULL, 67108864, 'DATA', 134217728, 'CACHE', 'ALL'),
    case when
           (i.analyzetime is null or
            t.analyzetime is null) then null
         when (i.analyzetime < t.analyzetime or
               (dbms_stats_internal.is_stale(t.obj#,
                  null,
                  null,
                  (m.inserts + m.deletes + m.updates),
                  t.rowcnt, m.flags) > 0)) then 'YES'
         else  'NO'
    end,
    'SHARED'
  FROM
    sys.user$ u, sys.ind$ i, sys.obj$ o, sys.ind_stats$ ins,
    sys.obj$ ot, sys.user$ ut, sys.tab$ t, sys.mon_mods_v m
  WHERE
      u.user# = o.owner#
  and o.obj# = i.obj#
  and bitand(i.flags, 4096) = 0
  and i.type# in (1, 2, 4, 6, 7, 8)
  and i.obj# = ins.obj# (+)
  and i.bo# = ot.obj#
  and ot.type# = 2
  and ot.owner# = ut.user#
  and ot.obj# = t.obj#
  and t.obj# = m.obj# (+)
  and o.subname IS NULL
  and o.namespace = 4 and o.remoteowner IS NULL and o.linkname IS NULL
  and bitand(o.flags, 128) = 0 -- not in recycle bin
  and (o.owner# = userenv('SCHEMAID')
        or
       o.obj# in ( select obj#
                    FROM sys.objauth$
                    where grantee# in ( select kzsrorol
                                        FROM x$kzsro
                                      )
                   )
        or
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       )
  UNION ALL
  /* Cluster indexes */
  SELECT
    u.name, o.name, ut.name, ot.name,
    NULL,NULL, NULL, NULL, 'INDEX',
    i.blevel, i.leafcnt, i.distkey, i.lblkkey, i.dblkkey, i.clufac, i.rowcnt,
    ins.cachedblk, ins.cachehit, i.samplesize, i.analyzetime,
    decode(bitand(i.flags, 2048), 0, 'NO', 'YES'),
    decode(bitand(i.flags, 64), 0, 'NO', 'YES'),
    -- a cluster index is considered locked if any of the table in
    -- the cluster is locked.
    decode((select
           decode(nvl(sum(decode(bitand(t.trigflag, 67108864), 0, 0, 1)),0),
                  0, 0, 67108864) +
           decode(nvl(sum(decode(bitand(nvl(t.trigflag, 0), 134217728),
                                 0, 0, 1)), 0),
                  0, 0, 134217728)
           from  sys.tab$ t where i.bo# = t.bobj#),
           0, NULL, 67108864, 'DATA', 134217728, 'CACHE', 'ALL'),
    case
         when i.analyzetime is null then null
         when
           (select                                 -- STALE
              sum(case when
                      i.analyzetime < tab.analyzetime or
                      (dbms_stats_internal.is_stale(ot.obj#,
                        null,
                        null,
                        (m.inserts + m.deletes + m.updates),
                        tab.rowcnt, m.flags) > 0)
                  then 1 else 0 end)
            from sys.tab$ tab, mon_mods_v m
            where
              m.obj#(+) = tab.obj# and tab.bobj# = i.bo#) > 0 then 'YES'
         else 'NO' end,
    'SHARED'
  FROM
    sys.user$ u, sys.ind$ i, sys.obj$ o, sys.ind_stats$ ins,
    sys.obj$ ot, sys.user$ ut
  WHERE
      u.user# = o.owner#
  and o.obj# = i.obj#
  and bitand(i.flags, 4096) = 0
  and i.type# = 3 /* Cluster index */
  and i.obj# = ins.obj# (+)
  and i.bo# = ot.obj#
  and ot.owner# = ut.user#
  and o.subname IS NULL
  and o.namespace = 4 and o.remoteowner IS NULL and o.linkname IS NULL
  and bitand(o.flags, 128) = 0 -- not in recycle bin
  and (o.owner# = userenv('SCHEMAID')
        or
       o.obj# in ( select obj#
                    FROM sys.objauth$
                    where grantee# in ( select kzsrorol
                                        FROM x$kzsro
                                      )
                   )
        or
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       )
  UNION ALL
  /* Partitions */
  SELECT
    u.name, io.name, ut.name, ot.name,
    io.subname, ip.part#, NULL, NULL, 'PARTITION',
    ip.blevel, ip.leafcnt, ip.distkey, ip.lblkkey, ip.dblkkey,
    ip.clufac, ip.rowcnt, ins.cachedblk, ins.cachehit,
    ip.samplesize, ip.analyzetime,
    decode(bitand(ip.flags, 16), 0, 'NO', 'YES'),
    decode(bitand(ip.flags, 8), 0, 'NO', 'YES'),
    /* stattype_locked */
    (select
       -- not a local index, just look at the lock at table level
       decode(bitand(t.trigflag, 67108864) + bitand(t.trigflag, 134217728),
              0, NULL, 67108864, 'DATA', 134217728, 'CACHE', 'ALL')
       FROM sys.tab$ t
       where t.obj# = i.bo# and
             bitand(po.flags, 1) = 0   -- not local index
     union all
     select
       -- local index, we need to see if the corresponding partn is locked
       decode(
       /*
        * Following decode returns 1 if DATA stats locked for partition
        * or at table level
        */
       decode(bitand(t.trigflag, 67108864) + bitand(tp.flags, 32), 0, 0, 1) +
       /*
        * Following decode returns 2 if CACHE stats locked for partition
        * or at table level
        */
       decode(bitand(t.trigflag, 134217728) + bitand(tp.flags, 64), 0, 0, 2),
       /* if 0 => not locked, 3 => data and cache stats locked */
       0, NULL, 1, 'DATA', 2, 'CACHE', 'ALL')
       FROM sys.tabpartv$ tp, sys.tab$ t
       where tp.bo# = i.bo# and tp.phypart# = ip.phypart# and
             tp.bo# = t.obj# and
             bitand(po.flags, 1) = 1),  -- local index
    /* stale_stats */
    (select
       case     when (i.analyzetime is null or
                      tab.analyzetime is null) then null
                when (i.analyzetime < tab.analyzetime  or
                      (dbms_stats_internal.is_stale(tab.obj#,
                         null,
                         null,
                         (m.inserts + m.deletes + m.updates),
                         tab.rowcnt, m.flags) > 0)) then 'YES'
                else 'NO'
       end
       FROM sys.tab$ tab, sys.mon_mods_v m
       where tab.obj# = i.bo# and tab.obj# = m.obj# (+) and
             bitand(po.flags, 1) = 0   -- not local index
     union all
     select
       case     when (ip.analyzetime is null or
                      tp.analyzetime is null) then null
                when (ip.analyzetime < tp.analyzetime  or
                      (dbms_stats_internal.is_stale(tp.bo#,
                         null,
                         null,
                         (m.inserts + m.deletes + m.updates),
                         tp.rowcnt, m.flags) > 0)) then 'YES'
                else 'NO'
       end
       FROM sys.tabpartv$ tp, sys.mon_mods_v m
       where tp.bo# = i.bo# and tp.phypart# = ip.phypart# and
             tp.obj# = m.obj# (+) and
             bitand(po.flags, 1) = 1),  -- local index
    'SHARED'
  FROM
    sys.obj$ io, sys.indpartv$ ip,
    sys.user$ u, sys.ind_stats$ ins,
    sys.ind$ i, sys.obj$ ot, sys.user$ ut, sys.partobj$ po
  WHERE
      io.obj# = ip.obj#
  and ip.bo# = i.obj#
  and io.owner# = u.user#
  and ip.obj# = ins.obj# (+)
  and ip.bo# = i.obj#
  and i.type# != 9  --  no domain indexes
  and i.bo# = ot.obj#
  and ot.type# = 2
  and ot.owner# = ut.user#
  and i.obj# = po.obj#
  and io.namespace = 4 and io.remoteowner IS NULL and io.linkname IS NULL
  and bitand(io.flags, 128) = 0 -- not in recycle bin
  and (io.owner# = userenv('SCHEMAID')
        or
        i.bo# in (select obj#
                    FROM sys.objauth$
                    where grantee# in ( select kzsrorol
                                        FROM x$kzsro
                                      )
                   )
        or
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       )
  UNION ALL
  /* Composite partitions */
  SELECT
    u.name, io.name, ut.name, ot.name,
    io.subname, icp.part#, NULL, NULL, 'PARTITION',
    icp.blevel, icp.leafcnt, icp.distkey, icp.lblkkey, icp.dblkkey,
    icp.clufac, icp.rowcnt, ins.cachedblk, ins.cachehit,
    icp.samplesize, icp.analyzetime,
    decode(bitand(icp.flags, 16), 0, 'NO', 'YES'),
    decode(bitand(icp.flags, 8), 0, 'NO', 'YES'),
    /* stattype_locked */
    (select
       -- not a local index, just look at the lock at table level
       decode(bitand(t.trigflag, 67108864) + bitand(t.trigflag, 134217728),
              0, NULL, 67108864, 'DATA', 134217728, 'CACHE', 'ALL')
       FROM sys.tab$ t
       where t.obj# = i.bo# and
             bitand(po.flags, 1) = 0   -- not local index
     union all
     select
       -- local index, we need to see if the corresponding partn is locked
       decode(
       /*
        * Following decode returns 1 if DATA stats locked for partition
        * or at table level
        */
       decode(bitand(t.trigflag, 67108864) + bitand(tcp.flags, 32), 0, 0, 1) +
       /*
        * Following decode returns 2 if CACHE stats locked for partition
        * or at table level
        */
       decode(bitand(t.trigflag, 134217728) + bitand(tcp.flags, 64), 0, 0, 2),
       /* if 0 => not locked, 3 => data and cache stats locked */
       0, NULL, 1, 'DATA', 2, 'CACHE', 'ALL')
       FROM sys.tabcompartv$ tcp, sys.tab$ t
       where tcp.bo# = i.bo# and tcp.phypart# = icp.phypart# and
             tcp.bo# = t.obj# and
             bitand(po.flags, 1) = 1),  -- local index
    /* stale_stats */
    (select
       case     when (i.analyzetime is null or
                      tab.analyzetime is null) then null
                when (i.analyzetime < tab.analyzetime  or
                      (dbms_stats_internal.is_stale(tab.obj#,
                         null,
                         null,
                         (m.inserts + m.deletes + m.updates),
                         tab.rowcnt, m.flags) > 0)) then 'YES'
                else 'NO'
       end
       FROM sys.tab$ tab, sys.mon_mods_v m
       where tab.obj# = i.bo# and tab.obj# = m.obj# (+) and
             bitand(po.flags, 1) = 0   -- not local index
     union all
     select
       case     when (icp.analyzetime is null or
                      tcp.analyzetime is null) then null
                when (icp.analyzetime < tcp.analyzetime  or
                      (dbms_stats_internal.is_stale(tcp.bo#,
                         null,
                         null,
                         (m.inserts + m.deletes + m.updates),
                         tcp.rowcnt, m.flags) > 0)) then 'YES'
                else 'NO'
       end
       FROM sys.tabcompartv$ tcp, sys.mon_mods_v m
       where tcp.bo# = i.bo# and tcp.phypart# = icp.phypart# and
             tcp.obj# = m.obj# (+) and
             bitand(po.flags, 1) = 1),  -- local index
    'SHARED'
  FROM
    sys.obj$ io, sys.indcompartv$ icp, sys.user$ u, sys.ind_stats$ ins,
    sys.ind$ i, sys.obj$ ot, sys.user$ ut, sys.partobj$ po
  WHERE
      io.obj# = icp.obj#
  and io.owner# = u.user#
  and icp.obj# = ins.obj# (+)
  and i.obj# = icp.bo#
  and icp.bo# = i.obj#
  and i.type# != 9  --  no domain indexes
  and i.bo# = ot.obj#
  and ot.type# = 2
  and ot.owner# = ut.user#
  and i.obj# = po.obj#
  and io.namespace = 4 and io.remoteowner IS NULL and io.linkname IS NULL
  and bitand(io.flags, 128) = 0 -- not in recycle bin
  and (io.owner# = userenv('SCHEMAID')
        or
        i.bo# in (select oa.obj#
                  FROM sys.objauth$ oa
                    where grantee# in ( select kzsrorol
                                        FROM x$kzsro
                                      )
                   )
        or /* user has system privileges */
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
  UNION ALL
  /* Subpartitions */
  SELECT
    u.name, op.name, ut.name, ot.name,
    op.subname, icp.part#, os.subname, isp.subpart#,
    'SUBPARTITION',
    isp.blevel, isp.leafcnt, isp.distkey, isp.lblkkey, isp.dblkkey,
    isp.clufac, isp.rowcnt, ins.cachedblk, ins.cachehit,
    isp.samplesize, isp.analyzetime,
    decode(bitand(isp.flags, 16), 0, 'NO', 'YES'),
    decode(bitand(isp.flags, 8), 0, 'NO', 'YES'),
    /* stattype_locked */
    (select
       -- not a local index, just look at the lock at table level
       decode(bitand(t.trigflag, 67108864) + bitand(t.trigflag, 134217728),
              0, NULL, 67108864, 'DATA', 134217728, 'CACHE', 'ALL')
       FROM sys.tab$ t
       where t.obj# = i.bo# and
             bitand(po.flags, 1) = 0   -- not local index
     union all
     select
       -- local index, we need to see if the corresponding composite partn
       -- is locked
       decode(
       /*
        * Following decode returns 1 if DATA stats locked for partition
        * or at table level
        */
       decode(bitand(t.trigflag, 67108864) + bitand(tcp.flags, 32), 0, 0, 1) +
       /*
        * Following decode returns 2 if CACHE stats locked for partition
        * or at table level
        */
       decode(bitand(t.trigflag, 134217728) + bitand(tcp.flags, 64), 0, 0, 2),
       /* if 0 => not locked, 3 => data and cache stats locked */
       0, NULL, 1, 'DATA', 2, 'CACHE', 'ALL')
       FROM  sys.tabcompartv$ tcp, sys.tabsubpartv$ tsp, sys.tab$ t
       where tcp.bo# = i.bo# and tcp.phypart# = icp.phypart# and
             tsp.pobj# = tcp.obj# and
             isp.physubpart# = tsp.physubpart# and
             tcp.bo# = t.obj# and
             bitand(po.flags, 1) = 1),  -- local index
    /* stale_stats */
    (select
       case     when (i.analyzetime is null or
                      tab.analyzetime is null) then null
                when (i.analyzetime < tab.analyzetime  or
                      (dbms_stats_internal.is_stale(tab.obj#,
                         null,
                         null,
                         (m.inserts + m.deletes + m.updates),
                         tab.rowcnt, m.flags) > 0)) then 'YES'
                else 'NO'
       end
       FROM sys.tab$ tab, sys.mon_mods_v m
       where tab.obj# = i.bo# and tab.obj# = m.obj# (+) and
             bitand(po.flags, 1) = 0   -- not local index
     union all
     select
       case     when (isp.analyzetime is null or
                      tsp.analyzetime is null) then null
                when (isp.analyzetime < tsp.analyzetime  or
                      (dbms_stats_internal.is_stale(tcp.bo#,
                         null,
                         null,
                         (m.inserts + m.deletes + m.updates),
                         tsp.rowcnt, m.flags) > 0)) then 'YES'
                else 'NO'
       end
       FROM  sys.tabcompartv$ tcp, sys.tabsubpartv$ tsp, sys.mon_mods_v m
       where tcp.bo# = i.bo# and tcp.phypart# = icp.phypart# and
             tsp.pobj# = tcp.obj# and
             isp.physubpart# = tsp.physubpart# and
             tsp.obj# = m.obj# (+) and
             bitand(po.flags, 1) = 1),  -- local index
    'SHARED'
  FROM
    sys.obj$ os, sys.obj$ op, sys.indcompartv$ icp, sys.indsubpartv$ isp,
    sys.user$ u,  sys.ind_stats$ ins,
    sys.ind$ i, sys.obj$ ot, sys.user$ ut, sys.partobj$ po
  WHERE
      os.obj# = isp.obj#
  and op.obj# = icp.obj#
  and icp.obj# = isp.pobj#
  and icp.bo# = i.obj#
  and i.type# != 9  --  no domain indexes
  and u.user# = op.owner#
  and isp.obj# = ins.obj# (+)
  and icp.bo# = i.obj#
  and i.bo# = ot.obj#
  and ot.type# = 2
  and ot.owner# = ut.user#
  and i.obj# = po.obj#
  and op.namespace = 4 and op.remoteowner IS NULL and op.linkname IS NULL
  and bitand(op.flags, 128) = 0 -- not in recycle bin
  and (op.owner# = userenv('SCHEMAID')
        or i.bo# in
            (select oa.obj#
             FROM sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 FROM x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
 UNION ALL
 SELECT
    u.name, o.name, ut.name, ot.name,
    NULL,NULL, NULL, NULL, 'INDEX',
    sesi.blevel_kxttst_is, sesi.leafcnt_kxttst_is, sesi.distkey_kxttst_is,
    sesi.lblkkey_kxttst_is, sesi.dblkkey_kxttst_is, sesi.clufac_kxttst_is,
    sesi.rowcnt_kxttst_is,
    sesi.cachedblk_kxttst_is, sesi.cachehit_kxttst_is,
    sesi.samplesize_kxttst_is, sesi.analyzetime_kxttst_is,
    decode(bitand(sesi.flags_kxttst_is, 2048), 0, 'NO', 'YES'),
    decode(bitand(sesi.flags_kxttst_is, 64), 0, 'NO', 'YES'),
    null,  /* no lock on session private stats */
    null, /* session based dml monitoring not available */
    'SESSION'
  FROM
    sys.x$kxttsteis sesi,
    sys.user$ u, sys.ind$ i, sys.obj$ o,
    sys.obj$ ot, sys.user$ ut
  WHERE
      u.user# = o.owner#
  and o.obj# = i.obj#
  and i.obj# = sesi.obj#_kxttst_is
  and bitand(i.flags, 4096) = 0
  and i.type# in (1, 2, 4, 6, 7, 8)
  and i.bo# = ot.obj#
  and ot.type# = 2
  and ot.owner# = ut.user#
  and o.subname IS NULL
  and o.namespace = 4 and o.remoteowner IS NULL and o.linkname IS NULL
  and bitand(o.flags, 128) = 0 -- not in recycle bin
  and (o.owner# = userenv('SCHEMAID')
        or
       o.obj# in ( select obj#
                    FROM sys.objauth$
                    where grantee# in ( select kzsrorol
                                        FROM x$kzsro
                                      )
                   )
        or
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       );

   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."OWNER" IS 'Username of the owner of the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."INDEX_NAME" IS 'Name of the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."TABLE_OWNER" IS 'Owner of the indexed object';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."TABLE_NAME" IS 'Name of the indexed object';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."PARTITION_NAME" IS 'Name of the partition';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."PARTITION_POSITION" IS 'Position of the partition within index';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."SUBPARTITION_NAME" IS 'Name of the subpartition';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."SUBPARTITION_POSITION" IS 'Position of the subpartition within partition';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."OBJECT_TYPE" IS 'Type of the object (INDEX, PARTITION, SUBPARTITION)';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."BLEVEL" IS 'B-Tree level';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."LEAF_BLOCKS" IS 'The number of leaf blocks in the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."DISTINCT_KEYS" IS 'The number of distinct keys in the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."AVG_LEAF_BLOCKS_PER_KEY" IS 'The average number of leaf blocks per key';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."AVG_DATA_BLOCKS_PER_KEY" IS 'The average number of data blocks per key';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."CLUSTERING_FACTOR" IS 'A measurement of the amount of (dis)order of the table this index is for';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."NUM_ROWS" IS 'The number of rows in the index';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."AVG_CACHED_BLOCKS" IS 'Average number of blocks in buffer cache';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."AVG_CACHE_HIT_RATIO" IS 'Average cache hit ratio for the object';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."SAMPLE_SIZE" IS 'The sample size used in analyzing this index';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."LAST_ANALYZED" IS 'The date of the most recent time this index was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."STATTYPE_LOCKED" IS 'type of statistics lock';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."STALE_STATS" IS 'Whether statistics for the object is stale or not';
   COMMENT ON COLUMN "SYS"."ALL_IND_STATISTICS"."SCOPE" IS 'whether statistics for the object is shared or session';
   COMMENT ON TABLE "SYS"."ALL_IND_STATISTICS"  IS 'Optimizer statistics for all indexes on tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_IND_SUBPARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_IND_SUBPARTITIONS" ("INDEX_OWNER", "INDEX_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "HIGH_VALUE", "HIGH_VALUE_LENGTH", "PARTITION_POSITION", "SUBPARTITION_POSITION", "STATUS", "TABLESPACE_NAME", "PCT_FREE", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENT", "MAX_EXTENT", "MAX_SIZE", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "COMPRESSION", "BLEVEL", "LEAF_BLOCKS", "DISTINCT_KEYS", "AVG_LEAF_BLOCKS_PER_KEY", "AVG_DATA_BLOCKS_PER_KEY", "CLUSTERING_FACTOR", "NUM_ROWS", "SAMPLE_SIZE", "LAST_ANALYZED", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "USER_STATS", "GLOBAL_STATS", "INTERVAL", "SEGMENT_CREATED", "DOMIDX_OPSTATUS", "PARAMETERS") AS 
  select u.name, po.name, po.subname, so.subname,
       isp.hiboundval, isp.hiboundlen,
       dense_rank() over (partition by u.name, po.name order by icp.part#),
       row_number() over (partition by u.name, po.name, po.subname
                          order by isp.subpart#),
       decode(bitand(isp.flags, 1), 1, 'UNUSABLE', 'USABLE'), ts.name,
       isp.pctfree$, isp.initrans, isp.maxtrans,
       decode(bitand(isp.flags, 65536), 65536,
              ds.initial_stg * ts.blocksize, s.iniexts * ts.blocksize),
       decode(bitand(isp.flags, 65536), 65536,
              ds.next_stg * ts.blocksize, s.extsize * ts.blocksize),
       decode(bitand(isp.flags, 65536), 65536, ds.minext_stg, s.minexts),
       decode(bitand(isp.flags, 65536), 65536, ds.maxext_stg, s.maxexts),
       decode(bitand(isp.flags, 65536), 65536,
              ds.maxsiz_stg * ts.blocksize,
              decode(bitand(s.spare1, 4194304), 4194304, bitmapranges, NULL)),
       decode(bitand(ts.flags, 3), 1, to_number(NULL),
              decode(bitand(isp.flags, 65536), 65536,
                     ds.pctinc_stg, s.extpct)),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(isp.flags, 65536), 65536,
                     decode(ds.frlins_stg, 0, 1, ds.frlins_stg),
                     decode(s.lists, 0, 1, s.lists))),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(isp.flags, 65536), 65536,
                     decode(ds.maxins_stg, 0, 1, ds.maxins_stg),
                     decode(s.groups, 0, 1, s.groups))),
       decode(mod(trunc(isp.flags / 4), 2), 0, 'YES', 'NO'),
       case
         when bitand(isp.flags, 1024) = 1024 then 'ENABLED'
       else
         case when (bitand(isp.flags, 65536) = 65536) then
           decode(bitand(ds.flags_stg, 4), 4,
                  decode(bitand(ds.cmpflag_stg, 6),
                         4, 'ADVANCED LOW',
                         2, 'ADVANCED HIGH',
                         NULL),
                  'DISABLED')
         else
           decode(bitand(s.spare1, 2048), 2048,
                  decode(bitand(s.spare1, 16777216 + 1048576),
                         16777216, 'ADVANCED HIGH',
                         1048576, 'ADVANCED LOW',
                         NULL),
                  'DISABLED')
         end
       end,
       isp.blevel, isp.leafcnt, isp.distkey, isp.lblkkey, isp.dblkkey,
       isp.clufac, isp.rowcnt, isp.samplesize, isp.analyzetime,
       decode(bitand(decode(bitand(isp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 3),
              1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(decode(bitand(isp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 12)/4,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(decode(bitand(isp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 48)/16,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(isp.flags, 8), 0, 'NO', 'YES'),
       decode(bitand(isp.flags, 16), 0, 'NO', 'YES'),
       decode(bitand(isp.flags, 32768), 32768, 'YES', 'NO'),
       decode(bitand(isp.flags, 65536), 65536, 'NO', 'YES'), '', ''
from   obj$ so, sys.obj$ po, ind$ i, indcompart$ icp, indsubpart$ isp,
       ts$ ts, seg$ s, user$ u, tab$ t, sys.deferred_stg$ ds
where  so.obj# = isp.obj# and i.type# != 9 and /* not domain index */
       po.obj# = icp.obj# and icp.obj# = isp.pobj# and
       i.obj# = icp.bo# and ts.ts# = isp.ts# and isp.file# = s.file#(+) and
       isp.block# = s.block#(+) and isp.ts# = s.ts#(+) and
       isp.obj# = ds.obj#(+) and u.user# = po.owner# and
       bitand(icp.flags, 8388608) = 0 and   /* filter out hidden partitions */
       bitand(isp.flags, 8388608) = 0 and   /* filter out hidden partitions */
       i.bo# = t.obj# and bitand(t.trigflag, 1073741824) != 1073741824 and
       i.type# != 8 and      /* not LOB index */
       po.namespace = 4 and po.remoteowner IS NULL and po.linkname IS NULL and
       so.namespace = 4 and so.remoteowner IS NULL and so.linkname IS NULL and
       ((po.owner# = userenv('SCHEMAID') and so.owner# = userenv('SCHEMAID'))
        or i.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
union all
select u.name, po.name, po.subname, so.subname,
       isp.hiboundval, isp.hiboundlen,
       dense_rank() over (partition by u.name, po.name order by icp.part#),
       row_number() over (partition by u.name, po.name, po.subname
                          order by isp.subpart#),
       decode(bitand(isp.flags, 1), 1, 'UNUSABLE',
               decode(bitand(isp.flags, 4096), 4096, 'INPROGRS', 'USABLE')),
       null,
       icp.defpctfree, icp.definitrans, icp.defmaxtrans,
       icp.definiexts, icp.defextsize, icp.defminexts, icp.defmaxexts,
       icp.defmaxsize, icp.defextpct, icp.deflists, icp.defgroups,
       decode(mod(trunc(isp.flags / 4), 2), 0, 'YES', 'NO'),
       'N/A',
       isp.blevel, isp.leafcnt, isp.distkey, isp.lblkkey, isp.dblkkey,
       isp.clufac, isp.rowcnt, isp.samplesize, isp.analyzetime,
        'DEFAULT', 'DEFAULT', 'DEFAULT',
       decode(bitand(isp.flags, 8), 0, 'NO', 'YES'),
       decode(bitand(isp.flags, 16), 0, 'NO', 'YES'),
       decode(bitand(isp.flags, 32768), 32768, 'YES', 'NO'),
       'N/A',
       decode(i.type#,
              9, decode(bitand(isp.flags, 8192), 8192, 'FAILED', 'VALID'),
              ''),
       ipp.parameters
from   obj$ so, sys.obj$ po, ind$ i, indcompart$ icp, indsubpart$ isp,
       user$ u, tab$ t, sys.indpart_param$ ipp
where  so.obj# = isp.obj# and icp.obj# = ipp.obj# and
       po.obj# = icp.obj# and icp.obj# = isp.pobj# and
       i.obj# = icp.bo# and
       u.user# = po.owner# and
       bitand(icp.flags, 8388608) = 0 and   /* filter out hidden partitions */
       bitand(isp.flags, 8388608) = 0 and   /* filter out hidden partitions */
       i.bo# = t.obj# and bitand(t.trigflag, 1073741824) != 1073741824 and
       i.type# != 8 and      /* not LOB index */
       po.namespace = 4 and po.remoteowner IS NULL and po.linkname IS NULL and
       so.namespace = 4 and so.remoteowner IS NULL and so.linkname IS NULL and
       ((po.owner# = userenv('SCHEMAID') and so.owner# = userenv('SCHEMAID'))
        or i.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
;
--------------------------------------------------------
--  DDL for View ALL_INT_DEQUEUE_QUEUES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_INT_DEQUEUE_QUEUES" ("OWNER", "NAME", "QID") AS 
  select /*+ ORDERED NO_USE_MERGE(ro) */
      t.schema OWNER, q.name NAME, q.eventid QID
from system.aq$_queues q, system.aq$_queue_tables t,sys.obj$ ro
where q.table_objno = t.objno
and   ro.obj# = q.eventid
and  (ro.owner# = userenv('SCHEMAID')
      or ro.obj# in
           (select oa.obj#
            from sys.objauth$ oa
            where oa.privilege# = 21 and
                  grantee# in (select kzsrorol from x$kzsro))
      or (ro.owner# != 0) and exists (select null from v$enabledprivs
                 where priv_number in (-218 /* MANAGE ANY QUEUE */,
                                       -220 /* DEQUEUE ANY QUEUE */))
      or (bitand(t.flags, 8) = 0
          and (exists (select null from sys.objauth$ oa, sys.obj$ o
                      where oa.obj# = o.obj#
                      and o.owner# = 0
                      and (o.name = 'DBMS_AQ' or  o.name = 'DBMS_AQADM')
                      and o.type# = 9
                      and oa.grantee# = userenv('SCHEMAID'))))
     );

   COMMENT ON COLUMN "SYS"."ALL_INT_DEQUEUE_QUEUES"."OWNER" IS 'Owner of the queue';
   COMMENT ON COLUMN "SYS"."ALL_INT_DEQUEUE_QUEUES"."NAME" IS 'Name of the queue';
   COMMENT ON COLUMN "SYS"."ALL_INT_DEQUEUE_QUEUES"."QID" IS 'Object number of the queue';
   COMMENT ON TABLE "SYS"."ALL_INT_DEQUEUE_QUEUES"  IS 'All queues accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_INTERNAL_TRIGGERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_INTERNAL_TRIGGERS" ("TABLE_NAME", "INTERNAL_TRIGGER_TYPE") AS 
  select o.name, 'DEFERRED RPC QUEUE'
from sys.tab$ t, sys.obj$ o
where t.obj# = o.obj#
      and bitand(t.trigflag,1) = 1
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
                (select oa.obj#
                 from sys.objauth$ oa
                 where grantee# in ( select kzsrorol
                                     from x$kzsro
                                   )
                )
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                     where priv_number in (-45 /* LOCK ANY TABLE */,
                                           -47 /* SELECT ANY TABLE */,
                                           -397/* READ ANY TABLE */,
                                           -48 /* INSERT ANY TABLE */,
                                           -49 /* UPDATE ANY TABLE */,
                                           -50 /* DELETE ANY TABLE */)
                     )
          )
union
select o.name, 'MVIEW LOG'
from sys.tab$ t, sys.obj$ o
where t.obj# = o.obj#
      and bitand(t.trigflag,2) = 2
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
                (select oa.obj#
                 from sys.objauth$ oa
                 where grantee# in ( select kzsrorol
                                     from x$kzsro
                                   )
                )
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                     where priv_number in (-45 /* LOCK ANY TABLE */,
                                           -47 /* SELECT ANY TABLE */,
                                           -397/* READ ANY TABLE */,
                                           -48 /* INSERT ANY TABLE */,
                                           -49 /* UPDATE ANY TABLE */,
                                           -50 /* DELETE ANY TABLE */)
                     )
          )
union
select o.name, 'UPDATABLE MVIEW LOG'
from sys.tab$ t, sys.obj$ o
where t.obj# = o.obj#
      and bitand(t.trigflag,4) = 4
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
                (select oa.obj#
                 from sys.objauth$ oa
                 where grantee# in ( select kzsrorol
                                     from x$kzsro
                                   )
                )
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                     where priv_number in (-45 /* LOCK ANY TABLE */,
                                           -47 /* SELECT ANY TABLE */,
                                           -397/* READ ANY TABLE */,
                                           -48 /* INSERT ANY TABLE */,
                                           -49 /* UPDATE ANY TABLE */,
                                           -50 /* DELETE ANY TABLE */)
                     )
          )
union
select o.name, 'CONTEXT'
from sys.tab$ t, sys.obj$ o
where t.obj# = o.obj#
      and bitand(t.trigflag,8) = 8
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
                (select oa.obj#
                 from sys.objauth$ oa
                 where grantee# in ( select kzsrorol
                                     from x$kzsro
                                   )
                )
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                     where priv_number in (-45 /* LOCK ANY TABLE */,
                                           -47 /* SELECT ANY TABLE */,
                                           -397/* READ ANY TABLE */,
                                           -48 /* INSERT ANY TABLE */,
                                           -49 /* UPDATE ANY TABLE */,
                                           -50 /* DELETE ANY TABLE */)
                     )
          )
union
select o.name, 'SYNC CHANGE TABLE'
from sys.tab$ t, sys.obj$ o
where t.obj# = o.obj#
      and bitand(t.trigflag,16) = 16
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
                (select oa.obj#
                 from sys.objauth$ oa
                 where grantee# in ( select kzsrorol
                                     from x$kzsro
                                   )
                )
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                     where priv_number in (-45 /* LOCK ANY TABLE */,
                                           -47 /* SELECT ANY TABLE */,
                                           -397/* READ ANY TABLE */,
                                           -48 /* INSERT ANY TABLE */,
                                           -49 /* UPDATE ANY TABLE */,
                                           -50 /* DELETE ANY TABLE */)
                     )
          )
union
select o.name, 'ZONEMAP'
from sys.tab$ t, sys.obj$ o
where t.obj# = o.obj#
      and bitand(t.trigflag,1024) = 1024
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
                (select oa.obj#
                 from sys.objauth$ oa
                 where grantee# in ( select kzsrorol
                                     from x$kzsro
                                   )
                )
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                     where priv_number in (-45 /* LOCK ANY TABLE */,
                                           -47 /* SELECT ANY TABLE */,
                                           -397/* READ ANY TABLE */,
                                           -48 /* INSERT ANY TABLE */,
                                           -49 /* UPDATE ANY TABLE */,
                                           -50 /* DELETE ANY TABLE */)
                     )
          )
union
select o.name, 'MVIEW STATEMENT REFRESH'
from sys.tab$ t, sys.obj$ o
where t.obj# = o.obj#
      and bitand(t.trigflag,2048) = 2048
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
                (select oa.obj#
                 from sys.objauth$ oa
                 where grantee# in ( select kzsrorol
                                     from x$kzsro
                                   )
                )
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                     where priv_number in (-45 /* LOCK ANY TABLE */,
                                           -47 /* SELECT ANY TABLE */,
                                           -397/* READ ANY TABLE */,
                                           -48 /* INSERT ANY TABLE */,
                                           -49 /* UPDATE ANY TABLE */,
                                           -50 /* DELETE ANY TABLE */)
                     )
          );

   COMMENT ON COLUMN "SYS"."ALL_INTERNAL_TRIGGERS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_INTERNAL_TRIGGERS"."INTERNAL_TRIGGER_TYPE" IS 'Type of internal trigger';
   COMMENT ON TABLE "SYS"."ALL_INTERNAL_TRIGGERS"  IS 'Description of the internal triggers on the tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_ARGUMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_ARGUMENTS" ("OWNER", "NAME", "METHOD_INDEX", "METHOD_NAME", "ARGUMENT_POSITION", "ARRAY_DEPTH", "BASE_TYPE", "ARGUMENT_CLASS") AS 
  select /*+ no_cartesian(mmd) no_cartesian(mag)  ordered use_nl(o mmd) */ u.name, mmd.kln, mmd.mix, mmd.mnm, mag.aix,
       mag.aad,
       decode(mag.abt, 10, 'int',
                     11, 'long',
                     6, 'float',
                     7, 'double',
                     4, 'boolean',
                     8, 'byte',
                     5, 'char',
                     9, 'short',
                     2, 'class',
                     NULL),
       mag.aln
from sys.x$joxfm mmd, sys.x$joxmag mag, user$ u
where mmd.own = u.user#
  and mmd.mix != -1
  and mmd.mix = mag.mix
  and mmd.obn = mag.obn
  and
  (
    u.user# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          mmd.obn in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_ARGUMENTS"."OWNER" IS 'owner of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_ARGUMENTS"."NAME" IS 'name of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_ARGUMENTS"."METHOD_INDEX" IS 'the index of the method';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_ARGUMENTS"."METHOD_NAME" IS 'the name of the method';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_ARGUMENTS"."ARGUMENT_POSITION" IS 'the position of the argument, starting from 0';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_ARGUMENTS"."ARRAY_DEPTH" IS 'array depth of the type of the arguement';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_ARGUMENTS"."BASE_TYPE" IS 'base type of the type of the argument';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_ARGUMENTS"."ARGUMENT_CLASS" IS 'if base_type is class, this gives the actual class name of the argument';
   COMMENT ON TABLE "SYS"."ALL_JAVA_ARGUMENTS"  IS 'argument information for java classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_CLASSES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_CLASSES" ("OWNER", "NAME", "MAJOR", "MINOR", "KIND", "ACCESSIBILITY", "IS_INNER", "IS_ABSTRACT", "IS_FINAL", "IS_STATIC", "IS_STRICTFP", "IS_SYNTHETIC", "IS_DEBUG", "SOURCE", "SUPER", "OUTER") AS 
  select /*+ no_cartesian(m) ordered use_nl(o m)*/
       u.name, m.kln, m.maj, m.min,
       decode(BITAND(m.acc, 512 + 8192 + 16384), 0,     'CLASS',
                                                 512,   'INTERFACE',
                                                 8192,  'ANNOTATION',
                                                 16384, 'ENUM',
                      '??? OAC = '|| BITAND(m.oac, 512 + 8192 + 16384)),
       decode(BITAND(decode(BITAND(m.acc, 131072), 131072, m.oac, m.acc), 7),
              1, 'PUBLIC',
              2, 'PRIVATE',
              4, 'PROTECTED',
              NULL),
       decode(BITAND(m.acc, 131072), 131072, 'YES', 0, 'NO'),
       decode(BITAND(m.acc, 1024), 1024, 'YES', 0, 'NO'),
       decode(BITAND(decode(BITAND(m.acc, 131072), 131072, m.oac, m.acc), 16),
              16, 'YES', 0, 'NO'),
       decode(BITAND(decode(BITAND(m.acc, 131072), 131072, m.oac, m.acc), 8),
              8, 'YES', 0, 'NO'),
       decode(BITAND(decode(BITAND(m.acc, 131072), 131072, m.oac, m.acc),
              2048),
              2048, 'YES', 0, 'NO'),
       decode(BITAND(decode(BITAND(m.acc, 131072), 131072, m.oac, m.acc),
              4096),
              4096, 'YES', 0, 'NO'),
       decode(m.dbg, 1, 'YES', 0, 'NO'),
       m.src, m.spl, m.oln
from sys.x$joxmob m, sys.user$ u
where m.own = u.user#
  and
  (
    m.own in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          m.obn in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."OWNER" IS 'owner of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."NAME" IS 'name of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."MAJOR" IS 'the major version number of the class as defined in JVM specification';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."MINOR" IS 'the minor version number of the class as defined in JVM specification';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."KIND" IS 'type (class, interface, enum or annotation) of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."ACCESSIBILITY" IS 'the accessiblity of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."IS_INNER" IS 'is this class an inner class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."IS_ABSTRACT" IS 'is this an abstract class?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."IS_FINAL" IS 'is this an final class?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."IS_STATIC" IS 'is this a static inner class?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."IS_STRICTFP" IS 'is the class declared strictfp?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."IS_SYNTHETIC" IS 'is this an inner class generated by the compiler?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."IS_DEBUG" IS 'was the class compiled with debug information?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."SOURCE" IS 'source file of the class ';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."SUPER" IS 'super class of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_CLASSES"."OUTER" IS 'outer class of the class if the class is an inner class';
   COMMENT ON TABLE "SYS"."ALL_JAVA_CLASSES"  IS 'class level information for java classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_COMPILER_OPTIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_COMPILER_OPTIONS" ("OWNER", "OPTION_NAME", "VALUE") AS 
  select u.name, o.property,
       dbms_java.decode_native_compiler_option(o.property, o.value)
from sys.user$ u, sys.java$compiler$options o
where o.owner# = u.user#
and o.owner# in (userenv('SCHEMAID'), 0 /* SYS */);

   COMMENT ON COLUMN "SYS"."ALL_JAVA_COMPILER_OPTIONS"."OWNER" IS 'owner of native-compiler option';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_COMPILER_OPTIONS"."OPTION_NAME" IS 'name of the native-compiler option';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_COMPILER_OPTIONS"."VALUE" IS 'value of the native-compiler option';
   COMMENT ON TABLE "SYS"."ALL_JAVA_COMPILER_OPTIONS"  IS 'native-compiler options applicable to user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_DERIVATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_DERIVATIONS" ("OWNER", "SOURCE_NAME", "CLASS_INDEX", "CLASS_NAME") AS 
  select u.name,
       nvl(j.longdbcs, o.name),
       t.joxftderivedclassnumber,
       nvl(j2.longdbcs, t.joxftderivedclassname)
from sys.javasnm$ j, sys.javasnm$ j2, sys.obj$ o, sys.x$joxdrc t, sys.user$ u
where o.obj# = t.joxftobn
  and o.type# = 28
  and o.owner# = u.user#
  and j.short(+) = o.name
  and j2.short(+) = t.joxftderivedclassname
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_DERIVATIONS"."OWNER" IS 'owner of the java class object';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_DERIVATIONS"."SOURCE_NAME" IS 'name of the java source object';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_DERIVATIONS"."CLASS_INDEX" IS 'index of the derived java class object';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_DERIVATIONS"."CLASS_NAME" IS 'name of the derived java class object';
   COMMENT ON TABLE "SYS"."ALL_JAVA_DERIVATIONS"  IS 'this view maps java source objects and their derived java class objects and java resource objects  for the java class accessible to user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_FIELDS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_FIELDS" ("OWNER", "NAME", "FIELD_INDEX", "FIELD_NAME", "ACCESSIBILITY", "IS_STATIC", "IS_FINAL", "IS_VOLATILE", "IS_TRANSIENT", "IS_SYNTHETIC", "IS_ENUM", "ARRAY_DEPTH", "BASE_TYPE", "FIELD_CLASS") AS 
  select /*+ no_cartesian(m) ordered use_nl(o m) */ u.name, m.kln, m.fix, m.fnm,
       decode(BITAND(m.fac, 7), 1, 'PUBLIC',
                                2, 'PRIVATE',
                                4, 'PROTECTED',
                                NULL),
       decode(BITAND(m.fac, 8), 8, 'YES',
                                0, 'NO'),
       decode(BITAND(m.fac, 16), 16, 'YES',
                                 0, 'NO'),
       decode(BITAND(m.fac, 64), 64, 'YES',
                                 0, 'NO'),
       decode(BITAND(m.fac, 128), 128, 'YES',
                                  0, 'NO'),
       decode(BITAND(m.fac, 4096), 4096, 'YES',
                                  0, 'NO'),
       decode(BITAND(m.fac, 16384), 16384, 'YES',
                                  0, 'NO'),
       m.fad,
       decode(m.fbt, 10, 'int',
                     11, 'long',
                     6, 'float',
                     7, 'double',
                     4, 'boolean',
                     8, 'byte',
                     5, 'char',
                     9, 'short',
                     2, 'class',
                     NULL),
       m.fln
from sys.x$joxmfd m, sys.user$ u
where m.own = u.user#
  and m.fix != -1
  and
  (
    m.own in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          m.obn in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."OWNER" IS 'owner of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."NAME" IS 'name of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."FIELD_INDEX" IS 'the index of the field';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."FIELD_NAME" IS 'the name of the field at FIELD_INDEX';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."ACCESSIBILITY" IS 'the accessiblity of the field, public/private/protected/null(i.e. package)';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."IS_STATIC" IS 'is the field a static field?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."IS_FINAL" IS 'is the field a final field?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."IS_VOLATILE" IS 'is the field volatile?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."IS_TRANSIENT" IS 'is the field transient?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."IS_SYNTHETIC" IS 'is the field generated by the compiler?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."IS_ENUM" IS 'is the field a member of an enum?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."ARRAY_DEPTH" IS 'array depth of the type of the field';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."BASE_TYPE" IS 'base type of the type of the field';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_FIELDS"."FIELD_CLASS" IS 'if base_type is class, this gives the actual class name of the base object';
   COMMENT ON TABLE "SYS"."ALL_JAVA_FIELDS"  IS 'field information for java classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_IMPLEMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_IMPLEMENTS" ("OWNER", "NAME", "INTERFACE_INDEX", "INTERFACE_NAME") AS 
  select /*+ no_cartesian(m) ordered use_nl(o m) */
       u.name, nvl(j.longdbcs, o.name), m.ifx, m.iln
from sys.javasnm$ j, sys.obj$ o, sys.x$joxmif m, sys.user$ u
where o.obj# = m.obn
  and o.type# = 29
  and o.owner# = u.user#
  and j.short(+) = o.name
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_IMPLEMENTS"."OWNER" IS 'owner of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_IMPLEMENTS"."NAME" IS 'name of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_IMPLEMENTS"."INTERFACE_INDEX" IS 'index of the interfaces implemented by the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_IMPLEMENTS"."INTERFACE_NAME" IS 'name of the interface identified by the INTERFACE_INDEX';
   COMMENT ON TABLE "SYS"."ALL_JAVA_IMPLEMENTS"  IS 'interfaces implemented by java classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_INNERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_INNERS" ("OWNER", "NAME", "INNER_INDEX", "SIMPLE_NAME", "FULL_NAME", "ACCESSIBILITY", "IS_STATIC", "IS_FINAL", "IS_ABSTRACT", "IS_INTERFACE", "IS_STRICTFP", "IS_SYNTHETIC", "IS_ENUM", "IS_ANNOTATION", "KIND", "ALL_QUALIFIERS") AS 
  select u.name,
       m.kln, m.nix, m.nsm, m.nln,
       decode(BITAND(m.oac, 7), 1, 'PUBLIC',
                                2, 'PRIVATE',
                                4, 'PROTECTED',
                                NULL),
       decode(BITAND(m.oac, 8), 8, 'YES', 0, 'NO'),
       decode(BITAND(m.oac, 16), 16, 'YES', 0, 'NO'),
       decode(BITAND(m.oac, 1024), 1024, 'YES', 0, 'NO'),
       decode(BITAND(m.oac, 512), 512, 'YES', 0, 'NO'),
       decode(BITAND(m.oac, 2048), 2048, 'YES', 0, 'NO'),
       decode(BITAND(m.oac, 4096), 4096, 'YES', 0, 'NO'),
       decode(BITAND(m.oac, 8192), 8192, 'YES', 0, 'NO'),
       decode(BITAND(m.oac, 16384), 16384, 'YES', 0, 'NO'),
       decode(BITAND(m.oac, 512 + 8192 + 16384), 0,     'CLASS',
                                                 512,   'INTERFACE',
                                                 8192,  'ANNOTATION',
                                                 16384, 'ENUM',
                      '??? OAC = '|| BITAND(m.oac, 512 + 8192 + 16384)),
       decode(BITAND(m.oac, 7), 1, 'PUBLIC ',
                                2, 'PRIVATE ',
                                4, 'PROTECTED ',
                                '') ||
       decode(BITAND(m.oac, 8), 8, 'STATIC ', 0, '') ||
       decode(BITAND(m.oac, 16), 16, 'FINAL ', 0, '') ||
       decode(BITAND(m.oac, 1024), 1024, 'ABSTRACT ', 0, '') ||
       decode(BITAND(m.oac, 2048), 2048, 'STRICTFP ', 0, '') ||
       decode(BITAND(m.oac, 4096), 4096, 'SYNTHETIC ', 0, '') ||
       decode(BITAND(m.oac, 512 + 8192 + 16384), 0,     'CLASS',
                                                 512,   'INTERFACE',
                                                 8192,  'ANNOTATION',
                                                 16384, 'ENUM',
                      '??? OAC = '|| BITAND(m.oac, 512 + 8192 + 16384))
from sys.x$joxmic m, sys.user$ u
where m.own = u.user#
  and m.nix != -1
  and
  (
    m.own in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          m.obn in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."OWNER" IS 'owner of the referencing class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."NAME" IS 'name of the referencing class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."INNER_INDEX" IS 'index of the inner class among the inner classes referenced by the referencing class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."SIMPLE_NAME" IS 'simple name of the inner class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."FULL_NAME" IS 'full name of the inner class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."ACCESSIBILITY" IS 'accessibility (public, protected, private) of the inner class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."IS_STATIC" IS 'is the inner class declared or implicitly static';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."IS_FINAL" IS 'is the inner class declared final';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."IS_ABSTRACT" IS 'is the inner class declared abstract';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."IS_INTERFACE" IS 'is the inner class an interface';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."IS_STRICTFP" IS 'is the inner class declared strictfp';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."IS_SYNTHETIC" IS 'is the inner class generated by the compiler';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."IS_ENUM" IS 'is the inner class an enum';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."IS_ANNOTATION" IS 'is the inner class an annotation';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."KIND" IS 'type (class, interface, enum or annotation) of the inner class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_INNERS"."ALL_QUALIFIERS" IS 'concatenation of accessibility, type and other attributes of the inner class';
   COMMENT ON TABLE "SYS"."ALL_JAVA_INNERS"  IS 'list of inner classes referenced by a java class accessible to user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_LAYOUTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_LAYOUTS" ("OWNER", "NAME", "INTERFACES", "INNER_CLASSES", "FIELDS", "STATIC_FIELDS", "METHODS", "STATIC_METHODS", "NATIVE_METHODS") AS 
  select /*+ no_cartesian(m) ordered use_nl(o m) */
              u.name, nvl(j.longdbcs, o.name), m.lic, m.lnc,
              m.lfc, m.lsf,
              m.lmc, m.lsm, m.jnc
from sys.javasnm$ j, sys.obj$ o, sys.x$joxmob m, sys.user$ u
where o.obj# = m.obn
  and o.type# = 29
  and o.owner# = u.user#
  and j.short(+) = o.name
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_LAYOUTS"."OWNER" IS 'owner of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_LAYOUTS"."INTERFACES" IS 'how many interfaces does this class implement?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_LAYOUTS"."INNER_CLASSES" IS 'how many inner classes does this class contain?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_LAYOUTS"."FIELDS" IS 'how many locally declared fields does this class contain?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_LAYOUTS"."STATIC_FIELDS" IS 'how many locally declared static fields does this class contain?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_LAYOUTS"."METHODS" IS 'how many locally declared methods does this class contain?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_LAYOUTS"."STATIC_METHODS" IS 'how many locally declared static methods does this class contain?';
   COMMENT ON TABLE "SYS"."ALL_JAVA_LAYOUTS"  IS 'class layout information for java classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_METHODS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_METHODS" ("OWNER", "NAME", "METHOD_INDEX", "METHOD_NAME", "ACCESSIBILITY", "IS_STATIC", "IS_FINAL", "IS_SYNCHRONIZED", "HAS_VARARGS", "IS_NATIVE", "IS_ABSTRACT", "IS_STRICTFP", "IS_SYNTHETIC", "ARGUMENTS", "THROWS", "ARRAY_DEPTH", "BASE_TYPE", "RETURN_CLASS", "IS_COMPILED") AS 
  select /*+ no_cartesian(m) no_cartesian(m) ordered use_nl(o m) */ u.name,
m.kln, m.mix, m.mnm,
       decode(BITAND(m.mac, 7), 1, 'PUBLIC',
                                2, 'PRIVATE',
                                4, 'PROTECTED',
                                NULL),
       decode(BITAND(m.mac, 8), 8, 'YES',
                                0, 'NO'),
       decode(BITAND(m.mac, 16), 16, 'YES',
                                 0, 'NO'),
       decode(BITAND(m.mac, 32), 32, 'YES',
                                 0, 'NO'),
       decode(BITAND(m.mac, 128), 128, 'YES',
                                 0, 'NO'),
       decode(BITAND(m.mac, 256), 256, 'YES',
                                  0, 'NO'),
       decode(BITAND(m.mac, 1024), 1024, 'YES',
                                   0, 'NO'),
       decode(BITAND(m.mac, 2048), 2048, 'YES',
                                   0, 'NO'),
       decode(BITAND(m.mac, 4096), 4096, 'YES',
                                   0, 'NO'),
       m.agc, m.exc, m.rad,
       decode(m.rbt, 10, 'int',
                     11, 'long',
                     6,  'float',
                     7,  'double',
                     4,  'boolean',
                     8,  'byte',
                     5,  'char',
                     9,  'short',
                     2,  'class',
                     12, 'void',
                     NULL),
       m.rln,
       nvl((select 'YES' from sys.java$mc$ j where
               j.method#=m.mmt and
               j.obj#=m.obn and
               j.length>68 and
               rownum=1), 'NO')
from sys.x$joxmmd m, user$ u
where m.own = u.user#
  and m.mix != -1
  and
  (
    m.own in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          m.obn in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."OWNER" IS 'owner of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."NAME" IS 'name of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."METHOD_INDEX" IS 'the index of the method';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."METHOD_NAME" IS 'the name of the method at METHOD_INDEX';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."ACCESSIBILITY" IS 'the accessiblity of the method, public/private/protected/null(i.e. package)';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."IS_STATIC" IS 'is the method a static method?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."IS_FINAL" IS 'is the method a final method?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."IS_SYNCHRONIZED" IS 'is the method a synchronized method?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."HAS_VARARGS" IS 'does the method have a variable number of arguments?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."IS_NATIVE" IS 'is the method a native method?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."IS_ABSTRACT" IS 'is the method an abstract method?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."IS_STRICTFP" IS 'is the method declared strictfp?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."IS_SYNTHETIC" IS 'is the method generated by the compiler?';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."ARGUMENTS" IS 'number of arguments of the method';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."THROWS" IS 'number of exceptions thrown by the method';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."ARRAY_DEPTH" IS 'array depth of the return type of the method';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."BASE_TYPE" IS 'base type of the return type of the field';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."RETURN_CLASS" IS 'if base_type is class, this gives the actual class name of the return value';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_METHODS"."IS_COMPILED" IS 'has the method been compiled by the just in time compiler?';
   COMMENT ON TABLE "SYS"."ALL_JAVA_METHODS"  IS 'method information for java classes accessible the current user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_NCOMPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_NCOMPS" ("OWNER", "NAME", "SOURCE", "INITIALIZER", "LIBRARYFILE", "LIBRARY") AS 
  select /*+ no_cartesian(t) ordered use_nl(o t) */
       u.name,
       nvl(j.longdbcs, o.name),
       t.joxftncompsource,
       t.joxftncompinitializer,
       t.joxftncomplibraryfile,
       t.joxftncomplibrary
from sys.javasnm$ j, sys.obj$ o, sys.x$joxobj t, sys.user$ u
where o.obj# = t.joxftobn
  and o.type# = 29
  and o.owner# = u.user#
  and j.short(+) = o.name
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_NCOMPS"."OWNER" IS 'owner of the java class object';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_NCOMPS"."NAME" IS 'name of the java class object';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_NCOMPS"."SOURCE" IS 'ncomp source shown in this row';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_NCOMPS"."INITIALIZER" IS 'ncomp initializer shown in this row';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_NCOMPS"."LIBRARYFILE" IS 'ncomp libraryfile shown in this row';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_NCOMPS"."LIBRARY" IS 'ncomp library shown in this row';
   COMMENT ON TABLE "SYS"."ALL_JAVA_NCOMPS"  IS 'ncomp related information of all java classes'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_RESOLVERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_RESOLVERS" ("OWNER", "NAME", "TERM_INDEX", "PATTERN", "SCHEMA") AS 
  select u.name,
       nvl(j.longdbcs, o.name),
       t.joxftresolvertermnumber,
       t.joxftresolvertermpattern,
       t.joxftresolvertermschema
from sys.javasnm$ j, sys.obj$ o, sys.x$joxrsv t, sys.user$ u
where o.obj# = t.joxftobn
  and o.type# = 29
  and o.owner# = u.user#
  and j.short(+) = o.name
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          o.obj# in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_RESOLVERS"."OWNER" IS 'owner of the java class object';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_RESOLVERS"."NAME" IS 'name of the java class object';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_RESOLVERS"."TERM_INDEX" IS 'index of the resolver term in this row';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_RESOLVERS"."PATTERN" IS 'resolver pattern of the resolver term identified by TERM_INDEX column';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_RESOLVERS"."SCHEMA" IS 'resolver schema of the resolver term identified by TERM_INDEX column';
   COMMENT ON TABLE "SYS"."ALL_JAVA_RESOLVERS"  IS 'resolver of java class owned by user'
;
--------------------------------------------------------
--  DDL for View ALL_JAVA_THROWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JAVA_THROWS" ("OWNER", "NAME", "METHOD_INDEX", "METHOD_NAME", "EXCEPTION_INDEX", "EXCEPTION_CLASS") AS 
  select /*+ no_cartesian(mmd) no_cartesian(mex)  ordered use_nl(o mmd) */
       u.name, mmd.kln, mmd.mix, mmd.mnm, mex.xix, mex.xln
from sys.x$joxmex mex, sys.x$joxmmd mmd, sys.user$ u
where mmd.own = u.user#
  and mmd.mix != -1
  and mmd.mix = mex.mix
  and mmd.obn = mex.obn
  and
  (
    u.user# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      (
        (
          mmd.obn in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege#  = 12 /* EXECUTE */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_JAVA_THROWS"."OWNER" IS 'owner of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_THROWS"."NAME" IS 'name of the class';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_THROWS"."METHOD_INDEX" IS 'the index of the method throwing the exception';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_THROWS"."METHOD_NAME" IS 'the name of the method throwing the exception';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_THROWS"."EXCEPTION_INDEX" IS 'the index of the exception';
   COMMENT ON COLUMN "SYS"."ALL_JAVA_THROWS"."EXCEPTION_CLASS" IS 'the class of the exception';
   COMMENT ON TABLE "SYS"."ALL_JAVA_THROWS"  IS 'list of exceptions thrown from methods of classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_JOIN_IND_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JOIN_IND_COLUMNS" ("INDEX_OWNER", "INDEX_NAME", "INNER_TABLE_OWNER", "INNER_TABLE_NAME", "INNER_TABLE_COLUMN", "OUTER_TABLE_OWNER", "OUTER_TABLE_NAME", "OUTER_TABLE_COLUMN") AS 
  select
  ui.name, oi.name,
  uti.name, oti.name, ci.name,
  uto.name, oto.name, co.name
from
  sys.user$ ui, sys.user$ uti, sys.user$ uto,
  sys.obj$ oi, sys.obj$ oti, sys.obj$ oto,
  sys.col$ ci, sys.col$ co,
  sys.jijoin$ ji
where ji.obj# = oi.obj#
  and oi.owner# = ui.user#
  and ji.tab1obj# = oti.obj#
  and oti.owner# = uti.user#
  and ci.obj# = oti.obj#
  and ji.tab1col# = ci.intcol#
  and ji.tab2obj# = oto.obj#
  and oto.owner# = uto.user#
  and co.obj# = oto.obj#
  and ji.tab2col# = co.intcol#
  and (oi.owner# = userenv('SCHEMAID')
        or
       oti.owner# = userenv('SCHEMAID')
        or
       oto.owner# = userenv('SCHEMAID')
        or
       oti.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
        or
       oto.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
        or
          /* user has system privileges */
         ora_check_sys_privilege ( oi.owner#, oi.type#) = 1
        or
         ora_check_sys_privilege ( oti.owner#, oti.type#) = 1
        or
         ora_check_sys_privilege ( oto.owner#, oto.type#) = 1
       );

   COMMENT ON COLUMN "SYS"."ALL_JOIN_IND_COLUMNS"."INDEX_OWNER" IS 'Index owner';
   COMMENT ON COLUMN "SYS"."ALL_JOIN_IND_COLUMNS"."INDEX_NAME" IS 'Index name';
   COMMENT ON COLUMN "SYS"."ALL_JOIN_IND_COLUMNS"."INNER_TABLE_OWNER" IS 'Table owner of inner table (table closer to the fact table)';
   COMMENT ON COLUMN "SYS"."ALL_JOIN_IND_COLUMNS"."INNER_TABLE_NAME" IS 'Table name of inner table (table closer to the fact table)';
   COMMENT ON COLUMN "SYS"."ALL_JOIN_IND_COLUMNS"."INNER_TABLE_COLUMN" IS 'Column name of inner table (table closer to the fact table)';
   COMMENT ON COLUMN "SYS"."ALL_JOIN_IND_COLUMNS"."OUTER_TABLE_OWNER" IS 'Table owner of outer table (table closer to the fact table)';
   COMMENT ON COLUMN "SYS"."ALL_JOIN_IND_COLUMNS"."OUTER_TABLE_NAME" IS 'Table name of outer table (table closer to the fact table)';
   COMMENT ON COLUMN "SYS"."ALL_JOIN_IND_COLUMNS"."OUTER_TABLE_COLUMN" IS 'Column name of outer table (table closer to the fact table)';
   COMMENT ON TABLE "SYS"."ALL_JOIN_IND_COLUMNS"  IS 'Join Index columns comprising the join conditions'
;
--------------------------------------------------------
--  DDL for View ALL_JSON_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JSON_COLUMNS" ("OWNER", "TABLE_NAME", "OBJECT_TYPE", "COLUMN_NAME", "FORMAT", "DATA_TYPE") AS 
  SELECT OWNER, TABLE_NAME, OBJECT_TYPE, COLUMN_NAME, FORMAT, DATA_TYPE
FROM INT$DBA_JSON_COLUMNS
WHERE (NLSSORT(OWNER, 'NLS_SORT=BINARY') =
       NLSSORT(SYS_CONTEXT('USERENV', 'CURRENT_USER'), 'NLS_SORT=BINARY')
       OR OBJ_ID(OWNER, TABLE_NAME, OBJECT_TYPE#, OBJECT_ID) IN
           (select obj# from sys.objauth$  where grantee# in
              (select kzsrorol from x$kzsro))
       OR exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */))
      );

   COMMENT ON COLUMN "SYS"."ALL_JSON_COLUMNS"."OWNER" IS 'Owner of the table with the JSON column';
   COMMENT ON COLUMN "SYS"."ALL_JSON_COLUMNS"."TABLE_NAME" IS 'Name of the table/view with the JSON column';
   COMMENT ON COLUMN "SYS"."ALL_JSON_COLUMNS"."OBJECT_TYPE" IS 'TABLE or VIEW';
   COMMENT ON COLUMN "SYS"."ALL_JSON_COLUMNS"."COLUMN_NAME" IS 'Name of the JSON column';
   COMMENT ON COLUMN "SYS"."ALL_JSON_COLUMNS"."FORMAT" IS 'Format of the JSON data';
   COMMENT ON COLUMN "SYS"."ALL_JSON_COLUMNS"."DATA_TYPE" IS 'Data type of the JSON column';
   COMMENT ON TABLE "SYS"."ALL_JSON_COLUMNS"  IS 'Comments on the JSON columns accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_JSON_DATAGUIDE_FIELDS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JSON_DATAGUIDE_FIELDS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "PATH", "TYPE", "LENGTH") AS 
  SELECT OWNER, TABLE_NAME, COLUMN_NAME, PATH, TYPE, LENGTH
FROM INT$DBA_JSON_DG_COLS
WHERE (NLSSORT(OWNER, 'NLS_SORT=BINARY') =
       NLSSORT(SYS_CONTEXT('USERENV', 'CURRENT_USER'), 'NLS_SORT=BINARY')
       OR OBJ_ID(OWNER, TABLE_NAME, OBJECT_TYPE#, OBJECT_ID) IN
           (select obj# from sys.objauth$  where grantee# in
              (select kzsrorol from x$kzsro))
       OR exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */))
      )
;
--------------------------------------------------------
--  DDL for View ALL_JSON_DATAGUIDES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_JSON_DATAGUIDES" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "DATAGUIDE") AS 
  SELECT OWNER, TABLE_NAME, COLUMN_NAME, DATAGUIDE
FROM INT$DBA_JSON_DATAGUIDES
WHERE (NLSSORT(OWNER, 'NLS_SORT=BINARY') =
       NLSSORT(SYS_CONTEXT('USERENV', 'CURRENT_USER'), 'NLS_SORT=BINARY')
       OR OBJ_ID(OWNER, TABLE_NAME, OBJECT_TYPE#, OBJECT_ID) IN
           (select obj# from sys.objauth$  where grantee# in
              (select kzsrorol from x$kzsro))
       OR exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */))
      )
;
--------------------------------------------------------
--  DDL for View ALL_LIBRARIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_LIBRARIES" ("OWNER", "LIBRARY_NAME", "FILE_SPEC", "DYNAMIC", "STATUS", "AGENT", "LEAF_FILENAME", "ORIGIN_CON_ID") AS 
  select OWNER, LIBRARY_NAME, FILE_SPEC, DYNAMIC, STATUS, AGENT,
       LEAF_FILENAME, ORIGIN_CON_ID
from   INT$DBA_LIBRARIES
where  (OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER = 'PUBLIC'
       or OBJ_ID(OWNER, LIBRARY_NAME, 22, OBJECT_ID) in
          ( select oa.obj#
            from sys.objauth$ oa
            where grantee# in (select kzsrorol from x$kzsro)
          )
       or (
            exists (select NULL from v$enabledprivs
                    where priv_number in (
                                      -189 /* CREATE ANY LIBRARY */,
                                      -190 /* ALTER ANY LIBRARY */,
                                      -191 /* DROP ANY LIBRARY */,
                                      -192 /* EXECUTE ANY LIBRARY */
                                         )
                   )
          )
      );

   COMMENT ON COLUMN "SYS"."ALL_LIBRARIES"."OWNER" IS 'Owner of the library';
   COMMENT ON COLUMN "SYS"."ALL_LIBRARIES"."LIBRARY_NAME" IS 'Name of the library';
   COMMENT ON COLUMN "SYS"."ALL_LIBRARIES"."FILE_SPEC" IS 'Operating system file specification of the library';
   COMMENT ON COLUMN "SYS"."ALL_LIBRARIES"."DYNAMIC" IS 'Is the library dynamically loadable';
   COMMENT ON COLUMN "SYS"."ALL_LIBRARIES"."STATUS" IS 'Status of the library';
   COMMENT ON COLUMN "SYS"."ALL_LIBRARIES"."AGENT" IS 'Agent of the library';
   COMMENT ON COLUMN "SYS"."ALL_LIBRARIES"."LEAF_FILENAME" IS 'Leaf filename of the library';
   COMMENT ON COLUMN "SYS"."ALL_LIBRARIES"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_LIBRARIES"  IS 'Description of libraries accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_LOB_PARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_LOB_PARTITIONS" ("TABLE_OWNER", "TABLE_NAME", "COLUMN_NAME", "LOB_NAME", "PARTITION_NAME", "LOB_PARTITION_NAME", "LOB_INDPART_NAME", "PARTITION_POSITION", "COMPOSITE", "CHUNK", "PCTVERSION", "CACHE", "IN_ROW", "TABLESPACE_NAME", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENTS", "MAX_EXTENTS", "MAX_SIZE", "RETENTION", "MINRETENTION", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "ENCRYPT", "COMPRESSION", "DEDUPLICATION", "SECUREFILE", "SEGMENT_CREATED") AS 
  select u.name,
       o.name,
       decode(bitand(c.property, 1), 1, a.name, c.name),
       lo.name,
       po.subname,
       lpo.subname,
       lipo.subname,
       row_number() over (partition by u.name, o.name,lo.name order by lf.frag#),
       'NO',
       lf.chunk * ts.blocksize,
       decode(bitand(lf.fragflags, 32), 0, lf.pctversion$, to_number(NULL)),
       decode(bitand(lf.fragflags, 795), 1, 'NO', 2, 'NO', 8, 'CACHEREADS',
                                         16, 'CACHEREADS', 256, 'YES', 512,
                                         'YES', 'YES'),
       decode(lf.fragpro, 0, 'NO', 2048, 'NO', 'YES'),
       ts.name,
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.initial_stg, s.iniexts) * ts.blocksize),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.next_stg, s.extsize) * ts.blocksize),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.minext_stg, s.minexts)),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.maxext_stg, s.maxexts)),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.maxsiz_stg * ts.blocksize,
                      decode(bitand(s.spare1, 4194304), 4194304,
                             bitmapranges, NULL))),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      decode(bitand(lf.fragpro, 2048), 2048,
                             decode(ds.lobret_stg, to_number(NULL), 'DEFAULT',
                                                   0, 'NONE', 1, 'AUTO',
                                                   2, 'MIN',  3, 'MAX',
                                                   4, 'DEFAULT', 'INVALID'),
                             decode(bitand(lf.fragflags, 32), 32, 'YES',
                                                            'NO')),
                      decode(bitand(s.spare1, 2097152), 2097152,
                             decode(s.lists, 0, 'NONE', 1, 'AUTO',
                                             2, 'MIN', 3, 'MAX',
                                             4, 'DEFAULT', 'INVALID'),
                             decode(bitand(lf.fragflags, 32), 32, 'YES',
                                                            'NO')))),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      decode(bitand(lf.fragpro, 2048), 2048,
                             ds.mintim_stg, NULL),
                      decode(bitand(s.spare1, 2097152), 2097152,
                             s.groups, NULL))),
       to_char(decode(bitand(ts.flags, 3), 1, to_number(NULL),
                     decode(bitand(lf.fragflags, 33554432), 33554432,
                           ds.pctinc_stg, s.extpct))),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                     decode(ds.frlins_stg, 0, 1, ds.frlins_stg),
                     decode(s.lists, 0, 1, s.lists))),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                     decode(ds.maxins_stg, 0, 1, ds.maxins_stg),
                     decode(s.groups, 0, 1, s.groups))),
       decode(bitand(lf.fragflags, 786), 2,'NO', 16, 'NO', 256, 'NO', 512,
                                           'YES', 'YES'),
       decode(bitand(decode(bitand(lf.fragflags, 33554432), 33554432, ds.bfp_stg, s.cachehint), 3),
              1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(decode(bitand(lf.fragflags, 33554432), 33554432, ds.bfp_stg, s.cachehint), 12)/4,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(decode(bitand(lf.fragflags, 33554432), 33554432, ds.bfp_stg, s.cachehint), 48)/16,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(lf.fragflags,4096), 4096, 'YES',
              decode(bitand(lf.fragpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lf.fragflags,57344), 8192, 'LOW', 16384, 'MEDIUM',
              32768, 'HIGH',
              decode(bitand(lf.fragpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lf.fragflags,458752), 65536, 'LOB', 131072, 'OBJECT',
              327680, 'LOB VALIDATE', 393216, 'OBJECT VALIDATE',
              decode(bitand(lf.fragpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lf.fragpro,2048), 2048, 'YES', 'NO'),
       decode(bitand(lf.fragflags, 33554432), 33554432, 'NO', 'YES')
from   sys.obj$ o, sys.col$ c,
       sys.lob$ l, sys.obj$ lo,
       sys.lobfrag$ lf, sys.obj$ lpo,
       sys.obj$ po, sys.obj$ lipo,
       sys.partobj$ pobj, sys.tab$ t,
       sys.ts$ ts, sys.seg$ s, sys.user$ u, sys.attrcol$ a,
       sys.deferred_stg$ ds
where o.owner# = u.user#
  and pobj.obj# = o.obj#
  and o.obj# = t.obj#
  and bitand(t.trigflag, 1073741824) != 1073741824
  and mod(pobj.spare2, 256) = 0
  and o.obj# = c.obj#
  and c.obj# = l.obj#
  and c.intcol# = l.intcol#
  and l.lobj# = lo.obj#
  and l.lobj# = lf.parentobj#
  and lf.tabfragobj# = po.obj#
  and lf.fragobj# = lpo.obj#
  and lf.indfragobj# = lipo.obj#
  and lf.fragobj# = ds.obj#(+)
  and lf.ts# = s.ts#(+)
  and lf.file# = s.file#(+)
  and lf.block# = s.block#(+)
  and bitand(lf.fragflags, 67108864) = 0    /* filter out hidden fragments */
  and lf.ts# = ts.ts#
  and bitand(lf.fragflags, 67108864) = 0    /* filter out hidden fragments */
  and bitand(c.property,32768) != 32768           /* not unused column */
  and c.obj# = a.obj#(+) and c.intcol# = a.intcol#(+)
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and lo.namespace = 8 and lo.remoteowner IS NULL and lo.linkname IS NULL
  and ((o.owner# = userenv('SCHEMAID') and lo.owner# = userenv('SCHEMAID'))
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
      )
union all
select u.name,
       o.name,
       decode(bitand(c.property, 1), 1, a.name, c.name),
       lo.name,
       po.subname,
       lpo.subname,
       lipo.subname,
       row_number() over (partition by u.name, o.name,lo.name order by lcp.part#),
       'YES',
       lcp.defchunk,
       decode(bitand(lcp.defflags, 32), 0, lcp.defpctver$, to_number(NULL)),
       decode(bitand(lcp.defflags, 795), 1, 'NO', 2, 'NO', 8, 'CACHEREADS',
                                         16, 'CACHEREADS', 256, 'YES', 512,
                                         'YES', 'YES'),
       decode(lcp.defpro, 0, 'NO', 2048, 'NO', 'YES'),
       ts.name,
       decode(lcp.definiexts, NULL, 'DEFAULT', lcp.definiexts),
       decode(lcp.defextsize, NULL, 'DEFAULT', lcp.defextsize),
       decode(lcp.defminexts, NULL, 'DEFAULT', lcp.defminexts),
       decode(lcp.defmaxexts, NULL, 'DEFAULT', lcp.defmaxexts),
       decode(lcp.defmaxsize, NULL, 'DEFAULT', lcp.defmaxsize),
       decode(bitand(lcp.defpro, 2048), 2048,
               decode(lcp.defretention,
                      to_number(NULL), 'DEFAULT',
                      0, 'NONE',
                      1, 'AUTO',
                      2, 'MIN',
                      3, 'MAX',
                      4, 'DEFAULT',
                      'INVALID'),
               decode(bitand(lcp.defflags, 32), 32, 'YES', 'NO')),
       decode(lcp.defmintime, NULL, 'DEFAULT', lcp.defmintime),
       decode(lcp.defextpct,  NULL, 'DEFAULT', lcp.defextpct),
       decode(lcp.deflists,   NULL, 'DEFAULT', lcp.deflists),
       decode(lcp.defgroups,  NULL, 'DEFAULT', lcp.defgroups),
       decode(bitand(lcp.defflags, 790), 0,'NONE', 4,'YES', 2,'NO',
                                  16, 'NO', 256, 'NO', 512, 'YES', 'UNKNOWN'),
       decode(bitand(lcp.defbufpool, 3), 1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(lcp.defbufpool, 12)/4, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(lcp.defbufpool, 48)/16, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(lcp.defflags,4096), 4096, 'YES',
              decode(bitand(lcp.defpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lcp.defflags,57344), 8192, 'LOW', 16384, 'MEDIUM', 32768,
              'HIGH',
              decode(bitand(lcp.defpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lcp.defflags,458752), 65536, 'LOB', 131072, 'OBJECT',
              327680, 'LOB VALIDATE', 393216, 'OBJECT VALIDATE',
              decode(bitand(lcp.defpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lcp.defpro,2048), 2048, 'YES', 'NO'), 'N/A'
from   sys.obj$ o, sys.col$ c,
       sys.lob$ l, sys.obj$ lo,
       sys.lobcomppart$ lcp, sys.obj$ lpo,
       sys.obj$ po, sys.obj$ lipo,
       sys.ts$ ts, partobj$ pobj, sys.tab$ t, sys.user$ u, sys.attrcol$ a
where o.owner# = u.user#
  and pobj.obj# = o.obj#
  and o.obj# = t.obj#
  and bitand(t.trigflag, 1073741824) != 1073741824
  and mod(pobj.spare2, 256) != 0
  and o.obj# = c.obj#
  and c.obj# = l.obj#
  and c.intcol# = l.intcol#
  and l.lobj# = lo.obj#
  and l.lobj# = lcp.lobj#
  and lcp.tabpartobj# = po.obj#
  and lcp.partobj# = lpo.obj#
  and lcp.indpartobj# = lipo.obj#
  and lcp.defts# = ts.ts# (+)
  and bitand(lcp.defflags, 67108864) = 0    /* filter out hidden fragments */
  and bitand(c.property,32768) != 32768           /* not unused column */
  and c.obj# = a.obj#(+) and c.intcol# = a.intcol#(+)
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and lo.namespace = 8 and lo.remoteowner IS NULL and lo.linkname IS NULL
  and ((o.owner# = userenv('SCHEMAID') and lo.owner# = userenv('SCHEMAID'))
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
      )
;
--------------------------------------------------------
--  DDL for View ALL_LOBS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_LOBS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "SEGMENT_NAME", "TABLESPACE_NAME", "INDEX_NAME", "CHUNK", "PCTVERSION", "RETENTION", "FREEPOOLS", "CACHE", "LOGGING", "ENCRYPT", "COMPRESSION", "DEDUPLICATION", "IN_ROW", "FORMAT", "PARTITIONED", "SECUREFILE", "SEGMENT_CREATED", "RETENTION_TYPE", "RETENTION_VALUE") AS 
  select u.name, o.name,
       decode(bitand(c.property, 1), 1, ac.name, c.name), lo.name,
       decode(bitand(l.property, 8),
           8, decode(l.ts#, 2147483647, ts1.name, ts.name), ts.name),
       io.name,
       l.chunk * decode(bitand(l.property, 8), 8, ts1.blocksize,
                        ts.blocksize),
       decode(bitand(l.flags, 32), 0, l.pctversion$, to_number(NULL)),
       decode(bitand(l.flags, 32), 32,
              decode(bitand(l.property, 2048), 2048, to_number(NULL),
                     l.retention), to_number(NULL)),
       decode(l.freepools, 0, to_number(NULL), 65534, to_number(NULL),
              65535, to_number(NULL), l.freepools),
       decode(bitand(l.flags, 795), 1, 'NO', 2, 'NO', 8, 'CACHEREADS',
                                   16, 'CACHEREADS', 256, 'YES', 512, 'YES',
                                    'YES'),
       decode(bitand(l.flags, 786), 2, 'NO', 16, 'NO', 256, 'NO', 512, 'YES',
                                    'YES'),
       decode(bitand(l.flags, 4096), 4096, 'YES',
              decode(bitand(l.property, 2048), 2048, 'NO', 'NONE')),
       decode(bitand(l.flags, 57344), 8192, 'LOW', 16384, 'MEDIUM', 32768,
              'HIGH',
              decode(bitand(l.property, 2048), 2048, 'NO', 'NONE')),
       decode(bitand(l.flags, 458752), 65536, 'LOB', 131072, 'OBJECT',
              327680, 'LOB VALIDATE', 393216, 'OBJECT VALIDATE',
              decode(bitand(l.property, 2048), 2048, 'NO', 'NONE')),
       decode(bitand(l.property, 2), 2, 'YES', 'NO'),
       decode(c.type#, 113, 'NOT APPLICABLE ',
              decode(bitand(l.property, 512), 512,
                     'ENDIAN SPECIFIC', 'ENDIAN NEUTRAL ')),
       decode(bitand(ta.property, 32), 32, 'YES', 'NO'),
       decode(bitand(l.property, 2048), 2048, 'YES', 'NO'),
       decode(bitand(l.property, 4096), 4096, 'NO',
              decode(bitand(ta.property, 32), 32, 'N/A', 'YES')),
       decode (bitand(l.property, 2048),
               2048,
               decode(bitand(ta.property, 17179869184), 17179869184,
                      decode(ds.lobret_stg, to_number(NULL), 'DEFAULT',
                                            0, 'NONE', 1, 'AUTO',
                                            2, 'MIN', 3, 'MAX',
                                            4, 'DEFAULT', 'INVALID'),
                      decode(s.lists, 0, 'NONE', 1, 'AUTO',
                                      2, 'MIN', 3, 'MAX',
                                      4, 'DEFAULT', 'INVALID')),
               decode(bitand(l.flags, 32), 32, 'YES', 'NO')),
       decode (bitand(l.property, 2048),
               2048,
               decode(bitand(ta.property, 17179869184), 17179869184,
                      decode(ds.lobret_stg, 2, ds.mintim_stg, to_number(NULL)),
                      decode(s.lists, 2, s.groups, to_number(NULL))))
from sys.obj$ o, sys.col$ c, sys.attrcol$ ac, sys.tab$ ta, sys.lob$ l,
     sys.obj$ lo, sys.obj$ io, sys.user$ u, sys.ts$ ts, sys.ts$ ts1,
     sys.seg$ s, sys.deferred_stg$ ds
where o.owner# = u.user#
  and bitand(o.flags, 128) = 0
  and o.obj# = c.obj#
  and c.obj# = l.obj#
  and c.intcol# = l.intcol#
  and l.lobj# = lo.obj#
  and l.ind# = io.obj#
  and l.ts# = ts.ts#(+)
  and u.tempts# = ts1.ts#
  and c.obj# = ac.obj#(+)
  and c.intcol# = ac.intcol#(+)
  and bitand(c.property,32768) != 32768           /* not unused column */
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has System Privileges */
       ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
  and o.obj# = ta.obj#
  and bitand(ta.property, 32) != 32    /* not partitioned table */
  and l.file# = s.file#(+)
  and l.block# = s.block#(+)
  and l.ts# = s.ts#(+)
  and l.lobj# = ds.obj#(+)
union all
select u.name, o.name,
       decode(bitand(c.property, 1), 1, ac.name, c.name),
       lo.name,
       NVL(ts1.name,
        (select ts2.name
        from    ts$ ts2, partobj$ po
        where   o.obj# = po.obj# and po.defts# = ts2.ts#)),
       io.name,
       plob.defchunk * NVL(ts1.blocksize, NVL((
        select ts2.blocksize
        from   sys.ts$ ts2, sys.lobfrag$ lf
        where  l.lobj# = lf.parentobj# and
               lf.ts# = ts2.ts# and rownum < 2),
        (select ts2.blocksize
        from   sys.ts$ ts2, sys.lobcomppart$ lcp, sys.lobfrag$ lf
        where  l.lobj# = lcp.lobj# and lcp.partobj# = lf.parentobj# and
               lf.ts# = ts2.ts# and rownum < 2))),
       decode(bitand(plob.defflags, 32), 0, plob.defpctver$, to_number(NULL)),
       decode(bitand(plob.defflags, 32), 32,
              decode(bitand(plob.defpro, 2048), 2048, to_number(NULL),
                     l.retention), to_number(NULL)),
       decode(l.freepools, 0, to_number(NULL), 65534, to_number(NULL),
              65535, to_number(NULL), l.freepools),
       decode(bitand(plob.defflags, 795), 1, 'NO', 2, 'NO', 8, 'CACHEREADS',
                                         16, 'CACHEREADS', 256, 'YES',
                                         512, 'YES', 'YES'),
       decode(bitand(plob.defflags, 790), 0,'NONE', 4,'YES', 2,'NO',
                                        16,'NO', 256, 'NO', 512, 'YES',
                                        'UNKNOWN'),
       decode(bitand(plob.defflags, 4096), 4096, 'YES',
              decode(bitand(plob.defpro, 2048), 2048, 'NO', 'NONE')),
       decode(bitand(plob.defflags, 57344), 8192, 'LOW', 16384, 'MEDIUM',
              32768, 'HIGH',
              decode(bitand(plob.defpro, 2048), 2048, 'NO', 'NONE')),
       decode(bitand(plob.defflags, 458752), 65536, 'LOB', 131072, 'OBJECT',
              327680, 'LOB VALIDATE', 393216, 'OBJECT VALIDATE',
              decode(bitand(plob.defpro, 2048), 2048, 'NO', 'NONE')),
       decode(bitand(plob.defpro, 2), 2, 'YES', 'NO'),
       decode(c.type#, 113, 'NOT APPLICABLE ',
              decode(bitand(l.property, 512), 512,
                     'ENDIAN SPECIFIC', 'ENDIAN NEUTRAL ')),
       decode(bitand(ta.property, 32), 32, 'YES', 'NO'),
       decode(bitand(plob.defpro, 2048), 2048, 'YES', 'NO'),
       decode(bitand(l.property, 4096), 4096, 'NO', 'YES'),
       decode (bitand(plob.defpro, 2048), 2048,
               decode(bitand(ta.property, 17179869184), 17179869184,
                      decode(ds.lobret_stg, to_number(NULL), 'DEFAULT',
                                            0, 'NONE', 1, 'AUTO',
                                            2, 'MIN', 3, 'MAX',
                                            4, 'DEFAULT', 'INVALID'),
                      decode(s.lists, to_number(NULL), 'DEFAULT',
                                      0, 'NONE', 1, 'AUTO',
                                      2, 'MIN', 3, 'MAX',
                                      4, 'DEFAULT', 'INVALID')),
               decode(bitand(plob.defflags, 32), 32, 'YES', 'NO')),
       decode (bitand(plob.defpro, 2048),
               2048, decode(bitand(ta.property, 17179869184), 17179869184,
                            decode(ds.lobret_stg, 2, plob.defmintime,
                                   to_number(NULL)),
                            decode(s.lists, 2, plob.defmintime, to_number(NULL))
                           ))
from sys.obj$ o, sys.col$ c, sys.attrcol$ ac, sys.partlob$ plob,
     sys.lob$ l, sys.obj$ lo, sys.obj$ io, sys.ts$ ts1, sys.tab$ ta,
     sys.user$ u, sys.seg$ s, sys.deferred_stg$ ds
where o.owner# = u.user#
  and o.obj# = c.obj#
  and c.obj# = l.obj#
  and c.intcol# = l.intcol#
  and l.lobj# = lo.obj#
  and l.ind# = io.obj#
  and l.lobj# = plob.lobj#
  and plob.defts# = ts1.ts# (+)
  and c.obj# = ac.obj#(+)
  and c.intcol# = ac.intcol#(+)
  and bitand(c.property,32768) != 32768           /* not unused column */
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has System Privileges */
       ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
  and o.obj# = ta.obj#
  and bitand(ta.property, 32) = 32         /* partitioned table */
  and l.file# = s.file#(+)
  and l.block# = s.block#(+)
  and l.ts# = s.ts#(+)
  and l.lobj# = ds.obj#(+);

   COMMENT ON COLUMN "SYS"."ALL_LOBS"."OWNER" IS 'Owner of the table containing the LOB';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."TABLE_NAME" IS 'Name of the table containing the LOB';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."COLUMN_NAME" IS 'Name of the LOB column or attribute';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."SEGMENT_NAME" IS 'Name of the LOB segment';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."TABLESPACE_NAME" IS 'Name of the tablespace containing the LOB segment';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."INDEX_NAME" IS 'Name of the LOB index';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."CHUNK" IS 'Size of the LOB chunk as a unit of allocation/manipulation in bytes';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."PCTVERSION" IS 'Maximum percentage of the LOB space used for versioning';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."RETENTION" IS 'Maximum time duration for versioning of the LOB space';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."FREEPOOLS" IS 'Number of freepools for this LOB segment';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."CACHE" IS 'Is the LOB accessed through the buffer cache?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."LOGGING" IS 'Are changes to the LOB logged?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."ENCRYPT" IS 'Is this lob encrypted?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."COMPRESSION" IS 'What level of compression is used for this lob?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."DEDUPLICATION" IS 'What kind of deduplication is used for this lob?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."IN_ROW" IS 'Are some of the LOBs stored with the base row?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."FORMAT" IS 'Is the LOB storage format dependent on the endianness of the platform?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."PARTITIONED" IS 'Is the LOB column in a partitioned table?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."SECUREFILE" IS 'Is the LOB a SECUREFILE LOB?';
   COMMENT ON COLUMN "SYS"."ALL_LOBS"."SEGMENT_CREATED" IS 'Is the LOB segment created?';
   COMMENT ON TABLE "SYS"."ALL_LOBS"  IS 'Description of LOBs contained in tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_LOB_SUBPARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_LOB_SUBPARTITIONS" ("TABLE_OWNER", "TABLE_NAME", "COLUMN_NAME", "LOB_NAME", "LOB_PARTITION_NAME", "SUBPARTITION_NAME", "LOB_SUBPARTITION_NAME", "LOB_INDSUBPART_NAME", "SUBPARTITION_POSITION", "CHUNK", "PCTVERSION", "CACHE", "IN_ROW", "TABLESPACE_NAME", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENTS", "MAX_EXTENTS", "MAX_SIZE", "RETENTION", "MINRETENTION", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "ENCRYPT", "COMPRESSION", "DEDUPLICATION", "SECUREFILE", "SEGMENT_CREATED") AS 
  select u.name,
       o.name,
       decode(bitand(c.property, 1), 1, a.name, c.name),
       lo.name,
       lpo.subname,
       spo.subname,
       lspo.subname,
       lispo.subname,
       row_number() over (partition by u.name, o.name, lo.name, lpo.subname
                          order by lf.frag#),
       lf.chunk * ts.blocksize,
       decode(bitand(lf.fragflags, 32), 0, lf.pctversion$, to_number(NULL)),
       decode(bitand(lf.fragflags, 795), 1, 'NO', 2, 'NO', 8, 'CACHEREADS',
                                         16, 'CACHEREADS', 256, 'YES', 512,
                                         'YES', 'YES'),
       decode(lf.fragpro, 0, 'NO', 2048, 'NO', 'YES'),
       ts.name,
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.initial_stg, s.iniexts) * ts.blocksize),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.next_stg, s.extsize) * ts.blocksize),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.minext_stg, s.minexts)),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.maxext_stg, s.maxexts)),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      ds.maxsiz_stg * ts.blocksize,
                      decode(bitand(s.spare1, 4194304), 4194304,
                             bitmapranges, NULL))),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                     decode(bitand(lf.fragpro, 2048),
                            2048, decode(ds.lobret_stg,
                                         to_number(NULL), 'DEFAULT',
                                         0, 'NONE', 1, 'AUTO',
                                         2, 'MIN',  3, 'MAX',
                                         4, 'DEFAULT', 'INVALID'),
                            decode(bitand(lf.fragflags, 32), 32,'YES', 'NO')),
                     decode(bitand(s.spare1, 2097152), 2097152,
                            decode(s.lists, 0, 'NONE', 1, 'AUTO',
                                            2, 'MIN', 3, 'MAX',
                                            4, 'DEFAULT', 'INVALID'),
                            decode(bitand(lf.fragflags, 32), 32,'YES', 'NO')))),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                      decode(bitand(lf.fragpro, 2048), 2048,
                             ds.mintim_stg, NULL),
                      decode(bitand(s.spare1, 2097152), 2097152,
                             s.groups, NULL))),
       to_char(decode(bitand(ts.flags, 3), 1, to_number(NULL),
                     decode(bitand(lf.fragflags, 33554432), 33554432,
                           ds.pctinc_stg, s.extpct))),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                     decode(ds.frlins_stg, 0, 1, ds.frlins_stg),
                     decode(s.lists, 0, 1, s.lists))),
       to_char(decode(bitand(lf.fragflags, 33554432), 33554432,
                     decode(ds.maxins_stg, 0, 1, ds.maxins_stg),
                     decode(s.groups, 0, 1, s.groups))),
       decode(bitand(lf.fragflags, 786), 2, 'NO', 16, 'NO', 256, 'NO',
                                         512, 'YES', 'YES'),
       decode(bitand(decode(bitand(lf.fragflags, 33554432), 33554432, ds.bfp_stg, s.cachehint), 3),
              1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(decode(bitand(lf.fragflags, 33554432), 33554432, ds.bfp_stg, s.cachehint), 12)/4,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(decode(bitand(lf.fragflags, 33554432), 33554432, ds.bfp_stg, s.cachehint), 48)/16,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(lf.fragflags,4096), 4096, 'YES',
              decode(bitand(lf.fragpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lf.fragflags,57344), 8192, 'LOW', 16384, 'MEDIUM', 32768,
              'HIGH',
              decode(bitand(lf.fragpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lf.fragflags,458752), 65536, 'LOB', 131072, 'OBJECT',
              327680, 'LOB VALIDATE', 393216, 'OBJECT VALIDATE',
              decode(bitand(lf.fragpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(lf.fragpro,2048), 2048, 'YES', 'NO'),
       decode(bitand(lf.fragflags, 33554432), 33554432, 'NO', 'YES')
from   sys.obj$ o, sys.col$ c,
       sys.lob$ l, sys.obj$ lo,
       sys.lobcomppart$ lcp, sys.obj$ lpo,
       sys.lobfrag$ lf, sys.obj$ lspo,
       sys.obj$ spo, sys.obj$ lispo,
       sys.partobj$ pobj, sys.tab$ t,
       sys.ts$ ts, sys.seg$ s, sys.user$ u, sys.attrcol$ a,
       sys.deferred_stg$ ds
where o.owner# = u.user#
  and pobj.obj# = o.obj#
  and o.obj# = t.obj#
  and bitand(t.trigflag, 1073741824) != 1073741824
  and mod(pobj.spare2, 256) != 0
  and o.obj# = c.obj#
  and c.obj# = l.obj#
  and c.intcol# = l.intcol#
  and l.lobj# = lo.obj#
  and l.lobj# = lcp.lobj#
  and lcp.partobj# = lpo.obj#
  and bitand(lcp.defflags, 67108864) = 0    /* filter out hidden fragments */
  and bitand(lf.fragflags, 67108864) = 0    /* filter out hidden fragments */
  and lf.parentobj# = lcp.partobj#
  and lf.tabfragobj# = spo.obj#
  and lf.fragobj# = lspo.obj#
  and lf.indfragobj# = lispo.obj#
  and lf.fragobj# = ds.obj#(+)
  and lf.ts# = s.ts#(+)
  and lf.file# = s.file#(+)
  and lf.block# = s.block#(+)
  and lf.ts# = ts.ts#
  and bitand(c.property,32768) != 32768           /* not unused column */
  and c.obj# = a.obj#(+) and c.intcol# = a.intcol#(+)
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and lo.namespace = 8 and lo.remoteowner IS NULL and lo.linkname IS NULL
  and ((o.owner# = userenv('SCHEMAID') and lo.owner# = userenv('SCHEMAID'))
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
      )
;
--------------------------------------------------------
--  DDL for View ALL_LOB_TEMPLATES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_LOB_TEMPLATES" ("USER_NAME", "TABLE_NAME", "LOB_COL_NAME", "SUBPARTITION_NAME", "LOB_SEGMENT_NAME", "TABLESPACE_NAME") AS 
  select u.name, o.name, decode(bitand(c.property, 1), 1, ac.name, c.name),
       st.spart_name, lst.lob_spart_name, ts.name
from sys.obj$ o, sys.defsubpart$ st, sys.defsubpartlob$ lst, sys.ts$ ts,
     sys.col$ c, sys.attrcol$ ac, sys.user$ u
where o.obj# = lst.bo# and st.bo# = lst.bo# and
      st.spart_position =  lst.spart_position and
      lst.lob_spart_ts# = ts.ts#(+) and c.obj# = lst.bo# and
      c.intcol# = lst.intcol# and lst.intcol# = ac.intcol#(+) and
      lst.bo# = ac.obj#(+) and o.owner# = u.user# and o.subname IS NULL and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID') or
       o.obj# in (select oa.obj# from sys.objauth$ oa
                  where grantee# in ( select kzsrorol from x$kzsro )) or
       exists (select null from v$enabledprivs
               where priv_number in (-45 /* LOCK ANY TABLE */,
                                     -47 /* SELECT ANY TABLE */,
                                     -397/* READ ANY TABLE */,
                                     -48 /* INSERT ANY TABLE */,
                                     -49 /* UPDATE ANY TABLE */,
                                     -50 /* DELETE ANY TABLE */)))
;
--------------------------------------------------------
--  DDL for View ALL_LOG_GROUP_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_LOG_GROUP_COLUMNS" ("OWNER", "LOG_GROUP_NAME", "TABLE_NAME", "COLUMN_NAME", "POSITION", "LOGGING_PROPERTY") AS 
  select u.name, c.name, o.name,
       decode(ac.name, null, col.name, ac.name), cc.pos#,
       decode(cc.spare1, 1, 'NO LOG', 'LOG')
from sys.user$ u, sys.con$ c, sys.col$ col, sys.ccol$ cc, sys.cdef$ cd,
     sys.obj$ o, sys.attrcol$ ac
where c.owner# = u.user#
  and c.con# = cd.con#
  and cd.type# = 12
  and cd.con# = cc.con#
  and cc.obj# = col.obj#
  and cc.intcol# = col.intcol#
  and cc.obj# = o.obj#
  and (c.owner# = userenv('SCHEMAID')
       or cd.obj# in (select obj#
                      from sys.objauth$
                      where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                     )
        or /* user has system privileges */
        ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
  and col.obj# = ac.obj#(+)
  and col.intcol# = ac.intcol#(+);

   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUP_COLUMNS"."OWNER" IS 'Owner of the log group definition';
   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUP_COLUMNS"."LOG_GROUP_NAME" IS 'Name associated with the log group definition';
   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUP_COLUMNS"."TABLE_NAME" IS 'Name associated with table with log group definition';
   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUP_COLUMNS"."COLUMN_NAME" IS 'Name associated with column or attribute of object column specified in the log group definition';
   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUP_COLUMNS"."POSITION" IS 'Original position of column or attribute in definition';
   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUP_COLUMNS"."LOGGING_PROPERTY" IS 'Whether the column or attribute would be supplementally logged';
   COMMENT ON TABLE "SYS"."ALL_LOG_GROUP_COLUMNS"  IS 'Information about columns in log group definitions'
;
--------------------------------------------------------
--  DDL for View ALL_LOG_GROUPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_LOG_GROUPS" ("OWNER", "LOG_GROUP_NAME", "TABLE_NAME", "LOG_GROUP_TYPE", "ALWAYS", "GENERATED") AS 
  select ou.name, oc.name, o.name,
       case c.type# when 14 then 'PRIMARY KEY LOGGING'
                    when 15 then 'UNIQUE KEY LOGGING'
                    when 16 then 'FOREIGN KEY LOGGING'
                    when 17 then 'ALL COLUMN LOGGING'
                    else 'USER LOG GROUP'
       end,
       case bitand(c.defer,64) when 64 then 'ALWAYS'
                               else  'CONDITIONAL'
       end,
       case bitand(c.defer,8) when 8 then 'GENERATED NAME'
                              else  'USER NAME'
       end
from sys.con$ oc,  sys.user$ ou,
     sys.obj$ o, sys.cdef$ c
where oc.owner# = ou.user#
  and oc.con# = c.con#
  and c.obj# = o.obj#
  and
  (c.type# = 12 or c.type# = 14 or
   c.type# = 15 or c.type# = 16 or
   c.type# = 17)
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in (select obj#
                     from sys.objauth$
                     where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                    )
        or /* user has system privileges */
        ora_check_sys_privilege ( o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUPS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUPS"."LOG_GROUP_NAME" IS 'Name associated with log group definition';
   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUPS"."ALWAYS" IS 'Is this an ALWAYS or a CONDITIONAL supplemental log group?';
   COMMENT ON COLUMN "SYS"."ALL_LOG_GROUPS"."GENERATED" IS 'Was the name of this supplemental log group system generated?';
   COMMENT ON TABLE "SYS"."ALL_LOG_GROUPS"  IS 'Log group definitions on accessible tables'
;
--------------------------------------------------------
--  DDL for View ALL_MEASURE_FOLDER_CONTENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MEASURE_FOLDER_CONTENTS" ("OWNER", "MEASURE_FOLDER_NAME", "CUBE_OWNER", "CUBE_NAME", "MEASURE_NAME", "ORDER_NUM") AS 
  SELECT
  u.name OWNER,
  o.name MEASURE_FOLDER_NAME,
  cu.name CUBE_OWNER,
  co.name CUBE_NAME,
  m.measure_name MEASURE_NAME,
  mf.order_num ORDER_NUM
FROM
  olap_meas_folder_contents$ mf,
  obj$ o,
  user$ u,
  olap_measures$ m,
  obj$ co,
  user$ cu,
  (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  mf.measure_folder_obj#=o.obj#
  AND o.owner#=u.user#
  AND mf.object_type = 2 -- MEASURE
  AND mf.object_id = m.measure_id
  AND m.cube_obj# = co.obj#
  AND co.owner# = cu.user#
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- folder is ownwd by user or public object
       or   -- user has access to measure folder
             (o.obj# in
                  ( select obj#  -- directly granted privileges
                    from sys.objauth$
                    where grantee# in ( select kzsrorol from x$kzsro ) ) )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND (co.owner# in (userenv('SCHEMAID'), 1)   -- cube is owned by user or public object
       or   -- user has access to cube
             (co.obj# in
                  ( select obj#  -- directly granted privileges
                    from sys.objauth$
                    where grantee# in ( select kzsrorol from x$kzsro ) ) )
       or   -- user has system privileges
              ora_check_SYS_privilege (co.owner#, co.type#) = 1
            )
  AND co.obj# = da.obj#(+)
  AND (da.have_all_dim_access = 1 or da.have_all_dim_access is NULL);

   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_CONTENTS"."OWNER" IS 'Owner of the OLAP Measure Folder Content';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_CONTENTS"."MEASURE_FOLDER_NAME" IS 'Name of the owning OLAP Measure Folder';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_CONTENTS"."CUBE_OWNER" IS 'Owner of the cube of the OLAP Measure Folder Content';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_CONTENTS"."CUBE_NAME" IS 'Name of the owning cube of the OLAP Measure Folder Content';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_CONTENTS"."MEASURE_NAME" IS 'Name of the owning measure of the OLAP Measure Folder Content';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_CONTENTS"."ORDER_NUM" IS 'Order number of the OLAP Measure Folder Content';
   COMMENT ON TABLE "SYS"."ALL_MEASURE_FOLDER_CONTENTS"  IS 'OLAP Measure Folder Contents in the database accessible by the user'
;
--------------------------------------------------------
--  DDL for View ALL_MEASURE_FOLDERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MEASURE_FOLDERS" ("OWNER", "MEASURE_FOLDER_NAME", "MEASURE_FOLDER_ID", "DESCRIPTION") AS 
  SELECT
  u.name OWNER,
  o.name MEASURE_FOLDER_NAME,
  mf.obj# MEASURE_FOLDER_ID,
  d.description_value DESCRIPTION
FROM
  olap_measure_folders$ mf,
  obj$ o,
  user$ u,
  (select d.* from olap_descriptions$ d, nls_session_parameters n where
        n.parameter = 'NLS_LANGUAGE'
        and d.description_type = 'Description'
        and d.owning_object_type = 10 --MEASURE_FOLDER
        and (d.language = n.value
             or d.language like n.value || '\_%' escape '\')) d
WHERE
  mf.obj# = o.obj#
  AND o.owner# = u.user#
  AND mf.obj# = d.owning_object_id(+)
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDERS"."OWNER" IS 'Owner of the OLAP Measure Folder';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDERS"."MEASURE_FOLDER_NAME" IS 'Name of the OLAP Measure Folder';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDERS"."MEASURE_FOLDER_ID" IS 'Dictionary Id of the OLAP Measure Folder';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDERS"."DESCRIPTION" IS 'Long Description of the OLAP Measure Folder';
   COMMENT ON TABLE "SYS"."ALL_MEASURE_FOLDERS"  IS 'OLAP Measure Folders in the database accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MEASURE_FOLDER_SUBFOLDERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MEASURE_FOLDER_SUBFOLDERS" ("OWNER", "MEASURE_FOLDER_NAME", "MEASURE_SUBFOLDER_OWNER", "MEASURE_SUBFOLDER_NAME") AS 
  SELECT
  u.name OWNER,
  o.name MEASURE_FOLDER_NAME,
  uchild.name MEASURE_SUBFOLDER_OWNER,
  ochild.name MEASURE_SUBFOLDER_NAME
FROM
  olap_meas_folder_contents$ mfc,
  obj$ o,
  obj$ ochild,
  user$ uchild,
  user$ u
WHERE
  mfc.MEASURE_FOLDER_OBJ# = o.obj# -- PARENT
  AND ochild.owner# = uchild.user# -- SUBFOLDER_OWNER
  AND o.owner#=u.user#
  AND mfc.object_type = 10 --MEASURE_FOLDER
  AND ochild.obj# = mfc.OBJECT_ID --CHILD
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_SUBFOLDERS"."OWNER" IS 'Owner of the OLAP Measure Folder that contains a subfolder';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_SUBFOLDERS"."MEASURE_FOLDER_NAME" IS 'Name of the OLAP Measure Folder that contains a subfolder';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_SUBFOLDERS"."MEASURE_SUBFOLDER_OWNER" IS 'Owner of the OLAP Measure Folder subfolder';
   COMMENT ON COLUMN "SYS"."ALL_MEASURE_FOLDER_SUBFOLDERS"."MEASURE_SUBFOLDER_NAME" IS 'Name of the owning OLAP Measure Folder subfolder';
   COMMENT ON TABLE "SYS"."ALL_MEASURE_FOLDER_SUBFOLDERS"  IS 'OLAP Measure Folders contained within the OLAP Measure Folders accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_METADATA_PROPERTIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_METADATA_PROPERTIES" ("OWNER", "OWNING_OBJECT_ID", "OWNING_TYPE", "PROPERTY_ID", "PROPERTY_KEY", "PROPERTY_VALUE", "PROPERTY_ORDER") AS 
  SELECT
  u.name OWNER,
  mp.owning_object_id OWNING_OBJECT_ID,
  decode(mp.owning_type, '1', 'CUBE',
                         '2', 'MEASURE',
                         '3', 'MODEL',
                         '4', 'ASSIGNMENT',
                         '6', 'CALCULATION MEMBER',
                         '8', 'BUILD PROCESS',
                         '10', 'MEASURE FOLDER',
                         '11', 'DIMENSION',
                         '12', 'DIMENSION LEVEL',
                         '13', 'HIERARCHY',
                         '14', 'HIERARCHY LEVEL',
                         '15', 'ATTRIBUTE',
                         '16', 'DIMENSIONALITY',
                         '17', 'ATTRIBUTE MAP',
                         '18', 'HIER LEVEL MAP',
                         '19', 'SOLVED LEVEL HIER MAP',
                         '20', 'SOLVED VALUE HIER MAP',
                         '21', 'MEMBER LIST MAP',
                         '22', 'CUBE MAP',
                         '23', 'CUBE DIMENSIONALITY MAP',
                         '24', 'MEASURE MAP',
                         '34', 'METADATA PROPERTY') OWNING_TYPE,
  mp.property_id PROPERTY_ID,
  mp.property_key PROPERTY_KEY,
  mp.property_value PROPERTY_VALUE,
  mp.property_order PROPERTY_ORDER
FROM
  user$ u,
  obj$ o,
  olap_metadata_properties$ mp
WHERE
  o.obj# = mp.top_obj# -- joined via the top level object id
  AND o.type# = 92 -- Cube Dimension
  AND o.owner#=u.user#(+)
  AND mp.owning_type2 IS NULL
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
UNION ALL
SELECT
  u.name OWNER,
  mp.owning_object_id OWNING_OBJECT_ID,
  decode(mp.owning_type, '1', 'CUBE',
                         '2', 'MEASURE',
                         '3', 'MODEL',
                         '4', 'ASSIGNMENT',
                         '6', 'CALCULATION MEMBER',
                         '8', 'BUILD PROCESS',
                         '10', 'MEASURE FOLDER',
                         '11', 'DIMENSION',
                         '12', 'DIMENSION LEVEL',
                         '13', 'HIERARCHY',
                         '14', 'HIERARCHY LEVEL',
                         '15', 'ATTRIBUTE',
                         '16', 'DIMENSIONALITY',
                         '17', 'ATTRIBUTE MAP',
                         '18', 'HIER LEVEL MAP',
                         '19', 'SOLVED LEVEL HIER MAP',
                         '20', 'SOLVED VALUE HIER MAP',
                         '21', 'MEMBER LIST MAP',
                         '22', 'CUBE MAP',
                         '23', 'CUBE DIMENSIONALITY MAP',
                         '24', 'MEASURE MAP',
                         '34', 'METADATA PROPERTY') OWNING_TYPE,
  mp.property_id PROPERTY_ID,
  mp.property_key PROPERTY_KEY,
  mp.property_value PROPERTY_VALUE,
  mp.property_order PROPERTY_ORDER
FROM
  user$ u,
  obj$ o,
  olap_metadata_properties$ mp,
 (SELECT
    obj#,
    MIN(have_dim_access) have_all_dim_access
  FROM
    (SELECT
      c.obj# obj#,
      (CASE
        WHEN
        (do.owner# in (userenv('SCHEMAID'), 1)   -- public objects
         or do.obj# in
              ( select obj#  -- directly granted privileges
                from sys.objauth$
                where grantee# in ( select kzsrorol from x$kzsro )
              )
         or   -- user has system privileges
                ora_check_SYS_privilege (do.owner#, do.type#) = 1
        )
        THEN 1
        ELSE 0
       END) have_dim_access
    FROM
      olap_cubes$ c,
      dependency$ d,
      obj$ do
    WHERE
      do.obj# = d.p_obj#
      AND do.type# = 92 -- CUBE DIMENSION
      AND c.obj# = d.d_obj#
    )
    GROUP BY obj# ) da
WHERE
  o.obj# = mp.top_obj# -- joined via the top level object id
  AND o.type# = 93 -- Cube
  AND o.obj#=da.obj#(+)
  AND o.owner#=u.user#(+)
  AND mp.owning_type2 IS NULL
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            )
  AND ((have_all_dim_access = 1) OR (have_all_dim_access is NULL))
UNION ALL
SELECT
  u.name OWNER,
  mp.owning_object_id OWNING_OBJECT_ID,
  decode(mp.owning_type, '1', 'CUBE',
                         '2', 'MEASURE',
                         '3', 'MODEL',
                         '4', 'ASSIGNMENT',
                         '6', 'CALCULATION MEMBER',
                         '8', 'BUILD PROCESS',
                         '10', 'MEASURE FOLDER',
                         '11', 'DIMENSION',
                         '12', 'DIMENSION LEVEL',
                         '13', 'HIERARCHY',
                         '14', 'HIERARCHY LEVEL',
                         '15', 'ATTRIBUTE',
                         '16', 'DIMENSIONALITY',
                         '17', 'ATTRIBUTE MAP',
                         '18', 'HIER LEVEL MAP',
                         '19', 'SOLVED LEVEL HIER MAP',
                         '20', 'SOLVED VALUE HIER MAP',
                         '21', 'MEMBER LIST MAP',
                         '22', 'CUBE MAP',
                         '23', 'CUBE DIMENSIONALITY MAP',
                         '24', 'MEASURE MAP',
                         '34', 'METADATA PROPERTY') OWNING_TYPE,
  mp.property_id PROPERTY_ID,
  mp.property_key PROPERTY_KEY,
  mp.property_value PROPERTY_VALUE,
  mp.property_order PROPERTY_ORDER
FROM
  user$ u,
  obj$ o,
  olap_metadata_properties$ mp
WHERE
  o.obj# = mp.top_obj# -- joined via the top level object id
  AND o.type# = 94 -- Measure Folder
  AND o.owner#=u.user#(+)
  AND mp.owning_type2 IS NULL
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
       or   -- user has access to cubes in measure folder
              ( exists (select null from olap_meas_folder_contents$ mfc, olap_measures$ m
                        where mfc.measure_folder_obj# = o.obj#
                          and m.measure_id  = mfc.object_id
                          and (
                              m.cube_obj# in
                                ( select obj#  -- directly granted authorization
                                  from sys.objauth$
                                  where grantee# in ( select kzsrorol from x$kzsro )
                                )
                              )
                       )
              )
            )
UNION ALL
SELECT
  u.name OWNER,
  mp.owning_object_id OWNING_OBJECT_ID,
  decode(mp.owning_type, '1', 'CUBE',
                         '2', 'MEASURE',
                         '3', 'MODEL',
                         '4', 'ASSIGNMENT',
                         '6', 'CALCULATION MEMBER',
                         '8', 'BUILD PROCESS',
                         '10', 'MEASURE FOLDER',
                         '11', 'DIMENSION',
                         '12', 'DIMENSION LEVEL',
                         '13', 'HIERARCHY',
                         '14', 'HIERARCHY LEVEL',
                         '15', 'ATTRIBUTE',
                         '16', 'DIMENSIONALITY',
                         '17', 'ATTRIBUTE MAP',
                         '18', 'HIER LEVEL MAP',
                         '19', 'SOLVED LEVEL HIER MAP',
                         '20', 'SOLVED VALUE HIER MAP',
                         '21', 'MEMBER LIST MAP',
                         '22', 'CUBE MAP',
                         '23', 'CUBE DIMENSIONALITY MAP',
                         '24', 'MEASURE MAP',
                         '34', 'METADATA PROPERTY') OWNING_TYPE,
  mp.property_id PROPERTY_ID,
  mp.property_key PROPERTY_KEY,
  mp.property_value PROPERTY_VALUE,
  mp.property_order PROPERTY_ORDER
FROM
  user$ u,
  obj$ o,
  olap_metadata_properties$ mp
WHERE
  o.obj# = mp.top_obj# -- joined via the top level object id
  AND o.type# = 95 -- Build Process
  AND o.owner#=u.user#(+)
  AND mp.owning_type2 IS NULL
  AND (o.owner# in (userenv('SCHEMAID'), 1)   -- public objects
       or o.obj# in
            ( select obj#  -- directly granted privileges
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or   -- user has system privileges
              ora_check_SYS_privilege (o.owner#, o.type#) = 1
            );

   COMMENT ON COLUMN "SYS"."ALL_METADATA_PROPERTIES"."OWNER" IS 'Owner of the OLAP Metadata Property';
   COMMENT ON COLUMN "SYS"."ALL_METADATA_PROPERTIES"."OWNING_OBJECT_ID" IS 'Dictionary Id of the OLAP Metadata Property owner';
   COMMENT ON COLUMN "SYS"."ALL_METADATA_PROPERTIES"."OWNING_TYPE" IS 'Owning type of the OLAP Metadata Property';
   COMMENT ON COLUMN "SYS"."ALL_METADATA_PROPERTIES"."PROPERTY_ID" IS 'Dictionary Id of the OLAP Metadata Property';
   COMMENT ON COLUMN "SYS"."ALL_METADATA_PROPERTIES"."PROPERTY_KEY" IS 'Key of the OLAP Metadata Property';
   COMMENT ON COLUMN "SYS"."ALL_METADATA_PROPERTIES"."PROPERTY_VALUE" IS 'Value of the OLAP Metadata Property';
   COMMENT ON COLUMN "SYS"."ALL_METADATA_PROPERTIES"."PROPERTY_ORDER" IS 'Order number of the OLAP Metadata Property';
   COMMENT ON TABLE "SYS"."ALL_METADATA_PROPERTIES"  IS 'OLAP Metadata Properties in the database'
;
--------------------------------------------------------
--  DDL for View ALL_METHOD_PARAMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_METHOD_PARAMS" ("OWNER", "TYPE_NAME", "METHOD_NAME", "METHOD_NO", "PARAM_NAME", "PARAM_NO", "PARAM_MODE", "PARAM_TYPE_MOD", "PARAM_TYPE_OWNER", "PARAM_TYPE_NAME", "CHARACTER_SET_NAME") AS 
  select u.name, o.name, m.name, m.method#,
       p.name, p.parameter#,
       decode(bitand(p.properties, 768), 768, 'IN OUT',
              decode(bitand(p.properties, 256), 256, 'IN',
                     decode(bitand(p.properties, 512), 512, 'OUT'))),
       decode(bitand(p.properties, 32768), 32768, 'REF',
              decode(bitand(p.properties, 16384), 16384, 'POINTER')),
       decode(bitand(pt.properties, 64), 64, null, pu.name),
       decode(pt.typecode,
              9, decode(p.charsetform, 2, 'NVARCHAR2', po.name),
              96, decode(p.charsetform, 2, 'NCHAR', po.name),
              112, decode(p.charsetform, 2, 'NCLOB', po.name),
              po.name),
       decode(p.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(p.charsetid),
                             4, 'ARG:'||p.charsetid)
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.method$ m, sys.parameter$ p,
     sys."_CURRENT_EDITION_OBJ" po, sys.user$ pu, sys.type$ pt
where o.owner# = u.user#
  and o.type# <> 10 -- must not be invalid
  and o.oid$ = m.toid
  and o.subname IS NULL -- get the latest version only
  and m.toid = p.toid
  and m.version# = p.version#
  and m.method# = p.method#
  and p.param_toid = po.oid$
  and po.owner# = pu.user#
  and p.param_toid = pt.toid
  and p.param_version# = pt.version#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
       ora_check_sys_privilege (o.owner#, o.type#) = 1
       );

   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."OWNER" IS 'Onwer of the type';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."METHOD_NAME" IS 'Name of the method';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."METHOD_NO" IS 'Method number for distinguishing overloaded method (not to be used as ID number)';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."PARAM_NAME" IS 'Name of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."PARAM_NO" IS 'Parameter number or position';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."PARAM_MODE" IS 'Mode of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."PARAM_TYPE_MOD" IS 'Type modifier of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."PARAM_TYPE_OWNER" IS 'Owner of the type of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."PARAM_TYPE_NAME" IS 'Name of the type of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_PARAMS"."CHARACTER_SET_NAME" IS 'Character set name of the parameter';
   COMMENT ON TABLE "SYS"."ALL_METHOD_PARAMS"  IS 'Description of method parameters of types accessible
to the user'
;
--------------------------------------------------------
--  DDL for View ALL_METHOD_RESULTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_METHOD_RESULTS" ("OWNER", "TYPE_NAME", "METHOD_NAME", "METHOD_NO", "RESULT_TYPE_MOD", "RESULT_TYPE_OWNER", "RESULT_TYPE_NAME", "CHARACTER_SET_NAME") AS 
  select u.name, o.name, m.name, m.method#,
       decode(bitand(r.properties, 32768), 32768, 'REF',
              decode(bitand(r.properties, 16384), 16384, 'POINTER')),
       decode(bitand(rt.properties, 64), 64, null, ru.name),
       decode(rt.typecode,
              9, decode(r.charsetform, 2, 'NVARCHAR2', ro.name),
              96, decode(r.charsetform, 2, 'NCHAR', ro.name),
              112, decode(r.charsetform, 2, 'NCLOB', ro.name),
              ro.name),
       decode(r.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(r.charsetid),
                             4, 'ARG:'||r.charsetid)
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.method$ m, sys.result$ r,
     sys."_CURRENT_EDITION_OBJ" ro, sys.user$ ru, sys.type$ rt
where o.owner# = u.user#
  and o.type# <> 10 -- must not be invalid
  and o.oid$ = m.toid
  and o.subname IS NULL -- get the latest version only
  and m.toid = r.toid
  and m.version# = r.version#
  and m.method# = r.method#
  and r.result_toid = ro.oid$
  and ro.owner# = ru.user#
  and r.result_toid = rt.toid
  and r.result_version# = rt.version#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
        ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_METHOD_RESULTS"."OWNER" IS 'Onwer of the type';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_RESULTS"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_RESULTS"."METHOD_NAME" IS 'Name of the method';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_RESULTS"."METHOD_NO" IS 'Method number for distinguishing overloaded method (not to be used as ID number)';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_RESULTS"."RESULT_TYPE_MOD" IS 'Type modifier of the result';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_RESULTS"."RESULT_TYPE_OWNER" IS 'Owner of the type of the result';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_RESULTS"."RESULT_TYPE_NAME" IS 'Name of the type of the result';
   COMMENT ON COLUMN "SYS"."ALL_METHOD_RESULTS"."CHARACTER_SET_NAME" IS 'Character set name of the result';
   COMMENT ON TABLE "SYS"."ALL_METHOD_RESULTS"  IS 'Description of method results of types accessible
to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MINING_ALGORITHMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MINING_ALGORITHMS" ("ALGORITHM_NAME", "MINING_FUNCTION", "ALGORITHM_TYPE", "ALGORITHM_METADATA", "DESCRIPTION") AS 
  select a.name as algorithm_name,
cast(decode(a.func,
              1, 'CLASSIFICATION',
              2, 'REGRESSION',
              3, 'CLUSTERING',
              4, 'FEATURE_EXTRACTION',
              5, 'ASSOCIATION_RULES',
              6, 'ATTRIBUTE_IMPORTANCE', /*7 reserved for anomaly */
              8, 'TIME_SERIES',
                 'UNDEFINED') as varchar2(30)) as mining_function,
       a.type as algorithm_type,
       a.mdata as algorithm_metadata,
       a.des as description
from sys.modelalg$ a
;
--------------------------------------------------------
--  DDL for View ALL_MINING_MODEL_ATTRIBUTES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MINING_MODEL_ATTRIBUTES" ("OWNER", "MODEL_NAME", "ATTRIBUTE_NAME", "ATTRIBUTE_TYPE", "DATA_TYPE", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "USAGE_TYPE", "TARGET", "ATTRIBUTE_SPEC") AS 
  select u.name, o.name, a.name,
       decode(atyp, /* attribute type */
              1, 'NUMERICAL',
              2, 'CATEGORICAL',
              3, 'TEXT',
              4, 'MIXED',
              5, 'PARTITION',
                 'UNDEFINED'),
       case when bitand(a.properties,8) = 8
       then
         decode(dtyp, /* nested data type */
                1, 'DM_NESTED_CATEGORICALS',
                2, 'DM_NESTED_NUMERICALS',
              100, 'DM_NESTED_BINARY_FLOATS',
              101, 'DM_NESTED_BINARY_DOUBLES')
       else
         decode(dtyp, /* data type */
                       1, decode(bitand(a.properties,16), 16,
                                 'NVARCHAR2', 'VARCHAR2'),
                       2, decode(a.scale, null,
                                 decode(a.precision#, null, 'NUMBER', 'FLOAT'),
                                 'NUMBER'),
                       4, 'FLOAT',
                       8, 'LONG',
                       9, decode(bitand(a.properties,16), 16,
                                 'NCHAR VARYING', 'VARCHAR'),
                       12, 'DATE',
                       23, 'RAW', 24, 'LONG RAW',
                       69, 'ROWID',
                       96, decode(bitand(a.properties,16), 16,
                                  'NCHAR', 'CHAR'),
                       100, 'BINARY_FLOAT',
                       101, 'BINARY_DOUBLE',
                       105, 'MLSLABEL',
                       106, 'MLSLABEL',
                       112, decode(bitand(a.properties,16), 16,
                                   'NCLOB', 'CLOB'),
                       113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
                       178, 'TIME(' ||a.scale|| ')',
                       179, 'TIME(' ||a.scale|| ')' || ' WITH TIME ZONE',
                       180, 'TIMESTAMP(' ||a.scale|| ')',
                       181, 'TIMESTAMP(' ||a.scale|| ')' || ' WITH TIME ZONE',
                       231, 'TIMESTAMP(' ||a.scale|| ')' || ' WITH LOCAL TIME ZONE',
                       182, 'INTERVAL YEAR(' ||a.precision#||') TO MONTH',
                       183, 'INTERVAL DAY(' ||a.precision#||') TO SECOND(' ||
                             a.scale || ')',
                       208, 'UROWID',
                       'UNDEFINED')
       end,
       a.length,
       a.precision#,
       a.scale,
       decode(bitand(a.properties,3),0,'INACTIVE','ACTIVE'),
       decode(bitand(a.properties,2),2,'YES','NO'),
       a.attrspec
from sys.modelatt$ a, sys.obj$ o, sys.user$ u
where o.obj#=a.mod#
  and o.owner#=u.user#
  and (o.owner#=userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      )
  and bitand(a.properties, 3) != 0;

   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."MODEL_NAME" IS 'Name of the model to which the attribute belongs';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."ATTRIBUTE_NAME" IS 'Name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."ATTRIBUTE_TYPE" IS 'Mining type of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."DATA_TYPE" IS 'Data type of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."DATA_LENGTH" IS 'Data length of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."DATA_PRECISION" IS 'Data precision of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."DATA_SCALE" IS 'Data scale of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."USAGE_TYPE" IS 'Usage type for the attribute';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_ATTRIBUTES"."ATTRIBUTE_SPEC" IS 'Attribute specification for the attribute';
   COMMENT ON TABLE "SYS"."ALL_MINING_MODEL_ATTRIBUTES"  IS 'Description of all the model attributes accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MINING_MODEL_PARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MINING_MODEL_PARTITIONS" ("OWNER", "MODEL_NAME", "PARTITION_NAME", "POSITION", "COLUMN_NAME", "COLUMN_VALUE") AS 
  select owner, model_name, partition_name, position, column_name, hiboundval from (
select u.name owner,
       o.name model_name,
       o.subname partition_name,
       mp.pos#  position,
       mpc.name column_name,
       hiboundval
from modelpart$ mp, obj$ o, modelpartcol$ mpc, sys.user$ u
where mp.obj#=o.obj#
  and o.owner#=u.user#
  and (o.owner#=userenv('SCHEMAID')
    or mp.mod# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      )
  and mp.mod#=mpc.obj#
  and mp.pos#=mpc.pos#
  and mp.pos# is not null);

   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_PARTITIONS"."OWNER" IS 'Name of the model owner';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_PARTITIONS"."MODEL_NAME" IS 'Name of the model';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_PARTITIONS"."PARTITION_NAME" IS 'Name of the model partition';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_PARTITIONS"."POSITION" IS 'Column position number for partitioning column';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_PARTITIONS"."COLUMN_NAME" IS 'Name of the column used for partitioning';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_PARTITIONS"."COLUMN_VALUE" IS 'Value of the column for this partition';
   COMMENT ON TABLE "SYS"."ALL_MINING_MODEL_PARTITIONS"  IS 'Description of all the partitions accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MINING_MODELS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MINING_MODELS" ("OWNER", "MODEL_NAME", "MINING_FUNCTION", "ALGORITHM", "ALGORITHM_TYPE", "CREATION_DATE", "BUILD_DURATION", "MODEL_SIZE", "PARTITIONED", "COMMENTS") AS 
  select u.name, o.name,
       cast(decode(func, /* Mining Function */
              1, 'CLASSIFICATION',
              2, 'REGRESSION',
              3, 'CLUSTERING',
              4, 'FEATURE_EXTRACTION',
              5, 'ASSOCIATION_RULES',
              6, 'ATTRIBUTE_IMPORTANCE', /*7 reserved for anomaly */
              8, 'TIME_SERIES',
                 'UNDEFINED') as varchar2(30)),
       cast(decode(alg, /* Mining Algorithm */
              1, 'NAIVE_BAYES',
              2, 'ADAPTIVE_BAYES_NETWORK',
              3, 'DECISION_TREE',
              4, 'SUPPORT_VECTOR_MACHINES',
              5, 'KMEANS',
              6, 'O_CLUSTER',
              7, 'NONNEGATIVE_MATRIX_FACTOR',
              8, 'GENERALIZED_LINEAR_MODEL',
              9, 'APRIORI_ASSOCIATION_RULES',
             10, 'MINIMUM_DESCRIPTION_LENGTH',
             11, 'SINGULAR_VALUE_DECOMP',
             12, 'EXPECTATION_MAXIMIZATION',
             13,  NVL(s.value, 'R_EXTENSIBLE'),
             14, 'EXPLICIT_SEMANTIC_ANALYS',
             15, 'RANDOM_FOREST',
             16, 'NEURAL_NETWORK',
             17, 'EXPONENTIAL_SMOOTHING',
             18, 'CUR_DECOMPOSITION',
                 'UNDEFINED') as varchar2(30)),
       cast(decode(alg, 13, 'R', 'NATIVE') as varchar2(10)),
       o.ctime, bdur, msize,
       decode(bitand(m.properties,1),1,'YES','NO'), c.comment$
from sys.model$ m, sys.obj$ o, sys.user$ u, sys.com$ c,
         (select mod#, value from sys.modelset$
          where bitand(properties,2) != 2 and name = 'ALGO_NAME') s
where o.obj#=m.obj#
  and o.obj#=c.obj#(+)
  and o.type#=82
  and o.owner#=u.user#
  and o.obj#=s.mod#(+)
  and (o.owner#=userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_MINING_MODELS"."MODEL_NAME" IS 'Name of the model';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODELS"."MINING_FUNCTION" IS 'Mining function of the model';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODELS"."ALGORITHM" IS 'Algorithm of the model';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODELS"."ALGORITHM_TYPE" IS 'Algorithm type of the model';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODELS"."CREATION_DATE" IS 'Creation date of the model';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODELS"."BUILD_DURATION" IS 'Model build time (in seconds)';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODELS"."MODEL_SIZE" IS 'Model size (in Mb)';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODELS"."COMMENTS" IS 'Model comments';
   COMMENT ON TABLE "SYS"."ALL_MINING_MODELS"  IS 'Description of the models accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MINING_MODEL_SETTINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MINING_MODEL_SETTINGS" ("OWNER", "MODEL_NAME", "SETTING_NAME", "SETTING_VALUE", "SETTING_TYPE") AS 
  select u.name, o.name, s.name, s.value,
       decode(s.properties,1,'INPUT','DEFAULT')
from sys.modelset$ s, sys.obj$ o, sys.user$ u
where s.mod#=o.obj#
  and o.owner#=u.user#
  and (o.owner#=userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      )
  and bitand(s.properties,2) != 2;

   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_SETTINGS"."MODEL_NAME" IS 'Name of the model to which the setting belongs';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_SETTINGS"."SETTING_NAME" IS 'Name of the setting';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_SETTINGS"."SETTING_VALUE" IS 'Value of the setting';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_SETTINGS"."SETTING_TYPE" IS 'Type of the setting';
   COMMENT ON TABLE "SYS"."ALL_MINING_MODEL_SETTINGS"  IS 'Description of all the settings accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MINING_MODEL_VIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MINING_MODEL_VIEWS" ("OWNER", "MODEL_NAME", "VIEW_NAME", "VIEW_TYPE") AS 
  select u.name,
       o1.name,
       o2.name,
       cast(decode(typ#-32767,
            1 , 'Clustering Description',
	        2 , 'Clustering Attribute Statistics',
	        3 , 'Clustering Histograms',
	        4 , 'Clustering Rules',
	        5 , 'Model Build Alerts',
	        6 , 'Computed Settings',
	        7 , 'Global Name-Value Pairs',
	        8 , 'Classification Targets',
	        9 , 'Scoring Cost Matrix',
	       10 , 'Decision Tree Build Cost Matrix',
	       11 , 'Text Features',
	       12 , 'Normalization and Missing Value Handling',
	       13 , 'Automatic Data Preparation Binning',
	       14 , 'Decision Tree Hierarchy',
	       15 , 'Decision Tree Statistics',
	       16 , 'Decision Tree Nodes',
	       17 , 'Association Rules',
	       18 , 'Association Rule Itemsets',
	       19 , 'SVM Linear Coefficients',
	       20 , 'Expectation Maximization Components',
	       21 , 'Expectation Maximization Projections',
	       22 , 'GLM Regression Attribute Diagnostics',
	       23 , 'GLM Regression Row Diagnostics',
	       24 , 'GLM Classification Attribute Diagnostics',
	       25 , 'GLM Classification Row Diagnostics',
           26 , 'Extensible R Algorithm',
           27 , 'Attribute Importance',
           28 , 'Naive Bayes Target Priors',
           29 , 'Naive Bayes Conditional Probabilities',
           30 , 'Explicit Semantic Analysis Matrix',
           31 , 'Explicit Semantic Analysis Features',
           32 , 'Singular Value Decomposition U Matrix',
           33 , 'Singular Value Decomposition S Matrix',
           34 , 'Singular Value Decomposition V Matrix',
           35 , 'k-Means Scoring Centroids',
           36 , 'Non-Negative Matrix Factorization H Matrix',
           37 , 'Non-Negative Matrix Factorization Inverse H Matrix',
           38 , 'Expectation Maximization Gaussian parameters',
           39 , 'Expectation Maximization Bernoulli parameters',
           40 , 'Unsupervised Attribute Importance',
           41 , 'Attribute Pair Kullback-Leibler Divergence',
           42 , 'Association Rule Itemsets for transactional data',
           43 , 'Association Rules for transactional data',
           44 , 'Neural Network Weights',
           45 , 'Exponential Smoothing Forecast',
           46 , 'CUR Decomposition-Based Attribute Importance',
           47 , 'CUR Decomposition-Based Row Importance',
           48 , 'Variable Importance',
           49 , 'Extensible R Algorithm View 1',
           50 , 'Extensible R Algorithm View 2',
           51 , 'Extensible R Algorithm View 3',
           52 , 'Extensible R Algorithm View 4',
           53 , 'Extensible R Algorithm View 5',
           54 , 'Extensible R Algorithm View 6',
           55 , 'Extensible R Algorithm View 7',
           56 , 'Extensible R Algorithm View 8',
           57 , 'Extensible R Algorithm View 9',
           58 , 'Extensible R Algorithm View 10',
                 'UNDEFINED') as varchar2(128))
from sys.model$ m, sys.modeltab$ t, sys.obj$ o1, sys.obj$ o2, sys.user$ u
where m.obj#=o1.obj#
  and m.obj#=t.mod#
  and t.obj#=o2.obj#
  and o1.owner#=u.user#
  and t.typ# >= 32767
  and (o1.owner#=userenv('SCHEMAID')
       or o1.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
          ora_check_sys_privilege (o1.owner#, o1.type#) = 1
     );

   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_VIEWS"."MODEL_NAME" IS 'Name of the model to which model views belongs';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_VIEWS"."VIEW_NAME" IS 'Name of the model view';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_VIEWS"."VIEW_TYPE" IS 'Type of the model view';
   COMMENT ON TABLE "SYS"."ALL_MINING_MODEL_VIEWS"  IS 'Description of all the model views accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MINING_MODEL_XFORMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MINING_MODEL_XFORMS" ("OWNER", "MODEL_NAME", "ATTRIBUTE_NAME", "ATTRIBUTE_SUBNAME", "ATTRIBUTE_SPEC", "EXPRESSION", "REVERSE") AS 
  select u.name, o.name, x.attr, x.subn, x.attrspec, x.expr,
       decode(bitand(x.properties,16),16,'YES','NO')
from sys.obj$ o, sys.user$ u, sys.modelxfm$ x
where o.obj#=x.mod#
  and o.owner#=u.user#
  and bitand(x.properties,256) != 0
  and (o.owner#=userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_XFORMS"."OWNER" IS 'Name of the model owner';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_XFORMS"."MODEL_NAME" IS 'Name of the model';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_XFORMS"."ATTRIBUTE_NAME" IS 'Name of the attribute used in the transformation';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_XFORMS"."ATTRIBUTE_SUBNAME" IS 'Subame of the attribute used in the transformation';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_XFORMS"."ATTRIBUTE_SPEC" IS 'Attribute specification provided to model training';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_XFORMS"."EXPRESSION" IS 'Forward expression provided to model training';
   COMMENT ON COLUMN "SYS"."ALL_MINING_MODEL_XFORMS"."REVERSE" IS 'Reverse expression';
   COMMENT ON TABLE "SYS"."ALL_MINING_MODEL_XFORMS"  IS 'User-specified transformations embedded in all models accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_AGGREGATES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_AGGREGATES" ("OWNER", "MVIEW_NAME", "POSITION_IN_SELECT", "CONTAINER_COLUMN", "AGG_FUNCTION", "DISTINCTFLAG", "MEASURE") AS 
  select u.name, o.name, sa.sumcolpos#, c.name,
       decode(sa.aggfunction, 15, 'AVG', 16, 'SUM', 17, 'COUNT',
                              18, 'MIN', 19, 'MAX',
                              97, 'VARIANCE', 98, 'STDDEV',
                              440, 'USER'),
       decode(sa.flags, 0, 'N', 'Y'),
       sa.aggtext
from sys.sumagg$ sa, sys.obj$ o, sys.user$ u, sys.sum$ s, sys.col$ c
where sa.sumobj# = o.obj#
  AND o.owner# = u.user#
  AND sa.sumobj# = s.obj#
  AND c.obj# = s.containerobj#
  AND c.col# = sa.containercol#
  AND (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
  AND bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */;

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_AGGREGATES"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_AGGREGATES"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_AGGREGATES"."POSITION_IN_SELECT" IS 'Position of this aggregated measure with the SELECT list';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_AGGREGATES"."CONTAINER_COLUMN" IS 'Name of this column in the container table';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_AGGREGATES"."AGG_FUNCTION" IS 'Name of the aggregation function, one of the following:
COUNT, SUM, MIN, MAX, AVG, VARIANCE, STDDEV';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_AGGREGATES"."DISTINCTFLAG" IS 'Set to Y is this is a DISTINCT aggregation';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_AGGREGATES"."MEASURE" IS 'The SQL text of the measure, excluding the aggregation function';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_AGGREGATES"  IS 'Description of the materialized view aggregates accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_ANALYSIS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_ANALYSIS" ("OWNER", "MVIEW_NAME", "MVIEW_TABLE_OWNER", "CONTAINER_NAME", "LAST_REFRESH_SCN", "LAST_REFRESH_DATE", "REFRESH_METHOD", "SUMMARY", "FULLREFRESHTIM", "INCREFRESHTIM", "CONTAINS_VIEWS", "UNUSABLE", "RESTRICTED_SYNTAX", "INC_REFRESHABLE", "KNOWN_STALE", "INVALID", "REWRITE_ENABLED", "QUERY_LEN", "QUERY", "REVISION") AS 
  select u.name, o.name, u.name, s.containernam,
       s.lastrefreshscn, s.lastrefreshdate,
       decode (s.refreshmode, 0, 'NEVER', 1, 'FORCE', 2, 'FAST', 3,'COMPLETE'),
       decode(bitand(s.pflags, 25165824), 25165824, 'N', 'Y'),
       s.fullrefreshtim, s.increfreshtim,
       decode(bitand(s.pflags, 48), 0, 'N', 'Y'),
       decode(bitand(s.mflags, 64), 0, 'N', 'Y'), /* QSMQSUM_UNUSABLE */
       decode(bitand(s.pflags, 1294319), 0, 'Y', 'N'),
       decode(bitand((select n.flag2 from sys.snap$ n
                      where n.vname=s.containernam and n.sowner=u.name), 67108864),
                     67108864,  /* primary CUBE mv? */
                     decode(bitand((select n2.flag from sys.snap$ n2
                            where n2.parent_sowner=u.name and n2.parent_vname=s.containernam), 256),
                            256, 'N', 'Y'), /* Its child mv's properties determin INC_REFRESHABLE */
                     decode(bitand(s.pflags, 236617599), 0, 'Y', 'N')),
       decode(bitand(s.mflags, 1), 0, 'N', 'Y'), /* QSMQSUM_KNOWNSTL */
       decode(o.status, 5, 'Y', 'N'),
       decode(bitand(s.mflags, 4), 0, 'Y', 'N'), /* QSMQSUM_DISABLED */
       s.sumtextlen,s.sumtext,
       s.metaversion/* Metadata revision number */
from sys.user$ u, sys.sum$ s, sys.obj$ o
where o.owner# = u.user#
  and o.obj# = s.obj#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
  and bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */;

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."MVIEW_TABLE_OWNER" IS 'Owner of the container table';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."CONTAINER_NAME" IS 'Name of the container table for this materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."LAST_REFRESH_SCN" IS 'The SCN of the last transaction to refresh the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."LAST_REFRESH_DATE" IS 'The date of the last refresh of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."REFRESH_METHOD" IS 'User declared method of refresh for the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."SUMMARY" IS 'Indicates if the materialized view includes the GROUP BY clause';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."FULLREFRESHTIM" IS 'The time that it took to fully refresh the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."INCREFRESHTIM" IS 'The time that it took to incrementally refresh the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."CONTAINS_VIEWS" IS 'This materialized view contains views in the FROM clause';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."UNUSABLE" IS 'This materialized view is unusable, the build was deferred';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."RESTRICTED_SYNTAX" IS 'This materialized view contains restrictive syntax';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."INC_REFRESHABLE" IS 'This materialized view is not restricted from being incrementally refreshed';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."KNOWN_STALE" IS 'This materialized view is directly stale';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."INVALID" IS 'Invalidity of the materialized view, Y = INVALID, N = VALID';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."REWRITE_ENABLED" IS 'This materialized view is enabled for query rewrite';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."QUERY_LEN" IS 'The length (in bytes) of the query field';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."QUERY" IS 'SELECT expression of the materialized view definition';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_ANALYSIS"."REVISION" IS 'Reserved for internal use';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_ANALYSIS"  IS 'Description of the materialized views accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_COMMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_COMMENTS" ("OWNER", "MVIEW_NAME", "COMMENTS") AS 
  select u.name, o.name, c.comment$
from sys.obj$ o, sys.user$ u, sys.com$ c, sys.tab$ t
  where o.owner# = u.user# AND o.type# = 2
  and (bitand(t.property, 67108864) = 67108864)         /*mv container table */
  and o.obj# = c.obj#(+)
  and c.col#(+) is NULL
  and o.obj# = t.obj#
  and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-173 /* CREATE ANY MV */,
                                        -174 /* ALTER ANY MV */,
                                        -175 /* DROP ANY MV */)
                  )
      );

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_COMMENTS"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_COMMENTS"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_COMMENTS"."COMMENTS" IS 'Comment on the materialized view';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_COMMENTS"  IS 'Comments on materialized views accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_DETAIL_PARTITION
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_DETAIL_PARTITION" ("OWNER", "MVIEW_NAME", "DETAILOBJ_OWNER", "DETAILOBJ_NAME", "DETAIL_PARTITION_NAME", "DETAIL_PARTITION_POSITION", "FRESHNESS") AS 
  select m."OWNER",m."MVIEW_NAME",m."DETAILOBJ_OWNER",m."DETAILOBJ_NAME",m."DETAIL_PARTITION_NAME",m."DETAIL_PARTITION_POSITION",m."FRESHNESS" from dba_mview_detail_partition m, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and m.mview_name = o.name
  and u.name       = m.owner
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
        or /* user has system privileges */
        ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_PARTITION"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_PARTITION"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_PARTITION"."DETAILOBJ_NAME" IS 'Name of the detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_PARTITION"."DETAIL_PARTITION_NAME" IS 'Name of the detail object partition';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_PARTITION"."DETAIL_PARTITION_POSITION" IS 'Position of the detail object partition';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_PARTITION"."FRESHNESS" IS 'Freshness of the detail object partition';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_DETAIL_PARTITION"  IS 'Freshness information of all PCT materialized views in the database'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_DETAIL_RELATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_DETAIL_RELATIONS" ("OWNER", "MVIEW_NAME", "DETAILOBJ_OWNER", "DETAILOBJ_NAME", "DETAILOBJ_TYPE", "DETAILOBJ_ALIAS", "DETAILOBJ_PCT", "NUM_FRESH_PCT_PARTITIONS", "NUM_STALE_PCT_PARTITIONS") AS 
  select u.name, o.name, du.name,  do.name,
       decode (sd.detailobjtype, 1, 'TABLE', 2, 'VIEW',
                                3, 'SNAPSHOT', 4, 'CONTAINER', 'UNDEFINED'),
       sd.detailalias,
           /* whether this is a PCT refresh enabled primary CUBE MV */
       (decode(bitand(s.xpflags, 8589934592), 0,
                (decode(sd.detaileut, 0, 'N', 'Y')),
               /* If there's a qualifying secondary cube mv row for this detailtab,
                  it's pct refreshable, otherwise, no. */
                (decode((select count(*)
                          from  sumdetail$ sd2
                          where sd.sumobj#=sd2.sumobj# and sd.detailobj#=sd2.detailobj#
                            and sd2.detaileut > 268435456),
                        0, 'N', 'Y')))
       ) as DETAILOBJ_PCT,
     (select num_fresh_partns from
       (select sumobj#, detailobj#,
               sum(num_fresh_partitions) as num_fresh_partns,
               sum(num_stale_partitions) as num_stale_partns
       from
        (select sumobj#, detailobj#,
                decode(partn_state, 'FRESH', partn_count, 0)
                as num_fresh_partitions,
                decode(partn_state, 'STALE', partn_count, 0)
                as num_stale_partitions
         from
          (select sumobj#, detailobj#, partn_state, count(*) as partn_count from
            (select sumobj#, detailobj#,
                    (case when partn_scn is NULL then 'FRESH'
                     when partn_scn < mv_scn
                     then 'FRESH' else 'STALE' end) partn_state
             from
             (select sumobj#, detailobj#, mv_scn, sub_pobj#,
                     max(partn_scn) partn_scn
              from
                      /* from tabpart$ */
              (select s.obj# as sumobj#, sd.detailobj#,
                      s.lastrefreshscn as mv_scn,
                      t.obj# pobj#, t.obj# as sub_pobj#, t.spare1 as partn_scn
               from sys.sum$ s, sys.sumdetail$ sd, sys.tabpart$ t
               where s.obj# = sd.sumobj# and sd.detailobj# = t.bo#
               union  /* from sumdelta$ */
               select s.obj# as sumobj#, sd.detailobj#,
                      s.lastrefreshscn as mv_scn,
                      t.tableobj# pobj#, t.spare2 as sub_pobj#,
                      t.scn as partn_scn
               from sys.sum$ s, sys.sumdetail$ sd, sys.sumdelta$ t
               where s.obj# = sd.sumobj# and sd.detailobj# = t.tableobj#
               union  /* from tabsubpart$ */
               select s.sumobj#, s.detailobj#, s.mv_scn,
                      s.pobj# pobj#, t.obj# as sub_pobj#,t.spare1 as partn_scn
               from  tabsubpart$ t,
               (select s.obj# as sumobj#, sd.detailobj# as detailobj#,
                       s.lastrefreshscn as mv_scn,
                       t.obj# pobj#, t.spare1 as partn_scn
                from sys.sum$ s, sys.sumdetail$ sd, sys.tabcompart$ t,
                     sys.obj$ o
                where s.obj# = sd.sumobj# and sd.detailobj# = t.bo#) s
               where t.pobj# = s.pobj#)
              group by sumobj#,detailobj#,mv_scn, sub_pobj#)
            )
           group by sumobj#,detailobj#,partn_state))
         group by sumobj#,detailobj#) nfsp
         where nfsp.sumobj# = s.obj# and nfsp.detailobj# = sd.detailobj#)
         as NUM_FRESH_PCT_PARTNS,
     (select num_stale_partns from
       (select sumobj#, detailobj#,
               sum(num_fresh_partitions) as num_fresh_partns,
               sum(num_stale_partitions) as num_stale_partns
       from
        (select sumobj#, detailobj#,
                decode(partn_state, 'FRESH', partn_count, 0)
                as num_fresh_partitions,
                decode(partn_state, 'STALE', partn_count, 0)
                as num_stale_partitions
         from
          (select sumobj#, detailobj#, partn_state, count(*) as partn_count
           from
            (select sumobj#, detailobj#,
                    (case when partn_scn is NULL then 'FRESH'
                     when partn_scn < mv_scn
                     then 'FRESH' else 'STALE' end) partn_state
             from
             (select sumobj#, detailobj#, mv_scn, sub_pobj#,
                     max(partn_scn) partn_scn
              from
                      /* from tabpart$ */
              (select s.obj# as sumobj#, sd.detailobj#,
                      s.lastrefreshscn as mv_scn,
                      t.obj# pobj#, t.obj# as sub_pobj#, t.spare1 as partn_scn
               from sys.sum$ s, sys.sumdetail$ sd, sys.tabpart$ t
               where s.obj# = sd.sumobj# and sd.detailobj# = t.bo#
               union  /* from sumdelta$ */
               select s.obj# as sumobj#, sd.detailobj#,
                      s.lastrefreshscn as mv_scn,
                      t.tableobj# pobj#, t.spare2 as sub_pobj#,
                      t.scn as partn_scn
               from sys.sum$ s, sys.sumdetail$ sd, sys.sumdelta$ t
               where s.obj# = sd.sumobj# and sd.detailobj# = t.tableobj#
               union  /* from tabsubpart$ */
               select s.sumobj#, s.detailobj#, s.mv_scn,
                      s.pobj# pobj#, t.obj# as sub_pobj#,t.spare1 as partn_scn
               from  tabsubpart$ t,
               (select s.obj# as sumobj#, sd.detailobj# as detailobj#,
                       s.lastrefreshscn as mv_scn,
                       t.obj# pobj#, t.spare1 as partn_scn
                from sys.sum$ s, sys.sumdetail$ sd, sys.tabcompart$ t,
                     sys.obj$ o
                where s.obj# = sd.sumobj# and sd.detailobj# = t.bo#) s
               where t.pobj# = s.pobj#)
              group by sumobj#,detailobj#,mv_scn, sub_pobj#)
            )
           group by sumobj#,detailobj#,partn_state))
         group by sumobj#,detailobj#) nfsp
         where nfsp.sumobj# = s.obj# and nfsp.detailobj# = sd.detailobj#)
         as NUM_STALE_PCT_PARTNS
from sys.user$ u, sys.sumdetail$ sd, sys.obj$ o, sys.obj$ do,
sys.user$ du, sys.sum$ s
where o.owner# = u.user#
  and o.obj# = sd.sumobj#
  and do.obj# = sd.detailobj#
  and do.owner# = du.user#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
  AND s.obj# = sd.sumobj#
  AND bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */
  AND bitand(sd.detaileut, 2147483648) = 0  /* NO secondary CUBE MV rows */;

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_RELATIONS"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_RELATIONS"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_RELATIONS"."DETAILOBJ_OWNER" IS 'Owner of the detail relation';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_RELATIONS"."DETAILOBJ_NAME" IS 'Name of the materialized view detail table';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_RELATIONS"."DETAILOBJ_TYPE" IS 'Type of materialized view detail table type';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_RELATIONS"."DETAILOBJ_ALIAS" IS 'Alias of the detail relation if used';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_DETAIL_RELATIONS"  IS 'Description of the materialized view detail tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_DETAIL_SUBPARTITION
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION" ("OWNER", "MVIEW_NAME", "DETAILOBJ_OWNER", "DETAILOBJ_NAME", "DETAIL_PARTITION_NAME", "DETAIL_SUBPARTITION_NAME", "DETAIL_SUBPARTITION_POSITION", "FRESHNESS") AS 
  select m."OWNER",m."MVIEW_NAME",m."DETAILOBJ_OWNER",m."DETAILOBJ_NAME",m."DETAIL_PARTITION_NAME",m."DETAIL_SUBPARTITION_NAME",m."DETAIL_SUBPARTITION_POSITION",m."FRESHNESS" from dba_mview_detail_subpartition m, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and m.mview_name = o.name
  and u.name       = m.owner
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
        or /* user has system privileges */
        ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION"."DETAILOBJ_NAME" IS 'Name of the detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION"."DETAIL_PARTITION_NAME" IS 'Name of the detail object partition';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION"."DETAIL_SUBPARTITION_NAME" IS 'Name of the detail object subpartition';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION"."DETAIL_SUBPARTITION_POSITION" IS 'Position of the detail object subpartition';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION"."FRESHNESS" IS 'Freshness of the detail object partition';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_DETAIL_SUBPARTITION"  IS 'Freshness information of all PCT materialized views in the database'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_JOINS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_JOINS" ("OWNER", "MVIEW_NAME", "DETAILOBJ1_OWNER", "DETAILOBJ1_RELATION", "DETAILOBJ1_COLUMN", "OPERATOR", "OPERATOR_TYPE", "DETAILOBJ2_OWNER", "DETAILOBJ2_RELATION", "DETAILOBJ2_COLUMN") AS 
  select u.name, o.name,
       u1.name, o1.name, c1.name, '=',
       decode(sj.flags, 0, 'I', 1, 'L', 2, 'R'),
       u2.name, o2.name, c2.name
from sys.sumjoin$ sj, sys.obj$ o, sys.user$ u,
     sys.obj$ o1, sys.user$ u1, sys.col$ c1,
     sys.obj$ o2, sys.user$ u2, sys.col$ c2,
     sys.sum$ s
where sj.sumobj# = o.obj#
  AND o.owner# = u.user#
  AND sj.tab1obj# = o1.obj#
  AND o1.owner# = u1.user#
  AND sj.tab1obj# = c1.obj#
  AND sj.tab1col# = c1.intcol#
  AND sj.tab2obj# = o2.obj#
  AND o2.owner# = u2.user#
  AND sj.tab2obj# = c2.obj#
  AND sj.tab2col# = c2.intcol#
  AND (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
  AND s.obj# = sj.sumobj#
  AND bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */;

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."DETAILOBJ1_OWNER" IS 'Owner of the 1st detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."DETAILOBJ1_RELATION" IS 'Name of the 1st detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."DETAILOBJ1_COLUMN" IS 'Name of the 1st detail object column';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."OPERATOR" IS 'Name of the join operator. Currently only = is defined';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."DETAILOBJ2_OWNER" IS 'Owner of the 2nd detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."DETAILOBJ2_RELATION" IS 'Name of the 2nd detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_JOINS"."DETAILOBJ2_COLUMN" IS 'Name of the 2nd detail object column';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_JOINS"  IS 'Description of a join between two columns in the
WHERE clause of a materialized view accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_KEYS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_KEYS" ("OWNER", "MVIEW_NAME", "POSITION_IN_SELECT", "CONTAINER_COLUMN", "DETAILOBJ_OWNER", "DETAILOBJ_NAME", "DETAILOBJ_ALIAS", "DETAILOBJ_TYPE", "DETAILOBJ_COLUMN") AS 
  select distinct u1.name, o1.name, sk.sumcolpos#, c1.name,
       u2.name, o2.name, sd.detailalias,
       decode(sk.detailobjtype, 1, 'TABLE', 2, 'VIEW'), c2.name
from sys.sumkey$ sk, sys.obj$ o1, sys.user$ u1, sys.col$ c1, sys.sum$ s,
     sys.sumdetail$ sd, sys.obj$ o2, sys.user$ u2, sys.col$ c2
where sk.sumobj# = o1.obj#
  AND o1.owner# = u1.user#
  AND sk.sumobj# = s.obj#
  AND s.containerobj# = c1.obj#
  AND c1.col# = sk.containercol#
  AND sk.detailobj# = o2.obj#
  AND o2.owner# = u2.user#
  AND sk.sumobj# = sd.sumobj#
  AND sk.detailobj# = sd.detailobj#
  AND sk.detailobj# = c2.obj#
  AND sk.detailcol# = c2.intcol#
  AND sk.instance# = sd.instance#
  AND (o1.owner# = userenv('SCHEMAID')
       or o1.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o1.owner#, o1.type#) = 1
      )
  AND bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */
  AND bitand(sk.detailcolfunction, 2147483648) = 0
  AND bitand(sd.detaileut, 2147483648) = 0  /* NOT 2nd cube mv pct metadata */;

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."POSITION_IN_SELECT" IS 'Position of this key within the SELECT list';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."CONTAINER_COLUMN" IS 'Name of the column in the container table';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."DETAILOBJ_OWNER" IS 'Owner of the detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."DETAILOBJ_NAME" IS 'Name of the detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."DETAILOBJ_ALIAS" IS 'Alias of the detail object';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."DETAILOBJ_TYPE" IS 'Type of the detail object: VIEW or TABLE';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_KEYS"."DETAILOBJ_COLUMN" IS 'Name of the detail object column';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_KEYS"  IS 'Description of the columns that appear in the GROUP BY
list of a materialized view accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_LOGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_LOGS" ("LOG_OWNER", "MASTER", "LOG_TABLE", "LOG_TRIGGER", "ROWIDS", "PRIMARY_KEY", "OBJECT_ID", "FILTER_COLUMNS", "SEQUENCE", "INCLUDE_NEW_VALUES", "PURGE_ASYNCHRONOUS", "PURGE_DEFERRED", "PURGE_START", "PURGE_INTERVAL", "LAST_PURGE_DATE", "LAST_PURGE_STATUS", "NUM_ROWS_PURGED", "COMMIT_SCN_BASED", "STAGING_LOG") AS 
  select s."LOG_OWNER",s."MASTER",s."LOG_TABLE",s."LOG_TRIGGER",s."ROWIDS",s."PRIMARY_KEY",s."OBJECT_ID",s."FILTER_COLUMNS",s."SEQUENCE",s."INCLUDE_NEW_VALUES",s."PURGE_ASYNCHRONOUS",s."PURGE_DEFERRED",s."PURGE_START",s."PURGE_INTERVAL",s."LAST_PURGE_DATE",s."LAST_PURGE_STATUS",s."NUM_ROWS_PURGED",s."COMMIT_SCN_BASED",s."STAGING_LOG" from dba_mview_logs s, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and s.log_table = o.name
  and u.name       = s.log_owner
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."LOG_OWNER" IS 'Owner of the materialized view log';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."MASTER" IS 'Name of the master table which changes are logged';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."LOG_TABLE" IS 'Log table; with  rowids and timestamps of rows which changed in the master';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."LOG_TRIGGER" IS 'An after-row trigger on the master which inserts rows into the log';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."ROWIDS" IS 'If YES, the materialized view log records rowid information';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."PRIMARY_KEY" IS 'If YES, the materialized view log records primary key information';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."OBJECT_ID" IS 'If YES, the materialized view log records object id information';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."FILTER_COLUMNS" IS 'If YES, the materialized view log records filter column information';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."SEQUENCE" IS 'If YES, the materialized view log records sequence information';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."INCLUDE_NEW_VALUES" IS 'If YES, the materialized view log records old and new values (else only old values)';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."PURGE_ASYNCHRONOUS" IS 'If YES, the materialized view log is purged asynchronously';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."PURGE_DEFERRED" IS 'If YES, the materialized view log is purged in a deferred manner';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."PURGE_START" IS 'For deferred purge, the purge start date';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."PURGE_INTERVAL" IS 'For deferred purge, the purge interval';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."LAST_PURGE_DATE" IS 'Date of the last purge';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."LAST_PURGE_STATUS" IS 'Status of the last purge: error code or 0 for success';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."NUM_ROWS_PURGED" IS 'Number of rows purged in the last purge';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."COMMIT_SCN_BASED" IS 'If YES, the materialized view log is commit SCN-based';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_LOGS"."STAGING_LOG" IS 'If YES, the log is a staging log for synchronous refresh';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_LOGS"  IS 'All materialized view logs in the database that the user can see'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEW_REFRESH_TIMES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEW_REFRESH_TIMES" ("OWNER", "NAME", "MASTER_OWNER", "MASTER", "LAST_REFRESH") AS 
  select s."OWNER",s."NAME",s."MASTER_OWNER",s."MASTER",s."LAST_REFRESH" from dba_mview_refresh_times s, all_mviews a
where s.owner = a.owner
and   s.name  = a.mview_name;

   COMMENT ON COLUMN "SYS"."ALL_MVIEW_REFRESH_TIMES"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_REFRESH_TIMES"."NAME" IS 'The view used by users and applications for viewing the MV';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_REFRESH_TIMES"."MASTER_OWNER" IS 'Owner of the master table';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_REFRESH_TIMES"."MASTER" IS 'Name of the master table';
   COMMENT ON COLUMN "SYS"."ALL_MVIEW_REFRESH_TIMES"."LAST_REFRESH" IS 'SYSDATE from the master site at the time of the last refresh';
   COMMENT ON TABLE "SYS"."ALL_MVIEW_REFRESH_TIMES"  IS 'Materialized views and their last refresh times  for each master table that the user can look at'
;
--------------------------------------------------------
--  DDL for View ALL_MVIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_MVIEWS" ("OWNER", "MVIEW_NAME", "CONTAINER_NAME", "QUERY", "QUERY_LEN", "UPDATABLE", "UPDATE_LOG", "MASTER_ROLLBACK_SEG", "MASTER_LINK", "REWRITE_ENABLED", "REWRITE_CAPABILITY", "REFRESH_MODE", "REFRESH_METHOD", "BUILD_MODE", "FAST_REFRESHABLE", "LAST_REFRESH_TYPE", "LAST_REFRESH_DATE", "LAST_REFRESH_END_TIME", "STALENESS", "AFTER_FAST_REFRESH", "UNKNOWN_PREBUILT", "UNKNOWN_PLSQL_FUNC", "UNKNOWN_EXTERNAL_TABLE", "UNKNOWN_CONSIDER_FRESH", "UNKNOWN_IMPORT", "UNKNOWN_TRUSTED_FD", "COMPILE_STATE", "USE_NO_INDEX", "STALE_SINCE", "NUM_PCT_TABLES", "NUM_FRESH_PCT_REGIONS", "NUM_STALE_PCT_REGIONS", "SEGMENT_CREATED", "EVALUATION_EDITION", "UNUSABLE_BEFORE", "UNUSABLE_BEGINNING", "DEFAULT_COLLATION", "ON_QUERY_COMPUTATION") AS 
  select m."OWNER",m."MVIEW_NAME",m."CONTAINER_NAME",m."QUERY",m."QUERY_LEN",m."UPDATABLE",m."UPDATE_LOG",m."MASTER_ROLLBACK_SEG",m."MASTER_LINK",m."REWRITE_ENABLED",m."REWRITE_CAPABILITY",m."REFRESH_MODE",m."REFRESH_METHOD",m."BUILD_MODE",m."FAST_REFRESHABLE",m."LAST_REFRESH_TYPE",m."LAST_REFRESH_DATE",m."LAST_REFRESH_END_TIME",m."STALENESS",m."AFTER_FAST_REFRESH",m."UNKNOWN_PREBUILT",m."UNKNOWN_PLSQL_FUNC",m."UNKNOWN_EXTERNAL_TABLE",m."UNKNOWN_CONSIDER_FRESH",m."UNKNOWN_IMPORT",m."UNKNOWN_TRUSTED_FD",m."COMPILE_STATE",m."USE_NO_INDEX",m."STALE_SINCE",m."NUM_PCT_TABLES",m."NUM_FRESH_PCT_REGIONS",m."NUM_STALE_PCT_REGIONS",m."SEGMENT_CREATED",m."EVALUATION_EDITION",m."UNUSABLE_BEFORE",m."UNUSABLE_BEGINNING",m."DEFAULT_COLLATION",m."ON_QUERY_COMPUTATION" from dba_mviews m, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and m.mview_name = o.name
  and u.name       = m.owner
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
        or /* user has system privileges */
        ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."MVIEW_NAME" IS 'Name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."CONTAINER_NAME" IS 'Name of the materialized view container table';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."QUERY" IS 'The defining query that the materialized view instantiates';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."QUERY_LEN" IS 'The number of bytes in the defining query (based on the server character set';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UPDATABLE" IS 'Indicates whether the materialized view can be updated';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UPDATE_LOG" IS 'Name of the table that logs changes to an updatable materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."MASTER_ROLLBACK_SEG" IS 'Name of the rollback segment to use at the master site';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."MASTER_LINK" IS 'Name of the database link to the master site';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."REWRITE_ENABLED" IS 'Indicates whether rewrite is enabled for the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."REWRITE_CAPABILITY" IS 'Indicates the kind of rewrite that is enabled';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."REFRESH_MODE" IS 'Indicates how and when the materialized view will be refreshed';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."REFRESH_METHOD" IS 'The default refresh method for the materialized view (complete, fast, ...)';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."BUILD_MODE" IS 'How and when to initially build (load) the materialized view container';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."FAST_REFRESHABLE" IS 'Indicates the kinds of operations that can be fast refreshed for the MV';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."LAST_REFRESH_TYPE" IS 'Indicates the kind of refresh that was last performed on the MV';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."LAST_REFRESH_DATE" IS 'The date that the materialized view was last refreshed';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."LAST_REFRESH_END_TIME" IS 'The time that the last materialized view refresh ended';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."STALENESS" IS 'Indicates the staleness state of the materialized view (fresh, stale, ...)';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."AFTER_FAST_REFRESH" IS 'Indicates the staleness state the MV will have after a fast refresh is done';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UNKNOWN_PREBUILT" IS 'Indicates if the materialized view is prebuilt';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UNKNOWN_PLSQL_FUNC" IS 'Indicates if the materialized view contains PL/SQL function';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UNKNOWN_EXTERNAL_TABLE" IS 'Indicates if the materialized view contains external tables';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UNKNOWN_CONSIDER_FRESH" IS 'Indicates if the materialized view is considered fresh';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UNKNOWN_IMPORT" IS 'Indicates if the materialized view is imported';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UNKNOWN_TRUSTED_FD" IS 'Indicates if the materialized view used trusted constraints for refresh';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."COMPILE_STATE" IS 'Indicates the validity of the MV meta-data';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."USE_NO_INDEX" IS 'Indicates whether the MV uses no index';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."STALE_SINCE" IS 'Time from when the materialized view became stale';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."NUM_PCT_TABLES" IS 'Number of PCT detail tables';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."NUM_FRESH_PCT_REGIONS" IS 'Number of fresh PCT partition regions';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."NUM_STALE_PCT_REGIONS" IS 'Number of stale PCT partition regions';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."SEGMENT_CREATED" IS 'Whether the materialized view segment is created or not';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."EVALUATION_EDITION" IS 'Name of the evaluation edition assigned to the materialized view subquery';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UNUSABLE_BEFORE" IS 'Name of the oldest edition eligible for query rewrite';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."UNUSABLE_BEGINNING" IS 'Name of the oldest edition in which query rewrite becomes perpetually disabled';
   COMMENT ON COLUMN "SYS"."ALL_MVIEWS"."ON_QUERY_COMPUTATION" IS 'Indicates if the materialized view is a Real-Time MV';
   COMMENT ON TABLE "SYS"."ALL_MVIEWS"  IS 'All materialized views in the database'
;
--------------------------------------------------------
--  DDL for View ALL_NESTED_TABLE_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_NESTED_TABLE_COLS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "DATA_TYPE", "DATA_TYPE_MOD", "DATA_TYPE_OWNER", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "NULLABLE", "COLUMN_ID", "DEFAULT_LENGTH", "DATA_DEFAULT", "NUM_DISTINCT", "LOW_VALUE", "HIGH_VALUE", "DENSITY", "NUM_NULLS", "NUM_BUCKETS", "LAST_ANALYZED", "SAMPLE_SIZE", "CHARACTER_SET_NAME", "CHAR_COL_DECL_LENGTH", "GLOBAL_STATS", "USER_STATS", "AVG_COL_LEN", "CHAR_LENGTH", "CHAR_USED", "V80_FMT_IMAGE", "DATA_UPGRADED", "HIDDEN_COLUMN", "VIRTUAL_COLUMN", "SEGMENT_COLUMN_ID", "INTERNAL_COLUMN_ID", "HISTOGRAM", "QUALIFIED_COL_NAME") AS 
  select u.name, o.name,
       c.name,
       decode(c.type#, 1, decode(c.charsetform, 2, 'NVARCHAR2', 'VARCHAR2'),
                       2, decode(c.scale, null,
                                 decode(c.precision#, null, 'NUMBER', 'FLOAT'),
                                 'NUMBER'),
                       8, 'LONG',
                       9, decode(c.charsetform, 2, 'NCHAR VARYING', 'VARCHAR'),
                       12, 'DATE',
                       23, 'RAW', 24, 'LONG RAW',
                       58, nvl2(ac.synobj#, (select o.name from obj$ o
                                where o.obj#=ac.synobj#), ot.name),
                       69, 'ROWID',
                       96, decode(c.charsetform, 2, 'NCHAR', 'CHAR'),
                       100, 'BINARY_FLOAT',
                       101, 'BINARY_DOUBLE',
                       105, 'MLSLABEL',
                       106, 'MLSLABEL',
                       111, nvl2(ac.synobj#, (select o.name from obj$ o
                                 where o.obj#=ac.synobj#), ot.name),
                       112, decode(c.charsetform, 2, 'NCLOB', 'CLOB'),
                       113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
                       121, nvl2(ac.synobj#, (select o.name from obj$ o
                                 where o.obj#=ac.synobj#), ot.name),
                       122, nvl2(ac.synobj#, (select o.name from obj$ o
                                 where o.obj#=ac.synobj#), ot.name),
                       123, nvl2(ac.synobj#, (select o.name from obj$ o
                                 where o.obj#=ac.synobj#), ot.name),
                       178, 'TIME(' ||c.scale|| ')',
                       179, 'TIME(' ||c.scale|| ')' || ' WITH TIME ZONE',
                       180, 'TIMESTAMP(' ||c.scale|| ')',
                       181, 'TIMESTAMP(' ||c.scale|| ')' || ' WITH TIME ZONE',
                       231, 'TIMESTAMP(' ||c.scale|| ')' || ' WITH LOCAL TIME ZONE',
                       182, 'INTERVAL YEAR(' ||c.precision#||') TO MONTH',
                       183, 'INTERVAL DAY(' ||c.precision#||') TO SECOND(' ||
                             c.scale || ')',
                       208, 'UROWID',
                       'UNDEFINED'),
       decode(c.type#, 111, 'REF'),
       nvl2(ac.synobj#, (select u.name from "_BASE_USER" u, obj$ o
            where o.owner#=u.user# and o.obj#=ac.synobj#), ut.name),
       c.length, c.precision#, c.scale,
       decode(sign(c.null$),-1,'D', 0, 'Y', 'N'),
       decode(c.col#, 0, to_number(null), c.col#), c.deflength,
       c.default$, h.distcnt,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.lowval
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.hival
            else null
       end,
       h.density, h.null_cnt,
       case when nvl(h.distcnt,0) = 0 then h.distcnt
            when h.row_cnt = 0 then 1
	    when (h.bucket_cnt > 255
                  or
                  (h.bucket_cnt > h.distcnt
                   and h.row_cnt = h.distcnt
                   and h.density*h.bucket_cnt < 1))
                then h.row_cnt
            else h.bucket_cnt
       end,
       h.timestamp#, h.sample_size,
       decode(c.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(c.charsetid),
                             4, 'ARG:'||c.charsetid),
       decode(c.charsetid, 0, to_number(NULL),
                           nls_charset_decl_len(c.length, c.charsetid)),
       decode(bitand(h.spare2, 2), 2, 'YES', 'NO'),
       decode(bitand(h.spare2, 1), 1, 'YES', 'NO'),
       h.avgcln,
       c.spare3,
       decode(c.type#, 1, decode(bitand(c.property, 8388608), 0, 'B', 'C'),
                      96, decode(bitand(c.property, 8388608), 0, 'B', 'C'),
                      null),
       decode(bitand(ac.flags, 128), 128, 'YES', 'NO'),
       decode(o.status, 1, decode(bitand(ac.flags, 256), 256, 'NO', 'YES'),
                        decode(bitand(ac.flags, 2), 2, 'NO',
                               decode(bitand(ac.flags, 4), 4, 'NO',
                                      decode(bitand(ac.flags, 8), 8, 'NO',
                                             'N/A')))),
       decode(c.property, 0, 'NO', decode(bitand(c.property, 32), 32, 'YES',
                                          'NO')),
       decode(c.property, 0, 'NO', decode(bitand(c.property, 8), 8, 'YES',
                                          'NO')),
       decode(c.segcol#, 0, to_number(null), c.segcol#), c.intcol#,
       case when nvl(h.row_cnt,0) = 0 then 'NONE'
            when (h.bucket_cnt > 255
                  or
                  (h.bucket_cnt > h.distcnt and h.row_cnt = h.distcnt
                   and h.density*h.bucket_cnt < 1))
                then 'FREQUENCY'
            else 'HEIGHT BALANCED'
       end,
       decode(bitand(c.property, 1024), 1024,
              (select decode(bitand(cl.property, 1), 1, rc.name, cl.name)
               from sys.col$ cl, attrcol$ rc where cl.intcol# = c.intcol#-1
               and cl.obj# = c.obj# and c.obj# = rc.obj#(+) and
               cl.intcol# = rc.intcol#(+)),
              decode(bitand(c.property, 1), 0, c.name,
                     (select tc.name from sys.attrcol$ tc
                      where c.obj# = tc.obj# and c.intcol# = tc.intcol#)))
from sys.col$ c, sys.obj$ o, sys."_HIST_HEAD_DEC" h, sys.user$ u,
     sys.coltype$ ac, sys.obj$ ot, sys."_BASE_USER" ut, sys.tab$ t
where o.obj# = c.obj#
  and o.owner# = u.user#
  and c.obj# = h.obj#(+) and c.intcol# = h.intcol#(+)
  and c.obj# = ac.obj#(+) and c.intcol# = ac.intcol#(+)
  and ac.toid = ot.oid$(+)
  and ot.type#(+) = 13
  and ot.owner# = ut.user#(+)
  and o.obj# = t.obj#
  and bitand(t.property, 8192) = 8192        /* nested tables */
  and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
       );

   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."TABLE_NAME" IS 'Nested table name';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."COLUMN_NAME" IS 'Column name';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DATA_TYPE" IS 'Datatype of the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DATA_TYPE_MOD" IS 'Datatype modifier of the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DATA_TYPE_OWNER" IS 'Owner of the datatype of the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DATA_LENGTH" IS 'Length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DATA_PRECISION" IS 'Length: decimal digits (NUMBER) or binary digits (FLOAT)';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DATA_SCALE" IS 'Digits to right of decimal point in a number';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."NULLABLE" IS 'Does column allow NULL values?';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."COLUMN_ID" IS 'Sequence number of the column as created';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DEFAULT_LENGTH" IS 'Length of default value for the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DATA_DEFAULT" IS 'Default value for the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."NUM_DISTINCT" IS 'The number of distinct values in the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."LOW_VALUE" IS 'The low value in the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."HIGH_VALUE" IS 'The high value in the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DENSITY" IS 'The density of the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."NUM_NULLS" IS 'The number of nulls in the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."NUM_BUCKETS" IS 'The number of buckets in histogram for the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."LAST_ANALYZED" IS 'The date of the most recent time this column was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."SAMPLE_SIZE" IS 'The sample size used in analyzing this column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."CHARACTER_SET_NAME" IS 'Character set name';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."CHAR_COL_DECL_LENGTH" IS 'Declaration length of character type column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."AVG_COL_LEN" IS 'The average length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."CHAR_LENGTH" IS 'The maximum length of the column in characters';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."CHAR_USED" IS 'C if maximum length is specified in characters, B if in bytes';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."V80_FMT_IMAGE" IS 'Is column data in 8.0 image format?';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."DATA_UPGRADED" IS 'Has column data been upgraded to the latest type version format?';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."HIDDEN_COLUMN" IS 'Is this a hidden column?';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."VIRTUAL_COLUMN" IS 'Is this a virtual column?';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."SEGMENT_COLUMN_ID" IS 'Sequence number of the column in the segment';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."INTERNAL_COLUMN_ID" IS 'Internal sequence number of the column';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLE_COLS"."QUALIFIED_COL_NAME" IS 'Qualified column name';
   COMMENT ON TABLE "SYS"."ALL_NESTED_TABLE_COLS"  IS 'Columns of nested tables'
;
--------------------------------------------------------
--  DDL for View ALL_NESTED_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_NESTED_TABLES" ("OWNER", "TABLE_NAME", "TABLE_TYPE_OWNER", "TABLE_TYPE_NAME", "PARENT_TABLE_NAME", "PARENT_TABLE_COLUMN", "STORAGE_SPEC", "RETURN_TYPE", "ELEMENT_SUBSTITUTABLE") AS 
  select u.name, o.name,
       nvl2(ct.synobj#, (select u.name from "_BASE_USER" u, obj$ o
            where o.owner#=u.user# and o.obj#=ct.synobj#), ut.name),
       nvl2(ct.synobj#, (select o.name from obj$ o where o.obj#=ct.synobj#),
            ot.name),
       op.name, ac.name,
       lpad(decode(bitand(ct.flags, 64), 64, 'USER_SPECIFIED', 'DEFAULT'), 30),
       lpad(decode(bitand(ct.flags, 32), 32, 'LOCATOR', 'VALUE'), 20),
       lpad((case when bitand(ct.flags, 5120)=0 and bitand(t.properties, 8)= 8
       then 'Y' else 'N' end), 25)
from sys.ntab$ n, sys."_CURRENT_EDITION_OBJ" o, sys."_CURRENT_EDITION_OBJ" op,
  sys.obj$ ot, sys.col$ c, sys.coltype$ ct, sys.user$ u,
  sys."_BASE_USER" ut, sys.attrcol$ ac, sys.type$ t, sys.collection$ cl
where o.owner# = u.user#
  and op.owner# = u.user#
  and n.obj# = op.obj#
  and n.ntab# = o.obj#
  and c.obj# = op.obj#
  and n.intcol# = c.intcol#
  and c.obj# = ac.obj#
  and c.intcol# = ac.intcol#
  and op.obj# = ct.obj#
  and ct.toid = ot.oid$
  and ct.intcol#=n.intcol#
  and ot.owner# = ut.user#
  and ct.toid=cl.toid
  and cl.elem_toid=t.tvoid
  and bitand(ct.flags,4)=4
  and bitand(c.property,32768) != 32768           /* not unused column */
  and bitand(o.flags,128) = 0                     /* not in recycle bin */
  and (op.owner# = userenv('SCHEMAID')
       or op.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege (o.owner#, o.type#) = 1
      )
union all
select u.name, o.name,
       nvl2(ct.synobj#, (select u.name from "_BASE_USER" u, obj$ o
            where o.owner#=u.user# and o.obj#=ct.synobj#), ut.name),
       nvl2(ct.synobj#, (select o.name from obj$ o where o.obj#=ct.synobj#),
            ot.name),
       op.name, c.name,
       lpad(decode(bitand(ct.flags, 64), 64, 'USER_SPECIFIED', 'DEFAULT'), 30),
       lpad(decode(bitand(ct.flags, 32), 32, 'LOCATOR', 'VALUE'), 20),
       lpad((case when bitand(ct.flags, 5120)=0 and bitand(t.properties, 8)= 8
       then 'Y' else 'N' end), 25)
from sys.ntab$ n, sys."_CURRENT_EDITION_OBJ" o, sys."_CURRENT_EDITION_OBJ" op,
  sys.obj$ ot, sys.col$ c,  sys.coltype$ ct, sys.user$ u,
  sys."_BASE_USER" ut, sys.type$ t, sys.collection$ cl
where o.owner# = u.user#
  and op.owner# = u.user#
  and n.obj# = op.obj#
  and n.ntab# = o.obj#
  and c.obj# = op.obj#
  and n.intcol# = c.intcol#
  and bitand(c.property,1)=0
  and op.obj# = ct.obj#
  and ct.toid = ot.oid$
  and ct.intcol#=n.intcol#
  and ot.owner# = ut.user#
  and ct.toid=cl.toid
  and cl.elem_toid=t.tvoid
  and bitand(ct.flags,4)=4
  and bitand(c.property,32768) != 32768           /* not unused column */
  and bitand(o.flags,128) = 0                     /* not in recycle bin */
  and (op.owner# = userenv('SCHEMAID')
       or op.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLES"."OWNER" IS 'Owner of the nested table';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLES"."TABLE_NAME" IS 'Name of the nested table';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLES"."TABLE_TYPE_OWNER" IS 'Owner of the type of which the nested table was created';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLES"."TABLE_TYPE_NAME" IS 'Name of the type of the nested table';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLES"."PARENT_TABLE_NAME" IS 'Name of the parent table containing the nested table';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLES"."PARENT_TABLE_COLUMN" IS 'Column name of the parent table that corresponds to the nested table';
   COMMENT ON COLUMN "SYS"."ALL_NESTED_TABLES"."ELEMENT_SUBSTITUTABLE" IS 'Indication of whether the nested table element is substitutable or not';
   COMMENT ON TABLE "SYS"."ALL_NESTED_TABLES"  IS 'Description of nested tables in tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_OBJ_COLATTRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OBJ_COLATTRS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "SUBSTITUTABLE") AS 
  select u.name, o.name, c.name,
  lpad(decode(bitand(ct.flags, 512), 512, 'Y', 'N'), 15)
from sys.coltype$ ct, sys."_CURRENT_EDITION_OBJ" o, sys.col$ c, sys.user$ u
where o.owner# = u.user#
  and bitand(ct.flags, 2) = 2                                 /* ADT column */
  and o.obj#=ct.obj#
  and o.obj#=c.obj#
  and c.intcol#=ct.intcol#
  and bitand(c.property,32768) != 32768                 /* not unused column */
  and not exists (select null                   /* Doesn't exist in attrcol$ */
                  from sys.attrcol$ ac
                  where ac.intcol#=ct.intcol#
                        and ac.obj#=ct.obj#)
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      )
union all
select u.name, o.name, ac.name,
  lpad(decode(bitand(ct.flags, 512), 512, 'Y', 'N'), 15)
from sys.coltype$ ct, sys."_CURRENT_EDITION_OBJ" o, sys.attrcol$ ac,
     sys.user$ u, col$ c
where o.owner# = u.user#
  and bitand(ct.flags, 2) = 2                                /* ADT column */
  and o.obj#=ct.obj#
  and o.obj#=c.obj#
  and o.obj#=ac.obj#
  and c.intcol#=ct.intcol#
  and c.intcol#=ac.intcol#
  and bitand(c.property,32768) != 32768               /* not unused column */
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_OBJ_COLATTRS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJ_COLATTRS"."TABLE_NAME" IS 'Name of the table containing the object column or attribute';
   COMMENT ON COLUMN "SYS"."ALL_OBJ_COLATTRS"."COLUMN_NAME" IS 'Fully qualified name of the object column or attribute';
   COMMENT ON COLUMN "SYS"."ALL_OBJ_COLATTRS"."SUBSTITUTABLE" IS 'Indication of whether the column is substitutable or not';
   COMMENT ON TABLE "SYS"."ALL_OBJ_COLATTRS"  IS 'Description of object columns and attributes contained in the tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_OBJECTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OBJECTS" ("OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "OBJECT_ID", "DATA_OBJECT_ID", "OBJECT_TYPE", "CREATED", "LAST_DDL_TIME", "TIMESTAMP", "STATUS", "TEMPORARY", "GENERATED", "SECONDARY", "NAMESPACE", "EDITION_NAME", "SHARING", "EDITIONABLE", "ORACLE_MAINTAINED", "APPLICATION", "DEFAULT_COLLATION", "DUPLICATED", "SHARDED", "CREATED_APPID", "CREATED_VSNID", "MODIFIED_APPID", "MODIFIED_VSNID") AS 
  select u.name, o.name, o.subname, o.obj#, o.dataobj#,
       decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
                      7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
                      
                      11, 'PACKAGE BODY', 12, 'TRIGGER',
                      13, 'TYPE', 14, 'TYPE BODY',
                      19, 'TABLE PARTITION', 20, 'INDEX PARTITION', 21, 'LOB',
                      22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',
                      28, 'JAVA SOURCE', 29, 'JAVA CLASS', 30, 'JAVA RESOURCE',
                      32, 'INDEXTYPE', 33, 'OPERATOR',
                      34, 'TABLE SUBPARTITION', 35, 'INDEX SUBPARTITION',
                      40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',
                      42, CASE (SELECT BITAND(s.xpflags, 8388608 + 34359738368)
                                FROM sum$ s
                                WHERE s.obj#=o.obj#)
                          WHEN 8388608 THEN 'REWRITE EQUIVALENCE'
                          WHEN 34359738368 THEN 'MATERIALIZED ZONEMAP'
                          ELSE 'MATERIALIZED VIEW'
                          END,
                      43, 'DIMENSION',
                      44, 'CONTEXT', 46, 'RULE SET', 47, 'RESOURCE PLAN',
                      48, 'CONSUMER GROUP',
                      55, 'XML SCHEMA', 56, 'JAVA DATA',
                      57, 'EDITION', 59, 'RULE',
                      60, 'CAPTURE', 61, 'APPLY',
                      62, 'EVALUATION CONTEXT',
                      66, 'JOB', 67, 'PROGRAM', 68, 'JOB CLASS', 69, 'WINDOW',
                      72, 'SCHEDULER GROUP', 74, 'SCHEDULE', 79, 'CHAIN',
                      81, 'FILE GROUP', 82, 'MINING MODEL', 87, 'ASSEMBLY',
                      90, 'CREDENTIAL', 92, 'CUBE DIMENSION', 93, 'CUBE',
                      94, 'MEASURE FOLDER', 95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER', 101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE',
                      115, 'UNIFIED AUDIT POLICY',
                      144, 'MINING MODEL PARTITION',
                      148, 'LOCKDOWN PROFILE',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW',
                     'UNDEFINED'),
       o.ctime, o.mtime,
       to_char(o.stime, 'YYYY-MM-DD:HH24:MI:SS'),
       decode(o.status, 0, 'N/A', 1, 'VALID', 'INVALID'),
       decode(bitand(o.flags, 2), 0, 'N', 2, 'Y', 'N'),
       decode(bitand(o.flags, 4), 0, 'N', 4, 'Y', 'N'),
       decode(bitand(o.flags, 16), 0, 'N', 16, 'Y', 'N'),
       o.namespace,
       o.defining_edition,
       decode(bitand(o.flags, (65536+131072+4294967296)),
              4294967296+65536, 'EXTENDED DATA LINK', 65536, 'METADATA LINK',
              131072, 'DATA LINK', 'NONE'),
       case when o.type# in (4,5,7,8,9,11,12,13,14,22,87,114) then
           decode(bitand(o.flags, 1048576), 0, 'Y', 1048576, 'N', 'Y')
         else null end,
       decode(bitand(o.flags, 4194304), 4194304, 'Y', 'N'),
       decode(bitand(o.flags, 134217728), 134217728, 'Y', 'N'),
       case when o.type# in (2,4,7,8,9,12,13) then
           nls_collation_name(nvl(o.dflcollid, 16382))
         when (o.type# = 42
               and exists
               (SELECT 1
                FROM sum$ s
                WHERE s.obj#=o.obj#
                -- not rewrite equivalence or zone map
                and bitand(s.xpflags, 8388608 + 34359738368) = 0)) then
           nls_collation_name(nvl(o.dflcollid, 16382))
         else null end,
       decode(bitand(o.flags, 2684354560),
                     0, 'N',
                     2147483648, 'Y', /* KQDOBREF set */
                      536870912, 'Y', /* KQDOBOAS set */
                     2684354560, 'Y', /* both KQDOBREF and KQDOBOAS set */
                     'N'),
       decode(bitand(o.flags, 1073741824), 0, 'N', 1073741824, 'Y', 'N'),
       -- CREATED_APPID
       o.CREAPPID,
       -- CREATED_VSNID
       o.CREVERID,
       -- MODIFIED_APPID,
       o.MODAPPID,
       -- MODIFIED_VSNID,
       o.MODVERID
from sys."_CURRENT_EDITION_OBJ" o, sys.user$ u
where o.owner# = u.user#
  and o.linkname is null
  and (o.type# not in (1  /* INDEX - handled below */
                       , 10 /* NON-EXISTENT */)
       or
       (o.type# = 1 and 1 = (select 1
                             from sys.ind$ i
                            where i.obj# = o.obj#
                              and i.type# in (1, 2, 3, 4, 6, 7, 9))))
  and o.name != '_NEXT_OBJECT'
  and o.name != '_default_auditing_options_'
  and bitand(o.flags, 128) = 0
  -- Exclude XML Token set objects */
  and (o.type# not in (1 /* INDEXES */,
                       2 /* TABLES */,
                       6 /* SEQUENCE */)
      or
      (o.type# = 1 and not exists (select 1
                from sys.ind$ i, sys.tab$ t, sys.obj$ io
                where i.obj# = o.obj#
                  and io.obj# = i.bo#
                  and io.type# = 2
                  and i.bo# = t.obj#
                  and bitand(t.property, power(2,65)) =  power(2,65)))
      or
      (o.type# = 2 and 1 = (select 1
                from sys.tab$ t
                where t.obj# = o.obj#
                  and (bitand(t.property, power(2,65)) = 0
                         or t.property is null)))
      or
      (o.type# = 6 and 1 = (select 1
                from sys.seq$ s
                where s.obj# = o.obj#
                  and (bitand(s.flags, 1024) = 0 or s.flags is null))))
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      /* non-procedural objects */
      o.type# not in (7, 8, 9, 11, 12, 13, 14, 28, 29, 30, 56, 93)
      and
      o.obj# in (select obj# from sys.objauth$
                 where grantee# in (select kzsrorol from x$kzsro)
                   and privilege# in (3 /* DELETE */,   6 /* INSERT */,
                                      7 /* LOCK */,     9 /* SELECT */,
                                      10 /* UPDATE */, 12 /* EXECUTE */,
                                      11 /* USAGE */,  16 /* CREATE */,
                                      17 /* READ */,   18 /* WRITE  */ ))
    )
    or
    (
       o.type# in (7, 8, 9, 28, 29, 30, 56) /* prc, fcn, pkg */
       and
       (
         exists (select null from sys.objauth$ oa
                  where oa.obj# = o.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        or /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
       )
    )
    or
    (
       o.type# in (19) /* partitioned table objects */
       and
       (
       exists (select bo# from tabpart$ where obj# = o.obj# and
               bo# in  (select obj# from sys.objauth$
                        where grantee# in (select kzsrorol from x$kzsro)
                        and privilege# in (9 /* SELECT */, 17 /* READ */))
              )
       or
       exists (select bo# from tabcompart$ where obj# = o.obj# and
               bo# in  (select obj# from sys.objauth$
                        where grantee# in (select kzsrorol from x$kzsro)
                        and privilege# in (9 /* SELECT */, 17 /* READ */))
               )
       )
    )
    or
    (
       o.type# in (34) /* sub-partitioned table objects */
       and
       exists (select cp.bo# from tabsubpart$ sp, tabcompart$ cp
               where sp.obj# = o.obj# and sp.pobj# = cp.obj# and
                     cp.bo# in  (select obj# from sys.objauth$
                     where  grantee# in (select kzsrorol from x$kzsro)
                     and privilege# in (9 /* SELECT */, 17 /* READ */))
              )
    )
    or
    (
       o.type# in (12) /* trigger */
       and
       (
         exists (select null from sys.trigger$ t, sys.objauth$ oa
                  where bitand(t.property, 24) = 0
                    and t.obj# = o.obj#
                    and oa.obj# = t.baseobject
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# = 26 /* DEBUG */)
         or /* user has system privileges */
         ora_check_sys_privilege (o.owner#, o.type#) = 1
       )
    )
    or
    (
       o.type# = 11 /* pkg body */
       and
       (
         exists (select null
                   from sys."_ACTUAL_EDITION_OBJ" specobj, sys.dependency$ dep,
                        sys.objauth$ oa
                  where specobj.owner# = o.owner#
                    and specobj.name = o.name
                    and specobj.type# = 9 /* pkg */
                    and dep.d_obj# = o.obj# and dep.p_obj# = specobj.obj#
                    and oa.obj# = specobj.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# = 26 /* DEBUG */)
         or /* user has system privileges */
         ora_check_sys_privilege (o.owner#, o.type#) = 1
       )
    )
    or
    (
       o.type# in (1) /* index */
       and
       exists (select i.obj# from ind$ i
               where i.obj# = o.obj#
                 and exists (select null from sys.objauth$ oa
                             where oa.obj# = i.bo#
                               and oa.grantee# in (select kzsrorol
                                                   from x$kzsro)
                            )
              )
    )
    or
    ( o.type# = 13 /* type */
      and
      (
        exists (select null from sys.objauth$ oa
                 where oa.obj# = o.obj#
                   and oa.grantee# in (select kzsrorol from x$kzsro)
                   and oa.privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        or /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
    )
    or
    (
      o.type# = 14 /* type body */
      and
      (
        exists (select null
                  from sys."_ACTUAL_EDITION_OBJ" specobj, sys.dependency$ dep,
                       sys.objauth$ oa
                 where specobj.owner# = o.owner#
                   and specobj.name = o.name
                   and specobj.type# = 13 /* type */
                   and dep.d_obj# = o.obj# and dep.p_obj# = specobj.obj#
                   and oa.obj# = specobj.obj#
                   and oa.grantee# in (select kzsrorol from x$kzsro)
                   and oa.privilege# = 26 /* DEBUG */)
        or /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
    )
    or
    (
       o.type# in
       (
        1, /* index */
        2, /* table */
        3, /* view */
        4, /* synonym */
        5, /* table partn */
        6, /* sequence */
        19, /* index partn */
        20, /* table subpartn */
        22, /* library */
        23, /* directory */
        32, /* indextype */
        33, /* operator */
        34, /* index subpartn */
        35, /* cluster */
        42, /* summary */
        44, /* context */
        46, /* rule set */
        48, /* resource consumer group */
        59, /* rule */
        62, /* evaluation context */
        66, /* scheduler job */
        67, /* scheduler program */
        68, /* scheduler job class */
        79, /* scheduler chain */
        81, /* file group */
        82, /* mining model */
        87, /* assembly */
        92, /* cube dimension */
        94, /* measure folder */
        95, /* cube build process */
        100 /* file watcher */
       )
       and
          /* user has system privileges */
       ora_check_sys_privilege (o.owner#, o.type#) = 1
    )
    or
    (
      o.type# = 55 /* XML schema */
      and
      1 = (select /*+ NO_MERGE */ xml_schema_name_present.is_schema_present(o.name, u2.id2) id1 from (select /*+ NO_MERGE */ userenv('SCHEMAID') id2 from dual) u2)
      /* we need a sub-query instead of the directy invoking
       * xml_schema_name_present, because inside a view even the function
       * arguments are evaluated as definers rights.
       */
    )
    or
    (
     /* scheduler windows, scheduler groups, schedules and destinations */
     /* no privileges are needed to view these objects */
     o.type# in (69, 72, 74, 101)
    )
    or
    (
     o.type# = 57 /* edition */
    )
    or
    (
      o.type# = 93 /* cube */
      and
      (o.obj# in
            ( select obj#  /* directly granted privileges */
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or
       (
        /* user has system privileges */
        ora_check_sys_privilege ( o.owner#, o.type#) = 1
       )
      )
      and  /* require access to all Dimensions of the Cube */
      ( 1 = ( SELECT decode(have_all_dim_access, null, 1, have_all_dim_access)
              FROM
                ( SELECT
                    obj#,
                    MIN(have_dim_access) have_all_dim_access
                  FROM
                    ( SELECT
                        c.obj# obj#,
                        ( CASE
                          WHEN
                            ( do.owner# in ( userenv('SCHEMAID'), 1 )  /* public objects */
                              or do.obj# in
                              ( select obj#  /* directly granted privileges */
                                from sys.objauth$
                                where grantee# in ( select kzsrorol from x$kzsro )
                              )
                              or  /* user has system privileges */
                              ora_check_sys_privilege ( do.owner#, do.type#) = 1
                            )
                          THEN 1
                          ELSE 0
                          END ) have_dim_access
                      FROM
                        olap_cubes$ c,
                        dependency$ d,
                        obj$ do
                      WHERE
                        do.obj# = d.p_obj#
                        AND do.type# = 92 /* CUBE DIMENSION */
                        AND c.obj# = d.d_obj#
                    )
                  GROUP BY obj# ) da
              WHERE
                o.obj#=da.obj#(+)
            )
      )
    )
    or
    (
       o.type# = 114 /* sql translation profile */
       and
       (
         exists (select null from sys.objauth$ oa
                  where oa.obj# = o.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# in (0 /* ALTER */, 29 /* USE */))
         or
         /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
       )
    )
    or
    (
       o.type# in (
                   150, /* hierarchy */
                   151, /* attribute dimension */
                   152  /* analytic view */
                  )
       and ora_check_sys_privilege(o.owner#, o.type#) = 1
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."SUBOBJECT_NAME" IS 'Name of the sub-object (for example, partititon)';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."OBJECT_ID" IS 'Object number of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."DATA_OBJECT_ID" IS 'Object number of the segment which contains the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."OBJECT_TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."CREATED" IS 'Timestamp for the creation of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."LAST_DDL_TIME" IS 'Timestamp for the last DDL change (including GRANT and REVOKE) to the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."TIMESTAMP" IS 'Timestamp for the specification of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."STATUS" IS 'Status of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."TEMPORARY" IS 'Can the current session only see data that it placed in this object itself?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."GENERATED" IS 'Was the name of this object system generated?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."SECONDARY" IS 'Is this a secondary object created as part of icreate for domain indexes?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."NAMESPACE" IS 'Namespace for the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."EDITION_NAME" IS 'Name of the edition in which the object is actual';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."SHARING" IS 'Is this a Metadata Link, an Object Link or neither?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."EDITIONABLE" IS 'Object is considered editionable';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."ORACLE_MAINTAINED" IS 'Denotes whether the object was created, and is maintained, by Oracle-supplied scripts. An object for which this has the value Y must not be changed in any way except by running an Oracle-supplied script.';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."APPLICATION" IS 'Denotes whether the object is part of an Application Container.';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."DEFAULT_COLLATION" IS 'Default collation for the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."CREATED_APPID" IS 'ID of Application that created object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."CREATED_VSNID" IS 'ID of Application Version that created object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."MODIFIED_APPID" IS 'ID of Application that last modified object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS"."MODIFIED_VSNID" IS 'ID of Application Version that last modified object';
   COMMENT ON TABLE "SYS"."ALL_OBJECTS"  IS 'Objects accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_OBJECTS_AE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OBJECTS_AE" ("OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "OBJECT_ID", "DATA_OBJECT_ID", "OBJECT_TYPE", "CREATED", "LAST_DDL_TIME", "TIMESTAMP", "STATUS", "TEMPORARY", "GENERATED", "SECONDARY", "NAMESPACE", "EDITION_NAME", "SHARING", "EDITIONABLE", "ORACLE_MAINTAINED", "APPLICATION", "DEFAULT_COLLATION", "DUPLICATED", "SHARDED", "CREATED_APPID", "CREATED_VSNID", "MODIFIED_APPID", "MODIFIED_VSNID") AS 
  select u.name, o.name, o.subname, o.obj#, o.dataobj#,
       decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
                      7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
                      10, 'NON-EXISTENT',
                      11, 'PACKAGE BODY', 12, 'TRIGGER',
                      13, 'TYPE', 14, 'TYPE BODY',
                      19, 'TABLE PARTITION', 20, 'INDEX PARTITION', 21, 'LOB',
                      22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',
                      28, 'JAVA SOURCE', 29, 'JAVA CLASS', 30, 'JAVA RESOURCE',
                      32, 'INDEXTYPE', 33, 'OPERATOR',
                      34, 'TABLE SUBPARTITION', 35, 'INDEX SUBPARTITION',
                      40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',
                      42, CASE (SELECT BITAND(s.xpflags, 8388608 + 34359738368)
                                FROM sum$ s
                                WHERE s.obj#=o.obj#)
                          WHEN 8388608 THEN 'REWRITE EQUIVALENCE'
                          WHEN 34359738368 THEN 'MATERIALIZED ZONEMAP'
                          ELSE 'MATERIALIZED VIEW'
                          END,
                      43, 'DIMENSION',
                      44, 'CONTEXT', 46, 'RULE SET', 47, 'RESOURCE PLAN',
                      48, 'CONSUMER GROUP',
                      55, 'XML SCHEMA', 56, 'JAVA DATA',
                      57, 'EDITION', 59, 'RULE',
                      60, 'CAPTURE', 61, 'APPLY',
                      62, 'EVALUATION CONTEXT',
                      66, 'JOB', 67, 'PROGRAM', 68, 'JOB CLASS', 69, 'WINDOW',
                      72, 'SCHEDULER GROUP', 74, 'SCHEDULE', 79, 'CHAIN',
                      81, 'FILE GROUP', 82, 'MINING MODEL', 87, 'ASSEMBLY',
                      90, 'CREDENTIAL', 92, 'CUBE DIMENSION', 93, 'CUBE',
                      94, 'MEASURE FOLDER', 95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER', 101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE',
                      115, 'UNIFIED AUDIT POLICY',
                      144, 'MINING MODEL PARTITION',
                      148, 'LOCKDOWN PROFILE',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW',
                     'UNDEFINED'),
       o.ctime, o.mtime,
       to_char(o.stime, 'YYYY-MM-DD:HH24:MI:SS'),
       decode(o.status, 0, 'N/A', 1, 'VALID', 'INVALID'),
       decode(bitand(o.flags, 2), 0, 'N', 2, 'Y', 'N'),
       decode(bitand(o.flags, 4), 0, 'N', 4, 'Y', 'N'),
       decode(bitand(o.flags, 16), 0, 'N', 16, 'Y', 'N'),
       o.namespace,
       o.defining_edition,
       decode(bitand(o.flags, (65536+131072+4294967296)),
              4294967296+65536, 'EXTENDED DATA LINK', 65536, 'METADATA LINK',
              131072, 'DATA LINK', 'NONE'),
       case when o.type# in (4,5,7,8,9,11,12,13,14,22,87,114) then
           decode(bitand(o.flags, 1048576), 0, 'Y', 1048576, 'N', 'Y')
         else null end,
       decode(bitand(o.flags, 4194304), 4194304, 'Y', 'N'),
       decode(bitand(o.flags, 134217728), 134217728, 'Y', 'N'),
       case when o.type# in (2,4,7,8,9,12,13) then
           nls_collation_name(nvl(o.dflcollid, 16382))
         when (o.type# = 42
               and exists
               (SELECT 1
                FROM sum$ s
                WHERE s.obj#=o.obj#
                -- not rewrite equivalence or zone map
                and bitand(s.xpflags, 8388608 + 34359738368) = 0)) then
           nls_collation_name(nvl(o.dflcollid, 16382))
         else null end,
       decode(bitand(o.flags, 2684354560),
                     0, 'N',
                     2147483648, 'Y', /* KQDOBREF set */
                      536870912, 'Y', /* KQDOBOAS set */
                     2684354560, 'Y', /* both KQDOBREF and KQDOBOAS set */
                     'N'),
       decode(bitand(o.flags, 1073741824), 0, 'N', 1073741824, 'Y', 'N'),
       -- CREATED_APPID
       o.CREAPPID,
       -- CREATED_VSNID
       o.CREVERID,
       -- MODIFIED_APPID,
       o.MODAPPID,
       -- MODIFIED_VSNID,
       o.MODVERID
from sys."_ACTUAL_EDITION_OBJ" o, sys.user$ u
where o.owner# = u.user#
  and o.linkname is null
  and (o.type# not in (1  /* INDEX - handled below */
                       )
       or
       (o.type# = 1 and 1 = (select 1
                             from sys.ind$ i
                            where i.obj# = o.obj#
                              and i.type# in (1, 2, 3, 4, 6, 7, 9))))
  and o.name != '_NEXT_OBJECT'
  and o.name != '_default_auditing_options_'
  and bitand(o.flags, 128) = 0
  -- Exclude XML Token set objects */
  and (o.type# not in (1 /* INDEXES */,
                       2 /* TABLES */,
                       6 /* SEQUENCE */)
      or
      (o.type# = 1 and not exists (select 1
                from sys.ind$ i, sys.tab$ t, sys.obj$ io
                where i.obj# = o.obj#
                  and io.obj# = i.bo#
                  and io.type# = 2
                  and i.bo# = t.obj#
                  and bitand(t.property, power(2,65)) =  power(2,65)))
      or
      (o.type# = 2 and 1 = (select 1
                from sys.tab$ t
                where t.obj# = o.obj#
                  and (bitand(t.property, power(2,65)) = 0
                         or t.property is null)))
      or
      (o.type# = 6 and 1 = (select 1
                from sys.seq$ s
                where s.obj# = o.obj#
                  and (bitand(s.flags, 1024) = 0 or s.flags is null))))
  and
  (
    o.owner# in (userenv('SCHEMAID'), 1 /* PUBLIC */)
    or
    (
      /* non-procedural objects */
      o.type# not in (7, 8, 9, 11, 12, 13, 14, 28, 29, 30, 56, 93)
      and
      o.obj# in (select obj# from sys.objauth$
                 where grantee# in (select kzsrorol from x$kzsro)
                   and privilege# in (3 /* DELETE */,   6 /* INSERT */,
                                      7 /* LOCK */,     9 /* SELECT */,
                                      10 /* UPDATE */, 12 /* EXECUTE */,
                                      11 /* USAGE */,  16 /* CREATE */,
                                      17 /* READ */,   18 /* WRITE  */ ))
    )
    or
    (
       o.type# in (7, 8, 9, 28, 29, 30, 56) /* prc, fcn, pkg */
       and
       (
         exists (select null from sys.objauth$ oa
                  where oa.obj# = o.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        or /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
       )
    )
    or
    (
       o.type# in (19) /* partitioned table objects */
       and
       (
       exists (select bo# from tabpart$ where obj# = o.obj# and
               bo# in  (select obj# from sys.objauth$
                        where grantee# in (select kzsrorol from x$kzsro)
                        and privilege# in (9 /* SELECT */, 17 /* READ */))
              )
       or
       exists (select bo# from tabcompart$ where obj# = o.obj# and
               bo# in  (select obj# from sys.objauth$
                        where grantee# in (select kzsrorol from x$kzsro)
                        and privilege# in (9 /* SELECT */, 17 /* READ */))
               )
       )
    )
    or
    (
       o.type# in (34) /* sub-partitioned table objects */
       and
       exists (select cp.bo# from tabsubpart$ sp, tabcompart$ cp
               where sp.obj# = o.obj# and sp.pobj# = cp.obj# and
                     cp.bo# in  (select obj# from sys.objauth$
                     where  grantee# in (select kzsrorol from x$kzsro)
                     and privilege# in (9 /* SELECT */, 17 /* READ */))
              )
    )
    or
    (
       o.type# in (12) /* trigger */
       and
       (
         exists (select null from sys.trigger$ t, sys.objauth$ oa
                  where bitand(t.property, 24) = 0
                    and t.obj# = o.obj#
                    and oa.obj# = t.baseobject
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# = 26 /* DEBUG */)
         or /* user has system privileges */
         ora_check_sys_privilege (o.owner#, o.type#) = 1
       )
    )
    or
    (
       o.type# = 11 /* pkg body */
       and
       (
         exists (select null
                   from sys."_ACTUAL_EDITION_OBJ" specobj, sys.dependency$ dep,
                        sys.objauth$ oa
                  where specobj.owner# = o.owner#
                    and specobj.name = o.name
                    and specobj.type# = 9 /* pkg */
                    and dep.d_obj# = o.obj# and dep.p_obj# = specobj.obj#
                    and oa.obj# = specobj.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# = 26 /* DEBUG */)
         or /* user has system privileges */
         ora_check_sys_privilege (o.owner#, o.type#) = 1
       )
    )
    or
    (
       o.type# in (1) /* index */
       and
       exists (select i.obj# from ind$ i
               where i.obj# = o.obj#
                 and exists (select null from sys.objauth$ oa
                             where oa.obj# = i.bo#
                               and oa.grantee# in (select kzsrorol
                                                   from x$kzsro)
                            )
              )
    )
    or
    ( o.type# = 13 /* type */
      and
      (
        exists (select null from sys.objauth$ oa
                 where oa.obj# = o.obj#
                   and oa.grantee# in (select kzsrorol from x$kzsro)
                   and oa.privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        or /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
    )
    or
    (
      o.type# = 14 /* type body */
      and
      (
        exists (select null
                  from sys."_ACTUAL_EDITION_OBJ" specobj, sys.dependency$ dep,
                       sys.objauth$ oa
                 where specobj.owner# = o.owner#
                   and specobj.name = o.name
                   and specobj.type# = 13 /* type */
                   and dep.d_obj# = o.obj# and dep.p_obj# = specobj.obj#
                   and oa.obj# = specobj.obj#
                   and oa.grantee# in (select kzsrorol from x$kzsro)
                   and oa.privilege# = 26 /* DEBUG */)
        or /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
    )
    or
    (
       o.type# in
       (
        1, /* index */
        2, /* table */
        3, /* view */
        4, /* synonym */
        5, /* table partn */
        6, /* sequence */
        19, /* index partn */
        20, /* table subpartn */
        22, /* library */
        23, /* directory */
        32, /* indextype */
        33, /* operator */
        34, /* index subpartn */
        35, /* cluster */
        42, /* summary */
        44, /* context */
        46, /* rule set */
        48, /* resource consumer group */
        59, /* rule */
        62, /* evaluation context */
        66, /* scheduler job */
        67, /* scheduler program */
        68, /* scheduler job class */
        79, /* scheduler chain */
        81, /* file group */
        82, /* mining model */
        87, /* assembly */
        92, /* cube dimension */
        94, /* measure folder */
        95, /* cube build process */
        100 /* file watcher */
       )
       and
          /* user has system privileges */
       ora_check_sys_privilege (o.owner#, o.type#) = 1
    )
    or
    (
      o.type# = 55 /* XML schema */
      and
      1 = (select /*+ NO_MERGE */ xml_schema_name_present.is_schema_present(o.name, u2.id2) id1 from (select /*+ NO_MERGE */ userenv('SCHEMAID') id2 from dual) u2)
      /* we need a sub-query instead of the directy invoking
       * xml_schema_name_present, because inside a view even the function
       * arguments are evaluated as definers rights.
       */
    )
    or
    (
     /* scheduler windows, scheduler groups, schedules and destinations */
     /* no privileges are needed to view these objects */
     o.type# in (69, 72, 74, 101)
    )
    or
    (
     o.type# = 57 /* edition */
    )
    or
    (
      o.type# = 93 /* cube */
      and
      (o.obj# in
            ( select obj#  /* directly granted privileges */
              from sys.objauth$
              where grantee# in ( select kzsrorol from x$kzsro )
            )
       or
       (
        /* user has system privileges */
        ora_check_sys_privilege ( o.owner#, o.type#) = 1
       )
      )
      and  /* require access to all Dimensions of the Cube */
      ( 1 = ( SELECT decode(have_all_dim_access, null, 1, have_all_dim_access)
              FROM
                ( SELECT
                    obj#,
                    MIN(have_dim_access) have_all_dim_access
                  FROM
                    ( SELECT
                        c.obj# obj#,
                        ( CASE
                          WHEN
                            ( do.owner# in ( userenv('SCHEMAID'), 1 )  /* public objects */
                              or do.obj# in
                              ( select obj#  /* directly granted privileges */
                                from sys.objauth$
                                where grantee# in ( select kzsrorol from x$kzsro )
                              )
                              or  /* user has system privileges */
                              ora_check_sys_privilege ( do.owner#, do.type#) = 1
                            )
                          THEN 1
                          ELSE 0
                          END ) have_dim_access
                      FROM
                        olap_cubes$ c,
                        dependency$ d,
                        obj$ do
                      WHERE
                        do.obj# = d.p_obj#
                        AND do.type# = 92 /* CUBE DIMENSION */
                        AND c.obj# = d.d_obj#
                    )
                  GROUP BY obj# ) da
              WHERE
                o.obj#=da.obj#(+)
            )
      )
    )
    or
    (
       o.type# = 114 /* sql translation profile */
       and
       (
         exists (select null from sys.objauth$ oa
                  where oa.obj# = o.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# in (0 /* ALTER */, 29 /* USE */))
         or
         /* user has system privileges */
         ora_check_sys_privilege ( o.owner#, o.type#) = 1
       )
    )
    or
    (
       o.type# in (
                   150, /* hierarchy */
                   151, /* attribute dimension */
                   152  /* analytic view */
                  )
       and ora_check_sys_privilege(o.owner#, o.type#) = 1
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."SUBOBJECT_NAME" IS 'Name of the sub-object (for example, partititon)';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."OBJECT_ID" IS 'Object number of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."DATA_OBJECT_ID" IS 'Object number of the segment which contains the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."OBJECT_TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."CREATED" IS 'Timestamp for the creation of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."LAST_DDL_TIME" IS 'Timestamp for the last DDL change (including GRANT and REVOKE) to the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."TIMESTAMP" IS 'Timestamp for the specification of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."STATUS" IS 'Status of the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."TEMPORARY" IS 'Can the current session only see data that it placed in this object itself?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."GENERATED" IS 'Was the name of this object system generated?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."SECONDARY" IS 'Is this a secondary object created as part of icreate for domain indexes?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."NAMESPACE" IS 'Namespace for the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."EDITION_NAME" IS 'Name of the edition in which the object is actual';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."SHARING" IS 'Is this a Metadata Link, an Object Link or neither?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."EDITIONABLE" IS 'Object is considered editionable';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."ORACLE_MAINTAINED" IS 'Denotes whether the object was created, and is maintained, by Oracle-supplied scripts. An object for which this has the value Y must not be changed in any way except by running an Oracle-supplied script.';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."APPLICATION" IS 'Denotes whether the object is part of an Application Container.';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."DEFAULT_COLLATION" IS 'Default collation for the object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."CREATED_APPID" IS 'ID of Application that created object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."CREATED_VSNID" IS 'ID of Application Version that created object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."MODIFIED_APPID" IS 'ID of Application that last modified object';
   COMMENT ON COLUMN "SYS"."ALL_OBJECTS_AE"."MODIFIED_VSNID" IS 'ID of Application Version that last modified object';
   COMMENT ON TABLE "SYS"."ALL_OBJECTS_AE"  IS 'Objects accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_OBJECT_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OBJECT_TABLES" ("OWNER", "TABLE_NAME", "TABLESPACE_NAME", "CLUSTER_NAME", "IOT_NAME", "STATUS", "PCT_FREE", "PCT_USED", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENTS", "MAX_EXTENTS", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "BACKED_UP", "NUM_ROWS", "BLOCKS", "EMPTY_BLOCKS", "AVG_SPACE", "CHAIN_CNT", "AVG_ROW_LEN", "AVG_SPACE_FREELIST_BLOCKS", "NUM_FREELIST_BLOCKS", "DEGREE", "INSTANCES", "CACHE", "TABLE_LOCK", "SAMPLE_SIZE", "LAST_ANALYZED", "PARTITIONED", "IOT_TYPE", "OBJECT_ID_TYPE", "TABLE_TYPE_OWNER", "TABLE_TYPE", "TEMPORARY", "SECONDARY", "NESTED", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "ROW_MOVEMENT", "GLOBAL_STATS", "USER_STATS", "DURATION", "SKIP_CORRUPT", "MONITORING", "CLUSTER_OWNER", "DEPENDENCIES", "COMPRESSION", "COMPRESS_FOR", "DROPPED", "SEGMENT_CREATED", "INMEMORY", "INMEMORY_PRIORITY", "INMEMORY_DISTRIBUTE", "INMEMORY_COMPRESSION", "INMEMORY_DUPLICATE", "EXTERNAL", "CELLMEMORY", "INMEMORY_SERVICE", "INMEMORY_SERVICE_NAME", "MEMOPTIMIZE_READ", "MEMOPTIMIZE_WRITE", "HAS_SENSITIVE_COLUMN") AS 
  select u.name, o.name,
       decode(bitand(t.property,2151678048), 0, ts.name,
              decode(t.ts#, 0, null, ts.name)),
       decode(bitand(t.property, 1024), 0, null, co.name),
       decode((bitand(t.property, 512)+bitand(t.flags, 536870912)),
              0, null, co.name),
       decode(bitand(t.trigflag, 1073741824), 1073741824, 'UNUSABLE', 'VALID'),
       decode(bitand(t.property, 32+64), 0, mod(t.pctfree$, 100), 64, 0, null),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
          decode(bitand(t.property, 32+64), 0, t.pctused$, 64, 0, null)),
       decode(bitand(t.property, 32), 0, t.initrans, null),
       decode(bitand(t.property, 32), 0, t.maxtrans, null),
       s.iniexts * ts.blocksize, s.extsize * ts.blocksize,
       s.minexts, s.maxexts,
       decode(bitand(ts.flags, 3), 1, to_number(NULL),
                                      s.extpct),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
         decode(bitand(o.flags, 2), 2, 1, decode(s.lists, 0, 1, s.lists))),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
         decode(bitand(o.flags, 2), 2, 1, decode(s.groups, 0, 1, s.groups))),
       decode(bitand(t.property, 32), 32, null,
                decode(bitand(t.flags, 32), 0, 'YES', 'NO')),
       decode(bitand(t.flags,1), 0, 'Y', 1, 'N', '?'),
       t.rowcnt,
       decode(bitand(t.property, 64), 0, t.blkcnt, null),
       decode(bitand(t.property, 64), 0, t.empcnt, null),
       t.avgspc, t.chncnt, t.avgrln, t.avgspc_flb,
       decode(bitand(t.property, 64), 0, t.flbcnt, null),
       lpad(decode(t.degree, 32767, 'DEFAULT', nvl(t.degree,1)),10),
       lpad(decode(t.instances, 32767, 'DEFAULT', nvl(t.instances,1)),10),
       lpad(decode(bitand(t.flags, 8), 8, 'Y', 'N'),5),
       decode(bitand(t.flags, 6), 0, 'ENABLED', 'DISABLED'),
       t.samplesize, t.analyzetime,
       decode(bitand(t.property, 32), 32, 'YES', 'NO'),
       decode(bitand(t.property, 64), 64, 'IOT',
               decode(bitand(t.property, 512), 512, 'IOT_OVERFLOW',
               decode(bitand(t.flags, 536870912), 536870912, 'IOT_MAPPING', null))),
       decode(bitand(t.property, 4096), 4096, 'USER-DEFINED',
                                              'SYSTEM GENERATED'),
       nvl2(ac.synobj#, su.name, tu.name),
       nvl2(ac.synobj#, so.name, ty.name),
       decode(bitand(o.flags, 2), 0, 'N', 2, 'Y', 'N'),
       decode(bitand(o.flags, 16), 0, 'N', 16, 'Y', 'N'),
       decode(bitand(t.property, 8192), 8192, 'YES', 'NO'),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
             decode(bitand(s.cachehint, 3), 1, 'KEEP', 2, 'RECYCLE',
             'DEFAULT')),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
             decode(bitand(s.cachehint, 12)/4, 1, 'KEEP', 2, 'NONE',
             'DEFAULT')),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
             decode(bitand(s.cachehint, 48)/16, 1, 'KEEP', 2, 'NONE',
             'DEFAULT')),
       decode(bitand(t.flags, 131072), 131072, 'ENABLED', 'DISABLED'),
       decode(bitand(t.flags, 512), 0, 'NO', 'YES'),
       decode(bitand(t.flags, 256), 0, 'NO', 'YES'),
       decode(bitand(o.flags, 2), 0, NULL,
          decode(bitand(t.property, 8388608), 8388608,
                 'SYS$SESSION', 'SYS$TRANSACTION')),
       decode(bitand(t.flags, 1024), 1024, 'ENABLED', 'DISABLED'),
       decode(bitand(o.flags, 2), 2, 'NO',
           decode(bitand(t.property, 2147483648), 2147483648, 'NO',
              decode(ksppcv.ksppstvl, 'TRUE', 'YES', 'NO'))),
       decode(bitand(t.property, 1024), 0, null, cu.name),
       decode(bitand(t.flags, 8388608), 8388608, 'ENABLED', 'DISABLED'),
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 4), 4, 'ENABLED', 'DISABLED')
       else
         decode(bitand(s.spare1, 2048), 2048, 'ENABLED', 'DISABLED')
       end,
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
          decode(bitand(ds.flags_stg, 4), 4,
          case when bitand(ds.cmpflag_stg, 3) = 1 then 'BASIC'
               when bitand(ds.cmpflag_stg, 3) = 2 then 'ADVANCED'
               else concat(decode(ds.cmplvl_stg, 1, 'QUERY LOW',
                                                 2, 'QUERY HIGH',
                                                 3, 'ARCHIVE LOW',
                                                    'ARCHIVE HIGH'),
                           decode(bitand(ds.flags_stg, 524288), 524288,
                                  ' ROW LEVEL LOCKING', '')) end,
               null)
       else
         decode(bitand(s.spare1, 2048), 0, null,
         case when bitand(s.spare1, 16777216) = 16777216
                   then 'ADVANCED'
              when bitand(s.spare1, 100663296) = 33554432  -- 0x2000000
                   then concat('QUERY LOW',
                               decode(bitand(s.spare1, 2147483648),
                                      2147483648, ' ROW LEVEL LOCKING', ''))
              when bitand(s.spare1, 100663296) = 67108864  -- 0x4000000
                   then concat('QUERY HIGH',
                               decode(bitand(s.spare1, 2147483648),
                                      2147483648, ' ROW LEVEL LOCKING', ''))
              when bitand(s.spare1, 100663296) = 100663296 -- 0x2000000+0x4000000
                   then concat('ARCHIVE LOW',
                               decode(bitand(s.spare1, 2147483648),
                                      2147483648, ' ROW LEVEL LOCKING', ''))
              when bitand(s.spare1, 134217728) = 134217728 -- 0x8000000
                   then concat('ARCHIVE HIGH',
                               decode(bitand(s.spare1, 2147483648),
                                      2147483648, ' ROW LEVEL LOCKING', ''))
              else 'BASIC' end)
       end,
       decode(bitand(o.flags, 128), 128, 'YES', 'NO'),
       decode(bitand(t.property, 17179869184), 17179869184, 'NO',
              decode(bitand(t.property, 32), 32, 'N/A', 'YES')),
       -- INMEMORY
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 2147483648 ) = 2147483648) then
         decode(bitand(xt.property,16), 16, 'ENABLED', 'DISABLED')
       when (bitand(t.property, 17179869184) = 17179869184) then
         -- flags/imcflag_stg (stgdef.h)
         decode(bitand(ds.flags_stg, 6291456),
             2097152, 'ENABLED',
             4194304, 'DISABLED', 'DISABLED')
       else
         -- ktsscflg (ktscts.h)
         decode(bitand(s.spare1, 70373039144960),
             4294967296,     'ENABLED',
             70368744177664, 'DISABLED', 'DISABLED')
       end,
       -- INMEMORY_PRIORITY
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 4), 4,
                decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 7936),
                256, 'NONE',
                512, 'LOW',
                1024, 'MEDIUM',
                2048, 'HIGH',
                4096, 'CRITICAL', 'UNKNOWN'), null),
                'NONE'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 34359738368), 34359738368,
                decode(bitand(s.spare1, 61572651155456),
                8796093022208, 'LOW',
                17592186044416, 'MEDIUM',
                35184372088832, 'HIGH',
                52776558133248, 'CRITICAL', 'NONE'),
                'NONE'),
                null)
       end,
       -- INMEMORY_DISTRIBUTE
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 1), 1,
                       decode(bitand(ds.imcflag_stg, (16+32)),
                              16,  'BY ROWID RANGE',
                              32,  'BY PARTITION',
                              48,  'BY SUBPARTITION',
                               0,  'AUTO'),
                  null), null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 8589934592), 8589934592,
                        decode(bitand(s.spare1, 206158430208),
                        68719476736,   'BY ROWID RANGE',
                        137438953472,  'BY PARTITION',
                        206158430208,  'BY SUBPARTITION',
                        0,             'AUTO'),
                        'UNKNOWN'),
                  null)
       end,
       -- INMEMORY_COMPRESSION
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 2147483648 ) = 2147483648) then
             decode(bitand(xt.property, (16+32+64+128)),
                         (16+32), 'NO MEMCOMPRESS',
                         (16+64), 'FOR DML',
                      (16+32+64), 'FOR QUERY LOW',
                        (16+128), 'FOR QUERY HIGH',
                     (16+128+32), 'FOR CAPACITY LOW',
                     (16+128+64), 'FOR CAPACITY HIGH', NULL)
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, (2+8+64+128)),
                              2,   'NO MEMCOMPRESS',
                              8,  'FOR DML',
                              10,  'FOR QUERY LOW',
                              64, 'FOR QUERY HIGH',
                              66, 'FOR CAPACITY LOW',
                              72, 'FOR CAPACITY HIGH', 'UNKNOWN'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 841813590016),
                              17179869184,  'NO MEMCOMPRESS',
                              274877906944, 'FOR DML',
                              292057776128, 'FOR QUERY LOW',
                              549755813888, 'FOR QUERY HIGH',
                              566935683072, 'FOR CAPACITY LOW',
                              824633720832, 'FOR CAPACITY HIGH', 'UNKNOWN'),
                 null)
       end,
       -- INMEMORY_DUPLICATE
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
        decode(bitand(ds.flags_stg, 2097152), 2097152,
               decode(bitand(ds.imcflag_stg, (8192+16384)),
                              8192,   'NO DUPLICATE',
                              16384,  'DUPLICATE',
                              24576,  'DUPLICATE ALL',
                              'UNKNOWN'),
                null)
       else
          decode(bitand(s.spare1, 4294967296), 4294967296,
                   decode(bitand(s.spare1, 6597069766656),
                           2199023255552, 'NO DUPLICATE',
                           4398046511104, 'DUPLICATE',
                           6597069766656, 'DUPLICATE ALL', 'UNKNOWN'),
                 null)
       end,
       decode(bitand(t.property, 2147483648), 2147483648, 'YES', 'NO'),
       -- CELLMEMORY
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         -- deferred segment: stgccflags (stgdef.h)
         decode(ccflag_stg,
             8194, 'NO MEMCOMPRESS',
             8196, 'MEMCOMPRESS FOR QUERY',
             8200, 'MEMCOMPRESS FOR CAPACITY',
             16384, 'DISABLED', null)
       else
         -- created segment: ktsscflg (ktscts.h)
         decode(bitand(s.spare1, 4362862139015168),
              281474976710656, 'DISABLED',
              703687441776640, 'NO MEMCOMPRESS',
             1266637395197952, 'MEMCOMPRESS FOR QUERY',
             2392537302040576, 'MEMCOMPRESS FOR CAPACITY', null)
       end,
       -- INMEMORY_SERVICE
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 32768), 32768,
                       decode(bitand(svc.svcflags, 7),
                              0, null,
                              1, 'DEFAULT',
                              2, 'NONE',
                              3, 'ALL',
                              4, 'USER_DEFINED', 'UNKNOWN'), 'DEFAULT'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 9007199254740992), 9007199254740992,
                       decode(bitand(svc.svcflags, 7),
                              0, null,
                              1, 'DEFAULT',
                              2, 'NONE',
                              3, 'ALL',
                              4, 'USER_DEFINED', 'UNKNOWN'), 'DEFAULT'),
                 null)
       end,
       -- INMEMORY_SERVICE_NAME
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 32768), 32768,
                       svc.svcname, null),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 9007199254740992), 9007199254740992,
                       svc.svcname, null),
                null)
       end,
       -- MEMOPTIMIZE_READ
       case when bitand(t.property, 32) = 32
              then 'N/A'
       else
          decode(bitand(t.property, power(2,91)), power(2,91),
                        'ENABLED', 'DISABLED')
       end,
       -- MEMOPTIMIZE_WRITE
       case when bitand(t.property, 32) = 32
              then 'N/A'
       else
          decode(bitand(t.property, power(2,92)), power(2,92),
                        'ENABLED', 'DISABLED')
       end,
        -- HAS_SENSITIVE_COLUMN
       decode(bitand(t.property, power(2,89)), power(2,89), 'YES', 'NO')
from sys.user$ u, sys.ts$ ts, sys.seg$ s, sys.obj$ co, sys.tab$ t, sys.obj$ o,
     sys.external_tab$ xt, sys.coltype$ ac, sys.obj$ ty, sys."_BASE_USER" tu,
     sys.col$ tc, sys.obj$ cx, sys.user$ cu, sys.obj$ so, sys."_BASE_USER" su,
     x$ksppcv ksppcv, x$ksppi ksppi, sys.deferred_stg$ ds, sys.imsvc$ svc
where o.owner# = u.user#
  and o.obj# = t.obj#
  and t.obj# = xt.obj# (+)
  and bitand(t.property, 1) = 1
  and bitand(o.flags, 128) = 0
  and t.obj# = tc.obj#
  and tc.name = 'SYS_NC_ROWINFO$'
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = ty.oid$
  and ty.type# <> 10
  and ty.owner# = tu.user#
  and t.bobj# = co.obj# (+)
  and t.obj# = ds.obj# (+)
  and t.ts# = ts.ts#
  and t.file# = s.file# (+)
  and t.block# = s.block# (+)
  and t.ts# = s.ts# (+)
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
       ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
  and t.dataobj# = cx.obj# (+)
  and cx.owner# = cu.user# (+)
  and ac.synobj# = so.obj# (+)
  and so.owner# = su.user# (+)
  and ksppi.indx = ksppcv.indx
  and ksppi.ksppinm = '_dml_monitoring_enabled'
  and t.obj# = svc.obj# (+)
  and svc.subpart#(+) is null;

   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."TABLESPACE_NAME" IS 'Name of the tablespace containing the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."CLUSTER_NAME" IS 'Name of the cluster, if any, to which the table belongs';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."IOT_NAME" IS 'Name of the index-only table, if any, to which the overflow or mapping table entry belongs';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."STATUS" IS 'Status of the table will be UNUSABLE if a previous DROP TABLE operation failed,
VALID otherwise';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."PCT_FREE" IS 'Minimum percentage of free space in a block';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."PCT_USED" IS 'Minimum percentage of used space in a block';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INI_TRANS" IS 'Initial number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."MAX_TRANS" IS 'Maximum number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INITIAL_EXTENT" IS 'Size of the initial extent in bytes';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."NEXT_EXTENT" IS 'Size of secondary extents in bytes';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."MIN_EXTENTS" IS 'Minimum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."MAX_EXTENTS" IS 'Maximum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."PCT_INCREASE" IS 'Percentage increase in extent size';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."FREELISTS" IS 'Number of process freelists allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."FREELIST_GROUPS" IS 'Number of freelist groups allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."LOGGING" IS 'Logging attribute';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."BACKED_UP" IS 'Has table been backed up since last modification?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."NUM_ROWS" IS 'The number of rows in the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."BLOCKS" IS 'The number of used blocks in the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."EMPTY_BLOCKS" IS 'The number of empty (never used) blocks in the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."AVG_SPACE" IS 'The average available free space in the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."CHAIN_CNT" IS 'The number of chained rows in the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."AVG_ROW_LEN" IS 'The average row length, including row overhead';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."AVG_SPACE_FREELIST_BLOCKS" IS 'The average freespace of all blocks on a freelist';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."NUM_FREELIST_BLOCKS" IS 'The number of blocks on the freelist';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."DEGREE" IS 'The number of threads per instance for scanning the table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INSTANCES" IS 'The number of instances across which the table is to be scanned';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."CACHE" IS 'Whether the table is to be cached in the buffer cache';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."TABLE_LOCK" IS 'Whether table locking is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."SAMPLE_SIZE" IS 'The sample size used in analyzing this table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."LAST_ANALYZED" IS 'The date of the most recent time this table was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."PARTITIONED" IS 'Is this table partitioned? YES or NO';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."IOT_TYPE" IS 'If index-only table, then IOT_TYPE is IOT or IOT_OVERFLOW or IOT_MAPPING else NULL';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."OBJECT_ID_TYPE" IS 'If user-defined OID, then USER-DEFINED, else if system generated OID, then SYSTEM GENERATED';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."TABLE_TYPE_OWNER" IS 'Owner of the type of the table if the table is an object table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."TABLE_TYPE" IS 'Type of the table if the table is an object table';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."TEMPORARY" IS 'Can the current session only see data that it place in this object itself?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."SECONDARY" IS 'Is this table object created as part of icreate for domain indexes?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."NESTED" IS 'Is the table a nested table?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."BUFFER_POOL" IS 'The default buffer pool to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."FLASH_CACHE" IS 'The default flash cache hint to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."CELL_FLASH_CACHE" IS 'The default cell flash cache hint to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."ROW_MOVEMENT" IS 'Whether partitioned row movement is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."DURATION" IS 'If temporary table, then duration is sys$session or sys$transaction else NULL';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."SKIP_CORRUPT" IS 'Whether skip corrupt blocks is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."MONITORING" IS 'Should we keep track of the amount of modification?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."CLUSTER_OWNER" IS 'Owner of the cluster, if any, to which the table belongs';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."DEPENDENCIES" IS 'Should we keep track of row level dependencies?';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."COMPRESSION" IS 'Whether table compression is enabled or not';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."COMPRESS_FOR" IS 'Compress what kind of operations';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."DROPPED" IS 'Whether table is dropped and is in Recycle Bin';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."SEGMENT_CREATED" IS 'Whether the table segment is created or not';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INMEMORY" IS 'Whether in-memory is enabled or not';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INMEMORY_PRIORITY" IS 'User defined priority in which in-memory column store object is loaded';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INMEMORY_DISTRIBUTE" IS 'How the in-memory columnar store object is distributed';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INMEMORY_COMPRESSION" IS 'Compression level for the in-memory column store option';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INMEMORY_DUPLICATE" IS 'How the in-memory column store object is duplicated';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."EXTERNAL" IS 'Whether the table is an  external table or not';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."CELLMEMORY" IS 'Cell columnar cache';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INMEMORY_SERVICE" IS 'How the in-memory columnar store object is distributed for service';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."INMEMORY_SERVICE_NAME" IS 'Service on which the in-memory columnar store object is distributed';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."MEMOPTIMIZE_READ" IS 'Whether the table is enabled for Fast Key Based Access';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."MEMOPTIMIZE_WRITE" IS 'Whether the table is enabled for Fast Data Ingestion';
   COMMENT ON COLUMN "SYS"."ALL_OBJECT_TABLES"."HAS_SENSITIVE_COLUMN" IS 'Whether the table has one or more sensitive columns';
   COMMENT ON TABLE "SYS"."ALL_OBJECT_TABLES"  IS 'Description of all object tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL$OLAP2_AWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL$OLAP2_AWS" ("OWNER", "AW", "AW_NUMBER", "AW_VERSION", "SF_VERSION") AS 
  select aws11g.owner, aws11g.aw_name, aws11g.aw_number, aws11g.aw_version, '11.1' sf_version
  from all_aws aws11g,
            (select /*+ ordered */ a.awseq#, r.rid, p.rowid, p.propname
              from sys.aw$ a, sys.aw_prop$ p, sys.obj$ o, dba_users u,
                   (select max(rowid) keep (dense_rank last order by gen#) rid
                    from sys.aw_prop$ group by awseq#, oid, propname) r
              where a.owner# = u.user_id
                and o.owner# = a.owner#
                and o.name = 'AW$' || a.awname and o.type# = 2
                and a.awseq# = p.awseq#
                and p.objname = '___AW_VERSION'
                and p.propname  = 'AW$VERSION11.1'
                and p.rowid = r.rid
                and p.propval is not null) props11g
 where props11g.awseq# = aws11g.aw_number
union all
  select max(aws.owner) owner, max(aws.aw_name) aw, props1.awseq#,
         max(aws.aw_version) aw_version,
               (case when count(props1.awseq#) = 2 then '10.2'
                     when count(props1.awseq#) = 1 then '10.1.0.3'
                     else null end) sf_version
         from all_aws aws,
              (select /*+ ordered */ a.awseq#, r.rid, p.rowid, p.propname
               from sys.aw$ a, sys.aw_prop$ p, sys.obj$ o, dba_users u,
                    (select max(rowid) keep (dense_rank last order by gen#) rid
                     from sys.aw_prop$ group by awseq#, oid, propname) r
               where a.owner# = u.user_id
                 and o.owner# = a.owner#
                 and o.name = 'AW$' || a.awname and o.type# = 2
                 and a.awseq# = p.awseq#
                 and p.propname in ('AW$VERSION10.2', 'AW$VERSION10.1.0.3')
                 and p.objname = '___XML_USER_AW_VERSION'
                 and p.rowid = r.rid
                 and p.propval is not null) props1
  where props1.awseq# = aws.aw_number
        and (props1.awseq# not in
              (select /*+ ordered */ a.awseq#
               from sys.aw$ a, sys.aw_prop$ p, sys.obj$ o, dba_users u,
                    (select max(rowid) keep (dense_rank last order by gen#) rid
                     from sys.aw_prop$ group by awseq#, oid, propname) r
               where a.owner# = u.user_id
                 and o.owner# = a.owner#
                 and o.name = 'AW$' || a.awname and o.type# = 2
                 and a.awseq# = p.awseq#
                 and p.propname = 'AW$VERSION11.1'
                 and p.objname = '___AW_VERSION'
                 and p.rowid = r.rid
                 and p.propval is not null))
  group by awseq#
;
--------------------------------------------------------
--  DDL for View ALL_OPANCILLARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OPANCILLARY" ("OWNER", "OPERATOR_NAME", "BINDING#", "PRIMOP_OWNER", "PRIMOP_NAME", "PRIMOP_BIND#") AS 
  select distinct u.name, o.name, a.bind#, u1.name, o1.name, a1.primbind#
from   sys.user$ u, sys.obj$ o, sys.opancillary$ a, sys.user$ u1, sys.obj$ o1,
       sys.opancillary$ a1
where  a.obj#=o.obj# and o.owner#=u.user#   AND
       a1.primop#=o1.obj# and o1.owner#=u1.user# and a.obj#=a1.obj#
  and ( o.owner# = userenv ('SCHEMAID')
    or
    o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_OPANCILLARY"."OWNER" IS 'Owner of ancillary operator';
   COMMENT ON COLUMN "SYS"."ALL_OPANCILLARY"."OPERATOR_NAME" IS 'Name of ancillary operator';
   COMMENT ON COLUMN "SYS"."ALL_OPANCILLARY"."BINDING#" IS 'Binding number of ancillary operator';
   COMMENT ON COLUMN "SYS"."ALL_OPANCILLARY"."PRIMOP_OWNER" IS 'Owner of primary operator';
   COMMENT ON COLUMN "SYS"."ALL_OPANCILLARY"."PRIMOP_NAME" IS 'Name of primary operator';
   COMMENT ON COLUMN "SYS"."ALL_OPANCILLARY"."PRIMOP_BIND#" IS 'Binding number of primary operator';
   COMMENT ON TABLE "SYS"."ALL_OPANCILLARY"  IS 'All ancillary operators available to the user'
;
--------------------------------------------------------
--  DDL for View ALL_OPARGUMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OPARGUMENTS" ("OWNER", "OPERATOR_NAME", "BINDING#", "POSITION", "ARGUMENT_TYPE") AS 
  select  c.name, b.name, a.bind#, a.position, a.type
  from  sys.oparg$ a, sys.obj$ b, sys.user$ c
  where a.obj# = b.obj# and b.owner# = c.user#
  and  (b.owner# = userenv ('SCHEMAID')
        or
        b.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
           or
              ora_check_sys_privilege (b.owner#, b.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_OPARGUMENTS"."OWNER" IS 'Owner of the operator';
   COMMENT ON COLUMN "SYS"."ALL_OPARGUMENTS"."OPERATOR_NAME" IS 'Name of the operator';
   COMMENT ON COLUMN "SYS"."ALL_OPARGUMENTS"."BINDING#" IS 'Binding# of the operator';
   COMMENT ON COLUMN "SYS"."ALL_OPARGUMENTS"."POSITION" IS 'Position of the operator argument';
   COMMENT ON COLUMN "SYS"."ALL_OPARGUMENTS"."ARGUMENT_TYPE" IS 'Datatype of the operator argument';
   COMMENT ON TABLE "SYS"."ALL_OPARGUMENTS"  IS 'All arguments of the operators available to the user'
;
--------------------------------------------------------
--  DDL for View ALL_OPBINDINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OPBINDINGS" ("OWNER", "OPERATOR_NAME", "BINDING#", "FUNCTION_NAME", "RETURN_SCHEMA", "RETURN_TYPE", "IMPLEMENTATION_TYPE_SCHEMA", "IMPLEMENTATION_TYPE", "PROPERTY") AS 
  select   c.name, b.name, a.bind#, a.functionname, a.returnschema,
         a.returntype, a.impschema, a.imptype,
        decode(bitand(a.property,31), 1, 'WITH INDEX CONTEXT',
               3 , 'COMPUTE ANCILLARY DATA', 4 , 'ANCILLARY TO' ,
               16 , 'WITH COLUMN CONTEXT' ,
               17,  'WITH INDEX, COLUMN CONTEXT',
               19, 'COMPUTE ANCILLARY DATA, WITH COLUMN CONTEXT')
   from  sys.opbinding$ a, sys.obj$ b, sys.user$ c where
  a.obj# = b.obj# and b.owner# = c.user#
  and ( b.owner# = userenv ('SCHEMAID')
    or
    b.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
          ora_check_sys_privilege (b.owner#, b.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."OWNER" IS 'Owner of the operator';
   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."OPERATOR_NAME" IS 'Name of the operator';
   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."BINDING#" IS 'Binding# of the operator';
   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."FUNCTION_NAME" IS 'Name of the binding function or method as specified by the user';
   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."RETURN_SCHEMA" IS 'Name of the schema of the return type - not null only for ADTs';
   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."RETURN_TYPE" IS 'Name of the return type';
   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."IMPLEMENTATION_TYPE_SCHEMA" IS 'Schema of the implementation type of the indextype ';
   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."IMPLEMENTATION_TYPE" IS 'Implementation type of the indextype';
   COMMENT ON COLUMN "SYS"."ALL_OPBINDINGS"."PROPERTY" IS 'Property of the operator binding';
   COMMENT ON TABLE "SYS"."ALL_OPBINDINGS"  IS 'All binding functions for operators available to the user'
;
--------------------------------------------------------
--  DDL for View ALL_OPERATOR_COMMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OPERATOR_COMMENTS" ("OWNER", "OPERATOR_NAME", "COMMENTS") AS 
  select u.name, o.name, c.comment$
from   sys.obj$ o, sys.operator$ op, sys.com$ c, sys.user$ u
where  o.obj# = op.obj# and c.obj# = op.obj# and u.user# = o.owner#
       and
       ( o.owner# = userenv('SCHEMAID')
         or
         o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
         or
            ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_OPERATOR_COMMENTS"."OWNER" IS 'Owner of the user-defined operator';
   COMMENT ON COLUMN "SYS"."ALL_OPERATOR_COMMENTS"."OPERATOR_NAME" IS 'Name of the user-defined operator';
   COMMENT ON COLUMN "SYS"."ALL_OPERATOR_COMMENTS"."COMMENTS" IS 'Comment for the user-defined operator';
   COMMENT ON TABLE "SYS"."ALL_OPERATOR_COMMENTS"  IS 'Comments for user-defined operators'
;
--------------------------------------------------------
--  DDL for View ALL_OPERATORS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_OPERATORS" ("OWNER", "OPERATOR_NAME", "NUMBER_OF_BINDS") AS 
  select c.name, b.name, a.numbind from
  sys.operator$ a, sys.obj$ b, sys.user$ c where
  a.obj# = b.obj# and b.owner# = c.user# and
  ( b.owner# = userenv ('SCHEMAID')
    or
    b.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
          ora_check_sys_privilege (b.owner#, b.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_OPERATORS"."OWNER" IS 'Owner of the operator';
   COMMENT ON COLUMN "SYS"."ALL_OPERATORS"."OPERATOR_NAME" IS 'Name of the operator';
   COMMENT ON COLUMN "SYS"."ALL_OPERATORS"."NUMBER_OF_BINDS" IS 'Number of bindings associated with the operator';
   COMMENT ON TABLE "SYS"."ALL_OPERATORS"  IS 'All operators available to the user'
;
--------------------------------------------------------
--  DDL for View ALL_PART_COL_STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PART_COL_STATISTICS" ("OWNER", "TABLE_NAME", "PARTITION_NAME", "COLUMN_NAME", "NUM_DISTINCT", "LOW_VALUE", "HIGH_VALUE", "DENSITY", "NUM_NULLS", "NUM_BUCKETS", "SAMPLE_SIZE", "LAST_ANALYZED", "GLOBAL_STATS", "USER_STATS", "NOTES", "AVG_COL_LEN", "HISTOGRAM") AS 
  select u.name, o.name, o.subname, tp.cname, h.distcnt,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.lowval
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.hival
            else null
       end,
       h.density, h.null_cnt,
       case when nvl(h.distcnt,0) = 0 then h.distcnt
            when h.row_cnt = 0 then 1
	    when exists(select 1 from sys."_HISTGRM_DEC" hg
                        where tp.obj# = hg.obj# and tp.intcol# = hg.intcol#
                          and hg.ep_repeat_count > 0 and rownum < 2) then h.row_cnt
            when bitand(h.spare2, 64) > 0
              then h.row_cnt
            when (bitand(h.spare2, 32) > 0 or h.bucket_cnt > 2049 or
                  (h.bucket_cnt >= h.distcnt and h.density*h.bucket_cnt < 1))
                then h.row_cnt
            else h.bucket_cnt
       end,
       h.sample_size, h.timestamp#,
       decode(bitand(h.spare2, 2), 2, 'YES', 'NO'),
       decode(bitand(h.spare2, 1), 1, 'YES', 'NO'),
       decode(bitand(h.spare2, 8), 8, 'INCREMENTAL ', '') ||
         decode(bitand(h.spare2, 128), 128, 'HIST_FOR_INCREM_STATS ', '') ||
         decode(bitand(h.spare2, 256), 256, 'HISTOGRAM_ONLY ', '') ||
         decode(bitand(h.spare2, 512), 512, 'STATS_ON_LOAD ', '') ||
         case when (hh.analyzetime is not null) then
                decode(hh.spare1, null, 'ADAPTIVE_SAMPLING ',
                       'HYPERLOGLOG ')
              else
                null
         end notes,
       h.avgcln,
       case when nvl(h.row_cnt,0) = 0 then 'NONE'
            when exists(select 1 from sys."_HISTGRM_DEC" hg
                        where tp.obj# = hg.obj# and tp.intcol# = hg.intcol#
                          and hg.ep_repeat_count > 0 and rownum < 2) then 'HYBRID'
            when bitand(h.spare2, 64) > 0
              then 'TOP-FREQUENCY'
            when (bitand(h.spare2, 32) > 0 or h.bucket_cnt > 2049 or
                  (h.bucket_cnt >= h.distcnt and h.density*h.bucket_cnt < 1))
                then 'FREQUENCY'
            else 'HEIGHT BALANCED'
       end
from sys.obj$ o, sys."_HIST_HEAD_DEC" h, tp$ tp, user$ u,
     sys.wri$_optstat_synopsis_head$  hh
where o.obj# = tp.obj# and o.owner# = u.user#
  and tp.obj# = h.obj#(+) and tp.intcol# = h.intcol#(+)
  and o.type# = 19 /* TABLE PARTITION */
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and tp.bo# = hh.bo#(+) and tp.intcol# = hh.intcol#(+)
  and hh.group#(+) = tp.obj# * 2
  and (o.owner# = userenv('SCHEMAID')
        or tp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
;
--------------------------------------------------------
--  DDL for View ALL_PART_HISTOGRAMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PART_HISTOGRAMS" ("OWNER", "TABLE_NAME", "PARTITION_NAME", "COLUMN_NAME", "BUCKET_NUMBER", "ENDPOINT_VALUE", "ENDPOINT_ACTUAL_VALUE", "ENDPOINT_ACTUAL_VALUE_RAW", "ENDPOINT_REPEAT_COUNT") AS 
  select u.name,
       o.name, o.subname,
       tp.cname,
       h.bucket,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.endpoint
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then case when h.epvalue is not null then epvalue
                 else dbms_stats.conv_raw(h.epvalue_raw, tp.type#) end
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.epvalue_raw
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.ep_repeat_count
            else null
       end
from sys.obj$ o, sys."_HISTGRM_DEC" h, sys.user$ u, tp$ tp
where o.obj# = tp.obj# and tp.obj# = h.obj#
      and tp.intcol# = h.intcol#
      and o.type# = 19 /* TABLE PARTITION */
      and o.owner# = u.user# and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID')
        or
        tp.bo# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
union
select u.name,
       o.name, o.subname,
       tp.cname,
       0,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.minimum
            else null
       end,
       null,
       null,
       0
from sys.obj$ o, sys."_HIST_HEAD_DEC" h, sys.user$ u, tp$ tp
where o.obj# = tp.obj# and tp.obj# = h.obj#
      and tp.intcol# = h.intcol#
      and o.type# = 19 /* TABLE PARTITION */
      and h.row_cnt = 0 and h.distcnt > 0
      and o.owner# = u.user# and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID')
        or
        tp.bo# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
union
select u.name,
       o.name, o.subname,
       tp.cname,
       1,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.maximum
            else null
       end,
       null,
       null,
       0
from sys.obj$ o, sys."_HIST_HEAD_DEC" h, sys.user$ u, tp$ tp
where o.obj# = tp.obj# and tp.obj# = h.obj#
      and tp.intcol# = h.intcol#
      and o.type# = 19 /* TABLE PARTITION */
      and h.row_cnt = 0 and h.distcnt > 0
      and o.owner# = u.user# and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID')
        or
        tp.bo# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
;
--------------------------------------------------------
--  DDL for View ALL_PARTIAL_DROP_TABS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PARTIAL_DROP_TABS" ("OWNER", "TABLE_NAME") AS 
  select u.name, o.name
from sys.user$ u, sys.obj$ o, sys.tab$ t
where o.owner# = u.user#
  and o.obj# = t.obj#
  and bitand(t.flags,32768) = 32768
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
       ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
  group by u.name, o.name;

   COMMENT ON COLUMN "SYS"."ALL_PARTIAL_DROP_TABS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_PARTIAL_DROP_TABS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON TABLE "SYS"."ALL_PARTIAL_DROP_TABS"  IS 'All tables with patially dropped columns accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_PART_INDEXES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PART_INDEXES" ("OWNER", "INDEX_NAME", "TABLE_NAME", "PARTITIONING_TYPE", "SUBPARTITIONING_TYPE", "PARTITION_COUNT", "DEF_SUBPARTITION_COUNT", "PARTITIONING_KEY_COUNT", "SUBPARTITIONING_KEY_COUNT", "LOCALITY", "ALIGNMENT", "DEF_TABLESPACE_NAME", "DEF_PCT_FREE", "DEF_INI_TRANS", "DEF_MAX_TRANS", "DEF_INITIAL_EXTENT", "DEF_NEXT_EXTENT", "DEF_MIN_EXTENTS", "DEF_MAX_EXTENTS", "DEF_MAX_SIZE", "DEF_PCT_INCREASE", "DEF_FREELISTS", "DEF_FREELIST_GROUPS", "DEF_LOGGING", "DEF_BUFFER_POOL", "DEF_FLASH_CACHE", "DEF_CELL_FLASH_CACHE", "DEF_PARAMETERS", "INTERVAL", "AUTOLIST", "INTERVAL_SUBPARTITION", "AUTOLIST_SUBPARTITION") AS 
  select u.name, io.name, o.name,
       decode(po.parttype, 1, 'RANGE', 2, 'HASH', 3, 'SYSTEM', 4, 'LIST',
                           5, 'REFERENCE', 'UNKNOWN'),
       decode(mod(po.spare2, 256), 0, 'NONE', 1, 'RANGE', 2, 'HASH',
                                   3, 'SYSTEM', 4, 'LIST', 5, 'REFERENCE',
                                   'UNKNOWN'),
       po.partcnt, mod(trunc(po.spare2/65536), 65536),
       po.partkeycols, mod(trunc(po.spare2/256), 256),
       decode(bitand(po.flags, 1), 1, 'LOCAL',    'GLOBAL'),
       decode(po.partkeycols, 0, 'NONE', decode(bitand(po.flags,2), 2, 'PREFIXED', 'NON_PREFIXED')),
       ts.name, po.defpctfree, po.definitrans,
       po.defmaxtrans,
       decode(po.deftiniexts, NULL, 'DEFAULT', po.deftiniexts),
       decode(po.defextsize, NULL, 'DEFAULT', po.defextsize),
       decode(po.defminexts, NULL, 'DEFAULT', po.defminexts),
       decode(po.defmaxexts, NULL, 'DEFAULT', po.defmaxexts),
       decode(po.defmaxsize, NULL, 'DEFAULT', po.defmaxsize),
       decode(po.defextpct, NULL, 'DEFAULT', po.defextpct),
       po.deflists, po.defgroups,
       decode(po.deflogging, 0, 'NONE', 1, 'YES', 2, 'NO', 'UNKNOWN'),
       decode(bitand(po.spare1, 3), 1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(po.spare1, 12)/4, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(po.spare1, 48)/16, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       po.parameters,
       case when (po.parttype = 5 and bitand(po.flags, 64) = 64) then 'YES'
            else po.interval_str end,
       case when (po.parttype = 4 and bitand(po.flags, 64) = 64)
            then 'YES' else 'NO' end, -- autolist partitioning
       case when (mod(po.spare2, 256) = 1 and bitand(po.flags, 32768) = 32768)
            then po.subptn_interval_str end, -- interval subpartitioning
       case when (mod(po.spare2, 256) = 4 and bitand(po.flags, 32768) = 32768)
            then 'YES' else 'NO' end -- autolist subpartitioning
from   sys.obj$ io, sys.obj$ o, sys.partobj$ po, sys.ts$ ts, sys.ind$ i,
       sys.user$ u
where  io.obj# = po.obj# and po.defts# = ts.ts# (+) and
       i.obj# = io.obj# and o.obj# = i.bo# and u.user# = io.owner# and
       i.type# != 8 and      /* not LOB index */
       io.subname IS NULL and
       io.namespace = 4 and io.remoteowner IS NULL and io.linkname IS NULL and
       (io.owner# = userenv('SCHEMAID')
        or
        i.bo# in ( select obj#
                    from objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
        or
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
       )
;
--------------------------------------------------------
--  DDL for View ALL_PART_KEY_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PART_KEY_COLUMNS" ("OWNER", "NAME", "OBJECT_TYPE", "COLUMN_NAME", "COLUMN_POSITION", "COLLATED_COLUMN_ID") AS 
  select
  OWNER, NAME, OBJECT_TYPE, COLUMN_NAME, COLUMN_POSITION, COLLATED_COLUMN_ID
from all_part_key_columns_v$
;
--------------------------------------------------------
--  DDL for View ALL_PART_KEY_COLUMNS_V$
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PART_KEY_COLUMNS_V$" ("OWNER", "NAME", "OBJECT_TYPE", "COLUMN_NAME", "COLUMN_POSITION", "COLLATED_COLUMN_ID") AS 
  select u.name, o.name, 'TABLE',
  decode(bitand(c.property, 1), 1, a.name, c.name), pc.pos#,
  c.collintcol#
from partcol$ pc, obj$ o, col$ c, user$ u, attrcol$ a
where pc.obj# = o.obj# and pc.obj# = c.obj# and c.intcol# = pc.intcol# and
      c.obj#    = a.obj#(+) and c.intcol# = a.intcol#(+) and
      u.user# = o.owner# and o.subname IS NULL and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID')
       or pc.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
union
select u.name, io.name, 'INDEX',
  decode(bitand(c.property, 1), 1, a.name, c.name), pc.pos#,
  c.collintcol#
from partcol$ pc, obj$ io, col$ c, user$ u, ind$ i, attrcol$ a
where pc.obj# = i.obj# and i.obj# = io.obj# and i.bo# = c.obj# and
     c.intcol# = pc.intcol# and u.user# = io.owner# and
     c.obj# = a.obj#(+) and c.intcol# = a.intcol#(+) and
     io.subname IS NULL and
     io.namespace = 4 and io.remoteowner IS NULL and io.linkname IS NULL and
      (io.owner# = userenv('SCHEMAID')
       or i.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
  
;
--------------------------------------------------------
--  DDL for View ALL_PART_LOBS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PART_LOBS" ("TABLE_OWNER", "TABLE_NAME", "COLUMN_NAME", "LOB_NAME", "LOB_INDEX_NAME", "DEF_CHUNK", "DEF_PCTVERSION", "DEF_CACHE", "DEF_IN_ROW", "DEF_TABLESPACE_NAME", "DEF_INITIAL_EXTENT", "DEF_NEXT_EXTENT", "DEF_MIN_EXTENTS", "DEF_MAX_EXTENTS", "DEF_MAX_SIZE", "DEF_RETENTION", "DEF_MINRET", "DEF_PCT_INCREASE", "DEF_FREELISTS", "DEF_FREELIST_GROUPS", "DEF_LOGGING", "DEF_BUFFER_POOL", "DEF_FLASH_CACHE", "DEF_CELL_FLASH_CACHE", "DEF_ENCRYPT", "DEF_COMPRESS", "DEF_DEDUPLICATE", "DEF_SECUREFILE") AS 
  select u.name,
       o.name,
       decode(bitand(c.property, 1), 1, a.name, c.name),
       lo.name,
       io.name,
       plob.defchunk,
       plob.defpctver$,
       decode(bitand(plob.defflags, 795), 1, 'NO', 2, 'NO', 8, 'CACHEREADS',
                                         16, 'CACHEREADS', 256, 'YES', 512,
                                         'YES', 'YES'),
       decode(plob.defpro, 0, 'NO', 2048, 'NO', 'YES'),
       ts.name,
       decode(plob.definiexts, NULL, 'DEFAULT', plob.definiexts),
       decode(plob.defextsize, NULL, 'DEFAULT', plob.defextsize),
       decode(plob.defminexts, NULL, 'DEFAULT', plob.defminexts),
       decode(plob.defmaxexts, NULL, 'DEFAULT', plob.defmaxexts),
       decode(plob.defmaxsize, NULL, 'DEFAULT', plob.defmaxsize),
       decode(bitand(plob.defpro, 2048), 2048,
               decode(plob.defretention,
                      to_number(NULL), 'DEFAULT',
                      0, 'NONE',
                      1, 'AUTO',
                      2, 'MIN',
                      3, 'MAX',
                      4, 'DEFAULT',
                      'INVALID'),
               decode(bitand(plob.defflags, 32),
                      32, 'YES', 'NO')),
       decode(plob.defmintime,  NULL, 'DEFAULT', plob.defmintime),
       decode(plob.defextpct,  NULL, 'DEFAULT', plob.defextpct),
       decode(plob.deflists,   NULL, 'DEFAULT', plob.deflists),
       decode(plob.defgroups,  NULL, 'DEFAULT', plob.defgroups),
       decode(bitand(plob.defflags, 790), 0,'NONE', 4,'YES', 2,'NO',
                                        16, 'NO', 256, 'NO', 512, 'YES', 'UNKNOWN'),
       decode(bitand(plob.defbufpool, 3), 1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(plob.defbufpool, 12)/4, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(plob.defbufpool, 48)/16, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(plob.defflags,4096), 4096, 'YES',
                     decode(bitand(plob.defpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(plob.defflags,57344), 8192, 'LOW', 16384, 'MEDIUM',
              32768, 'HIGH',
              decode(bitand(plob.defpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(plob.defflags,458752), 65536, 'LOB', 131072, 'OBJECT',
              327680, 'LOB VALIDATE', 393216, 'OBJECT VALIDATE',
              decode(bitand(plob.defpro,2048), 2048, 'NO', 'NONE')),
       decode(bitand(plob.defpro,2048), 2048, 'YES', 'NO')
from   sys.obj$ o, sys.col$ c, sys.lob$ l, sys.partlob$ plob,
       sys.obj$ lo, sys.obj$ io, sys.ts$ ts, sys.user$ u, sys.attrcol$ a
where o.owner# = u.user#
  and o.obj# = c.obj#
  and c.obj# = l.obj#
  and c.intcol# = l.intcol#
  and l.lobj# = lo.obj#
  and l.ind# = io.obj#
  and l.lobj# = plob.lobj#
  and plob.defts# = ts.ts# (+)
  and bitand(c.property,32768) != 32768           /* not unused column */
  and c.obj# = a.obj#(+) and c.intcol# = a.intcol#(+)
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and o.subname IS NULL and lo.subname IS NULL
  and lo.namespace = 8 and lo.remoteowner IS NULL and lo.linkname IS NULL
  and ((o.owner# = userenv('SCHEMAID') and lo.owner# = userenv('SCHEMAID'))
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
      )
;
--------------------------------------------------------
--  DDL for View ALL_PART_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PART_TABLES" ("OWNER", "TABLE_NAME", "PARTITIONING_TYPE", "SUBPARTITIONING_TYPE", "PARTITION_COUNT", "DEF_SUBPARTITION_COUNT", "PARTITIONING_KEY_COUNT", "SUBPARTITIONING_KEY_COUNT", "STATUS", "DEF_TABLESPACE_NAME", "DEF_PCT_FREE", "DEF_PCT_USED", "DEF_INI_TRANS", "DEF_MAX_TRANS", "DEF_INITIAL_EXTENT", "DEF_NEXT_EXTENT", "DEF_MIN_EXTENTS", "DEF_MAX_EXTENTS", "DEF_MAX_SIZE", "DEF_PCT_INCREASE", "DEF_FREELISTS", "DEF_FREELIST_GROUPS", "DEF_LOGGING", "DEF_COMPRESSION", "DEF_COMPRESS_FOR", "DEF_BUFFER_POOL", "DEF_FLASH_CACHE", "DEF_CELL_FLASH_CACHE", "REF_PTN_CONSTRAINT_NAME", "INTERVAL", "AUTOLIST", "INTERVAL_SUBPARTITION", "AUTOLIST_SUBPARTITION", "IS_NESTED", "DEF_SEGMENT_CREATION", "DEF_INDEXING", "DEF_INMEMORY", "DEF_INMEMORY_PRIORITY", "DEF_INMEMORY_DISTRIBUTE", "DEF_INMEMORY_COMPRESSION", "DEF_INMEMORY_DUPLICATE", "DEF_READ_ONLY", "DEF_CELLMEMORY", "DEF_INMEMORY_SERVICE", "DEF_INMEMORY_SERVICE_NAME") AS 
  select u.name, o.name,
       decode(po.parttype, 1, 'RANGE', 2, 'HASH', 3, 'SYSTEM', 4, 'LIST',
                           5, 'REFERENCE', 'UNKNOWN'),
       decode(mod(po.spare2, 256), 0, 'NONE', 1, 'RANGE', 2, 'HASH',
                                   3, 'SYSTEM', 4, 'LIST', 5, 'REFERENCE',
                                   'UNKNOWN'),
       po.partcnt, mod(trunc(po.spare2/65536), 65536), po.partkeycols,
       mod(trunc(po.spare2/256), 256),
       decode(bitand(t.trigflag, 1073741824), 1073741824, 'UNUSABLE', 'VALID'),
       ts.name, po.defpctfree,
       decode(bitand(ts.flags, 32), 32, to_number(NULL), po.defpctused),
       po.definitrans,
       po.defmaxtrans,
       decode(po.deftiniexts, NULL, 'DEFAULT', po.deftiniexts),
       decode(po.defextsize, NULL, 'DEFAULT', po.defextsize),
       decode(po.defminexts, NULL, 'DEFAULT', po.defminexts),
       decode(po.defmaxexts, NULL, 'DEFAULT', po.defmaxexts),
       decode(po.defmaxsize, NULL, 'DEFAULT', po.defmaxsize),
       decode(po.defextpct, NULL, 'DEFAULT', po.defextpct),
       decode(bitand(ts.flags, 32), 32, to_number(NULL), po.deflists),
       decode(bitand(ts.flags, 32), 32,  to_number(NULL),po.defgroups),
       decode(po.deflogging, 0, 'NONE', 1, 'YES', 2, 'NO', 'UNKNOWN'),
       decode(bitand(mod(trunc(po.spare2/4294967296),256), 3),
                       0, 'NONE', 1, 'ENABLED', 2, 'DISABLED', 'UNKNOWN'),
       -- compression info is in byte 4 of spare2
       case bitand(mod(trunc(po.spare2/4294967296),256), 127) -- 6 bits in use
         when 0 then NULL
         when 1 then 'BASIC'                                 -- 00000001
         when 2 then NULL
         when 5 then 'ADVANCED'                              -- 00000101
         when 9 then 'QUERY LOW'                             -- 00001001
         when 17 then 'QUERY HIGH'                           -- 00010001
         when 25 then 'ARCHIVE LOW'                          -- 00011001
         when 33 then 'ARCHIVE HIGH'                         -- 00100001
         when 73 then 'QUERY LOW ROW LEVEL LOCKING'          -- 01001001
         when 81 then 'QUERY HIGH ROW LEVEL LOCKING'         -- 01010001
         when 89 then 'ARCHIVE LOW ROW LEVEL LOCKING'        -- 01011001
         when 97 then 'ARCHIVE HIGH ROW LEVEL LOCKING'       -- 01100001
                 else 'UNKNOWN' end,                         -- internal ilevels
       decode(bitand(po.spare1, 3), 1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(po.spare1, 12)/4, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(po.spare1, 48)/16, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       (select c.name from sys.con$ c, sys.cdef$ cd
          where c.con# = cd.con# and cd.obj# = o.obj#
            and cd.type# = 4 and bitand(cd.defer, 512) != 0),
       case when (po.parttype = 5 and bitand(po.flags, 64) = 64) then 'YES'
            else po.interval_str end,
       case when (po.parttype = 4 and bitand(po.flags, 64) = 64)
            then 'YES' else 'NO' end, -- autolist partitioning
       case when (mod(po.spare2, 256) = 1 and bitand(po.flags, 32768) = 32768)
            then po.subptn_interval_str end, -- interval subpartitioning
       case when (mod(po.spare2, 256) = 4 and bitand(po.flags, 32768) = 32768)
            then 'YES' else 'NO' end, -- autolist subpartitioning
       decode(bitand(t.property,8224), 8224, 'YES', 'NO'),
       decode(bitand(po.flags, 6144), 4096, 'YES', 2048, 'NO', 'NONE'),
       decode(bitand(po.flags, 8192), 8192, 'OFF', 'ON'),
       -- DEF_INMEMORY
       --  defimcflags_kkpacocd (kkpac.h)
       case bitand(mod(trunc(po.spare2/1099511627776),4096), 3) -- bits 0,1
         when 0 then 'NONE'
         when 1 then 'ENABLED'
         when 2 then 'DISABLED'
         else 'UNKNOWN' end,
       -- DEF_INMEMORY_PRIORITY
       case bitand(mod(trunc(po.spare2/1099511627776),4096), 17) -- bits 0,4
         when 0 then NULL
         when 1 then
           case bitand(mod(trunc(po.spare2/4503599627370496),64), 7)
             when 0 then 'NONE'
             else NULL end
         when 17 then
           case bitand(mod(trunc(po.spare2/4503599627370496),64), 7)
             when 0 then 'NONE'
             when 1 then 'LOW'
             when 2 then 'MEDIUM'
             when 3 then 'HIGH'
             when 4 then 'CRITICAL'
             else 'UNKNOWN' end
         else 'UNKNOWN' end,
       -- DEF_INMEMORY_DISTRIBUTE
       case bitand(mod(trunc(po.spare2/1099511627776),256), 103)
         when 0 then NULL                              -- first 3 bits,5,6
         when 1 then NULL
         when 2 then NULL
         when 5 then 'AUTO'
         when 37 then 'BY ROWID RANGE'
         when 69 then 'BY PARTITION'
         when 101 then 'BY SUBPARTITION'
         else 'UNKNOWN' end,
       -- DEF_INMEMORY_COMPRESSION
       case bitand(mod(trunc(po.spare2/1099511627776),4096), 395)
         when 0 then NULL                              -- bits 0,1,3,7,8
         when 1 then NULL
         when 2 then NULL
         when 9 then 'NO MEMCOMPRESS'
         when 129 then 'FOR DML'
         when 137 then 'FOR QUERY LOW'
         when 257 then 'FOR QUERY HIGH'
         when 265 then 'FOR CAPACITY LOW'
         when 385 then 'FOR CAPACITY HIGH'
         else 'UNKNOWN' end,
       -- DEF_INMEMORY_DUPLICATE
       case bitand(mod(trunc(po.spare2/1099511627776),4096), 3073)
         when 0 then NULL                              -- bits 0,1,10,11
         when 1 then NULL
         when 2 then NULL
         when 1025 then 'NO DUPLICATE'
         when 2049 then 'DUPLICATE'
         when 3073 then 'DUPLICATE ALL'
         else 'UNKNOWN' end,
       decode(bitand(po.flags, 65536), 65536, 'YES', 'NO'),
       -- DEF_CELLMEMORY
       --  defccflags_kkpacpcd (kkpac.h)
       decode(bitand(po.spare3, 16711680),
               196608, 'DISABLED',
               327680, 'NO MEMCOMPRESS',
               589824, 'MEMCOMPRESS FOR QUERY',
              1114112, 'MEMCOMPRESS FOR CAPACITY',
              NULL),
       -- DEF_INMEMORY_SERVICE
       decode(bitand(po.spare2, 1099511627776),1099511627776,
              decode(bitand(po.spare3,16777216), 16777216,
                     decode(bitand(svc.svcflags,7),
                            0, null,
                            1, 'DEFAULT',
                            2, 'NONE',
                            3, 'ALL',
                            4, 'USER_DEFINED',
                            5, 'DEFAULT'), NULL), NULL),
       -- DEF_INMEMORY_SERVICE_NAME
       decode(bitand(po.spare2, 1099511627776),1099511627776,
              decode(bitand(po.spare3,16777216), 16777216,
                     svc.svcname, NULL), NULL)
from   sys.obj$ o, sys.partobj$ po, sys.ts$ ts, sys.tab$ t, sys.user$ u,
       sys.imsvc$ svc
where  o.obj# = po.obj# and po.defts# = ts.ts# (+) and t.obj# = o.obj# and
       o.owner# = u.user# and
       bitand(t.property, 64 + 128) = 0 and o.subname IS NULL and
       o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
       (o.owner# = userenv('SCHEMAID')
        or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      ) and o.obj# = svc.obj# (+) and svc.subpart#(+) is null
union all -- NON-IOT and IOT
select u.name, o.name,
       decode(po.parttype, 1, 'RANGE', 2, 'HASH', 3, 'SYSTEM', 4, 'LIST',
                           5, 'REFERENCE', 'UNKNOWN'),
       decode(mod(po.spare2, 256), 0, 'NONE', 1, 'RANGE', 2, 'HASH',
                                   3, 'SYSTEM', 4, 'LIST', 5, 'REFERENCE',
                                   'UNKNOWN'),
       po.partcnt, mod(trunc(po.spare2/65536), 65536), po.partkeycols,
       mod(trunc(po.spare2/256), 256),
       decode(bitand(t.trigflag, 1073741824), 1073741824, 'UNUSABLE', 'VALID'),
       NULL, TO_NUMBER(NULL),TO_NUMBER(NULL),TO_NUMBER(NULL),TO_NUMBER(NULL),
       NULL,--decode(po.deftiniexts, NULL, 'DEFAULT', po.deftiniexts),
       NULL,--decode(po.defextsize, NULL, 'DEFAULT', po.defextsize),
       NULL,--decode(po.defminexts, NULL, 'DEFAULT', po.defminexts),
       NULL,--decode(po.defmaxexts, NULL, 'DEFAULT', po.defmaxexts),
       NULL,--decode(po.defmaxsize, NULL, 'DEFAULT', po.defmaxsize),
       NULL,--decode(po.defextpct, NULL, 'DEFAULT', po.defextpct),
       TO_NUMBER(NULL),TO_NUMBER(NULL),--po.deflists, po.defgroups,
       decode(po.deflogging, 0, 'NONE', 1, 'YES', 2, 'NO', 'UNKNOWN'),
       'N/A',
       null,
       decode(bitand(po.spare1, 3), 1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(po.spare1, 12)/4, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(po.spare1, 48)/16, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       NULL  -- ref-partitioned IOT is not supported so skip the sub-query,
       ,case when (po.parttype = 5 and bitand(po.flags, 64) = 64) then 'YES'
             else po.interval_str end
       ,case when (po.parttype = 4 and bitand(po.flags, 64) = 64)
             then 'YES' else 'NO' end -- autolist partitioning
       ,case when (mod(po.spare2, 256) = 1 and bitand(po.flags, 32768) = 32768)
            then po.subptn_interval_str end -- interval subpartitioning
       ,case when (mod(po.spare2, 256) = 4 and bitand(po.flags, 32768) = 32768)
             then 'YES' else 'NO' end -- autolist subpartitioning
       ,'N/A'
       , decode(bitand(po.flags, 6144), 4096, 'YES', 2048, 'NO', 'NONE')
       , decode(bitand(po.flags, 8192), 8192, 'OFF', 'ON')
       , NULL
       , NULL
       , NULL
       , NULL
       , NULL
       , decode(bitand(po.flags, 65536), 65536, 'YES', 'NO')
       , NULL
       , NULL
       , NULL
from   sys.obj$ o, sys.partobj$ po, sys.tab$ t, sys.user$ u
where  o.obj# = po.obj# and t.obj# = o.obj# and
       o.owner# = u.user# and
       bitand(t.property, 64 + 128) != 0 and o.subname IS NULL and
       o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
       (o.owner# = userenv('SCHEMAID')
        or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
;
--------------------------------------------------------
--  DDL for View ALL_PENDING_CONV_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PENDING_CONV_TABLES" ("OWNER", "TABLE_NAME") AS 
  select u.name, o.name
from sys.obj$ o, user$ u
  where o.type# = 2 and o.status = 5
  and bitand(o.flags, 4096) = 4096  /* type evolved flg */
  and o.owner# = u.user#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_PENDING_CONV_TABLES"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_PENDING_CONV_TABLES"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON TABLE "SYS"."ALL_PENDING_CONV_TABLES"  IS 'All tables accessible to the user which are not upgraded to the latest type version'
;
--------------------------------------------------------
--  DDL for View ALL_PLSQL_COLL_TYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PLSQL_COLL_TYPES" ("OWNER", "TYPE_NAME", "PACKAGE_NAME", "COLL_TYPE", "UPPER_BOUND", "ELEM_TYPE_OWNER", "ELEM_TYPE_NAME", "ELEM_TYPE_PACKAGE", "LENGTH", "PRECISION", "SCALE", "CHARACTER_SET_NAME", "ELEM_STORAGE", "NULLS_STORED", "CHAR_USED", "INDEX_BY", "ELEM_TYPE_MOD") AS 
  select u.name,
       c.coll_name,
       o.name,
       decode(bitand(c.properties, 2097152), 2097152, 'PL/SQL INDEX TABLE',
              decode(bitand(c.properties, 4194304), 4194304,
                     'PL/SQL INDEX TABLE', co.name)),
       c.upper_bound,
       nvl2(c.synobj#, (select u.name from user$ u, "_CURRENT_EDITION_OBJ" o
            where o.owner#=u.user# and o.obj#=c.synobj#),
            decode(bitand(et.properties, 64), 64, null, eu.name)),
       nvl2(c.synobj#, (select o.name from "_CURRENT_EDITION_OBJ" o
                        where o.obj#=c.synobj#),
            decode(et.typecode,
                   9, decode(c.charsetform, 2, 'NVARCHAR2', eo.name),
                   96, decode(c.charsetform, 2, 'NCHAR', eo.name),
                   112, decode(c.charsetform, 2, 'NCLOB', eo.name),
                   eo.name)),
       null,
       c.length,
       c.precision,
       c.scale,
       decode(c.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(c.charsetid),
                             4, 'ARG:'||c.charsetid),
       decode(bitand(c.properties, 131072), 131072, 'FIXED',
              decode(bitand(c.properties, 262144), 262144, 'VARYING')),
       decode(bitand(c.properties, 65536), 65536, 'NO', 'YES'),
       decode(bitand(c.properties, 4096), 4096, 'C', 'B'),
       decode(bitand(c.properties, 2097152), 2097152, 'BINARY_INTEGER',
              decode(bitand(c.properties, 4194304), 4194304, 'VARCHAR2')),
       decode(bitand(c.properties, 32768), 32768, 'REF',
              decode(bitand(c.properties, 16384), 16384, 'POINTER'))
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.collection$ c,
     sys."_CURRENT_EDITION_OBJ" co, sys."_CURRENT_EDITION_OBJ" eo,
     sys.user$ eu, sys.type$ et
where c.package_obj# IS NOT NULL                          -- only package types
  and o.obj# = c.package_obj#
  and o.owner# = u.user#
  and o.subname IS NULL -- only the most recent version
  and o.type# <> 10 -- must not be invalid
  and c.coll_toid = co.oid$
  and c.elem_toid = eo.oid$
  and eo.owner# = eu.user#
  and c.elem_toid = et.tvoid
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
       exists (select null from v$enabledprivs
               where priv_number in (-184 /* EXECUTE ANY TYPE */,
                                     -181 /* CREATE ANY TYPE */)))
UNION
--
-- Package collection types with package level element types
--
select u.name,
       c.coll_name,
       o.name,
       decode(bitand(c.properties, 2097152), 2097152, 'PL/SQL INDEX TABLE',
              decode(bitand(c.properties, 4194304), 4194304,
                     'PL/SQL INDEX TABLE', co.name)),
       c.upper_bound,
       nvl2(c.synobj#, (select u.name from user$ u, "_CURRENT_EDITION_OBJ" o
            where o.owner#=u.user# and o.obj#=c.synobj#), eu.name),
       et.typ_name || decode(bitand(et.properties,134217728),134217728,
                                    '%ROWTYPE', null),
       nvl2(c.synobj#, (select o.name from "_CURRENT_EDITION_OBJ" o
                        where o.obj#=c.synobj#), eo.name),
       c.length,
       c.precision,
       c.scale,
       decode(c.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(c.charsetid),
                             4, 'ARG:'||c.charsetid),
       decode(bitand(c.properties, 131072), 131072, 'FIXED',
              decode(bitand(c.properties, 262144), 262144, 'VARYING')),
       decode(bitand(c.properties, 65536), 65536, 'NO', 'YES'),
       decode(bitand(c.properties, 4096), 4096, 'C', 'B'),
       decode(bitand(c.properties, 2097152), 2097152, 'BINARY_INTEGER',
              decode(bitand(c.properties, 4194304), 4194304, 'VARCHAR2')),
       null
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.collection$ c,
     sys."_CURRENT_EDITION_OBJ" co,
     sys."_CURRENT_EDITION_OBJ" eo, sys.user$ eu, sys.type$ et
where c.package_obj# IS NOT NULL                          -- only package types
  and o.obj# = c.package_obj#
  and o.owner# = u.user#
  and o.type# <> 10 -- must not be invalid
  and c.coll_toid = co.oid$
  and et.package_obj# IS NOT NULL
  and et.package_obj# = eo.obj#
  and eo.owner# = eu.user#
  and c.elem_toid = et.toid
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
       exists (select null from v$enabledprivs
               where priv_number in (-144 /* EXECUTE ANY PROCEDURE */,
                                     -141 /* CREATE ANY PROCEDURE */
                                     -241 /* DEBUG ANY PROCEDURE */)))
UNION
--
-- Package collection types with table/view rowtypes
--
select u.name,
       c.coll_name,
       o.name,
       decode(bitand(c.properties, 2097152), 2097152, 'PL/SQL INDEX TABLE',
              decode(bitand(c.properties, 4194304), 4194304,
                     'PL/SQL INDEX TABLE', co.name)),
       c.upper_bound,
       nvl2(c.synobj#, (select u.name
                        from user$ u, "_CURRENT_EDITION_OBJ" o
                        where o.owner#=u.user# and o.obj#=c.synobj#),
            eu.name),
       nvl2(c.synobj#, (select o.name
                        from "_CURRENT_EDITION_OBJ" o
                        where o.obj#=c.synobj#),
             eo.name) || '%ROWTYPE',
       null, null, null, null, null,
       decode(bitand(c.properties, 131072), 131072, 'FIXED',
              decode(bitand(c.properties, 262144), 262144, 'VARYING')),
       decode(bitand(c.properties, 65536), 65536, 'NO', 'YES'),
       decode(bitand(c.properties, 4096), 4096, 'C', 'B'),
       decode(bitand(c.properties, 2097152), 2097152, 'BINARY_INTEGER',
              decode(bitand(c.properties, 4194304), 4194304, 'VARCHAR2')),
       decode(bitand(c.properties, 32768), 32768, 'REF',
              decode(bitand(c.properties, 16384), 16384, 'POINTER'))
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.collection$ c,
     sys."_CURRENT_EDITION_OBJ" co, sys."_CURRENT_EDITION_OBJ" eo,
     sys.user$ eu, sys.oid$ id
where c.package_obj# IS NOT NULL                          -- only package types
  and o.obj# = c.package_obj#
  and o.owner# = u.user#
  and o.subname IS NULL -- only the most recent version
  and o.type# <> 10 -- must not be invalid
  and c.coll_toid = co.oid$
  and c.elem_toid = id.oid$
  and id.obj# = eo.obj#
  and eo.type# in (2,4)                     -- table or view collection element
  and eo.owner# = eu.user#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
       exists (select null from v$enabledprivs
               where priv_number in (-184 /* EXECUTE ANY TYPE */,
                                     -181 /* CREATE ANY TYPE */)));

   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."PACKAGE_NAME" IS 'Name of the package containing the collection';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."COLL_TYPE" IS 'Collection type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."UPPER_BOUND" IS 'The upper bound of a varray or length constraint of an index by varchar2
table';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."ELEM_TYPE_OWNER" IS 'Owner of the type of the element';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."ELEM_TYPE_NAME" IS 'Name of the type of the element';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."ELEM_TYPE_PACKAGE" IS 'Name of the package containing the element';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."LENGTH" IS 'Length of the CHAR element or maximum length of the VARCHAR
or VARCHAR2 element';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."PRECISION" IS 'Decimal precision of the NUMBER or DECIMAL element or
binary precision of the FLOAT element';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."SCALE" IS 'Scale of the NUMBER or DECIMAL element';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."CHARACTER_SET_NAME" IS 'Character set name of the element';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."ELEM_STORAGE" IS 'Storage optimization specification for VARRAY of numeric elements';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."NULLS_STORED" IS 'Is null information stored with each VARRAY element?';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."CHAR_USED" IS 'C if the width was specified in characters, B if in bytes';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_COLL_TYPES"."INDEX_BY" IS 'Index by binary_integer or varchar2';
   COMMENT ON TABLE "SYS"."ALL_PLSQL_COLL_TYPES"  IS 'Description of named plsql collection types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_PLSQL_OBJECT_SETTINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PLSQL_OBJECT_SETTINGS" ("OWNER", "NAME", "TYPE", "PLSQL_OPTIMIZE_LEVEL", "PLSQL_CODE_TYPE", "PLSQL_DEBUG", "PLSQL_WARNINGS", "NLS_LENGTH_SEMANTICS", "PLSQL_CCFLAGS", "PLSCOPE_SETTINGS", "ORIGIN_CON_ID") AS 
  select OWNER, NAME, TYPE, PLSQL_OPTIMIZE_LEVEL, PLSQL_CODE_TYPE, PLSQL_DEBUG,
       PLSQL_WARNINGS, NLS_LENGTH_SEMANTICS, PLSQL_CCFLAGS, PLSCOPE_SETTINGS,
       ORIGIN_CON_ID
  from INT$DBA_PLSQL_OBJECT_SETTINGS
 where
  (
    OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
    or OWNER = 'PUBLIC'
    or
    (
      /* EXECUTE privilege does not let user see package or type body */
      TYPE# in (7, 8, 9, 12, 13, 22)
      and
      OBJ_ID(OWNER, NAME, TYPE#, OBJECT_ID) in (select obj# from sys.objauth$
                 where grantee# in (select kzsrorol from x$kzsro)
                   and privilege# in (12 /* EXECUTE */,
                                      26 /* DEBUG */)
                )
    )
    or
    (
       TYPE# in (7, 8, 9) /* procedure, function, package */
       and
       exists (select null from v$enabledprivs
               where priv_number in (
                                      -144 /* EXECUTE ANY PROCEDURE */,
                                      -141 /* CREATE ANY PROCEDURE */,
                                      -241 /* DEBUG ANY PROCEDURE */
                                    )
              )
    )
    or
    (
      TYPE# = 11 /* package body */
      and
      exists (select null from v$enabledprivs
              where priv_number in (-141 /* CREATE ANY PROCEDURE */,
                                    -241 /* DEBUG ANY PROCEDURE */))
    )
    or
    (
       TYPE# = 12 /* trigger */
       and
       exists (select null from v$enabledprivs
               where priv_number in (-152 /* CREATE ANY TRIGGER */,
                                     -241 /* DEBUG ANY PROCEDURE */))
    )
    or
    (
      TYPE# = 13 /* type */
      and
      exists (select null from v$enabledprivs
              where priv_number in (-184 /* EXECUTE ANY TYPE */,
                                    -181 /* CREATE ANY TYPE */,
                                    -241 /* DEBUG ANY PROCEDURE */))
    )
    or
    (
      TYPE# = 14 /* type body */
      and
      exists (select null from v$enabledprivs
              where priv_number in (-181 /* CREATE ANY TYPE */,
                                    -241 /* DEBUG ANY PROCEDURE */))
    )
    or
    (
      TYPE# = 22 /* library */
      and
      exists (select null from v$enabledprivs
              where priv_number in ( -189 /* CREATE ANY LIBRARY */,
                                     -192 /* EXECUTE ANY LIBRARY */))
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."TYPE" IS 'Type of the object: "PROCEDURE", "FUNCTION",
"PACKAGE", "PACKAGE BODY", "TRIGGER", "TYPE", "TYPE BODY" or "LIBRARY"';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."PLSQL_OPTIMIZE_LEVEL" IS 'The optimization level to use to compile the object';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."PLSQL_CODE_TYPE" IS 'The object codes are to be compiled natively or are interpreted';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."PLSQL_DEBUG" IS 'The object is to be compiled with debug information or not';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."PLSQL_WARNINGS" IS 'The compiler warning settings to use to compile the object';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."NLS_LENGTH_SEMANTICS" IS 'The NLS length semantics to use to compile the object';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."PLSQL_CCFLAGS" IS 'The conditional compilation flag settings to use to compile the object';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."PLSCOPE_SETTINGS" IS 'Settings for using PL/Scope';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_OBJECT_SETTINGS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_PLSQL_OBJECT_SETTINGS"  IS 'Compiler settings of stored objects accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_PLSQL_TYPE_ATTRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PLSQL_TYPE_ATTRS" ("OWNER", "TYPE_NAME", "PACKAGE_NAME", "ATTR_NAME", "ATTR_TYPE_MOD", "ATTR_TYPE_OWNER", "ATTR_TYPE_NAME", "ATTR_TYPE_PACKAGE", "LENGTH", "PRECISION", "SCALE", "CHARACTER_SET_NAME", "ATTR_NO", "CHAR_USED") AS 
  select u.name,
       t.typ_name || decode(bitand(t.properties,134217728),134217728,
                             '%ROWTYPE', null),
       o.name, a.name,
       decode(bitand(a.properties, 32768), 32768, 'REF',
              decode(bitand(a.properties, 16384), 16384, 'POINTER')),
       nvl2(a.synobj#, (select u.name from user$ u, "_CURRENT_EDITION_OBJ" o
            where o.owner#=u.user# and o.obj#=a.synobj#),
            decode(bitand(at.properties, 64), 64, null, au.name)),
       nvl2(a.synobj#, (select o.name from "_CURRENT_EDITION_OBJ" o
                        where o.obj#=a.synobj#),
            decode(at.typecode,
                   9, decode(a.charsetform, 2, 'NVARCHAR2', ao.name),
                   96, decode(a.charsetform, 2, 'NCHAR', ao.name),
                   112, decode(a.charsetform, 2, 'NCLOB', ao.name),
                   ao.name)),
       null,
       a.length, a.precision#, a.scale,
       decode(a.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(a.charsetid),
                             4, 'ARG:'||a.charsetid),
       a.attribute#,
       decode(bitand(a.properties, 4096), 4096, 'C', 'B')
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.type$ t,
     sys.attribute$ a,
     sys."_CURRENT_EDITION_OBJ" ao, sys.user$ au, sys.type$ at
where bitand(t.properties, 64) != 64 -- u.name
  and o.owner# = u.user#
  and t.package_obj# IS NOT NULL                          -- only package types
  and o.obj# = t.package_obj#
  and o.subname IS NULL -- get the latest version only
  and o.type# <> 10 -- must not be invalid
  and bitand(t.properties, 2048) = 0 -- not system-generated
  and t.toid = a.toid
  and t.version# = a.version#
  and a.attr_toid = ao.oid$
  and ao.owner# = au.user#
  and a.attr_toid = at.toid
  and a.attr_version# = at.version#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
       exists (select null from v$enabledprivs
               where priv_number in (-184 /* EXECUTE ANY TYPE */,
                                     -181 /* CREATE ANY TYPE */)))
UNION
--
-- Package type attributes in package types.
--
select u.name, t.typ_name, o.name, a.name, null,
       nvl2(a.synobj#, (select u.name
                        from user$ u, "_CURRENT_EDITION_OBJ" o
                        where o.owner#=u.user# and o.obj#=a.synobj#),
            au.name),
       at.typ_name || decode(bitand(at.properties,134217728),134217728,
                             '%ROWTYPE', null),
       nvl2(a.synobj#, (select o.name
                        from "_CURRENT_EDITION_OBJ" o
                        where o.obj#=a.synobj#),
            ao.name),
       a.length, a.precision#, a.scale,
       decode(a.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(a.charsetid),
                             4, 'ARG:'||a.charsetid),
       a.attribute#,
       decode(bitand(a.properties, 4096), 4096, 'C', 'B')
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.type$ t,
     sys.attribute$ a,
     sys."_CURRENT_EDITION_OBJ" ao, sys.user$ au, sys.type$ at
where o.owner# = u.user#
  and t.package_obj# IS NOT NULL                          -- only package types
  and o.obj# = t.package_obj#
  and o.type# <> 10 -- must not be invalid
  and t.toid = a.toid
  and t.version# = a.version#
  and at.package_obj# IS NOT NULL
  and at.package_obj# = ao.obj#
  and ao.owner# = au.user#
  and a.attr_toid = at.toid
  and a.attr_version# = at.version#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
       exists (select null from v$enabledprivs
               where priv_number in (-144 /* EXECUTE ANY PROCEDURE */,
                                     -141 /* CREATE ANY PROCEDURE */
                                     -241 /* DEBUG ANY PROCEDURE */)))
UNION
--
-- %rowtype attributes in package types.
--
select u.name,
       t.typ_name,
       o.name, a.name, null,
       nvl2(a.synobj#, (select u.name
                        from user$ u, "_CURRENT_EDITION_OBJ" o
                        where o.owner#=u.user# and o.obj#=a.synobj#),
            au.name),
       nvl2(a.synobj#, (select o.name
                        from "_CURRENT_EDITION_OBJ" o
                        where o.obj#=a.synobj#),
            ao.name) || '%ROWTYPE',
       null, null, null, null, null,
       a.attribute#, null
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.type$ t,
     sys.attribute$ a,
     sys."_CURRENT_EDITION_OBJ" ao, sys.user$ au, sys.oid$ id
where bitand(t.properties, 64) != 64 -- u.name
  and o.owner# = u.user#
  and t.package_obj# IS NOT NULL                          -- only package types
  and o.obj# = t.package_obj#
  and o.subname IS NULL -- get the latest version only
  and o.type# <> 10 -- must not be invalid
  and bitand(t.properties, 2048) = 0 -- not system-generated
  and t.toid = a.toid
  and t.version# = a.version#
  and a.attr_toid = id.oid$
  and id.obj# = ao.obj#
  and ao.type# in (2,4)                     -- table or view collection element
  and ao.owner# = au.user#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
       exists (select null from v$enabledprivs
               where priv_number in (-184 /* EXECUTE ANY TYPE */,
                                     -181 /* CREATE ANY TYPE */)));

   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."PACKAGE_NAME" IS 'Name of the package containing the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."ATTR_NAME" IS 'Name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."ATTR_TYPE_MOD" IS 'Type modifier of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."ATTR_TYPE_OWNER" IS 'Owner of the type of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."ATTR_TYPE_NAME" IS 'Name of the type of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."ATTR_TYPE_PACKAGE" IS 'Name of the package containing the attribute type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."LENGTH" IS 'Length of the CHAR attribute or maximum length of the VARCHAR
or VARCHAR2 attribute';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."PRECISION" IS 'Decimal precision of the NUMBER or DECIMAL attribute or
binary precision of the FLOAT attribute';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."SCALE" IS 'Scale of the NUMBER or DECIMAL attribute';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."CHARACTER_SET_NAME" IS 'Character set name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."ATTR_NO" IS 'Syntactical order number or position of the attribute as specified in the
type specification or CREATE TYPE statement (not to be used as ID number)';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPE_ATTRS"."CHAR_USED" IS 'C if the width was specified in characters, B if in bytes';
   COMMENT ON TABLE "SYS"."ALL_PLSQL_TYPE_ATTRS"  IS 'Description of attributes of types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_PLSQL_TYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PLSQL_TYPES" ("OWNER", "TYPE_NAME", "PACKAGE_NAME", "TYPE_OID", "TYPECODE", "ATTRIBUTES", "CONTAINS_PLSQL") AS 
  select u.name, t.typ_name || decode(bitand(t.properties,134217728),134217728,
                                    '%ROWTYPE', null),
       o.name, t.toid,
       decode(t.typecode, 250,
                          decode(bitand(t.properties,134217728),134217728,
                          'CURSOR ROWTYPE', 'PL/SQL RECORD'),
                          122, 'COLLECTION',
                          'UNKNOWN TYPECODE: ' || t.typecode),
       t.attributes,
       decode(bitand(t.properties, 67108864), 67108864, 'YES', 0, 'NO')
from sys.user$ u, sys.type$ t, sys."_CURRENT_EDITION_OBJ" o
where o.owner# = u.user#
  and o.type# <> 10 -- must not be invalid
  and t.package_obj# IS NOT NULL                          -- only package types
  and o.obj# = t.package_obj#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
       exists (select null from v$enabledprivs
               where priv_number in (-144 /* EXECUTE ANY PROCEDURE */,
                                     -141 /* CREATE ANY PROCEDURE */
                                     -241 /* DEBUG ANY PROCEDURE */)));

   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPES"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPES"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPES"."PACKAGE_NAME" IS 'Name of the package containing the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPES"."TYPE_OID" IS 'Object identifier (OID) of the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPES"."TYPECODE" IS 'Typecode of the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPES"."ATTRIBUTES" IS 'Number of attributes in the type';
   COMMENT ON COLUMN "SYS"."ALL_PLSQL_TYPES"."CONTAINS_PLSQL" IS 'Does the type contain plsql specific data types?';
   COMMENT ON TABLE "SYS"."ALL_PLSQL_TYPES"  IS 'Description of types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_POLICIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_POLICIES" ("OBJECT_OWNER", "OBJECT_NAME", "POLICY_GROUP", "POLICY_NAME", "PF_OWNER", "PACKAGE", "FUNCTION", "SEL", "INS", "UPD", "DEL", "IDX", "CHK_OPTION", "ENABLE", "STATIC_POLICY", "POLICY_TYPE", "LONG_PREDICATE", "COMMON", "INHERITED") AS 
  SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, POLICY_NAME, PF_OWNER,
PACKAGE, FUNCTION, SEL, INS, UPD, DEL, IDX, CHK_OPTION, ENABLE, STATIC_POLICY,
POLICY_TYPE, LONG_PREDICATE, COMMON, INHERITED
FROM DBA_POLICIES, ALL_TABLES t
WHERE
(OBJECT_OWNER = t.OWNER AND OBJECT_NAME = t.TABLE_NAME)
union all
SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, POLICY_NAME, PF_OWNER,
PACKAGE, FUNCTION, SEL, INS, UPD, DEL, IDX, CHK_OPTION, ENABLE, STATIC_POLICY,
POLICY_TYPE, LONG_PREDICATE, COMMON, INHERITED
FROM DBA_POLICIES, ALL_VIEWS v
WHERE
(OBJECT_OWNER = v.OWNER AND OBJECT_NAME = v.VIEW_NAME )
union all
SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, POLICY_NAME, PF_OWNER,
PACKAGE, FUNCTION, SEL, INS, UPD, DEL, IDX, CHK_OPTION, ENABLE, STATIC_POLICY,
POLICY_TYPE, LONG_PREDICATE, COMMON, INHERITED
FROM DBA_POLICIES, ALL_SYNONYMS s
WHERE
(OBJECT_OWNER = s.OWNER AND OBJECT_NAME = s.SYNONYM_NAME);

   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."OBJECT_OWNER" IS 'Owner of the synonym, table, or view';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."OBJECT_NAME" IS 'Name of the synonym, table, or view';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."POLICY_NAME" IS 'Name of the policy';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."PF_OWNER" IS 'Owner of the policy function';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."PACKAGE" IS 'Name of the package containing the policy function';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."FUNCTION" IS 'Name of the policy function';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."SEL" IS 'If YES, policy is applied to query on the object';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."INS" IS 'If YES, policy is applied to insert on the object';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."UPD" IS 'If YES, policy is applied to update on the object';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."DEL" IS 'If YES, policy is applied to delete on the object';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."IDX" IS 'If YES, policy is applied to IDX on the object';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."CHK_OPTION" IS 'Is check option enforced for this policy?';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."ENABLE" IS 'Is this policy is enabled?';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."STATIC_POLICY" IS 'Is this policy is static?';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."POLICY_TYPE" IS 'policy types';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."LONG_PREDICATE" IS 'If YES, maximum predicate size can be 32K';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."COMMON" IS 'Is the policy common?';
   COMMENT ON COLUMN "SYS"."ALL_POLICIES"."INHERITED" IS 'Is the policy inherited?';
   COMMENT ON TABLE "SYS"."ALL_POLICIES"  IS 'All policies for objects if the user has system privileges or owns the objects'
;
--------------------------------------------------------
--  DDL for View ALL_POLICY_ATTRIBUTES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_POLICY_ATTRIBUTES" ("OBJECT_OWNER", "OBJECT_NAME", "POLICY_GROUP", "POLICY_NAME", "NAMESPACE", "ATTRIBUTE", "COMMON", "INHERITED") AS 
  SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, POLICY_NAME,
NAMESPACE, ATTRIBUTE, COMMON, INHERITED
FROM DBA_POLICY_ATTRIBUTES, ALL_TABLES t
WHERE
(OBJECT_OWNER = t.OWNER AND OBJECT_NAME = t.TABLE_NAME)
union all
SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, POLICY_NAME,
NAMESPACE, ATTRIBUTE, COMMON, INHERITED
FROM DBA_POLICY_ATTRIBUTES, ALL_VIEWS v
WHERE
(OBJECT_OWNER = v.OWNER AND OBJECT_NAME = v.VIEW_NAME )
union all
SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, POLICY_NAME,
NAMESPACE, ATTRIBUTE, COMMON, INHERITED
FROM DBA_POLICY_ATTRIBUTES, ALL_SYNONYMS s
WHERE
(OBJECT_OWNER = s.OWNER AND OBJECT_NAME = s.SYNONYM_NAME);

   COMMENT ON COLUMN "SYS"."ALL_POLICY_ATTRIBUTES"."OBJECT_OWNER" IS 'Owner of the synonym, table, or view';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_ATTRIBUTES"."OBJECT_NAME" IS 'Name of the synonym, table, or view';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_ATTRIBUTES"."POLICY_GROUP" IS 'Name of the policy group';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_ATTRIBUTES"."POLICY_NAME" IS 'Name of the policy';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_ATTRIBUTES"."NAMESPACE" IS 'Name of the local application context';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_ATTRIBUTES"."ATTRIBUTE" IS 'Name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_ATTRIBUTES"."COMMON" IS 'Is the policy attribute common?';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_ATTRIBUTES"."INHERITED" IS 'Is the policy attribute inherited?';
   COMMENT ON TABLE "SYS"."ALL_POLICY_ATTRIBUTES"  IS 'All attribute associations of context sensitive and shared context sensitive policies for objects if the user has system privileges or owns the objects'
;
--------------------------------------------------------
--  DDL for View ALL_POLICY_CONTEXTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_POLICY_CONTEXTS" ("OBJECT_OWNER", "OBJECT_NAME", "NAMESPACE", "ATTRIBUTE", "COMMON", "INHERITED") AS 
  SELECT OBJECT_OWNER, OBJECT_NAME,NAMESPACE,ATTRIBUTE, COMMON, INHERITED
FROM DBA_POLICY_CONTEXTS, ALL_TABLES t
WHERE
(OBJECT_OWNER = t.OWNER AND OBJECT_NAME = t.TABLE_NAME)
union all
SELECT OBJECT_OWNER, OBJECT_NAME,NAMESPACE,ATTRIBUTE, COMMON, INHERITED
FROM DBA_POLICY_CONTEXTS, ALL_VIEWS v
WHERE
(OBJECT_OWNER = v.OWNER AND OBJECT_NAME = v.VIEW_NAME )
union all
SELECT OBJECT_OWNER, OBJECT_NAME,NAMESPACE,ATTRIBUTE, COMMON, INHERITED
FROM DBA_POLICY_CONTEXTS, ALL_SYNONYMS s
WHERE
(OBJECT_OWNER = s.OWNER AND OBJECT_NAME = s.SYNONYM_NAME );

   COMMENT ON COLUMN "SYS"."ALL_POLICY_CONTEXTS"."OBJECT_OWNER" IS 'Schema of the synonym, table, or view';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_CONTEXTS"."OBJECT_NAME" IS 'Name of the synonym, table, or view';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_CONTEXTS"."NAMESPACE" IS 'Namespace of the context';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_CONTEXTS"."ATTRIBUTE" IS 'Attribute of the context';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_CONTEXTS"."COMMON" IS 'Is the policy context common?';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_CONTEXTS"."INHERITED" IS 'Is the policy context inherited?';
   COMMENT ON TABLE "SYS"."ALL_POLICY_CONTEXTS"  IS 'All policy driving context defined for all synonyms, tables, or views accessable to the user'
;
--------------------------------------------------------
--  DDL for View ALL_POLICY_GROUPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_POLICY_GROUPS" ("OBJECT_OWNER", "OBJECT_NAME", "POLICY_GROUP", "COMMON", "INHERITED") AS 
  SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, COMMON, INHERITED
FROM DBA_POLICY_GROUPS, ALL_TABLES t
WHERE
(OBJECT_OWNER = t.OWNER AND OBJECT_NAME = t.TABLE_NAME)
union all
SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, COMMON, INHERITED
FROM DBA_POLICY_GROUPS, ALL_VIEWS v
WHERE
(OBJECT_OWNER = v.OWNER AND OBJECT_NAME = v.VIEW_NAME )
union all
SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, COMMON, INHERITED
FROM DBA_POLICY_GROUPS, ALL_SYNONYMS s
WHERE
(OBJECT_OWNER = s.OWNER AND OBJECT_NAME = s.SYNONYM_NAME);

   COMMENT ON COLUMN "SYS"."ALL_POLICY_GROUPS"."OBJECT_OWNER" IS 'Schema of the synonym, table, or view';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_GROUPS"."OBJECT_NAME" IS 'Name of the synonym, table, or view';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_GROUPS"."POLICY_GROUP" IS 'Policy group defined';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_GROUPS"."COMMON" IS 'Is the policy group common?';
   COMMENT ON COLUMN "SYS"."ALL_POLICY_GROUPS"."INHERITED" IS 'Is the policy group inherited?';
   COMMENT ON TABLE "SYS"."ALL_POLICY_GROUPS"  IS 'All policy groups defined for any synonym, table or view accessable to the user'
;
--------------------------------------------------------
--  DDL for View ALL_PROBE_OBJECTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PROBE_OBJECTS" ("OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "OBJECT_ID", "DATA_OBJECT_ID", "OBJECT_TYPE", "CREATED", "LAST_DDL_TIME", "TIMESTAMP", "STATUS", "TEMPORARY", "GENERATED", "SECONDARY", "NAMESPACE", "EDITION_NAME", "SHARING", "EDITIONABLE", "ORACLE_MAINTAINED", "APPLICATION", "DEFAULT_COLLATION", "DUPLICATED", "SHARDED", "CREATED_APPID", "CREATED_VSNID", "MODIFIED_APPID", "MODIFIED_VSNID", "DEBUGINFO") AS 
  SELECT DISTINCT all_objects."OWNER",all_objects."OBJECT_NAME",all_objects."SUBOBJECT_NAME",all_objects."OBJECT_ID",all_objects."DATA_OBJECT_ID",all_objects."OBJECT_TYPE",all_objects."CREATED",all_objects."LAST_DDL_TIME",all_objects."TIMESTAMP",all_objects."STATUS",all_objects."TEMPORARY",all_objects."GENERATED",all_objects."SECONDARY",all_objects."NAMESPACE",all_objects."EDITION_NAME",all_objects."SHARING",all_objects."EDITIONABLE",all_objects."ORACLE_MAINTAINED",all_objects."APPLICATION",all_objects."DEFAULT_COLLATION",all_objects."DUPLICATED",all_objects."SHARDED",all_objects."CREATED_APPID",all_objects."CREATED_VSNID",all_objects."MODIFIED_APPID",all_objects."MODIFIED_VSNID",
                   decode(idl_char$.part,null,'F',0,'F','T') debuginfo
   FROM   idl_char$, all_objects
   WHERE  all_objects.object_id = idl_char$.obj# (+)
   AND    (idl_char$.part IS NULL OR
            (idl_char$.part = 0         -- Diana
              AND NOT EXISTS (SELECT *
                              FROM   idl_char$
                              WHERE  all_objects.object_id = idl_char$.obj#
                              AND    idl_char$.part = 1))
           OR idl_char$.part = 1        -- PCode
           )
;
--------------------------------------------------------
--  DDL for View ALL_PROCEDURES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PROCEDURES" ("OWNER", "OBJECT_NAME", "PROCEDURE_NAME", "OBJECT_ID", "SUBPROGRAM_ID", "OVERLOAD", "OBJECT_TYPE", "AGGREGATE", "PIPELINED", "IMPLTYPEOWNER", "IMPLTYPENAME", "PARALLEL", "INTERFACE", "DETERMINISTIC", "AUTHID", "RESULT_CACHE", "ORIGIN_CON_ID", "POLYMORPHIC") AS 
  select OWNER, OBJECT_NAME, PROCEDURE_NAME, OBJECT_ID, SUBPROGRAM_ID,
       OVERLOAD, OBJECT_TYPE,
       AGGREGATE, PIPELINED,
       IMPLTYPEOWNER, IMPLTYPENAME, PARALLEL,
       INTERFACE, DETERMINISTIC, AUTHID, RESULT_CACHE, ORIGIN_CON_ID,
       POLYMORPHIC
  from INT$DBA_PROCEDURES
 where OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
    or exists
       (select null from v$enabledprivs where priv_number in (-144,-141))
    or OBJ_ID(OWNER, OBJECT_NAME, OBJECT_TYPE#, OBJECT_ID) in
       (select obj#
          from sys.objauth$
         where grantee# in (select kzsrorol from x$kzsro)
           and privilege# = 12);

   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."OBJECT_NAME" IS 'Name of the object: top level function/procedure/package/type/trigger name';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."PROCEDURE_NAME" IS 'Name of the package or type subprogram';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."OBJECT_ID" IS 'Object number of the object';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."SUBPROGRAM_ID" IS 'Unique sub-program identifier';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."OVERLOAD" IS 'Overload unique identifier';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."OBJECT_TYPE" IS 'The typename of the object';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."AGGREGATE" IS 'Is it an aggregate function ?';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."PIPELINED" IS 'Is it a pipelined table function ?';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."IMPLTYPEOWNER" IS 'Name of the owner of the implementation type (if any)';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."IMPLTYPENAME" IS 'Name of the implementation type (if any)';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."PARALLEL" IS 'Is the procedure parallel enabled ?';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."RESULT_CACHE" IS 'Is it a result-cached function ?';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON COLUMN "SYS"."ALL_PROCEDURES"."POLYMORPHIC" IS 'If it is a polymorphic table function, then what is its kind ?';
   COMMENT ON TABLE "SYS"."ALL_PROCEDURES"  IS 'Functions/procedures/packages/types/triggers available to the user'
;
--------------------------------------------------------
--  DDL for View ALL_PROPAGATION
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_PROPAGATION" ("PROPAGATION_NAME", "SOURCE_QUEUE_OWNER", "SOURCE_QUEUE_NAME", "DESTINATION_QUEUE_OWNER", "DESTINATION_QUEUE_NAME", "DESTINATION_DBLINK", "RULE_SET_OWNER", "RULE_SET_NAME", "NEGATIVE_RULE_SET_OWNER", "NEGATIVE_RULE_SET_NAME", "QUEUE_TO_QUEUE", "STATUS", "ERROR_MESSAGE", "ERROR_DATE", "ORIGINAL_PROPAGATION_NAME", "ORIGINAL_SOURCE_QUEUE_OWNER", "ORIGINAL_SOURCE_QUEUE_NAME", "ACKED_SCN", "AUTO_MERGE_THRESHOLD") AS 
  SELECT p."PROPAGATION_NAME",p."SOURCE_QUEUE_OWNER",p."SOURCE_QUEUE_NAME",p."DESTINATION_QUEUE_OWNER",p."DESTINATION_QUEUE_NAME",p."DESTINATION_DBLINK",p."RULE_SET_OWNER",p."RULE_SET_NAME",p."NEGATIVE_RULE_SET_OWNER",p."NEGATIVE_RULE_SET_NAME",p."QUEUE_TO_QUEUE",p."STATUS",p."ERROR_MESSAGE",p."ERROR_DATE",p."ORIGINAL_PROPAGATION_NAME",p."ORIGINAL_SOURCE_QUEUE_OWNER",p."ORIGINAL_SOURCE_QUEUE_NAME",p."ACKED_SCN",p."AUTO_MERGE_THRESHOLD"
FROM   dba_propagation p, all_queues q
WHERE p.source_queue_owner = q.owner
   AND p.source_queue_name = q.name
   AND ((p.rule_set_owner IS NULL and p.rule_set_name IS NULL) OR
        ((p.rule_set_owner, p.rule_set_name) IN
          (SELECT r.rule_set_owner, r.rule_set_name
             FROM all_rule_sets r)))
   AND ((p.negative_rule_set_owner IS NULL AND
         p.negative_rule_set_name IS NULL) OR
        ((p.negative_rule_set_owner, p.negative_rule_set_name) IN
          (SELECT r.rule_set_owner, r.rule_set_name
             FROM all_rule_sets r)));

   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."PROPAGATION_NAME" IS 'name of the Streams propagation';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."SOURCE_QUEUE_OWNER" IS 'owner of the propgation source queue';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."SOURCE_QUEUE_NAME" IS 'name of the propagation source queue';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."DESTINATION_QUEUE_OWNER" IS 'owner of the propagation destination queue';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."DESTINATION_QUEUE_NAME" IS 'name of the propagation destination queue';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."DESTINATION_DBLINK" IS 'database link to access the propagation destination queue';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."RULE_SET_OWNER" IS 'propagation rule set owner';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."RULE_SET_NAME" IS 'propagation rule set name';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."NEGATIVE_RULE_SET_OWNER" IS 'propagation negative rule set owner';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."NEGATIVE_RULE_SET_NAME" IS 'propagation negative rule set name';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."STATUS" IS 'Status of the propagation: DISABLED, ENABLED, ABORTED';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."ERROR_MESSAGE" IS 'Error message last encountered by propagation';
   COMMENT ON COLUMN "SYS"."ALL_PROPAGATION"."ERROR_DATE" IS 'The time that propagation last encountered an error';
   COMMENT ON TABLE "SYS"."ALL_PROPAGATION"  IS 'Streams propagation seen by the user'
;
--------------------------------------------------------
--  DDL for View _ALL_QUEUE_CACHED_MESSAGES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_QUEUE_CACHED_MESSAGES" ("QUEUE_NAME", "QUEUE_ID", "MSGID", "SUBSCRIBER_BITMAP", "LCK_BITMAP", "CORRELATION", "PRIORITY", "STATE", "ENQ_TIME", "DELIVERY_TIME", "EXPIRATION") AS 
  select
  q.name QUEUE_NAME,
  q.eventid QUEUE_ID,
  gv.msgid,
  gv.bitmap SUBSCRIBER_BITMAP,
  gv.lck_bitmap LCK_BITMAP,
  gv.correlation,
  gv.priority,
  gv.state,
  gv.enq_time,
  gv.delivery_time,
  gv.expiration
FROM system.aq$_queues q, system.aq$_queue_tables t,
     sys.user$ cu, gv$aq_msgbm gv, sys.obj$ o
where
      q.table_objno = t.objno and
      q.usage != 1 and
      q.eventid = gv.queue_id and
      q.eventid = o.obj# and
      o.owner# = cu.user# and
      (t.schema = sys_context('USERENV','CURRENT_USER') or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where oa.privilege# = 21 and
                        grantee# in (select kzsrorol from x$kzsro))
                  or ((o.owner# != 0) and exists (select
                  null from v$enabledprivs
                  where priv_number = -220)))
;
--------------------------------------------------------
--  DDL for View ALL_QUEUE_PUBLISHERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_QUEUE_PUBLISHERS" ("QUEUE_OWNER", "QUEUE_NAME", "PUBLISHER_NAME", "PUBLISHER_ADDRESS", "PUBLISHER_PROTOCOL", "PUBLISHER_RULE", "PUBLISHER_RULE_NAME", "PUBLISHER_RULESET", "PUBLISHER_TRANSFORMATION") AS 
  select t.schema QUEUE_OWNER, q.name QUEUE_NAME,
        p.p_name PUBLISHER_NAME, p.p_address PUBLISHER_ADDRESS,
        p.p_protocol PUBLISHER_PROTOCOL, p.p_rule PUBLISHER_RULE,
        p.p_rule_name PUBLISHER_RULE_NAME, p.p_ruleset PUBLISHER_RULESET,
        p.p_transformation PUBLISHER_TRANSFORMATION
from
 system.aq$_queue_tables t,  system.aq$_queues q,
 sys.aq$_publisher p, sys.user$ u
where
 u.user# = USERENV('SCHEMAID') and
 u.name = t.schema and q.table_objno = t.objno
 and q.eventid = p.queue_id
;
--------------------------------------------------------
--  DDL for View ALL_QUEUES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_QUEUES" ("OWNER", "NAME", "QUEUE_TABLE", "QID", "QUEUE_TYPE", "MAX_RETRIES", "RETRY_DELAY", "ENQUEUE_ENABLED", "DEQUEUE_ENABLED", "RETENTION", "USER_COMMENT", "NETWORK_NAME", "SHARDED") AS 
  select u.name OWNER, q.name NAME, t.name QUEUE_TABLE, q.eventid QID,
       decode(q.usage, 1, 'EXCEPTION_QUEUE', 2, 'NON_PERSISTENT_QUEUE',
              'NORMAL_QUEUE') QUEUE_TYPE,
       q.max_retries MAX_RETRIES, q.retry_delay RETRY_DELAY,
       decode(bitand(q.enable_flag, 1), 1 , '  YES  ', '  NO  ')ENQUEUE_ENABLED,
       decode(bitand(q.enable_flag, 2), 2 , '  YES  ', '  NO  ')DEQUEUE_ENABLED,
       decode(q.ret_time, -1, ' FOREVER', q.ret_time) RETENTION,
       substrb(q.queue_comment, 1, 50) USER_COMMENT,
       s.network_name NETWORK_NAME,
       decode(q.sharded, 1, 'TRUE', 'FALSE') SHARDED
from system.aq$_queues q, system.aq$_queue_tables t, sys.user$ u, sys.obj$ ro,
dba_services s
where u.name  = t.schema
and   q.table_objno = t.objno
and   ro.owner# = u.user#
and   ro.obj# = q.eventid
and  (ro.owner# = userenv('SCHEMAID')
      or ro.obj# in
           (select oa.obj#
            from sys.objauth$ oa
            where grantee# in (select kzsrorol from x$kzsro))
      or
        -- bug 20339374,V$ENABLEDPRIVS replaced with
        -- ora_check_sys_privilege operator to protect sys owned object
        ora_check_sys_privilege (ro.owner#, ro.type#) = 1
      or ro.obj# in
           (select q.eventid from system.aq$_queues q,
                                  system.aq$_queue_tables t
              where q.table_objno = t.objno
              and bitand(t.flags, 8) = 0
              and exists (select null from sys.objauth$ oa, sys.obj$ o
                          where oa.obj# = o.obj#
                          and (o.name = 'DBMS_AQ' or o.name = 'DBMS_AQADM')
                          and o.owner# = 0
                          and o.type# = 9
                          and oa.grantee# = userenv('SCHEMAID')))
     )
and   q.service_name = s.name (+);

   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."OWNER" IS 'Owner of the queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."NAME" IS 'Name of the queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."QUEUE_TABLE" IS 'Name of the table the queue data resides in';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."QID" IS 'Object number of the queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."QUEUE_TYPE" IS 'Type of the queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."MAX_RETRIES" IS 'Maximum number of retries allowed when dequeuing from the queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."RETRY_DELAY" IS 'Time interval between retries';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."ENQUEUE_ENABLED" IS 'Queue is enabled for enqueue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."DEQUEUE_ENABLED" IS 'Queue is enabled for dequeue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."RETENTION" IS 'Time interval processed messages retained in the queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."USER_COMMENT" IS 'User specified comment';
   COMMENT ON COLUMN "SYS"."ALL_QUEUES"."NETWORK_NAME" IS 'Network name of queue service';
   COMMENT ON TABLE "SYS"."ALL_QUEUES"  IS 'All queues accessible to the user'
;
--------------------------------------------------------
--  DDL for View _ALL_QUEUE_SCHEDULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_QUEUE_SCHEDULES" ("SCHEMA", "QNAME", "DESTINATION", "START_DATE", "START_TIME", "PROPAGATION_WINDOW", "NEXT_TIME", "LATENCY", "SCHEDULE_DISABLED", "PROCESS_NAME", "SESSION_ID", "INSTANCE", "LAST_RUN_DATE", "LAST_RUN_TIME", "CURRENT_START_DATE", "CURRENT_START_TIME", "NEXT_RUN_DATE", "NEXT_RUN_TIME", "TOTAL_TIME", "TOTAL_NUMBER", "TOTAL_BYTES", "MAX_NUMBER", "MAX_BYTES", "AVG_NUMBER", "AVG_SIZE", "AVG_TIME", "FAILURES", "LAST_ERROR_DATE", "LAST_ERROR_TIME", "LAST_ERROR_MSG", "MESSAGE_DELIVERY_MODE", "ELAPSED_DEQUEUE_TIME", "ELAPSED_PICKLE_TIME", "JOB_NAME") AS 
  select t.schema SCHEMA, q.name QNAME,
        s.destination DESTINATION,
        j.start_date START_DATE,
        substr(to_char(j.start_date,'HH24:MI:SS'),1,8) START_TIME,
        to_number(s.duration) PROPAGATION_WINDOW,
        DECODE(BITAND(j.flags,1024+4096+134217728), 0, j.schedule_expr, NULL)
        NEXT_TIME, to_number(s.latency) LATENCY,
        decode(BITAND(j.job_status,1), 0, 'Y', 'N') SCHEDULE_DISABLED,
        (select substr(v.program, LENGTH(v.program)-4, 4)
          from gv$process v where v.inst_id = j.instance_id and
          (v.con_id = sys_context('USERENV', 'CON_ID') or
           v.con_id is null and sys_context('USERENV', 'CON_ID') is null) and
          v.spid = rj.os_process_id) PROCESS_NAME,
        (select concat(to_char(rj.session_id), concat(', ', to_char(vs.serial#)))
          from gv$session vs where vs.sid = rj.session_id and
          (vs.con_id = sys_context('USERENV', 'CON_ID') OR
           vs.con_id is null and sys_context('USERENV', 'CON_ID') is null) and
          vs.inst_id = j.instance_id) SESSION_ID,
        j.instance_id INSTANCE,
        j.last_start_date LAST_RUN_DATE,
        substr(to_char(j.last_start_date,'HH24:MI:SS'),1,8) LAST_RUN_TIME,
        decode(BITAND(j.job_status,2+65536), 2, j.last_start_date, NULL) CURRENT_START_DATE,
        decode(BITAND(j.job_status,2+65536), 2, substr(to_char(j.last_start_date,'HH24:MI:SS'),1,8),NULL) CURRENT_START_TIME,
        j.next_run_date NEXT_RUN_DATE,
        substr(to_char(j.next_run_date,'HH24:MI:SS'),1,8) NEXT_RUN_TIME,
        s.total_time TOTAL_TIME,
        s.total_msgs TOTAL_NUMBER,
        s.total_bytes TOTAL_BYTES,
        s.total_msgs MAX_NUMBER, s.max_size MAX_BYTES,
        s.total_msgs/GREATEST(1, (select count (*) from dba_scheduler_job_run_details where job_name = s.job_name)) AVG_NUMBER,
        s.total_bytes/decode(s.total_msgs, 0, 1, s.total_msgs) AVG_SIZE,
        s.total_time/decode(s.total_msgs, 0, 1, s.total_msgs) AVG_TIME,
        decode(j.failure_count, 1, 16, j.retry_count) FAILURES,
        s.error_time LAST_ERROR_DATE,
        substr(to_char(s.error_time,'HH24:MI:SS'),1,8) LAST_ERROR_TIME,
        s.last_error_msg LAST_ERROR_MSG,
        'PERSISTENT' MESSAGE_DELIVERY_MODE,
        null ELAPSED_DEQUEUE_TIME, null ELAPSED_PICKLE_TIME,
        s.job_name JOB_NAME
from    system.aq$_queues q, system.aq$_queue_tables t,
        sys.aq$_schedules s, sys.scheduler$_job j,
        gv$scheduler_running_jobs rj, sys.obj$ ro, sys.obj$ jo,
        dba_services d, sys.user$ u
where   s.oid  = q.oid
and     s.job_name = jo.name
and     j.obj# = jo.obj#
and     rj.job_id (+)= j.obj#
and     q.table_objno = t.objno
and     ro.owner# = u.user#
and     ro.obj# = q.eventid
and     (rj.con_id = sys_context('USERENV', 'CON_ID') or rj.con_id IS NULL)
and    (ro.owner# = userenv('SCHEMAID')
      or ro.obj# in
           (select oa.obj#
            from sys.objauth$ oa
            where grantee# in (select kzsrorol from x$kzsro))
      or
        -- bug 20339374,V$ENABLEDPRIVS replaced with
        -- ora_check_sys_privilege operator to protect sys owned object
        ora_check_sys_privilege (ro.owner#, ro.type#) = 1
      or ro.obj# in
           (select q.eventid from system.aq$_queues q,
                                  system.aq$_queue_tables t
              where q.table_objno = t.objno
              and bitand(t.flags, 8) = 0
              and exists (select null from sys.objauth$ oa, sys.obj$ o
                          where oa.obj# = o.obj#
                          and (o.name = 'DBMS_AQ' or o.name = 'DBMS_AQADM')
                          and o.owner# = 0
                          and o.type# = 9
                          and oa.grantee# = userenv('SCHEMAID')))
     )
and   q.service_name = d.name (+)
union all
select  p.queue_schema SCHEMA, p.queue_name QNAME,
        p.dblink DESTINATION, j.start_date START_DATE,
        substr(to_char(j.start_date,'HH24:MI:SS'),1,8) START_TIME,
        to_number(s.duration) PROPAGATION_WINDOW,
        DECODE(BITAND(j.flags,1024+4096+134217728), 0, j.schedule_expr, NULL)
        NEXT_TIME,
        decode(p.schedule_status, 'SCHEDULE OPTIMIZED',
               p.last_lcr_latency, to_number(s.latency)) LATENCY,
        decode(BITAND(j.job_status,1), 0, 'Y', 'N') SCHEDULE_DISABLED,
        (select substr(v.program, LENGTH(v.program)-4, 4)
          from gv$process v where v.inst_id = j.instance_id and
          (v.con_id = sys_context('USERENV', 'CON_ID') OR
           v.con_id is null and sys_context('USERENV', 'CON_ID') is null )and
          v.spid = decode(p.schedule_status,
                          'SCHEDULE OPTIMIZED', p.spid,
                          rj.os_process_id)) PROCESS_NAME,
        case when p.schedule_status = 'SCHEDULE OPTIMIZED'
             then (p.session_id || ', ' || p.serial#)
             else (select concat(to_char(rj.session_id),
                          concat(', ', to_char(vs.serial#)))
                   from gv$session vs
                   where vs.sid = rj.session_id and vs.inst_id = j.instance_id
                   and (vs.con_id = sys_context('USERENV', 'CON_ID') OR
                        vs.con_id is null AND
                    sys_context('USERENV', 'CON_ID') is null))
        end SESSION_ID,
        j.instance_id INSTANCE,
        decode(p.schedule_status, 'SCHEDULE OPTIMIZED',
               cast(p.last_lcr_propagation_time as timestamp with time zone), j.last_start_date)
        LAST_RUN_DATE,
        decode(p.schedule_status, 'SCHEDULE OPTIMIZED',
               substr(to_char(p.last_lcr_propagation_time, 'HH24:MI:SS'),1,8),
               substr(to_char(j.last_start_date,'HH24:MI:SS'),1,8))
        LAST_RUN_TIME,
        decode(BITAND(j.job_status,2+65536),2, j.last_start_date,
               decode(p.schedule_status, 'SCHEDULE OPTIMIZED',
                      cast(p.startup_time as timestamp with time zone), NULL))
        CURRENT_START_DATE,
        decode(BITAND(j.job_status,2+65536),2,
               substr(to_char(j.last_start_date,'HH24:MI:SS'),1,8),
               decode(p.schedule_status, 'SCHEDULE OPTIMIZED',
                      substr(to_char(p.startup_time,'HH24:MI:SS'),1,8), NULL))
        CURRENT_START_TIME,
        j.next_run_date NEXT_RUN_DATE,
        substr(to_char(j.next_run_date,'HH24:MI:SS'),1,8) NEXT_RUN_TIME,
        p.elapsed_propagation_time/100 TOTAL_TIME, p.total_msgs TOTAL_NUMBER,
        p.total_bytes TOTAL_BYTES,
        p.max_num_per_win MAX_NUMBER, p.max_size MAX_BYTES,
        p.total_msgs/GREATEST(1, (select count (*) from dba_scheduler_job_run_details where job_name = s.job_name)) AVG_NUMBER,
        p.total_bytes/decode(p.total_msgs, 0, 1, p.total_msgs) AVG_SIZE,
        (p.elapsed_propagation_time/100)/decode(p.total_msgs, 0, 1, p.total_msgs) AVG_TIME,
        decode(p.schedule_status, 'SCHEDULE OPTIMIZED', 0,
                decode(j.failure_count, 1, 16, j.retry_count)) FAILURES,
        decode(p.schedule_status, 'SCHEDULE OPTIMIZED', to_date(NULL),
               s.error_time) LAST_ERROR_DATE,
        decode(p.schedule_status, 'SCHEDULE OPTIMIZED', NULL,
               substr(to_char(s.error_time,'HH24:MI:SS'),1,8)) LAST_ERROR_TIME,
        decode(p.schedule_status, 'SCHEDULE OPTIMIZED', NULL,
               s.last_error_msg) LAST_ERROR_MSG,
        'BUFFERED' MESSAGE_DELIVERY_MODE,
        p.elapsed_dequeue_time/100 ELAPSED_DEQUEUE_TIME,
        p.elapsed_pickle_time/100 ELAPSED_PICKLE_TIME,
        s.job_name JOB_NAME
from    system.aq$_queues q, gv$propagation_sender p,
        sys.aq$_schedules s, sys.scheduler$_job j, obj$ jo,
        gv$scheduler_running_jobs rj,sys.obj$ ro,
        dba_services d, sys.user$ u
where   q.eventid = p.queue_id
  and   q.oid = s.oid
  and   s.job_name = jo.name
  and   jo.obj# = j.obj#
  and   rj.job_id (+)= j.obj#
  and   p.dblink = s.destination
  and   ro.owner# = u.user#
  and   ro.obj# = q.eventid
  and  (p.con_id = sys_context('USERENV', 'CON_ID') or p.con_id IS NULL AND sys_context('USERENV', 'CON_ID') IS NULL)
  and  (rj.con_id = sys_context('USERENV', 'CON_ID') or rj.con_id IS NULL)
  and  (ro.owner# = userenv('SCHEMAID')
      or ro.obj# in
           (select oa.obj#
            from sys.objauth$ oa
            where grantee# in (select kzsrorol from x$kzsro))
 -- bug 20339374,V$ENABLEDPRIVS replaced with
 -- ora_check_sys_privilege operator to protect sys owned object
      or   ora_check_sys_privilege (ro.owner#, ro.type#) = 1
      or ro.obj# in
           (select q.eventid from system.aq$_queues q,
                                  system.aq$_queue_tables t
              where q.table_objno = t.objno
              and bitand(t.flags, 8) = 0
              and exists (select null from sys.objauth$ oa, sys.obj$ o
                          where oa.obj# = o.obj#
                          and (o.name = 'DBMS_AQ' or o.name = 'DBMS_AQADM')
                          and o.owner# = 0
                          and o.type# = 9
                          and oa.grantee# = userenv('SCHEMAID')))
     )
  and   q.service_name = d.name (+)
;
--------------------------------------------------------
--  DDL for View ALL_QUEUE_SCHEDULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_QUEUE_SCHEDULES" ("SCHEMA", "QNAME", "DESTINATION", "START_DATE", "START_TIME", "PROPAGATION_WINDOW", "NEXT_TIME", "LATENCY", "SCHEDULE_DISABLED", "PROCESS_NAME", "SESSION_ID", "INSTANCE", "LAST_RUN_DATE", "LAST_RUN_TIME", "CURRENT_START_DATE", "CURRENT_START_TIME", "NEXT_RUN_DATE", "NEXT_RUN_TIME", "TOTAL_TIME", "TOTAL_NUMBER", "TOTAL_BYTES", "MAX_NUMBER", "MAX_BYTES", "AVG_NUMBER", "AVG_SIZE", "AVG_TIME", "FAILURES", "LAST_ERROR_DATE", "LAST_ERROR_TIME", "LAST_ERROR_MSG", "MESSAGE_DELIVERY_MODE", "ELAPSED_DEQUEUE_TIME", "ELAPSED_PICKLE_TIME", "JOB_NAME") AS 
  select  "SCHEMA","QNAME","DESTINATION","START_DATE","START_TIME","PROPAGATION_WINDOW","NEXT_TIME","LATENCY","SCHEDULE_DISABLED","PROCESS_NAME","SESSION_ID","INSTANCE","LAST_RUN_DATE","LAST_RUN_TIME","CURRENT_START_DATE","CURRENT_START_TIME","NEXT_RUN_DATE","NEXT_RUN_TIME","TOTAL_TIME","TOTAL_NUMBER","TOTAL_BYTES","MAX_NUMBER","MAX_BYTES","AVG_NUMBER","AVG_SIZE","AVG_TIME","FAILURES","LAST_ERROR_DATE","LAST_ERROR_TIME","LAST_ERROR_MSG","MESSAGE_DELIVERY_MODE","ELAPSED_DEQUEUE_TIME","ELAPSED_PICKLE_TIME","JOB_NAME" from  "_ALL_QUEUE_SCHEDULES"
;
--------------------------------------------------------
--  DDL for View ALL_QUEUE_SUBSCRIBERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_QUEUE_SUBSCRIBERS" ("OWNER", "QUEUE_NAME", "QUEUE_TABLE", "CONSUMER_NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "RULE", "DELIVERY_MODE", "IF_NONDURABLE_SUBSCRIBER", "QUEUE_TO_QUEUE", "SUBSCRIBER_ID", "POS_BITMAP") AS 
  select su.owner OWNER, su.queue_name QUEUE_NAME, su.queue_table QUEUE_TABLE,
       su.consumer_name CONSUMER_NAME, su.address ADDRESS,
       su.protocol PROTOCOL, su.transformation TRANSFORMATION,
       r.rule_condition RULE,
       decode(bitand(su.sub_type, 192), 64, 'PERSISTENT',
                                         128, 'BUFFERED',
                                         192, 'PERSISTENT_OR_BUFFERED',
                                         'NONE') DELIVERY_MODE,
       decode(bitand(su.sub_type, 32960), 32960, 'YES',
                                       'NO') IF_NONDURABLE_SUBSCRIBER,
       decode(bitand(su.sub_type, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE,
       su.subscriber_id SUBSCRIBER_ID,
       su.pos_bitmap POS_BITMAP
FROM   ( select  u.name OWNER, q.name QUEUE_NAME, t.name QUEUE_TABLE,
                 s.name CONSUMER_NAME, s.address ADDRESS, s.protocol PROTOCOL,
                 s.trans_name TRANSFORMATION, s.sub_type SUB_TYPE,
                 s.rule_name RULE_NAME, s.subscriber_id SUBSCRIBER_ID,
                 s.pos_bitmap POS_BITMAP
         FROM    system.aq$_queues q, system.aq$_queue_tables t, sys.user$ u,
                 sys.obj$ ro, sys.user$ cu,
                 TABLE(aq$_get_subscribers(u.name, q.name, t.name,
                                           cu.name, q.eventid, t.flags)) s
         where u.name  = t.schema
         and   q.table_objno = t.objno
         and   bitand(t.flags, 1) = 1 and q.usage!=1
         and   ro.owner# = u.user#
         and   ro.obj# = q.eventid
         and   cu.user# = userenv('SCHEMAID')
         and  (ro.owner# = userenv('SCHEMAID')
               or ro.obj# in
                    (select oa.obj#
                     from sys.objauth$ oa
                     where oa.privilege# in (21, 41) and
                           grantee# in (select kzsrorol from x$kzsro))
                 or ((ro.owner# != 0) and exists (select null from v$enabledprivs
                     where priv_number = -220))
               or ro.obj# in
                    (select q.eventid from system.aq$_queues q,
                                           system.aq$_queue_tables t
                     where q.table_objno = t.objno
                     and bitand(t.flags, 8) = 0
                     and exists (select null from sys.objauth$ oa, sys.obj$ o
                                 where oa.obj# = o.obj#
                                 and (o.name = 'DBMS_AQ'
                                      or o.name = 'DBMS_AQADM')
                                 and o.owner# = 0
                                 and o.type# = 9
                                 and oa.grantee# = userenv('SCHEMAID')))
              )
       ) su, sys.dba_rules r
where su.rule_name = r.rule_name(+)
and   su.owner = r.rule_owner(+);

   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."OWNER" IS 'owner of the queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."QUEUE_NAME" IS 'name of the queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."QUEUE_TABLE" IS 'name of the queue table';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."CONSUMER_NAME" IS 'name of the subscriber';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."ADDRESS" IS 'address of the subscriber';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."PROTOCOL" IS 'protocol of the subscriber';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."TRANSFORMATION" IS 'transformation for the subscriber';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."RULE" IS 'rule condition for the subscriber';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."DELIVERY_MODE" IS 'message delivery mode for the subscriber';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."QUEUE_TO_QUEUE" IS 'whether the subscriber is a queue to queue subscriber';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."SUBSCRIBER_ID" IS 'id of subscriber';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_SUBSCRIBERS"."POS_BITMAP" IS 'position of subscriber in the bitmap';
   COMMENT ON TABLE "SYS"."ALL_QUEUE_SUBSCRIBERS"  IS 'All queue subscribers accessible to user'
;
--------------------------------------------------------
--  DDL for View ALL_QUEUE_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_QUEUE_TABLES" ("OWNER", "QUEUE_TABLE", "TYPE", "OBJECT_TYPE", "SORT_ORDER", "RECIPIENTS", "MESSAGE_GROUPING", "REPLICATION_MODE", "COMPATIBLE", "PRIMARY_INSTANCE", "SECONDARY_INSTANCE", "OWNER_INSTANCE", "USER_COMMENT", "SECURE") AS 
  select t.schema OWNER, t.name QUEUE_TABLE,
     decode(t.udata_type, 1 , 'OBJECT', 2, 'VARIANT', 3, 'RAW', 5, 'JMS_BYTES') TYPE,
     u.name || '.' || o.name OBJECT_TYPE,
     decode(t.sort_cols, 0, 'NONE', 1, 'PRIORITY', 2, 'ENQUEUE_TIME',
                               3, 'PRIORITY, ENQUEUE_TIME',
                               4, 'COMMIT_TIME',
                               5, 'PRIORITY, COMMIT_TIME',
                               7, 'ENQUEUE_TIME, PRIORITY') SORT_ORDER,
     decode(bitand(t.flags, 1), 1, 'MULTIPLE', 0, 'SINGLE') RECIPIENTS,
     decode(bitand(t.flags, 2), 2, 'TRANSACTIONAL', 0, 'NONE')MESSAGE_GROUPING,
     decode(bitand(t.flags, 1073741824), 1073741824, 'REPLICATED_SOURCE',
            decode(bitand(t.flags,536870912), 536870912,
                   'REPLICATED_DESTINATION'))REPLICATION_MODE,
     decode(bitand(t.flags, 67108864), 67108864, '10.0.0', 0, /* KWQI_QT_12G = 67108864 */
                   (decode(bitand(t.flags, 8192+8), 8192+8, '10.0.0', 8, '8.1.3', 0, '8.0.3'))) COMPATIBLE,
     aft.primary_instance PRIMARY_INSTANCE,
     aft.secondary_instance SECONDARY_INSTANCE,
     aft.owner_instance OWNER_INSTANCE,
     substrb(t.table_comment, 1, 50) USER_COMMENT,
     decode(bitand(t.flags, 4096), 4096, 'YES', 0, 'NO') SECURE
from system.aq$_queue_tables t, sys.col$ c, sys.coltype$ ct, sys.obj$ o,
sys.user$ u, sys.aq$_queue_table_affinities aft
where c.intcol# = ct.intcol#
and c.obj# = ct.obj#
and c.name = 'USER_DATA'
and t.objno = c.obj#
and o.oid$ = ct.toid
and o.type# = 13
and o.owner# = u.user#
and t.objno = aft.table_objno
and t.objno in
(select q.table_objno
 from system.aq$_queues q, sys.obj$ ro
 where ro.obj# = q.eventid
 and (ro.owner# = userenv('SCHEMAID')
      or ro.obj# in
           (select oa.obj#
            from sys.objauth$ oa
            where grantee# in (select kzsrorol from x$kzsro))
      or
         -- bug 20339374,V$ENABLEDPRIVS replaced with
         -- ora_check_sys_privilege operator to protect sys owned object
        ora_check_sys_privilege (ro.owner#, ro.type#) = 1
      or ro.obj# in
           (select q.eventid from system.aq$_queues q,
                                  system.aq$_queue_tables t
              where q.table_objno = t.objno
              and bitand(t.flags, 8) = 0
              and exists (select null from sys.objauth$ oa, sys.obj$ o
                          where oa.obj# = o.obj#
                          and (o.name = 'DBMS_AQ' or o.name = 'DBMS_AQADM')
                          and o.owner# = 0
                          and o.type# = 9
                          and oa.grantee# = userenv('SCHEMAID')))
     )
)
union
select t.schema OWNER, t.name QUEUE_TABLE,
     decode(t.udata_type, 1 , 'OBJECT', 2, 'VARIANT', 3, 'RAW', 5, 'JMS_BYTES') TYPE,
     null OBJECT_TYPE,
     decode(t.sort_cols, 0, 'NONE', 1, 'PRIORITY', 2, 'ENQUEUE_TIME',
                               3, 'PRIORITY, ENQUEUE_TIME',
                               4, 'COMMIT_TIME',
                               5, 'PRIORITY, COMMIT_TIME',
                               7, 'ENQUEUE_TIME, PRIORITY') SORT_ORDER,
     decode(bitand(t.flags, 1), 1, 'MULTIPLE', 0, 'SINGLE') RECIPIENTS,
     decode(bitand(t.flags, 2), 2, 'TRANSACTIONAL', 0, 'NONE')MESSAGE_GROUPING,
     decode(bitand(t.flags, 1073741824), 1073741824, 'REPLICATED_SOURCE',
            decode(bitand(t.flags,536870912), 536870912,
                   'REPLICATED_DESTINATION'))REPLICATION_MODE,
     decode(bitand(t.flags, 67108864), 67108864, '10.0.0', 0, /* KWQI_QT_12G = 67108864 */
                   (decode(bitand(t.flags, 8192+8), 8192+8, '10.0.0', 8, '8.1.3', 0, '8.0.3'))) COMPATIBLE,
     aft.primary_instance PRIMARY_INSTANCE,
     aft.secondary_instance SECONDARY_INSTANCE,
     aft.owner_instance OWNER_INSTANCE,
     substrb(t.table_comment, 1, 50) USER_COMMENT,
     decode(bitand(t.flags, 4096), 4096, 'YES', 0, 'NO') SECURE
from system.aq$_queue_tables t, sys.aq$_queue_table_affinities aft
where (t.udata_type = 2
or t.udata_type = 3 or t.udata_type = 5)
and t.objno = aft.table_objno
and t.objno in
(select q.table_objno
 from system.aq$_queues q, sys.obj$ ro
 where ro.obj# = q.eventid
 and (ro.owner# = userenv('SCHEMAID')
      or ro.obj# in
           (select oa.obj#
            from sys.objauth$ oa
            where grantee# in (select kzsrorol from x$kzsro))
      or
         -- bug 20339374,V$ENABLEDPRIVS replaced with
         -- ora_check_sys_privilege operator to protect sys owned object
         ora_check_sys_privilege (ro.owner#, ro.type#) = 1
      or ro.obj# in
           (select q.eventid from system.aq$_queues q,
                                  system.aq$_queue_tables t
              where q.table_objno = t.objno
              and bitand(t.flags, 8) = 0
              and exists (select null from sys.objauth$ oa, sys.obj$ o
                          where oa.obj# = o.obj#
                          and (o.name = 'DBMS_AQ' or o.name = 'DBMS_AQADM')
                          and o.owner# = 0
                          and o.type# = 9
                          and oa.grantee# = userenv('SCHEMAID')))
     )
);

   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."OWNER" IS 'Owner of the queue table';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."QUEUE_TABLE" IS 'Name of the queue table';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."TYPE" IS 'Name of the payload type';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."OBJECT_TYPE" IS 'Name of the payload type for object type payload';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."SORT_ORDER" IS 'Sort order for the queue table';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."RECIPIENTS" IS 'Mulitple or single recipient queue';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."MESSAGE_GROUPING" IS 'Transaction grouping';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."COMPATIBLE" IS 'Compatibility version of the queue table';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."PRIMARY_INSTANCE" IS 'Instance assigned as the primary owner of the queue table';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."SECONDARY_INSTANCE" IS 'Instance assigned as the secondary owner of the queue table';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."OWNER_INSTANCE" IS 'Instance which owns the queue table currently';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."USER_COMMENT" IS 'User specified comment';
   COMMENT ON COLUMN "SYS"."ALL_QUEUE_TABLES"."SECURE" IS 'Secure queue table';
   COMMENT ON TABLE "SYS"."ALL_QUEUE_TABLES"  IS 'All queue tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_REFRESH
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REFRESH" ("ROWNER", "RNAME", "REFGROUP", "IMPLICIT_DESTROY", "PUSH_DEFERRED_RPC", "REFRESH_AFTER_ERRORS", "ROLLBACK_SEG", "JOB", "NEXT_DATE", "INTERVAL", "BROKEN", "PURGE_OPTION", "PARALLELISM", "HEAP_SIZE", "JOB_NAME") AS 
  select "ROWNER","RNAME","REFGROUP","IMPLICIT_DESTROY","PUSH_DEFERRED_RPC","REFRESH_AFTER_ERRORS","ROLLBACK_SEG","JOB","NEXT_DATE","INTERVAL","BROKEN","PURGE_OPTION","PARALLELISM","HEAP_SIZE","JOB_NAME" from dba_refresh where
  ( rowner = (select name from sys.user$ where user# = userenv('SCHEMAID')))
  or userenv('SCHEMAID') = 0 or exists
  (select kzsrorol
     from x$kzsro x, sys.system_privilege_map m, sys.sysauth$ s
     where x.kzsrorol = s.grantee# and
           s.privilege# = m.privilege and
           m.name = 'ALTER ANY MATERIALIZED VIEW');

   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."ROWNER" IS 'Name of the owner of the refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."RNAME" IS 'Name of the refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."REFGROUP" IS 'Internal identifier of refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."IMPLICIT_DESTROY" IS 'Y or N, if Y then destroy the refresh group when its last item is subtracted';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."PUSH_DEFERRED_RPC" IS 'Y or N, if Y then push changes from snapshot to master before refresh';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."REFRESH_AFTER_ERRORS" IS 'If Y, proceed with refresh despite error when pushing deferred RPCs';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."ROLLBACK_SEG" IS 'Name of the rollback segment to use while refreshing';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."JOB" IS 'Identifier of job used to automatically refresh the group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."NEXT_DATE" IS 'Date that this job will next be automatically refreshed, if not broken';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."INTERVAL" IS 'A date function used to compute the next NEXT_DATE';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."BROKEN" IS 'Y or N, Y is the job is broken and will never be run';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."PURGE_OPTION" IS 'The method for purging the transaction queue after each push';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."PARALLELISM" IS 'The level of parallelism for transaction propagation';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH"."HEAP_SIZE" IS 'The heap size used for transaction propagation';
   COMMENT ON TABLE "SYS"."ALL_REFRESH"  IS 'All the refresh groups that the user can touch'
;
--------------------------------------------------------
--  DDL for View ALL_REFRESH_CHILDREN
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REFRESH_CHILDREN" ("OWNER", "NAME", "TYPE", "ROWNER", "RNAME", "REFGROUP", "IMPLICIT_DESTROY", "PUSH_DEFERRED_RPC", "REFRESH_AFTER_ERRORS", "ROLLBACK_SEG", "JOB", "NEXT_DATE", "INTERVAL", "BROKEN", "PURGE_OPTION", "PARALLELISM", "HEAP_SIZE", "JOB_NAME") AS 
  select "OWNER","NAME","TYPE","ROWNER","RNAME","REFGROUP","IMPLICIT_DESTROY","PUSH_DEFERRED_RPC","REFRESH_AFTER_ERRORS","ROLLBACK_SEG","JOB","NEXT_DATE","INTERVAL","BROKEN","PURGE_OPTION","PARALLELISM","HEAP_SIZE","JOB_NAME" from dba_refresh_children where
 ( rowner = (select name from sys.user$ where user# = userenv('SCHEMAID')))
  or userenv('SCHEMAID') = 0 or exists
  (select kzsrorol
     from x$kzsro x, sys.system_privilege_map m, sys.sysauth$ s
     where x.kzsrorol = s.grantee# and
           s.privilege# = m.privilege and
           m.name = 'ALTER ANY MATERIALIZED VIEW');

   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."OWNER" IS 'Owner of the object in the refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."NAME" IS 'Name of the object in the refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."TYPE" IS 'Type of the object in the refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."ROWNER" IS 'Name of the owner of the refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."RNAME" IS 'Name of the refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."REFGROUP" IS 'Internal identifier of refresh group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."IMPLICIT_DESTROY" IS 'Y or N, if Y then destroy the refresh group when its last item is subtracted';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."PUSH_DEFERRED_RPC" IS 'Y or N, if Y then push changes from snapshot to master before refresh';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."REFRESH_AFTER_ERRORS" IS 'If Y, proceed with refresh despite error when pushing deferred RPCs';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."ROLLBACK_SEG" IS 'Name of the rollback segment to use while refreshing';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."JOB" IS 'Identifier of job used to automatically refresh the group';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."NEXT_DATE" IS 'Date that this job will next be automatically refreshed, if not broken';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."INTERVAL" IS 'A date function used to compute the next NEXT_DATE';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."BROKEN" IS 'Y or N, Y is the job is broken and will never be run';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."PURGE_OPTION" IS 'The method for purging the transaction queue after each push';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."PARALLELISM" IS 'The level of parallelism for transaction propagation';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_CHILDREN"."HEAP_SIZE" IS 'The heap size used for transaction propagation';
   COMMENT ON TABLE "SYS"."ALL_REFRESH_CHILDREN"  IS 'All the objects in refresh groups, where the user can touch the group'
;
--------------------------------------------------------
--  DDL for View ALL_REFRESH_DEPENDENCIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REFRESH_DEPENDENCIES" ("OWNER", "TABLE_NAME", "PARENT_OBJECT_TYPE", "OLDEST_REFRESH_SCN", "OLDEST_REFRESH_DATE") AS 
  select u.name, o.name, 'MATERIALIZED VIEW', dep.lastrefreshscn,
       dep.lastrefreshdate
from (select dt.obj#,
             min(dt.lastrefreshscn) as lastrefreshscn,
             min(dt.lastrefreshdate) as lastrefreshdate
      from
           (select d.p_obj# as obj#, s.lastrefreshscn, s.lastrefreshdate
            from sumdep$ d, sum$ s, obj$ do
            where d.sumobj# = s.obj#
              and d.sumobj# = do.obj#
              and do.type# IN (4, 42)
            union
            select sl.tableobj# as obj#,
                   decode(0, 1, 2, NULL) as lastrefreshscn,
                   sl.oldest  as lastrefreshdate
            from snap_loadertime$ sl) dt
      group by dt.obj#) dep, obj$ o, user$ u
where o.obj# = dep.obj#
  and o.owner# = u.user#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in (select oa.obj# from sys.objauth$ oa
                     where grantee# in (select kzsrorol from x$kzsro)
                    )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
       );

   COMMENT ON COLUMN "SYS"."ALL_REFRESH_DEPENDENCIES"."OWNER" IS 'Owner of the dependent table';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_DEPENDENCIES"."TABLE_NAME" IS 'Name of the dependent table';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_DEPENDENCIES"."PARENT_OBJECT_TYPE" IS 'Materialized View';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_DEPENDENCIES"."OLDEST_REFRESH_SCN" IS 'The oldest scn of a dependent materialized view';
   COMMENT ON COLUMN "SYS"."ALL_REFRESH_DEPENDENCIES"."OLDEST_REFRESH_DATE" IS 'The oldest date scn of a dependent materialized view';
   COMMENT ON TABLE "SYS"."ALL_REFRESH_DEPENDENCIES"  IS 'Description of the detail tables that materialized views depend on for
refresh'
;
--------------------------------------------------------
--  DDL for View ALL_REFS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REFS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "WITH_ROWID", "IS_SCOPED", "SCOPE_TABLE_OWNER", "SCOPE_TABLE_NAME", "OBJECT_ID_TYPE") AS 
  select distinct u.name, o.name,
       decode(bitand(c.property, 1), 1, ac.name, c.name),
       decode(bitand(rc.reftyp, 2), 2, 'YES', 'NO'),
       decode(bitand(rc.reftyp, 1), 1, 'YES', 'NO'),
       su.name, so.name,
       case
         when bitand(reftyp,4) = 4 then 'USER-DEFINED'
         when bitand(reftyp, 8) = 8 then 'SYSTEM GENERATED AND USER-DEFINED'
         else 'SYSTEM GENERATED'
       end
from sys.user$ u, sys.obj$ o, sys.col$ c, sys.refcon$ rc, sys.obj$ so,
     sys.user$ su, sys.attrcol$ ac
where o.owner# = u.user#
  and o.obj# = c.obj#
  and c.obj# = rc.obj#
  and c.col# = rc.col#
  and c.intcol# = rc.intcol#
  and rc.stabid = so.oid$(+)
  and so.owner# = su.user#(+)
  and c.obj# = ac.obj#(+)
  and c.intcol# = ac.intcol#(+)
  and bitand(c.property,32768) != 32768           /* not unused column */
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
          ora_check_sys_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_REFS"."OWNER" IS 'Owner of the table containing the REF column';
   COMMENT ON COLUMN "SYS"."ALL_REFS"."TABLE_NAME" IS 'Name of the table containing the REF column';
   COMMENT ON COLUMN "SYS"."ALL_REFS"."COLUMN_NAME" IS 'Column name or attribute of object column';
   COMMENT ON COLUMN "SYS"."ALL_REFS"."WITH_ROWID" IS 'Is the REF value stored with the rowid?';
   COMMENT ON COLUMN "SYS"."ALL_REFS"."IS_SCOPED" IS 'Is the REF column scoped?';
   COMMENT ON COLUMN "SYS"."ALL_REFS"."SCOPE_TABLE_OWNER" IS 'Owner of the scope table, if it exists';
   COMMENT ON COLUMN "SYS"."ALL_REFS"."SCOPE_TABLE_NAME" IS 'Name of the scope table, if it exists';
   COMMENT ON COLUMN "SYS"."ALL_REFS"."OBJECT_ID_TYPE" IS 'If ref contains user-defined OID, then USER-DEFINED, else if it contains system
 generated OID, then SYSTEM GENERATED';
   COMMENT ON TABLE "SYS"."ALL_REFS"  IS 'Description of REF columns contained in tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_REGISTERED_MVIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REGISTERED_MVIEWS" ("OWNER", "NAME", "MVIEW_SITE", "CAN_USE_LOG", "UPDATABLE", "REFRESH_METHOD", "MVIEW_ID", "VERSION", "QUERY_TXT") AS 
  select  "OWNER","NAME","MVIEW_SITE","CAN_USE_LOG","UPDATABLE","REFRESH_METHOD","MVIEW_ID","VERSION","QUERY_TXT" from dba_registered_mviews s
where exists (select a.mview_id from all_base_table_mviews a
                             where  s.mview_id = a.mview_id)
or  userenv('SCHEMAID') = 1
or  ora_check_sys_privilege(userenv('SCHEMAID'), 2) = 1;

   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."OWNER" IS 'Owner of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."NAME" IS 'The name of the materialized view';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."MVIEW_SITE" IS 'Global name of the materialized view site';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."CAN_USE_LOG" IS 'If NO, this materialized view is complex and cannot fast refresh';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."UPDATABLE" IS 'If NO, the materialized view is read only';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."REFRESH_METHOD" IS 'Whether the materialized view uses rowid or primary key or object id for fast refresh';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."MVIEW_ID" IS 'Identifier for the materialized view used by the master for fast refresh';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."VERSION" IS 'Version of materialized view';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_MVIEWS"."QUERY_TXT" IS 'Query defining the materialized view';
   COMMENT ON TABLE "SYS"."ALL_REGISTERED_MVIEWS"  IS 'Remote materialized views of local tables that the user can see'
;
--------------------------------------------------------
--  DDL for View ALL_REGISTERED_SNAPSHOTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REGISTERED_SNAPSHOTS" ("OWNER", "NAME", "SNAPSHOT_SITE", "CAN_USE_LOG", "UPDATABLE", "REFRESH_METHOD", "SNAPSHOT_ID", "VERSION", "QUERY_TXT") AS 
  select  "OWNER","NAME","SNAPSHOT_SITE","CAN_USE_LOG","UPDATABLE","REFRESH_METHOD","SNAPSHOT_ID","VERSION","QUERY_TXT" from dba_registered_snapshots s
where exists (select a.snapshot_id from  all_snapshot_logs a
                             where  s.snapshot_id = a.snapshot_id)
or  userenv('SCHEMAID') = 1
or  ora_check_sys_privilege(userenv('SCHEMAID'), 2) = 1;

   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."OWNER" IS 'Owner of the snapshot';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."NAME" IS 'The name of the snapshot';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."SNAPSHOT_SITE" IS 'Global name of the snapshot site';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."CAN_USE_LOG" IS 'If NO, this snapshot is complex and cannot fast refresh';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."UPDATABLE" IS 'If NO, the snapshot is read only';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."REFRESH_METHOD" IS 'Whether the snapshot uses rowid or primary key or object id for fast refresh';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."SNAPSHOT_ID" IS 'Identifier for the snapshot used by the master for fast refresh';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."VERSION" IS 'Version of snapshot';
   COMMENT ON COLUMN "SYS"."ALL_REGISTERED_SNAPSHOTS"."QUERY_TXT" IS 'Query defining the snapshot';
   COMMENT ON TABLE "SYS"."ALL_REGISTERED_SNAPSHOTS"  IS 'Remote snapshots of local tables that the user can see'
;
--------------------------------------------------------
--  DDL for View ALL_REGISTRY_BANNERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REGISTRY_BANNERS" ("BANNER", "BANNER_FULL") AS 
  SELECT banner, banner_full FROM registry$
WHERE status = 1
;
--------------------------------------------------------
--  DDL for View ALL_REPL_DBNAME_MAPPING
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REPL_DBNAME_MAPPING" ("SOURCE_ROOT_NAME", "SOURCE_DATABASE_NAME", "SOURCE_CONTAINER_NAME") AS 
  select
  source_root_name, source_database_name, source_container_name
from repl$_dbname_mapping;

   COMMENT ON COLUMN "SYS"."ALL_REPL_DBNAME_MAPPING"."SOURCE_ROOT_NAME" IS 'The fully qualified global name of the root container in a consolidated database where the LCRs originated';
   COMMENT ON COLUMN "SYS"."ALL_REPL_DBNAME_MAPPING"."SOURCE_DATABASE_NAME" IS 'The fully qualified global name of the database where the LCRs originated';
   COMMENT ON COLUMN "SYS"."ALL_REPL_DBNAME_MAPPING"."SOURCE_CONTAINER_NAME" IS 'The short container name of the database where the LCRs originated';
   COMMENT ON TABLE "SYS"."ALL_REPL_DBNAME_MAPPING"  IS 'Details about the database name mapping'
;
--------------------------------------------------------
--  DDL for View ALL_REPLICATION_PROCESS_EVENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REPLICATION_PROCESS_EVENTS" ("STREAMS_TYPE", "PROCESS_TYPE", "STREAMS_NAME", "EVENT_NAME", "DESCRIPTION", "EVENT_TIME", "ERROR_NUMBER", "ERROR_MESSAGE") AS 
  select DECODE(streams_type,
                0, 'STREAMS',
                1, 'XSTREAM',
                2, 'GOLDENGATE',
                   'UNDEFINED'),
       DECODE(process_type,
                1, 'CAPTURE',
                2, 'PROPAGATION SENDER',
                3, 'PROPAGATION RECEIVER',
                4, '',
                5, 'QUEUE',
                6, 'APPLY READER',
                7, 'APPLY SERVER',
                8, 'APPLY COORDINATOR',
                9, 'APPLY NETWORK RECEIVER',
                10, 'SYNCHRONOUS CAPTURE',
                11, 'CAPTURE SERVER',
                12, 'PROPAGATION SENDER+RECEIVER',
                13, 'MANUAL ERROR EXECUTION',
                14, 'APPLY HASH',
                    'UNDEFINED'),
        streams_name, event_name, description, event_time, error_number,
        error_message
from repl$_process_events;

   COMMENT ON COLUMN "SYS"."ALL_REPLICATION_PROCESS_EVENTS"."STREAMS_TYPE" IS 'Streams type: Streams, XStream, GoldenGate';
   COMMENT ON COLUMN "SYS"."ALL_REPLICATION_PROCESS_EVENTS"."PROCESS_TYPE" IS 'Process type: Capture, Capture server, Apply Coordinator, Apply Server,
Apply Network Receiver, Apply Reader, Apply Hash server.';
   COMMENT ON COLUMN "SYS"."ALL_REPLICATION_PROCESS_EVENTS"."STREAMS_NAME" IS 'Streams name';
   COMMENT ON COLUMN "SYS"."ALL_REPLICATION_PROCESS_EVENTS"."EVENT_NAME" IS 'EVENT NAME: START, STOP, ABORT, CREATE, DROP, PARAMETER CHANGE,
 HANDLER CREATE, HANDLER REMOVE, ALTER';
   COMMENT ON COLUMN "SYS"."ALL_REPLICATION_PROCESS_EVENTS"."DESCRIPTION" IS 'Event Description';
   COMMENT ON COLUMN "SYS"."ALL_REPLICATION_PROCESS_EVENTS"."EVENT_TIME" IS 'Time when the event ocurred';
   COMMENT ON COLUMN "SYS"."ALL_REPLICATION_PROCESS_EVENTS"."ERROR_NUMBER" IS 'Error Number (valid when event is Error)';
   COMMENT ON COLUMN "SYS"."ALL_REPLICATION_PROCESS_EVENTS"."ERROR_MESSAGE" IS 'Error Message (valid when event is Error)';
   COMMENT ON TABLE "SYS"."ALL_REPLICATION_PROCESS_EVENTS"  IS 'Dictionary table for the replication processes events'
;
--------------------------------------------------------
--  DDL for View ALL_REWRITE_EQUIVALENCES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_REWRITE_EQUIVALENCES" ("OWNER", "NAME", "SOURCE_STMT", "DESTINATION_STMT", "REWRITE_MODE") AS 
  select m."OWNER",m."NAME",m."SOURCE_STMT",m."DESTINATION_STMT",m."REWRITE_MODE" from dba_rewrite_equivalences m, sys.obj$ o, sys.user$ u
where o.owner# = u.user#
  and m.name   = o.name
  and u.name   = m.owner
  and ( o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
        or /* user has system privileges */
        ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_REWRITE_EQUIVALENCES"."OWNER" IS 'Owner of the rewrite equivalence';
   COMMENT ON COLUMN "SYS"."ALL_REWRITE_EQUIVALENCES"."NAME" IS 'Name of the rewrite equivalence';
   COMMENT ON COLUMN "SYS"."ALL_REWRITE_EQUIVALENCES"."SOURCE_STMT" IS 'Source statement of the rewrite equivalence';
   COMMENT ON COLUMN "SYS"."ALL_REWRITE_EQUIVALENCES"."DESTINATION_STMT" IS 'Destination of the rewrite equivalence';
   COMMENT ON COLUMN "SYS"."ALL_REWRITE_EQUIVALENCES"."REWRITE_MODE" IS 'Rewrite mode of the rewrite equivalence';
   COMMENT ON TABLE "SYS"."ALL_REWRITE_EQUIVALENCES"  IS 'Description of all rewrite equivalence accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_RULES" ("RULE_OWNER", "RULE_NAME", "RULE_CONDITION", "RULE_EVALUATION_CONTEXT_OWNER", "RULE_EVALUATION_CONTEXT_NAME", "RULE_ACTION_CONTEXT", "RULE_COMMENT") AS 
  SELECT /*+ all_rows */
       u.name, o.name, r.condition, bu.name, bo.name, r.r_action, r.r_comment
FROM   rule$ r, obj$ o, user$ u, obj$ bo, user$ bu
WHERE  r.obj# = o.obj# and
       (o.owner# in (USERENV('SCHEMAID'), 1 /* PUBLIC */) or
        o.obj# in (select oa.obj# from sys.objauth$ oa
                   where grantee# in (select kzsrorol from x$kzsro))
       or
         -- bug 20339374,V$ENABLEDPRIVS replaced with
         -- ora_check_sys_privilege operator to protect sys owned object
         ora_check_sys_privilege (o.owner#, o.type#) = 1) and
       o.owner# = u.user# and r.ectx# = bo.obj#(+) and bo.owner# = bu.user#(+);

   COMMENT ON COLUMN "SYS"."ALL_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_RULES"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_RULES"."RULE_CONDITION" IS 'the rule expression';
   COMMENT ON COLUMN "SYS"."ALL_RULES"."RULE_EVALUATION_CONTEXT_OWNER" IS 'owner of the evaluation context on which rule is defined';
   COMMENT ON COLUMN "SYS"."ALL_RULES"."RULE_EVALUATION_CONTEXT_NAME" IS 'name of the evaluation context on which rule is defined';
   COMMENT ON COLUMN "SYS"."ALL_RULES"."RULE_ACTION_CONTEXT" IS 'action context of the rule';
   COMMENT ON COLUMN "SYS"."ALL_RULES"."RULE_COMMENT" IS 'user description of the rule';
   COMMENT ON TABLE "SYS"."ALL_RULES"  IS 'Rules seen by the user'
;
--------------------------------------------------------
--  DDL for View ALL_RULE_SET_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_RULE_SET_RULES" ("RULE_SET_OWNER", "RULE_SET_NAME", "RULE_OWNER", "RULE_NAME", "RULE_SET_RULE_ENABLED", "RULE_SET_RULE_EVAL_CTX_OWNER", "RULE_SET_RULE_EVAL_CTX_NAME", "RULE_SET_RULE_COMMENT") AS 
  SELECT /*+ all_rows */
       u.name, o.name, ru.name, ro.name,
       decode(bitand(rm.property, 1), 1, 'DISABLED', 'ENABLED'),
       eu.name, eo.name, rm.rm_comment
FROM   rule_map$ rm, obj$ o, user$ u, obj$ ro, user$ ru, obj$ eo, user$ eu
WHERE  rm.rs_obj# = o.obj# and
       (o.owner# in (USERENV('SCHEMAID'), 1 /* PUBLIC */) or
        o.obj# in (select oa.obj# from sys.objauth$ oa
                   where grantee# in (select kzsrorol from x$kzsro)) or
       -- bug 20339374,V$ENABLEDPRIVS replaced with
       -- ora_check_sys_privilege operator to protect sys owned object
       ora_check_sys_privilege (o.owner#, o.type#) = 1) and
       o.owner# = u.user# and rm.r_obj# = ro.obj# and ro.owner# = ru.user#
       and rm.ectx# = eo.obj#(+) and eo.owner# = eu.user#(+);

   COMMENT ON COLUMN "SYS"."ALL_RULE_SET_RULES"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SET_RULES"."RULE_SET_NAME" IS 'Name of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SET_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SET_RULES"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SET_RULES"."RULE_SET_RULE_ENABLED" IS 'Whether the rule is enabled in this ruleset';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SET_RULES"."RULE_SET_RULE_EVAL_CTX_OWNER" IS 'evaluation context owner specified when the rule is added to this rule set';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SET_RULES"."RULE_SET_RULE_EVAL_CTX_NAME" IS 'evaluation context name specified when the rule is added to this rule set';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SET_RULES"."RULE_SET_RULE_COMMENT" IS 'User description of this mapping';
   COMMENT ON TABLE "SYS"."ALL_RULE_SET_RULES"  IS 'Rules in all rule sets seen by the user'
;
--------------------------------------------------------
--  DDL for View ALL_RULE_SETS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_RULE_SETS" ("RULE_SET_OWNER", "RULE_SET_NAME", "RULE_SET_EVAL_CONTEXT_OWNER", "RULE_SET_EVAL_CONTEXT_NAME", "RULE_SET_COMMENT") AS 
  SELECT /*+ all_rows */
       u.name, o.name, bu.name, bo.name, r.rs_comment
FROM   rule_set$ r, obj$ o, user$ u, obj$ bo, user$ bu
WHERE  r.obj# = o.obj# and
       (o.owner# in (USERENV('SCHEMAID'), 1 /* PUBLIC */) or
        o.obj# in (select oa.obj# from sys.objauth$ oa
                   where grantee# in (select kzsrorol from x$kzsro))
       or
         -- bug 20339374,V$ENABLEDPRIVS replaced with
         -- ora_check_sys_privilege operator to protect sys owned object
         ora_check_sys_privilege (o.owner#, o.type#) = 1) and
       u.user# = o.owner# and
       r.ectx# = bo.obj#(+) and bo.owner# = bu.user#(+);

   COMMENT ON COLUMN "SYS"."ALL_RULE_SETS"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SETS"."RULE_SET_NAME" IS 'Name of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SETS"."RULE_SET_EVAL_CONTEXT_OWNER" IS 'The evaluation context owner name associated with the rule set, if any';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SETS"."RULE_SET_EVAL_CONTEXT_NAME" IS 'The evaluation context name associated with the rule set, if any';
   COMMENT ON COLUMN "SYS"."ALL_RULE_SETS"."RULE_SET_COMMENT" IS 'user description of the rule set';
   COMMENT ON TABLE "SYS"."ALL_RULE_SETS"  IS 'Rule sets seen by the user'
;
--------------------------------------------------------
--  DDL for View ALL_RULESETS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_RULESETS" ("OWNER", "RULESET_NAME", "RULESET_STORAGE_TABLE", "BASE_TABLE", "RULESET_COMMENT") AS 
  SELECT rule_set_owner, rule_set_name, NULL,
       decode(rule_set_eval_context_owner, NULL, NULL,
              rule_set_eval_context_owner||'.'||rule_set_eval_context_name),
       rule_set_comment
FROM   all_rule_sets;

   COMMENT ON COLUMN "SYS"."ALL_RULESETS"."OWNER" IS 'Owner of the ruleset';
   COMMENT ON COLUMN "SYS"."ALL_RULESETS"."RULESET_NAME" IS 'Name of the ruleset';
   COMMENT ON COLUMN "SYS"."ALL_RULESETS"."RULESET_STORAGE_TABLE" IS 'name of the table to store rules in the ruleset';
   COMMENT ON COLUMN "SYS"."ALL_RULESETS"."BASE_TABLE" IS 'name of the evaluation context for the rule set';
   COMMENT ON COLUMN "SYS"."ALL_RULESETS"."RULESET_COMMENT" IS 'user description of the ruleset';
   COMMENT ON TABLE "SYS"."ALL_RULESETS"  IS 'Rulesets seen by the user: maintained for backward compatibility'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_CHAIN_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_CHAIN_RULES" ("OWNER", "CHAIN_NAME", "RULE_OWNER", "RULE_NAME", "CONDITION", "ACTION", "COMMENTS") AS 
  SELECT cu.name, co.name, ru.name, ro.name,
         dbms_scheduler.get_chain_rule_condition(r.r_action, r.condition),
         dbms_scheduler.get_chain_rule_action(r.r_action), r.r_comment
  FROM rule_map$ rm, obj$ rso, user$ rsu, obj$ ro, user$ ru, rule$ r,
     obj$ co, user$ cu, sys.scheduler$_chain c
  WHERE c.obj# = co.obj# AND co.owner# = cu.user#
     AND c.rule_set_owner = rsu.name(+) AND rsu.user# = rso.owner#
     AND c.rule_set = rso.name
     AND rso.obj# = rm.rs_obj#(+)
     AND rm.r_obj# = r.obj#(+)
     AND rm.r_obj# = ro.obj#(+) AND ro.owner# = ru.user# AND
    (co.owner# = userenv('SCHEMAID')
       or co.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -266 /* EXECUTE ANY PROGRAM */ )
                 )
          and co.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_RULES"."OWNER" IS 'Owner of the scheduler chain the rule is in';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_RULES"."CHAIN_NAME" IS 'Name of the scheduler chain the rule is in';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_RULES"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_RULES"."CONDITION" IS 'Boolean condition triggering the rule';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_RULES"."ACTION" IS 'Action to be performed when the rule is triggered';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_RULES"."COMMENTS" IS 'User-specified comments about the rule';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_CHAIN_RULES"  IS 'All rules from scheduler chains visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_CHAINS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_CHAINS" ("OWNER", "CHAIN_NAME", "RULE_SET_OWNER", "RULE_SET_NAME", "NUMBER_OF_RULES", "NUMBER_OF_STEPS", "ENABLED", "EVALUATION_INTERVAL", "USER_RULE_SET", "COMMENTS") AS 
  SELECT u.name, o.name, c.rule_set_owner, c.rule_set,
  (SELECT count(*) FROM rule_map$ rm, obj$ rmo, user$ rmu
     WHERE rm.rs_obj# = rmo.obj# AND rmo.owner# = rmu.user#
     AND rmu.name = c.rule_set_owner and rmo.name = c.rule_set),
  (SELECT COUNT(*) FROM sys.scheduler$_step cs
     WHERE cs.oid = c.obj#),
  DECODE(BITAND(c.flags,1),0,'FALSE',1,'TRUE'), c.eval_interval,
  DECODE(BITAND(c.flags,2),2,'FALSE',0,'TRUE'),
  c.comments
  FROM obj$ o, user$ u, sys.scheduler$_chain c
  WHERE c.obj# = o.obj# AND u.user# = o.owner# AND
    (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -266 /* EXECUTE ANY PROGRAM */ )
                 )
          and o.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."OWNER" IS 'Owner of the scheduler chain';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."CHAIN_NAME" IS 'Name of the scheduler chain';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."RULE_SET_OWNER" IS 'Owner of the associated rule set';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."RULE_SET_NAME" IS 'Name of the associated rule set';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."NUMBER_OF_RULES" IS 'Number of rules in this chain';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."NUMBER_OF_STEPS" IS 'Number of defined steps in this chain';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."ENABLED" IS 'Whether the chain is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."EVALUATION_INTERVAL" IS 'Periodic interval at which to reevaluate rules for this chain';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."USER_RULE_SET" IS 'Whether the chain uses a user-specified rule set';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAINS"."COMMENTS" IS 'Comments on the chain';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_CHAINS"  IS 'All scheduler chains in the database visible to current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_CHAIN_STEPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_CHAIN_STEPS" ("OWNER", "CHAIN_NAME", "STEP_NAME", "PROGRAM_OWNER", "PROGRAM_NAME", "EVENT_SCHEDULE_OWNER", "EVENT_SCHEDULE_NAME", "EVENT_QUEUE_OWNER", "EVENT_QUEUE_NAME", "EVENT_QUEUE_AGENT", "EVENT_CONDITION", "CREDENTIAL_OWNER", "CREDENTIAL_NAME", "DESTINATION", "SKIP", "PAUSE", "PAUSE_BEFORE", "RESTART_ON_RECOVERY", "RESTART_ON_FAILURE", "STEP_TYPE", "TIMEOUT") AS 
  SELECT u.name, o.name, cs.var_name,
  DECODE(BITAND(cs.flags,4), 4,
    substrb(cs.object_name,1,instrb(cs.object_name,'"')-1), NULL),
  DECODE(BITAND(cs.flags,4), 4,
    substrb(cs.object_name,instrb(cs.object_name,'"')+1,
      lengthb(cs.object_name)-instrb(cs.object_name,'"')), NULL),
  DECODE(BITAND(cs.flags,8), 8,
    substrb(cs.object_name,1,instrb(cs.object_name,'"')-1), NULL),
  DECODE(BITAND(cs.flags,8), 8,
    substrb(cs.object_name,instrb(cs.object_name,'"')+1,
      lengthb(cs.object_name)-instrb(cs.object_name,'"')), NULL),
  cs.queue_owner, cs.queue_name, cs.queue_agent, cs.condition,
  cs.credential_owner, cs.credential_name, cs.destination,
  DECODE(BITAND(cs.flags,1),0,'FALSE',1,'TRUE'),
  DECODE(BITAND(cs.flags,2),0,'FALSE',2,'TRUE'),
  DECODE(BITAND(cs.flags,512),0,'FALSE',512,'TRUE'),
  DECODE(BITAND(cs.flags,64),0,'FALSE',64,'TRUE'),
  DECODE(BITAND(cs.flags,128),0,'FALSE',128,'TRUE'),
  DECODE(BITAND(cs.flags,8+16+32+1024+2048),8,'EVENT_SCHEDULE',16,'INLINE_EVENT',
  32,'SUBCHAIN',1040,'INLINE_FILE_WATCHER', 2056, 'FILE_WATCHER_SCHEDULE',
  'PROGRAM'), cs.timeout
  FROM obj$ o, user$ u, sys.scheduler$_step cs
  WHERE cs.oid = o.obj# AND u.user# = o.owner# AND
    (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -266 /* EXECUTE ANY PROGRAM */ )
                 )
          and o.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."OWNER" IS 'Owner of the scheduler chain the step is in';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."CHAIN_NAME" IS 'Name of the scheduler chain the step is in';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."STEP_NAME" IS 'Name of the chain step';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."PROGRAM_OWNER" IS 'Owner of the program that runs during this step';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."PROGRAM_NAME" IS 'Name of the program that runs during this step';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."EVENT_SCHEDULE_OWNER" IS 'Owner of the event schedule that this step waits for';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."EVENT_SCHEDULE_NAME" IS 'Name of the event schedule that this step waits for';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."EVENT_QUEUE_OWNER" IS 'Owner of source queue into which event will be raised';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."EVENT_QUEUE_NAME" IS 'Name of source queue into which event will be raised';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."EVENT_QUEUE_AGENT" IS 'Name of AQ agent used by user on the event source queue (for a secure queue)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."EVENT_CONDITION" IS 'Boolean expression used as the subscription rule for event on the source queue';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."CREDENTIAL_OWNER" IS 'Owner of the credential to be used for an external step job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."CREDENTIAL_NAME" IS 'Name of the credential to be used for an external step job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."DESTINATION" IS 'Destination host on which a remote step job will run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."SKIP" IS 'Whether this step should be skipped or not';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."PAUSE" IS 'Whether this step should be paused after running or not';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."PAUSE_BEFORE" IS 'Whether this step should be paused before running or not';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."RESTART_ON_RECOVERY" IS 'Whether this step should be restarted on database recovery';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."RESTART_ON_FAILURE" IS 'Whether this step should be retried on application failure';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."STEP_TYPE" IS 'Type of this step';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CHAIN_STEPS"."TIMEOUT" IS 'Timeout for waiting on an event schedule';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_CHAIN_STEPS"  IS 'All steps of scheduler chains visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_CREDENTIALS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_CREDENTIALS" ("OWNER", "CREDENTIAL_NAME", "USERNAME", "DATABASE_ROLE", "WINDOWS_DOMAIN", "COMMENTS") AS 
  SELECT u.name, o.name, c.username,
  DECODE(bitand(c.flags,1+2+8+16), 1,'SYSDBA', 2, 'SYSOPER',
                                   8, 'SYSBACKUP' , 16, 'SYSDG', NULL),
  c.domain, c.comments
  FROM obj$ o, user$ u, sys.scheduler$_credential c
  WHERE c.obj# = o.obj# AND u.user# = o.owner# AND
    (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */)
                 )
          and o.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CREDENTIALS"."OWNER" IS 'Owner of the scheduler credential';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CREDENTIALS"."CREDENTIAL_NAME" IS 'Name of the scheduler credential';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CREDENTIALS"."USERNAME" IS 'User to execute the job as';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CREDENTIALS"."DATABASE_ROLE" IS 'Database role to use when logging in (SYSDBA, SYSOPER, SYSBACKUP, SYSDG or NULL)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CREDENTIALS"."WINDOWS_DOMAIN" IS 'Windows domain to use when logging in';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_CREDENTIALS"."COMMENTS" IS 'Comments on the credential';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_CREDENTIALS"  IS 'All scheduler credentials visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_DB_DESTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_DB_DESTS" ("OWNER", "DESTINATION_NAME", "CONNECT_INFO", "AGENT", "ENABLED", "REFS_ENABLED", "COMMENTS") AS 
  SELECT "OWNER","DESTINATION_NAME","CONNECT_INFO","AGENT","ENABLED","REFS_ENABLED","COMMENTS" FROM dba_scheduler_db_dests;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DB_DESTS"."OWNER" IS 'Owner of this destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DB_DESTS"."DESTINATION_NAME" IS 'Name of this destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DB_DESTS"."CONNECT_INFO" IS 'Connect string to connect to remote database';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DB_DESTS"."AGENT" IS 'Name of agent through which connection to remote database is being made';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DB_DESTS"."ENABLED" IS 'Whether this destination object is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DB_DESTS"."COMMENTS" IS 'Optional comment';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_DB_DESTS"  IS 'User-visible destination objects in the database pointing to remote databases'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_DESTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_DESTS" ("OWNER", "DESTINATION_NAME", "DESTINATION_TYPE", "ENABLED", "COMMENTS") AS 
  SELECT "OWNER","DESTINATION_NAME","DESTINATION_TYPE","ENABLED","COMMENTS" from dba_scheduler_dests;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DESTS"."OWNER" IS 'Owner of this destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DESTS"."DESTINATION_NAME" IS 'Name of this destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DESTS"."DESTINATION_TYPE" IS 'Type of this destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DESTS"."ENABLED" IS 'Whether this destination object is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_DESTS"."COMMENTS" IS 'Optional comment';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_DESTS"  IS 'All destination objects for jobs in the database visible to current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_EXTERNAL_DESTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS" ("OWNER", "DESTINATION_NAME", "HOSTNAME", "PORT", "IP_ADDRESS", "ENABLED", "COMMENTS") AS 
  SELECT "OWNER","DESTINATION_NAME","HOSTNAME","PORT","IP_ADDRESS","ENABLED","COMMENTS" from dba_scheduler_external_dests;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS"."OWNER" IS 'Owner of this destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS"."DESTINATION_NAME" IS 'Name of this destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS"."HOSTNAME" IS 'Name or IP address of host on which agent is located';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS"."PORT" IS 'Port that the agent is listening on';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS"."IP_ADDRESS" IS 'IP address of host on which agent is located';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS"."ENABLED" IS 'Whether this destination object is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS"."COMMENTS" IS 'Optional comment';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_EXTERNAL_DESTS"  IS 'User-visible destination objects in the database pointing to remote agents'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_FILE_WATCHERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_FILE_WATCHERS" ("OWNER", "FILE_WATCHER_NAME", "ENABLED", "DESTINATION_OWNER", "DESTINATION", "DIRECTORY_PATH", "FILE_NAME", "CREDENTIAL_OWNER", "CREDENTIAL_NAME", "MIN_FILE_SIZE", "STEADY_STATE_DURATION", "LAST_MODIFIED_TIME", "COMMENTS") AS 
  SELECT u.name, o.name, decode(bitand(f.flags, 1), 1, 'TRUE', 'FALSE'),
        decode(bitand(f.flags, 8), 0, NULL,
           substrb(f.destination, 1, instrb(f.destination, '"')-1)),
        decode(bitand(f.flags, 8), 0, f.destination,
           substrb(f.destination, instrb(f.destination, '"')+1,
           lengthb(f.destination) - instrb(f.destination, '"'))),
        f.directory_path, f.file_name,
        cu.name, co.name, f.min_file_size, f.steady_state_duration,
        f.last_modified_time, f.comments
 FROM sys.user$ u, sys.obj$ o, sys.scheduler$_file_watcher f,
      sys.user$ cu, sys.obj$ co
 WHERE f.obj# = o.obj# AND u.user# = o.owner# AND
       f.credoid = co.obj#(+) AND cu.user#(+) = co.owner# AND
       (o.owner# = userenv('SCHEMAID')
          or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
         or /* user has system privileges */
           (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */)
                 )
          and o.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."OWNER" IS 'Owner of file watch request';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."FILE_WATCHER_NAME" IS 'Name of file watch request';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."ENABLED" IS 'Is this file watch request enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."DESTINATION_OWNER" IS 'Owner of named destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."DESTINATION" IS 'Name of destination object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."DIRECTORY_PATH" IS 'Pathname of directory where file will arrive';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."FILE_NAME" IS 'Name or pattern specifying the files that need to be monitored';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."CREDENTIAL_OWNER" IS 'Owner of credential that should be used to authorize file watch';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."CREDENTIAL_NAME" IS 'Name of credential that should be used to authorize file watch';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."MIN_FILE_SIZE" IS 'Minimum size of file being monitored';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."STEADY_STATE_DURATION" IS 'Time to wait before concluding that the file has stopped growing';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."LAST_MODIFIED_TIME" IS 'Time at which this file watcher was last modified';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_FILE_WATCHERS"."COMMENTS" IS 'Comments on the file watch request';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_FILE_WATCHERS"  IS 'Scheduler file watch requests visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_GLOBAL_ATTRIBUTE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_GLOBAL_ATTRIBUTE" ("ATTRIBUTE_NAME", "VALUE") AS 
  SELECT o.name, a.value
 FROM sys.obj$ o, sys.scheduler$_global_attribute a
 WHERE o.obj# = a.obj# AND BITAND(a.flags,1) != 1;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GLOBAL_ATTRIBUTE"."ATTRIBUTE_NAME" IS 'Name of the scheduler global attribute';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GLOBAL_ATTRIBUTE"."VALUE" IS 'Value of the scheduler global attribute';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_GLOBAL_ATTRIBUTE"  IS 'All scheduler global attributes'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_GROUP_MEMBERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_GROUP_MEMBERS" ("OWNER", "GROUP_NAME", "MEMBER_NAME") AS 
  SELECT wgm.owner, wgm.group_name,wgm.cred || wgm.mem_name
FROM
(SELECT u.name owner, o.name group_name, wg.member_oid2 member_oid2,
        decode(member_oid2, null,null,'"' || cmu.name || '"."' || cmo.name || '"@') cred,
        decode(wmu.name || '"' || substr(wmo.name,1,12), 'SYS"SCHED$_LOCAL', 'LOCAL',
          '"'  || wmu.name || '"."' || wmo.name || '"' )mem_name
FROM user$ u, obj$ o, scheduler$_window_group w, scheduler$_wingrp_member wg,
     user$ wmu, obj$ wmo, user$ cmu, obj$ cmo
WHERE w.obj# = wg.oid AND w.obj# = o.obj# AND o.owner# = u.user# AND
  wg.member_oid = wmo.obj# AND wmo.owner# = wmu.user# AND
  cmo.obj#(+) = wg.member_oid2 AND cmo.owner# = cmu.user#(+) AND
  (bitand(w.flags, 8+16) = 0 OR -- this is not a job or dest group
   (bitand(w.flags, 8+16) != 0 AND  -- this is a job or destination group
    (o.owner# = USERENV('SCHEMAID') OR -- user owns this group
     wg.oid IN (select oa1.obj# from sys.objauth$ oa1  -- has obj privs on group
                       where grantee# in (select kzsrorol from x$kzsro)) OR
     (EXISTS (select null from v$enabledprivs  -- has CREATE ANY JOB
                 where priv_number = -265) AND o.owner# <> 0))) ) ) wgm;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUP_MEMBERS"."OWNER" IS 'Owner of the group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUP_MEMBERS"."GROUP_NAME" IS 'Name of the group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUP_MEMBERS"."MEMBER_NAME" IS 'Name of the member of this group';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_GROUP_MEMBERS"  IS 'Members of all scheduler object groups visible to current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_GROUPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_GROUPS" ("OWNER", "GROUP_NAME", "GROUP_TYPE", "ENABLED", "NUMBER_OF_MEMBERS", "COMMENTS") AS 
  SELECT u.name, o.name,
  decode(bitand(w.flags, 8+16), 0, 'WINDOW', 8, 'JOB', 16,
decode(bitand(w.flags, 4096+8192), 4096,'DB_DEST', 8192, 'EXTERNAL_DEST', 'UNKOWN_DEST')),
  DECODE(BITAND(w.flags,1),0,'FALSE',1,'TRUE'),
  (SELECT COUNT(*) FROM all_scheduler_group_members agm
   WHERE agm.group_name = o.name and agm.owner = u.name),
  w.comments
FROM obj$ o, user$ u, scheduler$_window_group w
WHERE o.owner# = u.user# AND o.obj# = w.obj# AND
  ( bitand(w.flags, 8+16)=0            -- window group
    or o.owner# = userenv('SCHEMAID')  -- user is owner
    or o.obj# in                       -- user has obj privs on group
         (select oa.obj#
          from sys.objauth$ oa
          where grantee# in ( select kzsrorol
                              from x$kzsro
                            )
         )
    or /* user has create any job, except for SYS group */
      (exists (select null from v$enabledprivs
              where priv_number in (-265 /* CREATE ANY JOB */)
              )
       and o.owner#!=0)
  );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUPS"."OWNER" IS 'Owner of the group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUPS"."GROUP_NAME" IS 'Name of the group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUPS"."GROUP_TYPE" IS 'Type of object contained in the group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUPS"."ENABLED" IS 'Whether the group is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUPS"."NUMBER_OF_MEMBERS" IS 'Number of members in this group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_GROUPS"."COMMENTS" IS 'An optional comment about this group';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_GROUPS"  IS 'All scheduler object groups visible to current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_INCOMPAT_MEMBER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_INCOMPAT_MEMBER" ("INCOMPATIBILITY_OWNER", "INCOMPATIBILITY_NAME", "OBJECT_OWNER", "OBJECT_NAME") AS 
  SELECT ru.name, ro.name,
            pu.name, po.name
  FROM obj$ ro, user$ ru, obj$ po, user$ pu, sys.scheduler$_resources r,
                 scheduler$_constraints pc
  WHERE r.obj# = ro.obj# AND ro.owner# = ru.user#
       AND pc.resoid = r.obj# AND pc.oid = po.obj#
       AND  po.owner# = pu.user#
       AND bitand(r.flags, 2) = 2
       AND (
        ro.owner# = userenv('SCHEMAID')
       or  po.owner# = userenv('SCHEMAID')
       or ro.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or po.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -266 /* EXECUTE ANY PROGRAM */,
                                       -390 /* USE ANY JOB RESOURCE */)
                 )
          and ro.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_INCOMPAT_MEMBER"."INCOMPATIBILITY_OWNER" IS 'Owner of the incompatibility resource object containing this member';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_INCOMPAT_MEMBER"."INCOMPATIBILITY_NAME" IS 'Name of the incompatibility resource object containing this member';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_INCOMPAT_MEMBER"."OBJECT_OWNER" IS 'Owner of the incompatibility resource member';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_INCOMPAT_MEMBER"."OBJECT_NAME" IS 'Name of the incompatibility resource member';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_INCOMPAT_MEMBER"  IS 'All incompatibility resource objects members in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_INCOMPATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_INCOMPATS" ("OWNER", "INCOMPATIBILITY_NAME", "CONSTRAINT_LEVEL", "ENABLED", "JOBS_RUNNING_COUNT", "COMMENTS") AS 
  SELECT su.name, so.name,
      decode(bitand(r.flags, 4+8), 4, 'JOB_LEVEL',
                                   8, 'PROGRAM_LEVEL',
                                   'ERROR'),
      decode(r.status,1, 'YES', 2, 'NO', 'ERROR'),
      ru.jobs_running,
      r.comments
  FROM obj$ so, user$ su, sys.scheduler$_resources r,
      scheduler$_resource_usage ru
  WHERE r.obj# = so.obj# AND so.owner# = su.user# and
                 r.obj# = ru.resoid and
      bitand(r.flags,2) = 2
    AND (so.owner# = userenv('SCHEMAID')
       or so.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -266 /* EXECUTE ANY PROGRAM */,
                                       -390 /* USE ANY JOB RESOURCE */)
                 )
          and so.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_INCOMPATS"."OWNER" IS 'Owner of the incompatibility resource object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_INCOMPATS"."INCOMPATIBILITY_NAME" IS 'Name of the incompatibility resource object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_INCOMPATS"."JOBS_RUNNING_COUNT" IS 'Current number of running jobs using the incompatibility resource object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_INCOMPATS"."COMMENTS" IS 'Comments for the resource incompatibility object';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_INCOMPATS"  IS 'All scheduler incompatibility resource objects in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_JOB_ARGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_JOB_ARGS" ("OWNER", "JOB_NAME", "ARGUMENT_NAME", "ARGUMENT_POSITION", "ARGUMENT_TYPE", "VALUE", "ANYDATA_VALUE", "OUT_ARGUMENT") AS 
  SELECT u.name, o.name, b.name, t.position,
  CASE WHEN (b.user_type_num IS NULL) THEN
    DECODE(b.type_number,
0, null,
1, decode(b.flags, 512, 'NVARCHAR2', 'VARCHAR2'),
2, decode(b.flags, 512, 'FLOAT', 'NUMBER'),
3, 'NATIVE INTEGER',
8, 'LONG',
9, decode(b.flags, 512, 'NCHAR VARYING', 'VARCHAR'),
11, 'ROWID',
12, 'DATE',
23, 'RAW',
24, 'LONG RAW',
29, 'BINARY_INTEGER',
69, 'ROWID',
96, decode(b.flags, 512, 'NCHAR', 'CHAR'),
100, 'BINARY_FLOAT',
101, 'BINARY_DOUBLE',
102, 'REF CURSOR',
104, 'UROWID',
105, 'MLSLABEL',
106, 'MLSLABEL',
110, 'REF',
111, 'REF',
112, decode(b.flags, 512, 'NCLOB', 'CLOB'),
113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
121, 'OBJECT',
122, 'TABLE',
123, 'VARRAY',
178, 'TIME',
179, 'TIME WITH TIME ZONE',
180, 'TIMESTAMP',
181, 'TIMESTAMP WITH TIME ZONE',
231, 'TIMESTAMP WITH LOCAL TIME ZONE',
182, 'INTERVAL YEAR TO MONTH',
183, 'INTERVAL DAY TO SECOND',
250, 'PL/SQL RECORD',
251, 'PL/SQL TABLE',
252, 'PL/SQL BOOLEAN',
'UNDEFINED')
    ELSE t_u.name ||'.'|| t_o.name END,
  dbms_scheduler.get_varchar2_value(t.value), t.value,
  DECODE(BITAND(b.flags,1),0,'FALSE',1,'TRUE')
  FROM obj$ t_o, user$ t_u,
    sys.scheduler$_program_argument b, obj$ o, user$ u, (
  SELECT a.oid job_oid, a.position position,
      po.obj# program_oid, a.value value
   FROM  sys.scheduler$_job_argument a
      JOIN sys.scheduler$_job j ON a.oid = j.obj#
      LEFT OUTER JOIN sys.user$ pu ON
       pu.name =  DECODE(bitand(j.flags,4194304),4194304,
          substr(j.program_action,1,instr(j.program_action,'"')-1),'1')
      LEFT OUTER JOIN sys.obj$ po ON
          pu.user#=po.owner# and
          po.name =
    DECODE(bitand(j.flags,4194304),4194304,
      substr(j.program_action,instr(j.program_action,'"')+1,
        length(j.program_action)-instr(j.program_action,'"')) ,'1')
    ) t
  WHERE t.job_oid = o.obj# AND u.user# = o.owner#
    AND b.user_type_num = t_o.obj#(+) AND t_o.owner# = t_u.user#(+)
    AND t.program_oid=b.oid(+) AND t.position=b.position(+) AND
    (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                    where priv_number in (-265 /* CREATE ANY JOB */,
                                          -255 /* EXPORT FULL DATABASE */ )
                 )
          and o.owner#!=0)
      )
UNION ALL
SELECT lu.name, lo.name, lb.name, lt.position,
  CASE WHEN (lb.user_type_num IS NULL) THEN
    DECODE(lb.type_number,
0, null,
1, decode(lb.flags, 512, 'NVARCHAR2', 'VARCHAR2'),
2, decode(lb.flags, 512, 'FLOAT', 'NUMBER'),
3, 'NATIVE INTEGER',
8, 'LONG',
9, decode(lb.flags, 512, 'NCHAR VARYING', 'VARCHAR'),
11, 'ROWID',
12, 'DATE',
23, 'RAW',
24, 'LONG RAW',
29, 'BINARY_INTEGER',
69, 'ROWID',
96, decode(lb.flags, 512, 'NCHAR', 'CHAR'),
100, 'BINARY_FLOAT',
101, 'BINARY_DOUBLE',
102, 'REF CURSOR',
104, 'UROWID',
105, 'MLSLABEL',
106, 'MLSLABEL',
110, 'REF',
111, 'REF',
112, decode(lb.flags, 512, 'NCLOB', 'CLOB'),
113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
121, 'OBJECT',
122, 'TABLE',
123, 'VARRAY',
178, 'TIME',
179, 'TIME WITH TIME ZONE',
180, 'TIMESTAMP',
181, 'TIMESTAMP WITH TIME ZONE',
231, 'TIMESTAMP WITH LOCAL TIME ZONE',
182, 'INTERVAL YEAR TO MONTH',
183, 'INTERVAL DAY TO SECOND',
250, 'PL/SQL RECORD',
251, 'PL/SQL TABLE',
252, 'PL/SQL BOOLEAN',
'UNDEFINED')
    ELSE lt_u.name ||'.'|| lt_o.name END,
  dbms_scheduler.get_varchar2_value(lt.value), lt.value,
  DECODE(BITAND(lb.flags,1),0,'FALSE',1,'TRUE')
  FROM obj$ lt_o, user$ lt_u, sys.obj$ lpo,
    sys.scheduler$_program_argument lb,
    sys.scheduler$_lwjob_obj lo, user$ lu,
    (SELECT la.oid job_oid, la.position position,
      decode(bitand(lj.flags, 8589934592), 0, lj.program_oid,
             ljp.program_oid) program_oid, lj.program_oid job_prog,
      lj.flags flags, la.value value
    FROM sys.scheduler$_comb_lw_job lj, sys.scheduler$_job_argument la,
         sys.scheduler$_job ljp
    WHERE lj.program_oid = ljp.obj#(+) and
       bitand(lj.flags, 137438953472) = 0 and
       la.oid = lj.obj#) lt
  WHERE lt.job_oid = lo.obj# AND lu.user# = lo.userid
    AND lb.user_type_num = lt_o.obj#(+) AND lt_o.owner# = lt_u.user#(+)
    AND lt.program_oid=lb.oid(+) AND lt.position=lb.position(+) AND
        lt.job_prog = lpo.obj# AND
        ((bitand(lt.flags, 8589934592) = 0 and lpo.type# = 67) or
         (bitand(lt.flags, 8589934592) <> 0 and lpo.type# = 66)) AND
    (lo.userid = userenv('SCHEMAID')
       or lt.job_prog in
            (select loa.obj#
             from sys.objauth$ loa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                    where priv_number in (-265 /* CREATE ANY JOB */,
                                          -255 /* EXPORT FULL DATABASE */ )
                 )
          and lo.userid!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_ARGS"."OWNER" IS 'Owner of the job this argument belongs to';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_ARGS"."JOB_NAME" IS 'Name of the job this argument belongs to';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_ARGS"."ARGUMENT_NAME" IS 'Optional name of this argument';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_ARGS"."ARGUMENT_POSITION" IS 'Position of this argument in the argument list';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_ARGS"."ARGUMENT_TYPE" IS 'Data type of this argument';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_ARGS"."VALUE" IS 'Value set to this argument in string format (if a string)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_ARGS"."ANYDATA_VALUE" IS 'Value set to this argument in AnyData format';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_ARGS"."OUT_ARGUMENT" IS 'Reserved for future use';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_JOB_ARGS"  IS 'All arguments with set values of all scheduler jobs in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_JOB_CLASSES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_JOB_CLASSES" ("OWNER", "JOB_CLASS_NAME", "RESOURCE_CONSUMER_GROUP", "SERVICE", "LOGGING_LEVEL", "LOG_HISTORY", "COMMENTS") AS 
  SELECT u.name, co.name, c.res_grp_name,
    c.affinity ,
    DECODE(BITAND(c.flags,32+64+128+256),32,'OFF',64,'RUNS',128,'FAILED RUNS',
      256,'FULL',NULL),
    c.log_history, c.comments
  FROM obj$ co, user$ u, sys.scheduler$_class c
  WHERE c.obj# = co.obj# AND co.owner# = u.user# AND
    (co.obj# in
         (select oa.obj#
          from sys.objauth$ oa
          where grantee# in ( select kzsrorol
                              from x$kzsro
                            )
         )
     or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-267, /* EXECUTE ANY CLASS */
                                       -268  /* MANAGE SCHEDULER */ )
                 )
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_CLASSES"."OWNER" IS 'Owner of the scheduler class';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_CLASSES"."JOB_CLASS_NAME" IS 'Name of the scheduler class';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_CLASSES"."RESOURCE_CONSUMER_GROUP" IS 'Resource consumer group associated with the class';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_CLASSES"."SERVICE" IS 'Name of the service this class is affined with';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_CLASSES"."LOGGING_LEVEL" IS 'Amount of logging that will be done pertaining to this class';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_CLASSES"."LOG_HISTORY" IS 'The history to maintain in the job log (in days) for this class';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_CLASSES"."COMMENTS" IS 'Comments on this class';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_JOB_CLASSES"  IS 'All scheduler classes visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_JOB_DESTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_JOB_DESTS" ("OWNER", "JOB_NAME", "JOB_SUBNAME", "CREDENTIAL_OWNER", "CREDENTIAL_NAME", "DESTINATION_OWNER", "DESTINATION", "JOB_DEST_ID", "ENABLED", "REFS_ENABLED", "STATE", "NEXT_START_DATE", "RUN_COUNT", "RETRY_COUNT", "FAILURE_COUNT", "LAST_START_DATE", "LAST_END_DATE") AS 
  SELECT  dd.OWNER, dd.JOB_NAME, dd.JOB_SUBNAME,
        decode(dd.local, 'X', null, CREDENTIAL_OWNER),
        decode(dd.local, 'X', null,dd.CREDENTIAL_NAME),
        decode(dd.local, 'N', dd.DESTINATION_OWNER, null),
        decode(dd.local, 'N', dd.DESTINATION_NAME, 'LOCAL'),
        lj.JOB_DEST_ID,
        decode(dd.pj_enbl, 1, 'TRUE', 'FALSE'),
        dd.ENABLED,
        (CASE WHEN (bitand(dd.pj_status,4+8+16+32+8192+524288) > 0 OR
                    (lj.STATE <> 'RUNNING' AND bitand(dd.pj_status, 1) = 0))
                 THEN  'DISABLED'
                 ELSE  coalesce(lj.STATE, 'SCHEDULED') END),
        dd.next_run_date NEXT_START_DATE,
        coalesce(lj.RUN_COUNT,0),
        coalesce(lj.RETRY_COUNT,0),
        coalesce(lj.FAILURE_COUNT,0),
        lj.LAST_START_DATE, lj.LAST_END_DATE
FROM
(SELECT
  d.job_dest_id JOB_DEST_ID,
  DECODE(BITAND(d.job_status,2+65536),2,'RUNNING',2+65536,'CHAIN_STALLED',
    DECODE(BITAND(d.job_status,1+4+8+16+32+128+8192),0,'SCHEDULED',1,
      (CASE WHEN d.retry_count>0 THEN 'RETRY SCHEDULED'
            WHEN (bitand(d.job_status, 1024) <> 0) THEN 'READY TO RUN'
            ELSE 'SCHEDULED' END),
      4,'COMPLETED',8,'BROKEN',16,'FAILED',
      32,'SUCCEEDED' ,128,'REMOTE',8192, 'STOPPED', NULL)) STATE,
    d.run_count, d.retry_count, d.failure_count,
    d.last_start_date, d.last_end_date, d.program_oid parent_job_id,d.dest_oid
  FROM  scheduler$_comb_lw_job d) lj,
(SELECT
     j0.OWNER, j0.JOB_NAME,
     'SCHED$_MD_'
     || TO_CHAR(coalesce(d0.dest_oid,j0.dest_oid), 'FMXXXXXXXXX') || '_'
     || TO_CHAR(decode(d0.local, 'X', 0,
                  coalesce(d0.cred_oid,j0.cred_oid)), 'FMXXXXXXXXX') JOB_SUBNAME,
     coalesce(d0.credential_owner,j0.credential_owner) credential_owner,
     coalesce(d0.credential_name,j0.credential_name) credential_name,
     d0.destination_owner,
     d0.destination_name,
     decode(d0.en_flag+j0.en_flag, 2, 'TRUE', 'FALSE') enabled,
     j0.en_flag pj_enbl,  j0.pj_status,
     j0.next_run_date, j0.parent_job_id, d0.dest_oid, d0.local
FROM
( SELECT cmu.name credential_owner,  cmo.name credential_name,
      wmu.name destination_owner, wmo.name destination_name,
      bitand(d.flags, bitand(w.flags,bitand(coalesce(ad.flags,1),1))) en_flag,
      w.obj# dest_grp_id,
      wg.member_oid2 cred_oid,
      wg.member_oid dest_oid,
      decode(bitand(d.flags, 12),12, 'X',8, 'Y','N') local
  FROM  scheduler$_window_group w, scheduler$_wingrp_member wg,
      scheduler$_destinations d, scheduler$_destinations ad,
      user$ wmu, obj$ wmo, user$ cmu, obj$ cmo
  WHERE w.obj# = wg.oid
       AND wg.member_oid = wmo.obj#
       AND wmo.owner# = wmu.user#
       AND wg.member_oid = d.obj#
       AND cmo.obj#(+) = wg.member_oid2
       AND d.agtdestoid = ad.obj#(+)
       AND cmo.owner# = cmu.user#(+)) d0,
(SELECT  j1.credential_owner, j1.credential_name,
    substrb(j1.destination, 1, instrb(j1.destination, '"')-1) destination_owner,
    substrb(j1.destination, instrb(j1.destination, '"')+1,
       lengthb(j1.destination) - instrb(j1.destination, '"')) destination_name,
    bitand(j1.job_status, 1) en_flag,
    j1.job_status pj_status,
    j1.dest_oid,
    j1.next_run_date,
    u.name OWNER, o.name JOB_NAME, o.subname JOB_SUBNAME,
    j1.obj# parent_job_id,
    j1.credential_oid cred_oid
    FROM scheduler$_job j1, user$ u, obj$ o
              WHERE j1.obj# = o.obj# AND o.owner# = u.user#
                AND (o.owner# = userenv('SCHEMAID')
                      or o.obj# in
                           (select oa.obj#
                            from sys.objauth$ oa
                            where grantee# in ( select kzsrorol
                                                from x$kzsro
                                              )
                           )
                      or /* user has system privileges */
                        (exists (select null from v$enabledprivs
                                where priv_number = -265
                                )
                         and o.owner#!=0)
                     )
            ) j0
       WHERE j0.dest_oid = d0.dest_grp_id
    and (j0.cred_oid is null or j0.cred_oid != coalesce(d0.cred_oid, 0)
        or not exists (select 1 from scheduler$_wingrp_member wm
                    where  wm.oid = d0.dest_grp_id
                      and wm.member_oid2 is null
                      and wm.member_oid = d0.dest_oid))) dd
WHERE
   lj.parent_job_id (+) = dd.parent_job_id and
   lj.dest_oid (+) = dd.dest_oid
   and (dd.pj_enbl = 1 or lj.dest_oid is not null)
UNION ALL
  SELECT u1.name, o1.name, o1.subname, j1.credential_owner, j1.credential_name,
    j1.destination_owner, j1.destination,
    j1.job_dest_id, DECODE(BITAND(j1.job_status,1),0,'FALSE','TRUE'),
    decode(jd1.enabled, 'TRUE', 'TRUE',
           decode(bitand(j1.flags, 274877906944), 0, 'TRUE', 'FALSE')),
    DECODE(BITAND(j1.job_status,2+65536),2,'RUNNING',2+65536,'CHAIN_STALLED',
       DECODE(BITAND(j1.job_status,1+4+8+16+32+128+8192),0,'DISABLED',1,
        (CASE WHEN j1.retry_count>0 AND bitand(j1.flags, 549755813888) = 0
            THEN 'RETRY SCHEDULED'
            WHEN (bitand(j1.job_status, 1024) <> 0) THEN 'READY TO RUN'
            ELSE 'SCHEDULED' END),
        4,'COMPLETED',8,'BROKEN',16,'FAILED',
        32,'SUCCEEDED' ,128,'REMOTE',8192, 'STOPPED', NULL)),
    j1.next_run_date, j1.run_count,
    decode(bitand(j1.flags, 549755813888), 0, j1.retry_count, 0),
    j1.failure_count, j1.last_start_date,
    (CASE WHEN j1.last_end_date>j1.last_start_date THEN j1.last_end_date
     ELSE NULL END)
  FROM
   (select rj1.obj# obj#, rj1.credential_owner credential_owner,
           rj1.credential_name credential_name,
           decode(bitand(rj1.flags, 274877906944), 0, NULL,
             substrb(rj1.destination, 1, instrb(rj1.destination, '"')-1))
               destination_owner,
           decode(bitand(rj1.flags, 274877906944), 0,
              decode(rj1.destination, NULL, 'LOCAL', rj1.destination),
                 substrb(rj1.destination, instrb(rj1.destination, '"')+1,
                    lengthb(rj1.destination) - instrb(rj1.destination, '"')))
                destination,
           rj1.job_status job_status, rj1.flags flags,
           rj1.next_run_date next_run_date, rj1.run_count run_count,
           rj1.retry_count retry_count, rj1.failure_count failure_count,
           rj1.last_start_date last_start_date, rj1.last_end_date last_end_date,
           rj1.job_dest_id job_dest_id
      from scheduler$_job rj1
    union all
    select lj1.obj#, lj1.credential_owner, lj1.credential_name,
           decode(bitand(lj1.flags, 274877906944), 0, NULL,
             substrb(lj1.destination, 1, instrb(lj1.destination, '"')-1)),
           decode(bitand(lj1.flags, 274877906944), 0,
              decode(lj1.destination, NULL, 'LOCAL', lj1.destination),
                 substrb(lj1.destination, instrb(lj1.destination, '"')+1,
                    lengthb(lj1.destination) - instrb(lj1.destination, '"'))),
           lj1.job_status, lj1.flags,
           lj1.next_run_date, lj1.run_count, lj1.retry_count,
           lj1.failure_count, lj1.last_start_date, lj1.last_end_date,
           lj1.job_dest_id
      from scheduler$_comb_lw_job lj1) j1,
    (select ro1.obj# obj#, ro1.owner# owner#, ro1.name name, ro1.subname subname
       from obj$ ro1
     union all
     select lo1.obj#, lo1.userid, lo1.name, lo1.subname
       from scheduler$_lwjob_obj lo1) o1,
    user$ u1,
    (select dd.owner owner, dd.destination_name dest_name,
            decode(dd.enabled, 'FALSE', 'FALSE', dd.refs_enabled) enabled
     from all_scheduler_db_dests dd
     union all
     select 'SYS', ed.destination_name, ed.enabled
     from all_scheduler_external_dests ed) jd1
  WHERE j1.obj# = o1.obj# AND o1.owner# = u1.user#
    AND bitand(j1.flags, 137438953472) = 0
    AND bitand(j1.flags, 549755813888) = 0
    AND (jd1.owner(+) = j1.destination_owner)
    AND (jd1.dest_name(+) = j1.destination)
    AND (o1.owner# = userenv('SCHEMAID')
                      or o1.obj# in
                           (select oa.obj#
                            from sys.objauth$ oa
                            where grantee# in ( select kzsrorol
                                                from x$kzsro
                                              )
                           )
                      or /* user has system privileges */
                        (exists (select null from v$enabledprivs
                                where priv_number = -265
                                )
                         and o1.owner#!=0)
                     )
UNION ALL
  SELECT du.name, do.name, do.subname,
    d.credential_owner, d.credential_name,
    substrb(d.destination, 1, instrb(d.destination, '"')-1),
    substrb(d.destination, instrb(d.destination, '"')+1,
        lengthb(d.destination) - instrb(d.destination, '"')),
    d.job_dest_id, 'FALSE', 'FALSE', 'RUNNING', NULL, d.run_count,
    d.retry_count, d.failure_count, d.last_start_date, d.last_end_date
  FROM  scheduler$_comb_lw_job d, user$ du, scheduler$_lwjob_obj do,
        scheduler$_job pj
  WHERE d.obj# = do.obj# and do.userid = du.user# and d.program_oid = pj.obj#
    and bitand(d.flags, 8589934592) <> 0
    and bitand(d.job_status, 2) = 2
    and (d.dest_oid is null or
         d.dest_oid not in
           (select so.obj# from obj$ so where so.owner# = 0 and so.namespace = 1
            and so.name = 'SCHED$_LOCAL_PSEUDO_DB'))
    and (nvl(d.dest_oid,0), nvl(d.credential_oid,0)) not in
          (select nvl(wg.member_oid,0),
             nvl(decode(wg.member_oid2, null, pj.credential_oid, wg.member_oid2), 0)
           from scheduler$_wingrp_member wg
           where wg.oid = pj.dest_oid)
    and (do.userid =   userenv('SCHEMAID') or
       d.program_oid IN
       (SELECT oa.obj#
        from sys.objauth$ oa
        where grantee# in (select kzsrorol from x$kzsro)) OR
     (EXISTS (select null from v$enabledprivs
                           where priv_number in (-265 /* CREATE ANY JOB */,
                                          -255 /* EXPORT FULL DATABASE */ )
                 )
          and do.userid!=0));

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."OWNER" IS 'Owner of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."JOB_NAME" IS 'Name of scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."JOB_SUBNAME" IS 'Subname of scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."CREDENTIAL_OWNER" IS 'Owner of credential used for remote destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."CREDENTIAL_NAME" IS 'Name of credential used for remote destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."DESTINATION_OWNER" IS 'Owner of destination object that points to destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."DESTINATION" IS 'Name of destination object or name of destination itself';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."JOB_DEST_ID" IS 'Numerical ID assigned to job at this destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."ENABLED" IS 'Is this job enabled at this destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."STATE" IS 'State of this job at this destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."NEXT_START_DATE" IS 'Next start time of this job at this destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."RUN_COUNT" IS 'Number of times this job has run at this destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."RETRY_COUNT" IS 'Number of times this job has been retried at this destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."FAILURE_COUNT" IS 'Number of times this job has failed at this destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."LAST_START_DATE" IS 'Last time this job started at this destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_DESTS"."LAST_END_DATE" IS 'Last time this job ended at this destination';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_JOB_DESTS"  IS 'State of all jobs visible to current user at each of their destinations'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_JOB_LOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_JOB_LOG" ("LOG_ID", "LOG_DATE", "OWNER", "JOB_NAME", "JOB_SUBNAME", "JOB_CLASS", "OPERATION", "STATUS", "USER_NAME", "CLIENT_ID", "GLOBAL_UID", "CREDENTIAL_OWNER", "CREDENTIAL_NAME", "DESTINATION_OWNER", "DESTINATION", "ADDITIONAL_INFO") AS 
  (SELECT
     e.LOG_ID, e.LOG_DATE, e.OWNER,
     DECODE(instrb(e.NAME,'"'),0, e.NAME,substrb(e.NAME,1,instrb(e.NAME,'"')-1)),
     DECODE(instrb(e.NAME,'"'),0,NULL,substrb(e.NAME,instrb(e.NAME,'"')+1)),
     co.NAME, OPERATION, e.STATUS, e.USER_NAME, e.CLIENT_ID, e.GUID,
     decode(e.credential, NULL, NULL,
        substrb(e.credential, 1, instrb(e.credential, '"')-1)),
     decode(e.credential, NULL, NULL,
        substrb(e.credential, instrb(e.credential, '"')+1,
           lengthb(e.credential) - instrb(e.credential, '"'))),
     decode(bitand(e.flags, 1), 0, NULL,
        substrb(e.destination, 1, instrb(e.destination, '"')-1)),
     decode(bitand(e.flags, 1), 0, e.destination,
        substrb(e.destination, instrb(e.destination, '"')+1,
           lengthb(e.destination) - instrb(e.destination, '"'))),
     e.ADDITIONAL_INFO
   FROM scheduler$_event_log e, obj$ co
   WHERE e.type# = 66 and e.dbid is null and e.class_id = co.obj#(+)
   AND ( e.owner = SYS_CONTEXT('USERENV','CURRENT_USER')
         or  /* user has object privileges */
            ( select jo.obj# from obj$ jo, user$ ju where
              DECODE(instrb(e.NAME,'"'),0, e.NAME,substrb(e.NAME,1,instrb(e.NAME,'"')-1)) = jo.name
                and e.owner = ju.name and jo.owner# = ju.user#
                and jo.subname is null and jo.type# = 66
            ) in
            ( select oa.obj#
                from sys.objauth$ oa
                where grantee# in ( select kzsrorol from x$kzsro )
            )
         or /* user has system privileges */
            (exists ( select null from v$enabledprivs
                       where priv_number = -265 /* CREATE ANY JOB */
                   )
             and e.owner!='SYS')
        )
  );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."LOG_ID" IS 'The unique id that identifies a row';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."LOG_DATE" IS 'The date of this log entry';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."OWNER" IS 'The owner of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."JOB_NAME" IS 'The name of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."JOB_SUBNAME" IS 'The subname of the scheduler job (for a chain step job)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."JOB_CLASS" IS 'The class the job belonged to at the time of entry';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."OPERATION" IS 'The operation corresponding to this log entry';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."STATUS" IS 'The status of the operation, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."USER_NAME" IS 'The name of the user who performed the operation, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."CLIENT_ID" IS 'The client id of the user who performed the operation, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."GLOBAL_UID" IS 'The global_uid of the user who performed the operation, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."CREDENTIAL_OWNER" IS 'Owner of the credential used for this external or remote job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."CREDENTIAL_NAME" IS 'Name of the credential used for this external or remote job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."DESTINATION_OWNER" IS 'Owner of destination object used in remote run or NULL if no object used';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."DESTINATION" IS 'The destination for a remote job operation';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_LOG"."ADDITIONAL_INFO" IS 'Additional information on this entry, if applicable';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_JOB_LOG"  IS 'Logged information for all scheduler jobs'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_JOB_RUN_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS" ("LOG_ID", "LOG_DATE", "OWNER", "JOB_NAME", "JOB_SUBNAME", "STATUS", "ERROR#", "REQ_START_DATE", "ACTUAL_START_DATE", "RUN_DURATION", "INSTANCE_ID", "SESSION_ID", "SLAVE_PID", "CPU_USED", "CREDENTIAL_OWNER", "CREDENTIAL_NAME", "DESTINATION_OWNER", "DESTINATION", "ADDITIONAL_INFO", "ERRORS", "OUTPUT", "BINARY_ERRORS", "BINARY_OUTPUT") AS 
  (SELECT
     j.LOG_ID, j.LOG_DATE, e.OWNER,
     DECODE(instr(e.NAME,'"'),0, e.NAME,substr(e.NAME,1,instr(e.NAME,'"')-1)),
     DECODE(instr(e.NAME,'"'),0,NULL,substr(e.NAME,instr(e.NAME,'"')+1)),
     e.STATUS, j.ERROR#, j.REQ_START_DATE, j.START_DATE, j.RUN_DURATION,
     j.INSTANCE_ID, j.SESSION_ID, j.SLAVE_PID, j.CPU_USED,
     decode(e.credential, NULL, NULL,
        substr(e.credential, 1, instr(e.credential, '"')-1)),
     decode(e.credential, NULL, NULL,
        substr(e.credential, instr(e.credential, '"')+1,
           length(e.credential) - instr(e.credential, '"'))),
     decode(bitand(e.flags, 1), 0, NULL,
        substr(e.destination, 1, instr(e.destination, '"')-1)),
     decode(bitand(e.flags, 1), 0, e.destination,
        substr(e.destination, instr(e.destination, '"')+1,
           length(e.destination) - instr(e.destination, '"'))),
     j.ADDITIONAL_INFO,
     dbms_scheduler.get_varchar2_value(o.errors),
     dbms_scheduler.get_varchar2_value(o.output),
     o.ERRORS, o.OUTPUT
   FROM scheduler$_job_run_details j, scheduler$_event_log e,
     scheduler$_job_output o
   WHERE j.log_id = e.log_id AND j.log_id = o.log_id(+)
   AND e.type# = 66 and e.dbid is null
   AND ( e.owner = SYS_CONTEXT('USERENV','CURRENT_USER')
         or  /* user has object privileges */
            ( select jo.obj# from obj$ jo, user$ ju where
                DECODE(instr(e.NAME,'"'),0, e.NAME,substr(e.NAME,1,instr(e.NAME,'"')-1)) = jo.name
                and e.owner = ju.name and jo.owner# = ju.user#
                and jo.subname is null and jo.type# = 66
            ) in
            ( select oa.obj#
                from sys.objauth$ oa
                where grantee# in ( select kzsrorol from x$kzsro )
            )
         or /* user has system privileges */
            (exists ( select null from v$enabledprivs
                       where priv_number = -265 /* CREATE ANY JOB */
                   )
             and e.owner!='SYS')
        )
  );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."LOG_ID" IS 'The unique id of the log entry. Foreign key on entry in dba_scheduler_job_log';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."LOG_DATE" IS 'The date of the log entry';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."OWNER" IS 'The owner of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."JOB_NAME" IS 'The name of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."JOB_SUBNAME" IS 'The subname of the scheduler job (for a chain step job)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."STATUS" IS 'The status of the job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."ERROR#" IS 'The error number in the case of error';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."REQ_START_DATE" IS 'The requested start date of the job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."ACTUAL_START_DATE" IS 'The actual date the job ran';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."RUN_DURATION" IS 'The duration that the job ran';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."INSTANCE_ID" IS 'The id of the instance on which the job ran';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."SESSION_ID" IS 'The session id of the job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."SLAVE_PID" IS 'The process id of the slave on which the job ran';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."CPU_USED" IS 'The amount of cpu used for this job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."CREDENTIAL_OWNER" IS 'Owner of the credential used for this external or remote job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."CREDENTIAL_NAME" IS 'Name of the credential used for this external or remote job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."DESTINATION_OWNER" IS 'Owner of destination object used in remote run or NULL if no object used';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."DESTINATION" IS 'The destination for a remote job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."ADDITIONAL_INFO" IS 'Additional information on the job run, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."ERRORS" IS 'Text representation in db character set of errors from this job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."OUTPUT" IS 'Text representation in db character set of output from this job run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."BINARY_ERRORS" IS 'Errors from this job run, in their original form';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"."BINARY_OUTPUT" IS 'Output from this job run, in its original form';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_JOB_RUN_DETAILS"  IS 'The details of a job run'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_JOBS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_JOBS" ("OWNER", "JOB_NAME", "JOB_SUBNAME", "JOB_STYLE", "JOB_CREATOR", "CLIENT_ID", "GLOBAL_UID", "PROGRAM_OWNER", "PROGRAM_NAME", "JOB_TYPE", "JOB_ACTION", "NUMBER_OF_ARGUMENTS", "SCHEDULE_OWNER", "SCHEDULE_NAME", "SCHEDULE_TYPE", "START_DATE", "REPEAT_INTERVAL", "EVENT_QUEUE_OWNER", "EVENT_QUEUE_NAME", "EVENT_QUEUE_AGENT", "EVENT_CONDITION", "EVENT_RULE", "FILE_WATCHER_OWNER", "FILE_WATCHER_NAME", "END_DATE", "JOB_CLASS", "ENABLED", "AUTO_DROP", "RESTART_ON_RECOVERY", "RESTART_ON_FAILURE", "STATE", "JOB_PRIORITY", "RUN_COUNT", "UPTIME_RUN_COUNT", "MAX_RUNS", "FAILURE_COUNT", "UPTIME_FAILURE_COUNT", "MAX_FAILURES", "RETRY_COUNT", "LAST_START_DATE", "LAST_RUN_DURATION", "NEXT_RUN_DATE", "SCHEDULE_LIMIT", "MAX_RUN_DURATION", "LOGGING_LEVEL", "STORE_OUTPUT", "STOP_ON_WINDOW_CLOSE", "INSTANCE_STICKINESS", "RAISE_EVENTS", "SYSTEM", "JOB_WEIGHT", "NLS_ENV", "SOURCE", "NUMBER_OF_DESTINATIONS", "DESTINATION_OWNER", "DESTINATION", "CREDENTIAL_OWNER", "CREDENTIAL_NAME", "INSTANCE_ID", "DEFERRED_DROP", "ALLOW_RUNS_IN_RESTRICTED_MODE", "COMMENTS", "FLAGS", "RESTARTABLE", "HAS_CONSTRAINTS", "CONNECT_CREDENTIAL_OWNER", "CONNECT_CREDENTIAL_NAME", "FAIL_ON_SCRIPT_ERROR") AS 
  SELECT ju.name, jo.name, jo.subname, 'REGULAR', j.creator, j.client_id, j.guid,
    DECODE(bitand(j.flags,4194304),4194304,
      substr(j.program_action,1,instr(j.program_action,'"')-1),NULL),
    /* PROGRAM_NAME */
    DECODE(bitand(j.flags,4194304),4194304,
      substr(j.program_action,instr(j.program_action,'"')+1,
        length(j.program_action)-instr(j.program_action,'"')) ,NULL),
    /* JOB_TYPE */
    DECODE(BITAND(j.flags,131072+262144+2097152+524288+281474976710656+
                          562949953421312+1125899906842624),
      131072, 'PLSQL_BLOCK', 262144, 'STORED_PROCEDURE',
      2097152, 'EXECUTABLE', 524288, 'CHAIN',
      281474976710656, 'EXTERNAL_SCRIPT', 562949953421312, 'SQL_SCRIPT',
      1125899906842624, 'BACKUP_SCRIPT', NULL),
    /* JOB_ACTION */
    DECODE(bitand(j.flags,4194304),0,j.program_action,NULL),
    /* NUMBER_OF_ARGUMENTS */
    j.number_of_args,
    /* SCHEDULER_OWNER */
    DECODE(bitand(j.flags,1024+4096),0,NULL,
      substr(j.schedule_expr,1,instr(j.schedule_expr,'"')-1)),
    /* SCHEDULE_NAME */
    DECODE(bitand(j.flags,1024+4096),0,NULL,
      substr(j.schedule_expr,instr(j.schedule_expr,'"') + 1,
        length(j.schedule_expr)-instr(j.schedule_expr,'"'))),
    /* SCHEDULE_TYPE */
    DECODE(BITAND(j.flags, 1+2+512+1024+2048+4096+8192+16384+134217728+34359738368),
      512,'PLSQL',1024,'NAMED',2048,'CALENDAR',4096,'WINDOW',4098,'WINDOW_GROUP',
      8192,'ONCE',16384,'IMMEDIATE',34493956096, 'FILE_WATCHER',
      134217728,'EVENT',NULL),
    /* START_DATE */
    j.start_date,
    /* REPEAT_INTERVAL */
    DECODE(BITAND(j.flags,1024+4096+134217728), 0, j.schedule_expr, NULL),
    /* EVENT_QUEUE_OWNER */
    j.queue_owner,
    /* EVENT_QUEUE_NAME */
    j.queue_name,
    /* EVENT_QUEUE_AGENT */
    j.queue_agent,
    /* EVENT_CONDITION */
    DECODE(BITAND(j.flags,134217728), 0, NULL,
      DECODE(BITAND(j.flags,1024+4096), 0, j.schedule_expr, NULL)),
    /* EVENT_RULE */
    j.event_rule,
    /* FILE_WATCHER_OWNER */
    DECODE(BITAND(j.flags, 34359738368), 0, NULL,
      substr(j.fw_name,1,instr(j.fw_name,'"')-1)),
    /* FILE_WATCHER_NAME */
    DECODE(BITAND(j.flags, 34359738368), 0, NULL,
      substr(j.fw_name,instr(j.fw_name,'"') + 1,
        length(j.fw_name)-instr(j.fw_name,'"'))),
    /* END_DATE */
    j.end_date,
    /* JOB_CLASS */
    co.name,
    /* ENABLED */
    DECODE(BITAND(j.job_status,1),0,'FALSE','TRUE'),
    /* AUTO_DROP */
    DECODE(BITAND(j.flags,32768),0,'TRUE','FALSE'),
    /* RESTART_ON_RECOVERY */
    DECODE(BITAND(j.flags, 35184372088832),0,'FALSE','TRUE'),
    /* RESTART_ON_FAILURE */
    DECODE(BITAND(j.flags, 70368744177664),0,'FALSE','TRUE'),
    /* STATE */
    (CASE WHEN j.job_dest_id <> 0 AND
     bitand(j.flags, 549755813888) <> 0 THEN 'RUNNING'
     ELSE
    DECODE(BITAND(j.job_status,2+65536),2,'RUNNING',2+65536,'CHAIN_STALLED',
    DECODE(BITAND(j.job_status,1+4+8+16+32+128+8192+524288),0,'DISABLED',1,
      (CASE WHEN j.retry_count>0  AND bitand(j.flags, 549755813888) = 0
            THEN 'RETRY SCHEDULED'
            WHEN (bitand(j.job_status, 1024) <> 0) THEN 'READY TO RUN'
            WHEN (bitand(j.job_status,8589934592)=8589934592) THEN 'BLOCKED'
            WHEN (bitand(j.job_status,4294967296)=4294967296)
                      THEN 'RESOURCE_UNAVAILABLE'
            ELSE 'SCHEDULED' END),
      4,'COMPLETED',8,'BROKEN',16,'FAILED',
      32,'SUCCEEDED' ,128,'REMOTE',8192, 'STOPPED',
      524288, 'SOME FAILED', NULL)) END),
    j.priority, j.run_count, cast(NULL as number), j.max_runs,
    j.failure_count, cast(NULL as number), j.max_failures,
    decode(bitand(j.flags, 549755813888), 0, j.retry_count, 0),
    /* LAST_START_DATE */
    j.last_start_date,
    /* LAST_RUN_DURATION*/
    (CASE WHEN j.last_end_date>j.last_start_date THEN j.last_end_date-j.last_start_date
       ELSE NULL END),
    /* NEXT_RUN_DATE */
    j.next_run_date,
    /* SCHEDULER_LIMIT */
    j.schedule_limit,
    /* MAX_RUN_DURATION */
    j.max_run_duration,
    /* LOGGING_LEVEL */
    DECODE(BITAND(j.flags,32+64+128+256),32,'OFF',64,'RUNS',128,'FAILED RUNS',
      256,'FULL',NULL),
    /* STORE_OUTPUT */
    DECODE(BITAND(j.flags,9007199254740992),0,'FALSE','TRUE'),
    /* STOP_ON_WINDOW_CLOSE */
    DECODE(BITAND(j.flags,8),0,'FALSE','TRUE'),
    /* INSTANCE_STICKINESS */
    DECODE(BITAND(j.flags,16),0,'FALSE','TRUE'),
    /* RAISE_EVENTS */
    sys.dbms_scheduler.generate_event_list(j.job_status),
    /* SYSTEM */
    DECODE(BITAND(j.flags,16777216),0,'FALSE','TRUE'),
    /* JOB_WEIGHT */
    j.job_weight,
    /* NLS_ENV */
    j.nls_env,
    /* SOURCE */
    j.source,
    /* NUMBER_OF_DESTINATIONS */
    decode(bitand(j.flags, 274877906944), 0, 1,
    decode(bitand(j.flags, 549755813888), 0, 1,
    (select count(*) from all_scheduler_job_dests ajd
     where ajd.owner = ju.name and ajd.job_name = jo.name))),
    /* DESTINATION_OWNER */
    decode(bitand(j.flags, 274877906944), 0, NULL,
       substr(j.destination, 1, instr(j.destination, '"')-1)),
    /* DESTINATION */
    decode(bitand(j.flags, 274877906944), 0, j.destination,
    substr(j.destination, instr(j.destination, '"')+1,
           length(j.destination) - instr(j.destination, '"'))),
    /* CREDENTIAL_OWNER */
    j.credential_owner,
    /* CREDENTIAL_NAME */
    j.credential_name,
    /* INSTANCE_ID */
    j.instance_id,
    /* DEFERRED_DROP */
    DECODE(BITAND(j.job_status,131072),0,'FALSE','TRUE'),
    /* ALLOW_RUNS_IN_RESTRICTED_MODE */
    DECODE(BITAND(j.flags,17179869184),0,'FALSE','TRUE'),
    /* COMMENTS */
    j.comments,
    /* FLAGS*/
    j.flags,
    /* RESTARTABLE */
    DECODE(BITAND(j.flags,35184372088832 + 70368744177664),
            35184372088832 + 70368744177664,'TRUE','FALSE'),
    /* has_constraints */
    DECODE(BITAND(j.flags,2251799813685248),0,'FALSE','TRUE'),
    /* connect credential owner and name */
    j.connect_credential_owner, j.connect_credential_name,
    /* FAIL_ON_SCRIPT_ERROR*/
    DECODE(BITAND(j.flags, 36028797018963968), 0, 'FALSE', 'TRUE')
  FROM obj$ jo, user$ ju, sys.scheduler$_job j, obj$ co
  WHERE j.obj# = jo.obj# AND jo.owner# = ju.user# AND
    j.class_oid = co.obj#(+) AND
   ( (j.database_role = SYS_CONTEXT('userenv','database_role')) OR
     (j.database_role = 'ALL')           OR
     (j.database_role is null AND SYS_CONTEXT('userenv','database_role') = 'PRIMARY')) AND
    (jo.owner# = userenv('SCHEMAID')
       or jo.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                    where priv_number in (-265 /* CREATE ANY JOB */,
                                          -255 /* EXPORT FULL DATABASE */ )
                 )
          and jo.owner#!=0)
       )
 UNION ALL
  SELECT
    /* OWNER */
    lu.name,
    /* JOB_NAME */
    lo.name,
    /* JOB_SUBNAME */
    lo.subname,
    /* JOB_STYLE */
    decode(bitand(l.flags, 17592186044416), 0, 'LIGHTWEIGHT',
      'IN_MEMORY_RUNTIME'),
    /* JOB_CREATOR */
    l.creator,
    /* CLIENT_ID */
    l.client_id,
    /* GLOBAL_UID */
    l.guid,
    /* PROGRAM_OWNER */
    lu.name,
    /* PROGRAM_NAME */
    po.name,
    /* JOB_TYPE */
    NULL,
    /* JOB_ACTION */
    NULL,
    /* NUMBER_OF_ARGUMENTS */
    NULL,
    /* SCHEDULER_OWNER */
    DECODE(bitand(l.flags,1024+4096),0,NULL,
      substr(l.schedule_expr,1,instr(l.schedule_expr,'"')-1)),
    /* SCHEDULE_NAME */
    DECODE(bitand(l.flags,1024+4096),0,NULL,
      substr(l.schedule_expr,instr(l.schedule_expr,'"') + 1,
        length(l.schedule_expr)-instr(l.schedule_expr,'"'))),
    /* SCHEDULE_TYPE */
    DECODE(BITAND(l.flags, 1+2+512+1024+2048+4096+8192+16384+134217728+34359738368),
      512,'PLSQL',1024,'NAMED',2048,'CALENDAR',4096,'WINDOW',4098,'WINDOW_GROUP',
      8192,'ONCE',16384,'IMMEDIATE',34493956096, 'FILE_WATCHER',
      134217728,'EVENT',NULL),
    /* START_DATE */
    l.start_date,
    /* REPEAT_INTERVAL */
    DECODE(BITAND(l.flags,1024+4096+134217728), 0, l.schedule_expr, NULL),
    /* EVENT_QUEUE_OWNER */
    l.queue_owner,
    /* EVENT_QUEUE_NAME */
    l.queue_name,
    /* EVENT_QUEUE_AGENT */
    l.queue_agent,
    /* EVENT_CONDITION */
    DECODE(BITAND(l.flags,134217728), 0, NULL,
      DECODE(BITAND(l.flags,1024+4096), 0, l.schedule_expr, NULL)),
    /* EVENT_RULE */
    l.event_rule,
    /* FILE_WATCHER_OWNER */
    DECODE(BITAND(l.flags, 34359738368), 0, NULL,
      substr(l.fw_name,1,instr(l.fw_name,'"')-1)),
    /* FILE_WATCHER_NAME */
    DECODE(BITAND(l.flags, 34359738368), 0, NULL,
      substr(l.fw_name,instr(l.fw_name,'"') + 1,
        length(l.fw_name)-instr(l.fw_name,'"'))),
    /* END_DATE */
    l.end_date,
    /* JOB_CLASS */
    lco.name,
    /* ENABLED */
    DECODE(BITAND(l.job_status,1),0,'FALSE','TRUE'),
    /* AUTO_DROP */
    DECODE(BITAND(l.flags,32768),0,'TRUE','FALSE'),
    /* RESTART_ON_RECOVERY */
    DECODE(BITAND(l.flags, 35184372088832),0,'FALSE','TRUE'),
    /* RESTART_ON_FAILURE */
    DECODE(BITAND(l.flags, 70368744177664),0,'FALSE','TRUE'),
    /* STATE */
    DECODE(BITAND(l.job_status,2+65536),2,'RUNNING',2+65536,'CHAIN_STALLED',
    DECODE(BITAND(l.job_status,1+4+8+16+32+128+8192),0,'DISABLED',1,
      (CASE WHEN l.retry_count>0 THEN 'RETRY SCHEDULED'
            WHEN (bitand(l.job_status, 1024) <> 0) THEN 'READY TO RUN'
            ELSE 'SCHEDULED' END),
      4,'COMPLETED',8,'BROKEN',16,'FAILED',
      32,'SUCCEEDED' ,128,'REMOTE',8192, 'STOPPED', NULL)),
    NULL,
    decode(bitand(l.flags, 17592186044416), 0,
           l.run_count, cast(NULL as number)),
    decode(bitand(l.flags, 17592186044416), 0,
           cast(NULL as number), l.run_count),
    NULL,
    decode(bitand(l.flags, 17592186044416), 0,
           l.failure_count, cast(NULL as number)),
    decode(bitand(l.flags, 17592186044416), 0,
           cast(NULL as number), l.failure_count),
    NULL,
    /* RETRY_COUNT */
    l.retry_count,
    /* LAST_START_DATE */
    l.last_start_date,
    /* LAST_RUN_DURATION*/
    (CASE WHEN l.last_end_date>l.last_start_date THEN l.last_end_date-l.last_start_date
       ELSE NULL END),
    /* NEXT_RUN_DATE */
    l.next_run_date,
    /* SCHEDULER_LIMIT */
    NULL,
    /* MAX_RUN_DURATION */
    NULL,
    /* LOGGING_LEVEL */
    DECODE(BITAND(l.flags,32+64+128+256),32,'OFF',64,'RUNS',128,'FAILED RUNS',
      256,'FULL',NULL),
    /* STORE_OUTPUT */
    DECODE(BITAND(l.flags,9007199254740992),0,'FALSE','TRUE'),
    /* STOP_ON_WINDOW_CLOSE */
    DECODE(BITAND(l.flags,8),0,'FALSE','TRUE'),
    /* INSTANCE_STICKINESS */
    DECODE(BITAND(l.flags,16),0,'FALSE','TRUE'),
    /* RAISE_EVENTS */
    sys.dbms_scheduler.generate_event_list(l.job_status),
    /* SYSTEM */
    DECODE(BITAND(l.flags,16777216),0,'FALSE','TRUE'),
    /* JOB_WEIGHT */
    NULL,
    /* NLS_ENV */
    NULL,
    /* SOURCE */
    NULL,
    /* NUMBER_OF_DESTINATIONS */
    1,
    /* DESTINATION_OWNER */
    NULL,
    /* DESTINATION */
    NULL,
    /* CREDENTIAL_OWNER */
    NULL,
    /* CREDENTIAL_NAME */
    NULL,
    /* INSTANCE_ID */
    l.instance_id,
    /* DEFERRED_DROP */
    DECODE(BITAND(l.job_status,131072),0,'FALSE','TRUE'),
    /* ALLOW_RUNS_IN_RESTRICTED_MODE */
    DECODE(BITAND(l.flags,17179869184),0,'FALSE','TRUE'),
    /* COMMENTS */
    NULL,
    /* FLAGS*/
    l.flags,
    /* RESTARTABLE */
    DECODE(BITAND(l.flags,35184372088832 + 70368744177664),
            35184372088832 + 70368744177664,'TRUE','FALSE'),
    'FALSE', NULL, NULL,
    /* FAIL_ON_SCRIPT_ERROR */
    NULL
  FROM scheduler$_lwjob_obj lo, user$ lu, obj$ lco,
    scheduler$_comb_lw_job l, obj$ po
  WHERE ((bitand(l.flags, 8589934592) = 0 AND po.type# = 67) OR
         (bitand(l.flags, 8589934592) <> 0 AND po.type# = 66))
    AND bitand(l.flags, 137438953472) = 0
    AND l.obj# = lo.obj# AND l.program_oid = po.obj#
    AND lo.userid = lu.user# AND l.class_oid = lco.obj#(+) AND
    (lo.userid = userenv('SCHEMAID') OR
     po.obj# IN
       (SELECT oa.obj#
        from sys.objauth$ oa
        where grantee# in (select kzsrorol from x$kzsro)) OR
     (EXISTS (select null from v$enabledprivs
                           where priv_number in (-265 /* CREATE ANY JOB */,
                                          -255 /* EXPORT FULL DATABASE */ )
                 )
          and lo.userid!=0))
UNION ALL
 SELECT mu.name, mr.name, NULL, 'IN_MEMORY_FULL', md.creator, md.client_id,
   md.guid, mu.name, mpo.name, NULL, NULL, NULL, NULL, NULL, NULL,
   NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
   mco.name, decode(bitand(mr.job_status, 1), 1, 'TRUE', 'FALSE'), 'TRUE',
   'FALSE', 'FALSE',
   DECODE(BITAND(mr.job_status,2+65536),2,'RUNNING',2+65536,'CHAIN_STALLED',
     DECODE(BITAND(mr.job_status,1+4+8+16+32+128+8192),0,'DISABLED',1,
      (CASE WHEN (bitand(mr.job_status, 1024) <> 0) THEN 'READY TO RUN'
            ELSE 'SCHEDULED' END),
      4,'COMPLETED',8,'BROKEN',16,'FAILED',
      32,'SUCCEEDED' ,128,'REMOTE',8192, 'STOPPED', NULL)),
   NULL, cast(NULL as number), mr.run_count, NULL,
   cast(NULL as number), mr.failure_count, NULL, NULL, mr.last_start_date,
   NULL, mr.next_run_date, NULL, NULL,
   DECODE(BITAND(md.flags,32+64+128+256),32,'OFF',64,'RUNS',128,'FAILED RUNS',
      256,'FULL',NULL),
   DECODE(BITAND(md.flags,9007199254740992),0,'FALSE','TRUE'),
   'FALSE', 'TRUE', NULL,
   DECODE(BITAND(md.flags,16777216),0,'FALSE','TRUE'),
   NULL, NULL, NULL, 1, NULL, NULL, NULL, NULL, md.instance_id, 'FALSE', 'FALSE',
   NULL, md.flags, 'FALSE', 'FALSE', NULL, NULL,
   /* FAIL_ON_SCRIPT_ERROR */
   NULL
 FROM GV$SCHEDULER_INMEM_MDINFO md, GV$SCHEDULER_INMEM_RTINFO mr,
      obj$ mpo, user$ mu, obj$ mco
 WHERE md.objid = mr.objid and mpo.obj# = md.prgoid and md.clsoid = mco.obj#(+)
   AND mu.user# = mr.userid AND mr.id_type = 2 AND
   (mr.userid = userenv('SCHEMAID') OR
     mpo.obj# IN
       (SELECT oa.obj#
        from sys.objauth$ oa
        where grantee# in (select kzsrorol from x$kzsro)) OR
    (EXISTS (select null from v$enabledprivs
                           where priv_number in (-265 /* CREATE ANY JOB */,
                                          -255 /* EXPORT FULL DATABASE */ )
                 )
          and mr.userid!=0));

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."OWNER" IS 'Owner of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_NAME" IS 'Name of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_SUBNAME" IS 'Subname of the scheduler job (for a job running a chain step)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_STYLE" IS 'Job style - regular, lightweight or volatile';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_CREATOR" IS 'Original creator of this job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."CLIENT_ID" IS 'Client id of user creating this job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."GLOBAL_UID" IS 'Global uid of user creating this job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."PROGRAM_OWNER" IS 'Owner of the program associated with the job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."PROGRAM_NAME" IS 'Name of the program associated with the job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_TYPE" IS 'Inlined job action type';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_ACTION" IS 'Inlined job action';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."NUMBER_OF_ARGUMENTS" IS 'Inlined job number of arguments';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."SCHEDULE_OWNER" IS 'Owner of the schedule that this job uses (can be a window or window group)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."SCHEDULE_NAME" IS 'Name of the schedule that this job uses (can be a window or window group)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."SCHEDULE_TYPE" IS 'Type of the schedule that this job uses';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."START_DATE" IS 'Original scheduled start date of this job (for an inlined schedule)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."REPEAT_INTERVAL" IS 'Inlined schedule PL/SQL expression or calendar string';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."EVENT_QUEUE_OWNER" IS 'Owner of source queue into which event will be raised';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."EVENT_QUEUE_NAME" IS 'Name of source queue into which event will be raised';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."EVENT_QUEUE_AGENT" IS 'Name of AQ agent used by user on the event source queue (if it is a secure queue)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."EVENT_CONDITION" IS 'Boolean expression used as subscription rule for event on the source queue';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."EVENT_RULE" IS 'Name of rule used by the coordinator to trigger event based job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."FILE_WATCHER_OWNER" IS 'Owner of file watcher on which this job is based';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."FILE_WATCHER_NAME" IS 'Name of file watcher on which this job is based';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."END_DATE" IS 'Date after which this job will no longer run (for an inlined schedule)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_CLASS" IS 'Name of job class associated with the job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."ENABLED" IS 'Whether the job is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."AUTO_DROP" IS 'Whether this job will be dropped when it has completed';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."RESTART_ON_RECOVERY" IS 'Whether this job can be restarted after a db crash';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."RESTART_ON_FAILURE" IS 'Whether this job can be re-tried if it fails';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."STATE" IS 'Current state of the job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_PRIORITY" IS 'Priority of the job relative to others within the same class';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."RUN_COUNT" IS 'Number of times this job has run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."MAX_RUNS" IS 'Maximum number of times this job is scheduled to run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."FAILURE_COUNT" IS 'Number of times this job has failed to run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."MAX_FAILURES" IS 'Number of times this job will be allowed to fail before being marked broken';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."RETRY_COUNT" IS 'Number of times this job has retried, if it is retrying.';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."LAST_START_DATE" IS 'Last date on which the job started running';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."LAST_RUN_DURATION" IS 'How long the job took last time';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."NEXT_RUN_DATE" IS 'Next date the job is scheduled to run on';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."SCHEDULE_LIMIT" IS 'Time in minutes after which a job which has not run yet will be rescheduled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."MAX_RUN_DURATION" IS 'This column is reserved for future use';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."LOGGING_LEVEL" IS 'Amount of logging that will be done pertaining to this job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."STORE_OUTPUT" IS 'Determines if full job output is to be stored';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."STOP_ON_WINDOW_CLOSE" IS 'Whether this job will stop if a window it is associated with closes';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."INSTANCE_STICKINESS" IS 'Whether this job is sticky';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."RAISE_EVENTS" IS 'List of job events to raise for this job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."SYSTEM" IS 'Whether this is a system job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."JOB_WEIGHT" IS 'Weight of this job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."NLS_ENV" IS 'NLS environment of this job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."SOURCE" IS 'Source global database identifier';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."DESTINATION_OWNER" IS 'Owner of destination object (if used) else NULL';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."DESTINATION" IS 'Destination that this job will run on';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."CREDENTIAL_OWNER" IS 'Owner of the login credential';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."CREDENTIAL_NAME" IS 'Name of the login credential';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."INSTANCE_ID" IS 'Instance user requests job to run on.';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."DEFERRED_DROP" IS 'Whether this job will be dropped when completed due to user request.';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."COMMENTS" IS 'Comments on the job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."FLAGS" IS 'This column is for internal use.';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."RESTARTABLE" IS 'Whether this job can be restarted or not';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."HAS_CONSTRAINTS" IS 'Whether this job (not including program of job) is part of a resource constraint or incompatibility';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."CONNECT_CREDENTIAL_OWNER" IS 'Owner of connect credential';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."CONNECT_CREDENTIAL_NAME" IS 'Name of connect credential';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_JOBS"."FAIL_ON_SCRIPT_ERROR" IS 'Wheter this job is set as failed when and script error occurs';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_JOBS"  IS 'All scheduler jobs visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_NOTIFICATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_NOTIFICATIONS" ("NOTIFICATION_OWNER", "OWNER", "JOB_NAME", "JOB_SUBNAME", "RECIPIENT", "SENDER", "SUBJECT", "BODY", "FILTER_CONDITION", "EVENT", "EVENT_FLAG") AS 
  SELECT sr.notification_owner,sr.owner, sr.job_name , sr.job_subname, sr.recipient,
    sr.sender , sr.subject , sr.body , sr.filter_condition ,
    DECODE(BITAND(sr.event_flag,1024-1),1,'JOB_STARTED',2,'JOB_SUCCEEDED',
      4,'JOB_FAILED',8,'JOB_BROKEN',16,'JOB_COMPLETED',32,'JOB_STOPPED',
      64,'JOB_SCH_LIM_REACHED',128,'JOB_DISABLED',256,'JOB_CHAIN_STALLED',
      512,'JOB_OVER_MAX_DUR', NULL), sr.event_flag
  FROM scheduler$_notification sr
  WHERE
    BITAND(flags,1)=0 AND
    (sr.owner = sys_context('USERENV', 'CURRENT_USER')
       or exists
            (select null
             from sys.objauth$ oa, sys.obj$ o, sys.user$ u
             where oa.grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
               and oa.obj#=o.obj# and o.owner#=u.user#
               and o.name=sr.job_name and u.name=sr.owner
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number = -265 /* CREATE ANY JOB */
                 )
          and sr.owner!='SYS'
         )
    );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."NOTIFICATION_OWNER" IS 'Owner of this notification';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."OWNER" IS 'Owner of the job this notification is for';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."JOB_NAME" IS 'Name of the job this notification is for';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."JOB_SUBNAME" IS 'Subname of the job this notification is for';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."RECIPIENT" IS 'E-mail address to send this e-mail notification to';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."SENDER" IS 'E-mail address to send this e-mail notification from';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."SUBJECT" IS 'Subject of the notification e-mail';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."BODY" IS 'Body of the notification e-mail';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."FILTER_CONDITION" IS 'Filter specifying which job events to send notifications for';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."EVENT" IS 'Job event to send notifications for';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_NOTIFICATIONS"."EVENT_FLAG" IS 'Event number of job event to send notifications for';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_NOTIFICATIONS"  IS 'All job e-mail notifications visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_PROGRAM_ARGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_PROGRAM_ARGS" ("OWNER", "PROGRAM_NAME", "ARGUMENT_NAME", "ARGUMENT_POSITION", "ARGUMENT_TYPE", "METADATA_ATTRIBUTE", "DEFAULT_VALUE", "DEFAULT_ANYDATA_VALUE", "OUT_ARGUMENT") AS 
  SELECT u.name, o.name, a.name, a.position,
  CASE WHEN (a.user_type_num IS NULL) THEN
    DECODE(a.type_number,
0, null,
1, decode(a.flags, 512, 'NVARCHAR2', 'VARCHAR2'),
2, decode(a.flags, 512, 'FLOAT', 'NUMBER'),
3, 'NATIVE INTEGER',
8, 'LONG',
9, decode(a.flags, 512, 'NCHAR VARYING', 'VARCHAR'),
11, 'ROWID',
12, 'DATE',
23, 'RAW',
24, 'LONG RAW',
29, 'BINARY_INTEGER',
69, 'ROWID',
96, decode(a.flags, 512, 'NCHAR', 'CHAR'),
100, 'BINARY_FLOAT',
101, 'BINARY_DOUBLE',
102, 'REF CURSOR',
104, 'UROWID',
105, 'MLSLABEL',
106, 'MLSLABEL',
110, 'REF',
111, 'REF',
112, decode(a.flags, 512, 'NCLOB', 'CLOB'),
113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
121, 'OBJECT',
122, 'TABLE',
123, 'VARRAY',
178, 'TIME',
179, 'TIME WITH TIME ZONE',
180, 'TIMESTAMP',
181, 'TIMESTAMP WITH TIME ZONE',
231, 'TIMESTAMP WITH LOCAL TIME ZONE',
182, 'INTERVAL YEAR TO MONTH',
183, 'INTERVAL DAY TO SECOND',
250, 'PL/SQL RECORD',
251, 'PL/SQL TABLE',
252, 'PL/SQL BOOLEAN',
'UNDEFINED')
    ELSE t_u.name ||'.'|| t_o.name END,
  DECODE(bitand(a.flags, 2+4+64+128+256+1024+2048+8192+16384+32768
         +65536+131072+262144+524288+1048576),
         2,'JOB_NAME',4,'JOB_OWNER',
         64, 'JOB_START', 128, 'WINDOW_START',
         256, 'WINDOW_END', 1024, 'JOB_SUBNAME',
         2048, 'EVENT_MESSAGE', 8192, 'JOB_SCHEDULED_START',
         16384, 'CHAIN_ID', 32768, 'CREDENTIAL_OWNER',
         65536, 'CREDENTIAL_NAME', 131072, 'DESTINATION_OWNER',
         262144, 'DESTINATION_NAME', 524288, 'JOB_DEST_ID',
         1048576, 'LOG_ID', ''),
  dbms_scheduler.get_varchar2_value(a.value), a.value,
  DECODE(BITAND(a.flags,1),0,'FALSE',1,'TRUE')
  FROM obj$ o, user$ u, sys.scheduler$_program_argument a, obj$ t_o, user$ t_u
  WHERE a.oid = o.obj# AND u.user# = o.owner# AND
    a.user_type_num = t_o.obj#(+) AND t_o.owner# = t_u.user#(+) AND
    (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -255 /* EXPORT FULL DATABASE */,
                                       -266 /* EXECUTE ANY PROGRAM */ )
                 )
          and o.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."OWNER" IS 'Owner of the program this argument belongs to';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."PROGRAM_NAME" IS 'Name of the program this argument belongs to';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."ARGUMENT_NAME" IS 'Optional name of this argument';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."ARGUMENT_POSITION" IS 'Position of this argument in the argument list';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."ARGUMENT_TYPE" IS 'Data type of this argument';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."METADATA_ATTRIBUTE" IS 'Metadata attribute (if a metadata argument)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."DEFAULT_VALUE" IS 'Default value taken by this argument in string format (if a string)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."DEFAULT_ANYDATA_VALUE" IS 'Default value taken by this argument in AnyData format';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"."OUT_ARGUMENT" IS 'Whether this is an out argument';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_PROGRAM_ARGS"  IS 'All arguments of all scheduler programs visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_PROGRAMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_PROGRAMS" ("OWNER", "PROGRAM_NAME", "PROGRAM_TYPE", "PROGRAM_ACTION", "NUMBER_OF_ARGUMENTS", "ENABLED", "DETACHED", "SCHEDULE_LIMIT", "PRIORITY", "WEIGHT", "MAX_RUNS", "MAX_FAILURES", "MAX_RUN_DURATION", "HAS_CONSTRAINTS", "NLS_ENV", "COMMENTS") AS 
  SELECT u.name, o.name,
  DECODE(bitand(p.flags,2+4+8+16+32+2048+4096+8192), 2,'PLSQL_BLOCK',
         4,'STORED_PROCEDURE', 32, 'EXECUTABLE', 2048, 'EXTERNAL_SCRIPT',
         4096, 'SQL_SCRIPT', 8192, 'BACKUP_SCRIPT', ''),
  p.action, p.number_of_args, DECODE(BITAND(p.flags,1),0,'FALSE',1,'TRUE'),
  DECODE(BITAND(p.flags,256),0,'FALSE','TRUE'),
  p.schedule_limit, p.priority, p.job_weight, p.max_runs,
  p.max_failures, p.max_run_duration,
  DECODE(BITAND(p.flags,16384),0,'FALSE','TRUE'),
  p.nls_env, p.comments
  FROM obj$ o, user$ u, sys.scheduler$_program p
  WHERE p.obj# = o.obj# AND u.user# = o.owner# AND
    (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -255 /* EXPORT FULL DATABASE */,
                                       -266 /* EXECUTE ANY PROGRAM */ )
                 )
          and o.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."OWNER" IS 'Owner of the scheduler program';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."PROGRAM_NAME" IS 'Name of the scheduler program';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."PROGRAM_TYPE" IS 'Type of program action';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."PROGRAM_ACTION" IS 'String specifying the program action';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."NUMBER_OF_ARGUMENTS" IS 'Number of arguments accepted by the program';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."ENABLED" IS 'Whether the program is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."DETACHED" IS 'This column is for internal use';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."SCHEDULE_LIMIT" IS 'Maximum delay in running program after scheduled start';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."PRIORITY" IS 'Priority of program';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."WEIGHT" IS 'Weight of program';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."MAX_RUNS" IS 'Maximum number of runs of program';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."MAX_FAILURES" IS 'Maximum number of failures of program';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."MAX_RUN_DURATION" IS 'Maximum run duration of program';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."HAS_CONSTRAINTS" IS 'Whether the program is used in a resource constraint or incompatibility';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."NLS_ENV" IS 'NLS Environment in which program was created';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_PROGRAMS"."COMMENTS" IS 'Comments on the program';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_PROGRAMS"  IS 'All scheduler programs visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_REMOTE_DATABASES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_REMOTE_DATABASES" ("DATABASE_NAME", "REGISTERED_AS", "DATABASE_LINK") AS 
  SELECT database_name, decode(reg_status, 0, 'SOURCE', 'DESTINATION'),
        database_link
 FROM scheduler$_remote_dbs
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_REMOTE_JOBSTATE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE" ("OWNER", "JOB_NAME", "DESTINATION", "STATE", "NEXT_START_DATE", "RUN_COUNT", "FAILURE_COUNT", "RETRY_COUNT", "LAST_START_DATE", "LAST_END_DATE") AS 
  SELECT u.name, o.name, j.destination,
        DECODE(BITAND(j.job_status,1+2+4+8+16+32+8192),0,'DISABLED',1,
        (CASE WHEN j.retry_count>0 THEN 'RETRY SCHEDULED' ELSE 'SCHEDULED' END),
        2, 'RUNNING',
        4,'COMPLETED',8,'BROKEN',16,'FAILED',
        32,'SUCCEEDED' ,8192, 'STOPPED', NULL),
	j.next_start_date, j.run_count,
        j.failure_count, j.retry_count,
        j.last_start_date, j.last_end_date
 FROM user$ u, obj$ o, scheduler$_remote_job_state j
 WHERE j.joboid = o.obj# and o.owner# = u.user# and
    (o.owner# = USERENV('SCHEMAID') or
     o.obj# in
        (select oa.obj#
             from sys.objauth$ oa
              where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number = -265 /* CREATE ANY JOB */
                 )
          and o.owner#!=0)
       );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."OWNER" IS 'Owner of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."JOB_NAME" IS 'Name of the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."DESTINATION" IS 'Name of job destination';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."STATE" IS 'State of job at remote system';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."NEXT_START_DATE" IS 'Next start date of job on remote system';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."RUN_COUNT" IS 'Run count of job on remote system';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."FAILURE_COUNT" IS 'Failure count of job on remote system';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."LAST_START_DATE" IS 'Last start time of job on remote system';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"."LAST_END_DATE" IS 'Last end date of job on remote system';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_REMOTE_JOBSTATE"  IS 'Remote state of all jobs originating from this database visible to current user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_RESOURCES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_RESOURCES" ("OWNER", "RESOURCE_NAME", "STATUS", "RESOURCE_UNITS", "UNITS_USED", "JOBS_RUNNING_COUNT", "COMMENTS") AS 
  SELECT su.name, so.name,
      decode(r.status,1, 'ENFORCE_CONSTRAINTS',
                      2, 'IGNORE_CONSTRAINTS',
                         'BLOCKED_ALL_JOBS'),
      r.resource_count,
      ru.units_in_use,
      ru.jobs_running,
      r.comments
  FROM obj$ so, user$ su, sys.scheduler$_resources r,
      scheduler$_resource_usage ru
  WHERE r.obj# = so.obj# AND so.owner# = su.user# and
                 r.obj# = ru.resoid and
      bitand(r.flags,1) = 1
     AND (so.owner# = userenv('SCHEMAID')
       or so.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -266 /* EXECUTE ANY PROGRAM */,
                                       -390 /* USE ANY JOB RESOURCE */)
                 )
          and so.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RESOURCES"."OWNER" IS 'Owner of the resource object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RESOURCES"."RESOURCE_NAME" IS 'Name of the resource object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RESOURCES"."STATUS" IS 'Resource status for resource object.';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RESOURCES"."RESOURCE_UNITS" IS 'Maximum number of available units for the resource object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RESOURCES"."UNITS_USED" IS 'Current number of resource units in use for the resource object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RESOURCES"."JOBS_RUNNING_COUNT" IS 'Current number of running jobs using the resource object';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RESOURCES"."COMMENTS" IS 'Comments for the resource object';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_RESOURCES"  IS 'All scheduler resource objects in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_RSC_CONSTRAINTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_RSC_CONSTRAINTS" ("OBJECT_OWNER", "OBJECT_NAME", "RESOURCE_OWNER", "RESOURCE_NAME", "UNITS_USED") AS 
  SELECT pu.name, po.name,
           ru.name, ro.name,
      pc.resource_count
  FROM obj$ ro, user$ ru, obj$ po, user$ pu, sys.scheduler$_resources r,
                 scheduler$_constraints pc
  WHERE r.obj# = ro.obj# AND ro.owner# = ru.user#
       AND pc.resoid = r.obj# AND pc.oid = po.obj#
       AND  po.owner# = pu.user#
       AND bitand(r.flags, 1) = 1
       AND (
        ro.owner# = userenv('SCHEMAID')
       or  po.owner# = userenv('SCHEMAID')
       or ro.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or po.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         (exists (select null from v$enabledprivs
                 where priv_number in (-265 /* CREATE ANY JOB */,
                                       -266 /* EXECUTE ANY PROGRAM */,
                                       -390 /* USE ANY JOB RESOURCE */)
                 )
          and ro.owner#!=0)
      );

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RSC_CONSTRAINTS"."OBJECT_OWNER" IS 'Owner of the resource object the member is in';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RSC_CONSTRAINTS"."OBJECT_NAME" IS 'Name of the resource object the member is in';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RSC_CONSTRAINTS"."RESOURCE_OWNER" IS 'Owner of the resource constraint resource member';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RSC_CONSTRAINTS"."RESOURCE_NAME" IS 'Name of the resource constraint resource member';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RSC_CONSTRAINTS"."UNITS_USED" IS 'Number of units used of the resource by this constraint resource member';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_RSC_CONSTRAINTS"  IS 'All scheduler resource constraint members in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_RUNNING_CHAINS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_RUNNING_CHAINS" ("OWNER", "JOB_NAME", "JOB_SUBNAME", "CHAIN_OWNER", "CHAIN_NAME", "STEP_NAME", "STATE", "ERROR_CODE", "COMPLETED", "START_DATE", "END_DATE", "DURATION", "SKIP", "PAUSE", "PAUSE_BEFORE", "RESTART_ON_RECOVERY", "RESTART_ON_FAILURE", "STEP_JOB_SUBNAME", "STEP_JOB_LOG_ID") AS 
  SELECT ju.name, jo.name, jo.subname, cu.name, co.name, cv.var_name,
    DECODE(BITAND(jss.flags,2),2,
      DECODE(jss.status, 'K', 'PAUSED', 'F', 'PAUSED', 'R', 'RUNNING',
        'C', 'SCHEDULED', 'E', 'RETRY SCHEDULED', 'T', 'STALLED', 'P','PAUSED',
        'NOT_STARTED'),
      DECODE(jss.status, 'K', 'STOPPED', 'R', 'RUNNING', 'C', 'SCHEDULED', 'E',
        'RETRY SCHEDULED', 'T', 'STALLED', 'P', 'PAUSED', 'F',
        DECODE(jss.error_code,0,'SUCCEEDED','FAILED'), 'NOT_STARTED')),
    jss.error_code, DECODE(jss.status, 'F', 'TRUE', 'K', 'TRUE','FALSE'),
    jss.start_date, jss.end_date,
    (CASE WHEN jss.end_date>jss.start_date THEN jss.end_date-jss.start_date
       ELSE NULL END),
    DECODE(BITAND(jss.flags,1),0,'FALSE',1,'TRUE',
      DECODE(BITAND(cv.flags,1),0,'FALSE',1,'TRUE')),
    DECODE(BITAND(jss.flags,2),0,'FALSE',2,'TRUE',
      DECODE(BITAND(cv.flags,2),0,'FALSE',2,'TRUE')),
    DECODE(BITAND(jss.flags,512),0,'FALSE',512,'TRUE',
      DECODE(BITAND(cv.flags,512),0,'FALSE',512,'TRUE')),
    DECODE(BITAND(jss.flags,64),0,'FALSE',64,'TRUE',
      DECODE(BITAND(cv.flags,64),0,'FALSE',64,'TRUE')),
    DECODE(BITAND(jss.flags,128),0,'FALSE',128,'TRUE',
      DECODE(BITAND(cv.flags,128),0,'FALSE',128,'TRUE')),
    jso.subname, jss.job_step_log_id
  FROM sys.scheduler$_job j JOIN obj$ jo ON (j.obj# = jo.obj#)
     JOIN user$ ju ON
     (jo.owner# = ju.user# AND
       (jo.owner# = userenv('SCHEMAID')
         or jo.obj# in
              (select oa.obj#
               from sys.objauth$ oa
               where grantee# in ( select kzsrorol
                                   from x$kzsro
                                 )
              )
         or /* user has system privileges */
           (exists (select null from v$enabledprivs
                   where priv_number in (-265 /* CREATE ANY JOB */)
                   )
            and jo.owner#!=0
           )
       )
     )
     JOIN obj$ co ON (co.obj# = j.program_oid)
     JOIN user$ cu ON (co.owner# = cu.user#)
     JOIN scheduler$_step cv ON (cv.oid = j.program_oid)
     LEFT OUTER JOIN scheduler$_step_state jss
       ON (jss.job_oid = j.obj# AND jss.step_name = cv.var_name)
     LEFT OUTER JOIN obj$ jso ON (jss.job_step_oid = jso.obj#)
     WHERE (BITAND(j.job_status,2+256) != 0 OR jo.subname IS NOT NULL);

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."OWNER" IS 'Owner of the job which is running the chain';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."JOB_NAME" IS 'Name of the job which is running the chain';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."JOB_SUBNAME" IS 'Subname of the job which is running the chain (for a subchain)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."CHAIN_OWNER" IS 'Owner of the chain being run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."CHAIN_NAME" IS 'Name of the chain being run';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."STEP_NAME" IS 'Name of this step of the running chain';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."STATE" IS 'State of this step';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."ERROR_CODE" IS 'Error code of this step, if it has finished running';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."COMPLETED" IS 'Whether this step has completed';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."START_DATE" IS 'When this step started, if it has already started';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."END_DATE" IS 'When this job step finished running, if it has finished running';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."DURATION" IS 'How long this step took to complete, if it has completed';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."SKIP" IS 'Whether this step will be skipped or not';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."PAUSE" IS 'Whether this step will be paused after running or not';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."PAUSE_BEFORE" IS 'Whether this step will be paused before running or not';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."RESTART_ON_RECOVERY" IS 'Whether this step will be restarted on database recovery';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."RESTART_ON_FAILURE" IS 'Whether this step should be retried on application failure';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."STEP_JOB_SUBNAME" IS 'Subname of the job running this step, if the step job has been created';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"."STEP_JOB_LOG_ID" IS 'Log id of the step job if it has completed and has been logged.';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_RUNNING_CHAINS"  IS 'All job steps of running job chains visible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_RUNNING_JOBS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_RUNNING_JOBS" ("OWNER", "JOB_NAME", "JOB_SUBNAME", "JOB_STYLE", "DETACHED", "SESSION_ID", "SLAVE_PROCESS_ID", "SLAVE_OS_PROCESS_ID", "RUNNING_INSTANCE", "RESOURCE_CONSUMER_GROUP", "ELAPSED_TIME", "CPU_USED", "DESTINATION_OWNER", "DESTINATION", "CREDENTIAL_OWNER", "CREDENTIAL_NAME", "LOG_ID") AS 
  SELECT ju.name, jo.name, jo.subname, 'REGULAR',
       (CASE WHEN p.obj# IS NULL OR BITAND(p.flags,256) = 0
                       OR rj.job_id  IS NOT NULL THEN 'FALSE'
             ELSE 'TRUE'
       END),
      rj.session_id, vp.pid,
      rj.os_process_id, rj.inst_id, vse.resource_consumer_group,
      CAST (systimestamp-j.last_start_date AS INTERVAL DAY(3) TO SECOND(2)),
      rj.session_stat_cpu,
      decode(bitand(j.flags, 2473901162496), 0, NULL, 2473901162496, NULL,
       substrb(j.destination, 1, instrb(j.destination, '"')-1)),
      decode(bitand(j.flags, 2473901162496), 0, j.destination,
        2473901162496, 'LOCAL',
        substrb(j.destination, instrb(j.destination, '"')+1,
           lengthb(j.destination) - instrb(j.destination, '"'))),
      j.credential_owner, j.credential_name,
      bitand(j.running_slave,18446744069414584320)/4294967296
  FROM
      scheduler$_job j JOIN obj$ jo ON (j.obj# = jo.obj#)
      JOIN user$ ju ON (jo.owner# = ju.user# AND
        (jo.owner# = userenv('SCHEMAID')
         or jo.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
         or /* user has system privileges */
           (exists (select null from v$enabledprivs
                 where priv_number  = -265 /* CREATE ANY JOB */
                )
            and jo.owner#!=0)
        )
      )
      LEFT OUTER JOIN gv$scheduler_running_jobs rj ON (rj.job_id = j.obj#)
      LEFT OUTER JOIN gv$session vse ON
        (rj.session_id = vse.sid AND rj.session_serial_num = vse.serial#
         AND vse.inst_id = rj.inst_id)
      LEFT OUTER JOIN gv$process vp ON
        (rj.paddr = vp.addr AND rj.inst_id = vp.inst_id)
      LEFT OUTER JOIN scheduler$_program p ON (j.program_oid = p.obj#)
  WHERE (BITAND(j.job_status,2) = 2 OR
          (BITAND(j.flags, 274877906944) <> 0 AND j.job_dest_id <> 0))
        AND ((j.database_role = SYS_CONTEXT('userenv','database_role')) OR
             (j.database_role = 'ALL')           OR
             (j.database_role is null AND SYS_CONTEXT('userenv','database_role') = 'PRIMARY'))
UNION ALL
  SELECT lju.name, ljo.name, ljo.subname,
       decode(bitand(lj.flags, 17592186044416), 0, 'LIGHTWEIGHT',
          'IN_MEMORY_RUNTIME'),
       (CASE WHEN BITAND(lp.flags,256) = 0
                OR lrj.job_id is NOT NULL THEN 'FALSE'
             ELSE 'TRUE'
       END),
       lrj.session_id, lvp.pid,
      lrj.os_process_id, lrj.inst_id, lvse.resource_consumer_group,
      CAST (systimestamp-lj.last_start_date AS INTERVAL DAY(3) TO SECOND(2)),
      lrj.session_stat_cpu,
      decode(bitand(lj.flags, 2473901162496), 0, NULL, 2473901162496, NULL,
       substrb(lj.destination, 1, instrb(lj.destination, '"')-1)),
      decode(bitand(lj.flags, 2473901162496), 0, lj.destination,
        2473901162496, 'LOCAL',
        substrb(lj.destination, instrb(lj.destination, '"')+1,
           lengthb(lj.destination) - instrb(lj.destination, '"'))),
      lj.credential_owner, lj.credential_name,
      bitand(lj.running_slave,18446744069414584320)/4294967296
  FROM scheduler$_comb_lw_job lj
      JOIN scheduler$_lwjob_obj ljo ON (lj.obj# = ljo.obj#)
      JOIN user$ lju ON (ljo.userid = lju.user# AND
        (ljo.userid = userenv('SCHEMAID')
         or (lj.program_oid is not null and
              lj.program_oid in
              (select loa.obj#
               from sys.objauth$ loa
               where grantee# in ( select kzsrorol
                                   from x$kzsro
                                 )
              )
            )
         or /* user has system privileges */
           (exists (select null from v$enabledprivs
                 where priv_number  = -265 /* CREATE ANY JOB */
                )
            and ljo.userid !=0)
        )
      )
      LEFT OUTER JOIN scheduler$_program lp ON (lj.program_oid = lp.obj#)
      LEFT OUTER JOIN gv$scheduler_running_jobs lrj ON (lrj.job_id = lj.obj#)
      LEFT OUTER JOIN gv$session lvse ON
        (lrj.session_id = lvse.sid AND lrj.session_serial_num = lvse.serial#
         AND lvse.inst_id = lrj.inst_id)
      LEFT OUTER JOIN gv$process lvp ON
        (lrj.paddr = lvp.addr AND lrj.inst_id = lvp.inst_id)
  WHERE BITAND(lj.job_status,2) = 2
UNION ALL
  SELECT mu.name, mr.name, NULL, 'IN_MEMORY_FULL', 'FALSE',
    lrj.session_id, lvp.pid,
      lrj.os_process_id, lrj.inst_id, lvse.resource_consumer_group,
    CAST (systimestamp-mr.last_start_date AS INTERVAL DAY(3) TO SECOND(2)),
      lrj.session_stat_cpu, NULL, NULL, NULL, NULL,
      bitand(mr.running_slave,18446744069414584320)/4294967296
  FROM GV$SCHEDULER_INMEM_RTINFO mr JOIN GV$SCHEDULER_INMEM_MDINFO md
    ON (mr.objid = md.objid)
    JOIN user$ mu ON (mr.userid = mu.user# AND
       (mr.userid = userenv('SCHEMAID')
        or (md.prgoid is not null and
            md.prgoid in
             (select loa.obj#
               from sys.objauth$ loa
               where grantee# in ( select kzsrorol
                                   from x$kzsro
                                 )
              )
            )
          or /* user has system privileges */
           (exists (select null from v$enabledprivs
                 where priv_number  = -265 /* CREATE ANY JOB */
                )
            and mr.userid !=0)
        ))
    LEFT OUTER JOIN scheduler$_program lp ON (md.prgoid = lp.obj#)
    LEFT OUTER JOIN gv$scheduler_running_jobs lrj ON (lrj.job_id = md.objid)
    LEFT OUTER JOIN gv$session lvse ON
       (lrj.session_id = lvse.sid AND lrj.session_serial_num = lvse.serial#
         AND lvse.inst_id = lrj.inst_id)
    LEFT OUTER JOIN gv$process lvp ON
        (lrj.paddr = lvp.addr AND lrj.inst_id = lvp.inst_id)
  WHERE BITAND(mr.job_status,2) = 2 AND mr.id_type = 2;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."OWNER" IS 'Owner of the running scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."JOB_NAME" IS 'Name of the running scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."JOB_SUBNAME" IS 'Subname of the running scheduler job (for a job running a chain step)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."JOB_STYLE" IS 'Job style - regular, lightweight or volatile';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."SLAVE_PROCESS_ID" IS 'Process number of the slave process running the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."SLAVE_OS_PROCESS_ID" IS 'Operating system process number of the slave process running the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."RUNNING_INSTANCE" IS 'Database instance number of the slave process running the scheduler job';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."RESOURCE_CONSUMER_GROUP" IS 'Resource consumer group of the session in which the scheduler job is running';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."ELAPSED_TIME" IS 'Time elapsed since the scheduler job started';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."CPU_USED" IS 'CPU time used by the running scheduler job, if available';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."DESTINATION_OWNER" IS 'Owner of destination object (if used) else NULL';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."DESTINATION" IS 'Destination that this job is running on';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."CREDENTIAL_OWNER" IS 'Owner of login credential used for this running job, if any';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."CREDENTIAL_NAME" IS 'Name of login credential used for this running job, if any';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_RUNNING_JOBS"."LOG_ID" IS 'Log id that will be used for this job run'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_SCHEDULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_SCHEDULES" ("OWNER", "SCHEDULE_NAME", "SCHEDULE_TYPE", "START_DATE", "REPEAT_INTERVAL", "EVENT_QUEUE_OWNER", "EVENT_QUEUE_NAME", "EVENT_QUEUE_AGENT", "EVENT_CONDITION", "FILE_WATCHER_OWNER", "FILE_WATCHER_NAME", "END_DATE", "COMMENTS") AS 
  SELECT "OWNER","SCHEDULE_NAME","SCHEDULE_TYPE","START_DATE","REPEAT_INTERVAL","EVENT_QUEUE_OWNER","EVENT_QUEUE_NAME","EVENT_QUEUE_AGENT","EVENT_CONDITION","FILE_WATCHER_OWNER","FILE_WATCHER_NAME","END_DATE","COMMENTS" FROM dba_scheduler_schedules;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."OWNER" IS 'Owner of the schedule';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."SCHEDULE_NAME" IS 'Name of the schedule';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."SCHEDULE_TYPE" IS 'Type of the schedule';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."START_DATE" IS 'Start date for the repeat interval';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."REPEAT_INTERVAL" IS 'Calendar syntax expression for this schedule';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."EVENT_QUEUE_OWNER" IS 'Owner of source queue into which event will be raised';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."EVENT_QUEUE_NAME" IS 'Name of source queue into which event will be raised';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."EVENT_QUEUE_AGENT" IS 'Name of AQ agent used by user on the event source queue (if it is a secure queue)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."EVENT_CONDITION" IS 'Boolean expression used as subscription rule for event on the source queue';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."FILE_WATCHER_OWNER" IS 'Owner of file watcher on which this schedule is based';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."FILE_WATCHER_NAME" IS 'Name of file watcher on which this schedule is based';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."END_DATE" IS 'Cutoff date after which the schedule will not specify any dates';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_SCHEDULES"."COMMENTS" IS 'Comments on this schedule';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_SCHEDULES"  IS 'All schedules in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_WINDOW_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_WINDOW_DETAILS" ("LOG_ID", "LOG_DATE", "OWNER", "WINDOW_NAME", "REQ_START_DATE", "ACTUAL_START_DATE", "WINDOW_DURATION", "ACTUAL_DURATION", "INSTANCE_ID", "ADDITIONAL_INFO") AS 
  SELECT "LOG_ID","LOG_DATE","OWNER","WINDOW_NAME","REQ_START_DATE","ACTUAL_START_DATE","WINDOW_DURATION","ACTUAL_DURATION","INSTANCE_ID","ADDITIONAL_INFO" FROM dba_scheduler_window_details;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."LOG_ID" IS 'The unique id of the log entry. Foreign key on entry in dba_scheduler_window_log';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."LOG_DATE" IS 'The date of the log entry';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."OWNER" IS 'The owner of the scheduler window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."WINDOW_NAME" IS 'The name of the scheduler window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."REQ_START_DATE" IS 'The requested start date for the scheduler window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."ACTUAL_START_DATE" IS 'The date the scheduler window actually started';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."WINDOW_DURATION" IS 'The original duration of the scheduler window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."ACTUAL_DURATION" IS 'The actual duration for which the scheduler window lasted';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."INSTANCE_ID" IS 'The id of the instance on which this window ran';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"."ADDITIONAL_INFO" IS 'Additional information on this entry, if applicable';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_WINDOW_DETAILS"  IS 'The details of a window'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_WINDOW_GROUPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_WINDOW_GROUPS" ("WINDOW_GROUP_NAME", "ENABLED", "NUMBER_OF_WINDOWS", "NEXT_START_DATE", "COMMENTS") AS 
  SELECT "WINDOW_GROUP_NAME","ENABLED","NUMBER_OF_WINDOWS","NEXT_START_DATE","COMMENTS" FROM dba_scheduler_window_groups;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_GROUPS"."WINDOW_GROUP_NAME" IS 'Name of the window group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_GROUPS"."ENABLED" IS 'Whether the window group is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_GROUPS"."NUMBER_OF_WINDOWS" IS 'Number of members in this window group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_GROUPS"."NEXT_START_DATE" IS 'Next start date of this window group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_GROUPS"."COMMENTS" IS 'An optional comment about this window group';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_WINDOW_GROUPS"  IS 'All scheduler window groups in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_WINDOW_LOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_WINDOW_LOG" ("LOG_ID", "LOG_DATE", "OWNER", "WINDOW_NAME", "OPERATION", "STATUS", "USER_NAME", "CLIENT_ID", "GLOBAL_UID", "ADDITIONAL_INFO") AS 
  SELECT "LOG_ID","LOG_DATE","OWNER","WINDOW_NAME","OPERATION","STATUS","USER_NAME","CLIENT_ID","GLOBAL_UID","ADDITIONAL_INFO" FROM dba_scheduler_window_log;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."LOG_ID" IS 'The unique id of the log entry';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."LOG_DATE" IS 'The date of this log entry';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."OWNER" IS 'The owner of the scheduler window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."WINDOW_NAME" IS 'The name of the scheduler window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."OPERATION" IS 'The operation corresponding to this log entry';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."STATUS" IS 'The status of the operation, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."USER_NAME" IS 'The name of the user who performed the operation, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."CLIENT_ID" IS 'The client id of the user who performed the operation, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."GLOBAL_UID" IS 'The global_uid of the user who performed the operation, if applicable';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOW_LOG"."ADDITIONAL_INFO" IS 'Additional information on this entry, if applicable';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_WINDOW_LOG"  IS 'Logged information for all scheduler windows'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_WINDOWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_WINDOWS" ("OWNER", "WINDOW_NAME", "RESOURCE_PLAN", "SCHEDULE_OWNER", "SCHEDULE_NAME", "SCHEDULE_TYPE", "START_DATE", "REPEAT_INTERVAL", "END_DATE", "DURATION", "WINDOW_PRIORITY", "NEXT_START_DATE", "LAST_START_DATE", "ENABLED", "ACTIVE", "MANUAL_OPEN_TIME", "MANUAL_DURATION", "COMMENTS") AS 
  SELECT "OWNER","WINDOW_NAME","RESOURCE_PLAN","SCHEDULE_OWNER","SCHEDULE_NAME","SCHEDULE_TYPE","START_DATE","REPEAT_INTERVAL","END_DATE","DURATION","WINDOW_PRIORITY","NEXT_START_DATE","LAST_START_DATE","ENABLED","ACTIVE","MANUAL_OPEN_TIME","MANUAL_DURATION","COMMENTS" FROM dba_scheduler_windows;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."OWNER" IS 'Owner of the scheduler window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."WINDOW_NAME" IS 'Name of the scheduler window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."RESOURCE_PLAN" IS 'Resource plan associated with the window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."SCHEDULE_OWNER" IS 'Owner of the schedule of this window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."SCHEDULE_NAME" IS 'Name of the schedule of this window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."SCHEDULE_TYPE" IS 'Type of the schedule of this window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."START_DATE" IS 'Start date of the window (for an inlined schedule)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."REPEAT_INTERVAL" IS 'Calendar string for this window (for an inlined schedule)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."END_DATE" IS 'Date after which the window will no longer open (for an inlined schedule)';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."DURATION" IS 'Duration of the window';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."WINDOW_PRIORITY" IS 'Priority of this job relative to other windows';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."NEXT_START_DATE" IS 'Next date on which this window is scheduled to start';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."LAST_START_DATE" IS 'The last date on which this window opened';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."ENABLED" IS 'True if the window is enabled';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."ACTIVE" IS 'True if the window is open';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."MANUAL_OPEN_TIME" IS 'Open time of window if it was manually opened, else NULL';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."MANUAL_DURATION" IS 'Duration of window if it was manually opened, else NULL';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINDOWS"."COMMENTS" IS 'Comments on the window';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_WINDOWS"  IS 'All scheduler windows in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SCHEDULER_WINGROUP_MEMBERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SCHEDULER_WINGROUP_MEMBERS" ("WINDOW_GROUP_NAME", "WINDOW_NAME") AS 
  SELECT "WINDOW_GROUP_NAME","WINDOW_NAME" FROM dba_scheduler_wingroup_members;

   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINGROUP_MEMBERS"."WINDOW_GROUP_NAME" IS 'Name of the window group';
   COMMENT ON COLUMN "SYS"."ALL_SCHEDULER_WINGROUP_MEMBERS"."WINDOW_NAME" IS 'Name of the window member of this window group';
   COMMENT ON TABLE "SYS"."ALL_SCHEDULER_WINGROUP_MEMBERS"  IS 'Members of all scheduler window groups in the database'
;
--------------------------------------------------------
--  DDL for View ALL_SECONDARY_OBJECTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SECONDARY_OBJECTS" ("INDEX_OWNER", "INDEX_NAME", "SECONDARY_OBJECT_OWNER", "SECONDARY_OBJECT_NAME", "SECONDARY_OBJDATA_TYPE") AS 
  select u.name, o.name, u1.name, o1.name, decode(s.spare1, 0, 'FROM INDEXTYPE',
                                                1, 'FROM STATISTICS TYPE')
from   sys.user$ u, sys.obj$ o, sys.user$ u1, sys.obj$ o1, sys.secobj$ s
where  s.obj# = o.obj# and o.owner# = u.user# and
       s.secobj# = o1.obj#  and  o1.owner# = u1.user# and
       ( o.owner# = userenv('SCHEMAID')
         or
         o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                   )
         or
            ora_check_sys_privilege (o.owner#, o.type#) = 1
       );

   COMMENT ON COLUMN "SYS"."ALL_SECONDARY_OBJECTS"."INDEX_OWNER" IS 'Name of the domain index owner';
   COMMENT ON COLUMN "SYS"."ALL_SECONDARY_OBJECTS"."INDEX_NAME" IS 'Name of the domain index';
   COMMENT ON COLUMN "SYS"."ALL_SECONDARY_OBJECTS"."SECONDARY_OBJECT_OWNER" IS 'Owner of the secondary object';
   COMMENT ON COLUMN "SYS"."ALL_SECONDARY_OBJECTS"."SECONDARY_OBJECT_NAME" IS 'Name of the secondary object';
   COMMENT ON COLUMN "SYS"."ALL_SECONDARY_OBJECTS"."SECONDARY_OBJDATA_TYPE" IS 'Type of the secondary object';
   COMMENT ON TABLE "SYS"."ALL_SECONDARY_OBJECTS"  IS 'All secondary objects for domain indexes'
;
--------------------------------------------------------
--  DDL for View ALL_SEC_RELEVANT_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SEC_RELEVANT_COLS" ("OBJECT_OWNER", "OBJECT_NAME", "POLICY_GROUP", "POLICY_NAME", "SEC_REL_COLUMN", "COLUMN_OPTION", "COMMON", "INHERITED") AS 
  SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, POLICY_NAME,
       SEC_REL_COLUMN, COLUMN_OPTION, COMMON, INHERITED
from DBA_SEC_RELEVANT_COLS, ALL_TABLES t
WHERE
(OBJECT_OWNER = t.OWNER AND OBJECT_NAME = t.TABLE_NAME)
union all
SELECT OBJECT_OWNER, OBJECT_NAME, POLICY_GROUP, POLICY_NAME,
       SEC_REL_COLUMN, COLUMN_OPTION, COMMON, INHERITED
from DBA_SEC_RELEVANT_COLS, ALL_VIEWS v
WHERE
(OBJECT_OWNER = v.OWNER AND OBJECT_NAME = v.VIEW_NAME );

   COMMENT ON COLUMN "SYS"."ALL_SEC_RELEVANT_COLS"."OBJECT_OWNER" IS 'Owner of the table or view';
   COMMENT ON COLUMN "SYS"."ALL_SEC_RELEVANT_COLS"."OBJECT_NAME" IS 'Name of the table or view';
   COMMENT ON COLUMN "SYS"."ALL_SEC_RELEVANT_COLS"."POLICY_GROUP" IS 'Name of the policy group';
   COMMENT ON COLUMN "SYS"."ALL_SEC_RELEVANT_COLS"."POLICY_NAME" IS 'Name of the policy';
   COMMENT ON COLUMN "SYS"."ALL_SEC_RELEVANT_COLS"."SEC_REL_COLUMN" IS 'Name of security relevant column';
   COMMENT ON COLUMN "SYS"."ALL_SEC_RELEVANT_COLS"."COLUMN_OPTION" IS 'Option of the security relevant column';
   COMMENT ON COLUMN "SYS"."ALL_SEC_RELEVANT_COLS"."COMMON" IS 'Is the policy security relevant column common?';
   COMMENT ON COLUMN "SYS"."ALL_SEC_RELEVANT_COLS"."INHERITED" IS 'Is the policy security relevant column inherited?';
   COMMENT ON TABLE "SYS"."ALL_SEC_RELEVANT_COLS"  IS 'Security Relevant columns of all VPD policies for tables or views which the user has access'
;
--------------------------------------------------------
--  DDL for View ALL_SEQUENCES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SEQUENCES" ("SEQUENCE_OWNER", "SEQUENCE_NAME", "MIN_VALUE", "MAX_VALUE", "INCREMENT_BY", "CYCLE_FLAG", "ORDER_FLAG", "CACHE_SIZE", "LAST_NUMBER", "SCALE_FLAG", "EXTEND_FLAG", "SESSION_FLAG", "KEEP_VALUE") AS 
  select u.name, o.name,
      s.minvalue, s.maxvalue, s.increment$,
      decode (s.cycle#, 0, 'N', 1, 'Y'),
      decode (s.order$, 0, 'N', 1, 'Y'),
      s.cache, s.highwater,
      decode(bitand(s.flags, 16), 16, 'Y', 'N'),
      decode(bitand(s.flags, 2048), 2048, 'Y', 'N'),
      decode(bitand(s.flags, 64), 64, 'Y', 'N'),
      decode(bitand(s.flags, 512), 512, 'Y', 'N')
from sys.seq$ s, sys.obj$ o, sys.user$ u
where u.user# = o.owner#
  and o.obj# = s.obj#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or
        ora_check_sys_privilege ( o.owner#, o.type#) = 1
      )
  and (bitand(s.flags, 1024) = 0 or s.flags is null);

   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."SEQUENCE_OWNER" IS 'Name of the owner of the sequence';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."SEQUENCE_NAME" IS 'SEQUENCE name';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."MIN_VALUE" IS 'Minimum value of the sequence';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."MAX_VALUE" IS 'Maximum value of the sequence';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."INCREMENT_BY" IS 'Value by which sequence is incremented';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."CYCLE_FLAG" IS 'Does sequence wrap around on reaching limit?';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."ORDER_FLAG" IS 'Are sequence numbers generated in order?';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."CACHE_SIZE" IS 'Number of sequence numbers to cache';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."LAST_NUMBER" IS 'Last sequence number written to disk';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."SCALE_FLAG" IS 'Is this a scalable sequence?';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."EXTEND_FLAG" IS 'Does this scalable sequence''s generated values extend beyond max_value or min_value?';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."SESSION_FLAG" IS 'Is this a session sequence?';
   COMMENT ON COLUMN "SYS"."ALL_SEQUENCES"."KEEP_VALUE" IS 'Are sequence values kept during replay after failure';
   COMMENT ON TABLE "SYS"."ALL_SEQUENCES"  IS 'Description of SEQUENCEs accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SERVICES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SERVICES" ("SERVICE_ID", "NAME", "NAME_HASH", "NETWORK_NAME", "CREATION_DATE", "CREATION_DATE_HASH", "FAILOVER_METHOD", "FAILOVER_TYPE", "FAILOVER_RETRIES", "FAILOVER_DELAY", "MIN_CARDINALITY", "MAX_CARDINALITY", "GOAL", "DTP", "ENABLED", "AQ_HA_NOTIFICATIONS", "CLB_GOAL", "EDITION", "COMMIT_OUTCOME", "RETENTION_TIMEOUT", "REPLAY_INITIATION_TIMEOUT", "SESSION_STATE_CONSISTENCY", "GLOBAL_SERVICE", "PDB", "SQL_TRANSLATION_PROFILE", "MAX_LAG_TIME", "GSM_FLAGS", "PQ_SVC", "STOP_OPTION", "FAILOVER_RESTORE", "DRAIN_TIMEOUT") AS 
  select "SERVICE_ID","NAME","NAME_HASH","NETWORK_NAME","CREATION_DATE","CREATION_DATE_HASH","FAILOVER_METHOD","FAILOVER_TYPE","FAILOVER_RETRIES","FAILOVER_DELAY","MIN_CARDINALITY","MAX_CARDINALITY","GOAL","DTP","ENABLED","AQ_HA_NOTIFICATIONS","CLB_GOAL","EDITION","COMMIT_OUTCOME","RETENTION_TIMEOUT","REPLAY_INITIATION_TIMEOUT","SESSION_STATE_CONSISTENCY","GLOBAL_SERVICE","PDB","SQL_TRANSLATION_PROFILE","MAX_LAG_TIME","GSM_FLAGS","PQ_SVC","STOP_OPTION","FAILOVER_RESTORE","DRAIN_TIMEOUT" from dba_services
;
--------------------------------------------------------
--  DDL for View ALL_SNAPSHOT_LOGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SNAPSHOT_LOGS" ("LOG_OWNER", "MASTER", "LOG_TABLE", "LOG_TRIGGER", "ROWIDS", "PRIMARY_KEY", "OBJECT_ID", "FILTER_COLUMNS", "SEQUENCE", "INCLUDE_NEW_VALUES", "CURRENT_SNAPSHOTS", "SNAPSHOT_ID") AS 
  select s."LOG_OWNER",s."MASTER",s."LOG_TABLE",s."LOG_TRIGGER",s."ROWIDS",s."PRIMARY_KEY",s."OBJECT_ID",s."FILTER_COLUMNS",s."SEQUENCE",s."INCLUDE_NEW_VALUES",s."CURRENT_SNAPSHOTS",s."SNAPSHOT_ID" from dba_snapshot_logs s, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and s.log_table = o.name
  and u.name       = s.log_owner
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."LOG_OWNER" IS 'Owner of the snapshot log';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."MASTER" IS 'Name of the master table which changes are logged';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."LOG_TABLE" IS 'Log table; with  rowids and timestamps of rows which changed in the master';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."LOG_TRIGGER" IS 'An after-row trigger on the master which inserts rows into the log';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."ROWIDS" IS 'If YES, the snapshot log records rowid information';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."PRIMARY_KEY" IS 'If YES, the snapshot log records primary key information';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."OBJECT_ID" IS 'If YES, the snapshot log records object id information';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."FILTER_COLUMNS" IS 'If YES, the snapshot log records filter column information';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."SEQUENCE" IS 'If YES, the snapshot log records sequence information';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."INCLUDE_NEW_VALUES" IS 'If YES, the snapshot log records old and new values (else only old values)';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."CURRENT_SNAPSHOTS" IS 'One date per snapshot -- the date the snapshot of the master last refreshed';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOT_LOGS"."SNAPSHOT_ID" IS 'Unique identifier of the snapshot';
   COMMENT ON TABLE "SYS"."ALL_SNAPSHOT_LOGS"  IS 'All snapshot logs in the database that the user can see'
;
--------------------------------------------------------
--  DDL for View ALL_SNAPSHOTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SNAPSHOTS" ("OWNER", "NAME", "TABLE_NAME", "MASTER_VIEW", "MASTER_OWNER", "MASTER", "MASTER_LINK", "CAN_USE_LOG", "UPDATABLE", "REFRESH_METHOD", "LAST_REFRESH", "ERROR", "FR_OPERATIONS", "CR_OPERATIONS", "TYPE", "NEXT", "START_WITH", "REFRESH_GROUP", "UPDATE_TRIG", "UPDATE_LOG", "QUERY", "MASTER_ROLLBACK_SEG", "STATUS", "REFRESH_MODE", "PREBUILT") AS 
  select s."OWNER",s."NAME",s."TABLE_NAME",s."MASTER_VIEW",s."MASTER_OWNER",s."MASTER",s."MASTER_LINK",s."CAN_USE_LOG",s."UPDATABLE",s."REFRESH_METHOD",s."LAST_REFRESH",s."ERROR",s."FR_OPERATIONS",s."CR_OPERATIONS",s."TYPE",s."NEXT",s."START_WITH",s."REFRESH_GROUP",s."UPDATE_TRIG",s."UPDATE_LOG",s."QUERY",s."MASTER_ROLLBACK_SEG",s."STATUS",s."REFRESH_MODE",s."PREBUILT" from dba_snapshots s, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and s.table_name = o.name
  and u.name       = s.owner
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."OWNER" IS 'Owner of the snapshot';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."NAME" IS 'The view used by users and applications for viewing the snapshot';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."TABLE_NAME" IS 'Table the snapshot is stored in -- has an extra column for the master rowid';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."MASTER_VIEW" IS 'View of the master table, owned by the snapshot owner, used for refreshes';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."MASTER_OWNER" IS 'Owner of the master table';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."MASTER" IS 'Name of the master table that this snapshot is a copy of';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."MASTER_LINK" IS 'Database link name to the master site';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."CAN_USE_LOG" IS 'If NO, this snapshot is complex and will never use a log';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."UPDATABLE" IS 'If NO, the snapshot is read only.  Look up REPLICATION';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."REFRESH_METHOD" IS 'The values used to drive a fast refresh of the snapshot';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."LAST_REFRESH" IS 'SYSDATE from the master site at the time of the last refresh';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."ERROR" IS 'The error returned last time an automatic refresh was attempted';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."TYPE" IS 'The type of refresh (complete,fast,force) for all automatic refreshes';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."NEXT" IS 'The date function used to compute next refresh dates';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."START_WITH" IS 'The date function used to compute next refresh dates';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."REFRESH_GROUP" IS 'All snapshots in a given refresh group get refreshed in the same transaction';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."UPDATE_TRIG" IS 'The name of the trigger which fills the UPDATE_LOG';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."UPDATE_LOG" IS 'The table which logs changes made to an updatable snapshots';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."QUERY" IS 'The original query that this snapshot is an instantiation of';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."MASTER_ROLLBACK_SEG" IS 'Rollback segment to use at the master site';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."STATUS" IS 'The status of the contents of the snapshot';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."REFRESH_MODE" IS 'This indicates how and when the snapshot will be refreshed';
   COMMENT ON COLUMN "SYS"."ALL_SNAPSHOTS"."PREBUILT" IS 'If YES, this snapshot uses a prebuilt table as the base table';
   COMMENT ON TABLE "SYS"."ALL_SNAPSHOTS"  IS 'Snapshots the user can access'
;
--------------------------------------------------------
--  DDL for View ALL_SOURCE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SOURCE" ("OWNER", "NAME", "TYPE", "LINE", "TEXT", "ORIGIN_CON_ID") AS 
  select OWNER, NAME, TYPE, LINE, TEXT,  ORIGIN_CON_ID
from int$dba_source ods
where
  (
    OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
    or
    OWNER='PUBLIC'
    or
    (
      (
         (
          (TYPE# in (7 /* proc */, 8 /* func */, 9 /* pkg */, 13 /* type */,
                       22 /* library */, 87 /* assembly */ ))
          and
          OBJ_ID(OWNER, NAME, TYPE#, OBJECT_ID) in
                   (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        )
        or
        (
          (TYPE# in (11 /* package body */, 14 /* type body */))
          and
          exists
          (
           select null
             from sys."_ACTUAL_EDITION_OBJ" specobj,
                  sys.dependency$ dep, sys.objauth$ oa, sys.user$ u
            where u.name = ods.OWNER
              and specobj.owner# = u.user#
              and specobj.name = ods.NAME
              and specobj.type# = decode(ods.TYPE#,
                                         11 /* pkg body */, 9 /* pkg */,
                                         14 /* type body */, 13 /* type */,
                                         null)
              and dep.d_obj# = OBJ_ID(ods.OWNER,
                                      ods.NAME,
                                      ods.TYPE#,
                                      ods.OBJECT_ID)
              and dep.p_obj# = specobj.obj#
              and oa.obj# = specobj.obj#
              and oa.grantee# in (select kzsrorol from x$kzsro)
              and oa.privilege# = 26 /* DEBUG */)
        )
        or
        (
          (TYPE# = 12 /* trigger */)
          and
          exists
          (
           select null from sys.trigger$ t, sys.objauth$ oa
            where bitand(t.property, 24) = 0
              and t.obj# = OBJ_ID(ods.OWNER,
                                  ods.NAME, 12,
                                  ods.OBJECT_ID)
              and oa.obj# = t.baseobject
              and oa.grantee# in (select kzsrorol from x$kzsro)
              and oa.privilege# = 26 /* DEBUG */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (TYPE# = 7 or TYPE# = 8 or TYPE# = 9)
              and
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* package body */
              TYPE# = 11 and
              (
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type */
              TYPE# = 13
              and
              (
                privilege# = -184 /* EXECUTE ANY TYPE */
                or
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type body */
              TYPE# = 14 and
              (
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* triggers */
              TYPE# = 12 and
              (
                privilege# = -152 /* CREATE ANY TRIGGER */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* library */
              TYPE# = 22 and
              (
                privilege# = -192 /* EXECUTE ANY LIBRARY */
                or
                privilege# = -189 /* CREATE ANY LIBRARY */
              )
            )
            or
            (
              /* assembly */
              TYPE# = 87 and
              (
                privilege# = -285 /* EXECUTE ANY ASSEMBLY */
                or
                privilege# = -282 /* CREATE ANY ASSEMBLY */
              )
            )
          )
        )
      )
    )
    or
    (
      TYPE# = 28
      and
      (
        (
          OBJ_ID(OWNER, NAME, 28, OBJECT_ID) in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_SOURCE"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE"."NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE"."TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE"."LINE" IS 'Line number of this line of source';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE"."TEXT" IS 'Source text';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_SOURCE"  IS 'Current source on stored objects that user is allowed to create'
;
--------------------------------------------------------
--  DDL for View ALL_SOURCE_AE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SOURCE_AE" ("OWNER", "NAME", "TYPE", "LINE", "TEXT", "EDITION_NAME", "ORIGIN_CON_ID") AS 
  select OWNER, NAME, TYPE, LINE, TEXT, edition_name,  ORIGIN_CON_ID
from int$dba_source_ae ods
where
  (
    OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
    or
    OWNER='PUBLIC'
    or
    (
      (
         (
          (TYPE# in (7 /* proc */, 8 /* func */, 9 /* pkg */, 13 /* type */,
                       22 /* library */, 87 /* assembly */ ))
          and
          OBJ_ID(OWNER, NAME, TYPE#, OBJECT_ID) in
                   (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        )
        or
        (
          (TYPE# in (11 /* package body */, 14 /* type body */))
          and
          exists
          (
           select null
             from sys."_ACTUAL_EDITION_OBJ" specobj,
                  sys.dependency$ dep, sys.objauth$ oa, sys.user$ u
            where u.name = ods.OWNER
              and specobj.owner# = u.user#
              and specobj.name = ods.NAME
              and specobj.type# = decode(ods.TYPE#,
                                         11 /* pkg body */, 9 /* pkg */,
                                         14 /* type body */, 13 /* type */,
                                         null)
              and dep.d_obj# = OBJ_ID(ods.OWNER,
                                      ods.NAME,
                                      ods.TYPE#,
                                      ods.OBJECT_ID)
              and dep.p_obj# = specobj.obj#
              and oa.obj# = specobj.obj#
              and oa.grantee# in (select kzsrorol from x$kzsro)
              and oa.privilege# = 26 /* DEBUG */)
        )
        or
        (
          (TYPE# = 12 /* trigger */)
          and
          exists
          (
           select null from sys.trigger$ t, sys.objauth$ oa
            where bitand(t.property, 24) = 0
              and t.obj# = OBJ_ID(ods.OWNER,
                                  ods.NAME, 12,
                                  ods.OBJECT_ID)
              and oa.obj# = t.baseobject
              and oa.grantee# in (select kzsrorol from x$kzsro)
              and oa.privilege# = 26 /* DEBUG */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (TYPE# = 7 or TYPE# = 8 or TYPE# = 9)
              and
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* package body */
              TYPE# = 11 and
              (
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type */
              TYPE# = 13
              and
              (
                privilege# = -184 /* EXECUTE ANY TYPE */
                or
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type body */
              TYPE# = 14 and
              (
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* triggers */
              TYPE# = 12 and
              (
                privilege# = -152 /* CREATE ANY TRIGGER */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* library */
              TYPE# = 22 and
              (
                privilege# = -192 /* EXECUTE ANY LIBRARY */
                or
                privilege# = -189 /* CREATE ANY LIBRARY */
              )
            )
            or
            (
              /* assembly */
              TYPE# = 87 and
              (
                privilege# = -285 /* EXECUTE ANY ASSEMBLY */
                or
                privilege# = -282 /* CREATE ANY ASSEMBLY */
              )
            )
          )
        )
      )
    )
    or
    (
      TYPE# = 28
      and
      (
        (
          OBJ_ID(OWNER, NAME, 28, OBJECT_ID) in (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_SOURCE_AE"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE_AE"."NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE_AE"."TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE_AE"."LINE" IS 'Line number of this line of source';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE_AE"."TEXT" IS 'Source text';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE_AE"."EDITION_NAME" IS 'Name of the Edition';
   COMMENT ON COLUMN "SYS"."ALL_SOURCE_AE"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_SOURCE_AE"  IS 'Current source on stored objects that user is allowed to create'
;
--------------------------------------------------------
--  DDL for View ALL_SQLJ_TYPE_ATTRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQLJ_TYPE_ATTRS" ("OWNER", "TYPE_NAME", "ATTR_NAME", "EXTERNAL_ATTR_NAME", "ATTR_TYPE_MOD", "ATTR_TYPE_OWNER", "ATTR_TYPE_NAME", "LENGTH", "PRECISION", "SCALE", "CHARACTER_SET_NAME", "ATTR_NO", "INHERITED") AS 
  select decode(bitand(t.properties, 64), 64, null, u.name),
       o.name, a.name, a.externname,
       decode(bitand(a.properties, 32768), 32768, 'REF',
              decode(bitand(a.properties, 16384), 16384, 'POINTER')),
       decode(bitand(at.properties, 64), 64, null, au.name),
       decode(at.typecode,
              9, decode(a.charsetform, 2, 'NVARCHAR2', ao.name),
              96, decode(a.charsetform, 2, 'NCHAR', ao.name),
              112, decode(a.charsetform, 2, 'NCLOB', ao.name),
              ao.name),
       a.length, a.precision#, a.scale,
       decode(a.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(a.charsetid),
                             4, 'ARG:'||a.charsetid),
       a.attribute#, decode(bitand(nvl(a.xflags,0), 1), 1, 'YES', 'NO')
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.type$ t, sys.attribute$ a,
     sys."_CURRENT_EDITION_OBJ" ao, sys.user$ au, sys.type$ at
where o.owner# = u.user#
  and o.oid$ = t.toid
  and o.subname IS NULL -- get the latest version only
  and o.type# <> 10 -- must not be invalid
  and bitand(t.properties, 2048) = 0 -- not system-generated
  and t.toid = a.toid
  and t.version# = a.version#
  and a.attr_toid = ao.oid$
  and ao.owner# = au.user#
  and a.attr_toid = at.tvoid
  and a.attr_version# = at.version#
  and t.externtype < 5
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."ATTR_NAME" IS 'Name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."EXTERNAL_ATTR_NAME" IS 'External name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."ATTR_TYPE_MOD" IS 'Type modifier of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."ATTR_TYPE_OWNER" IS 'Owner of the type of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."ATTR_TYPE_NAME" IS 'Name of the type of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."LENGTH" IS 'Length of the CHAR attribute or maximum length of the VARCHAR
or VARCHAR2 attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."PRECISION" IS 'Decimal precision of the NUMBER or DECIMAL attribute or
binary precision of the FLOAT attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."SCALE" IS 'Scale of the NUMBER or DECIMAL attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."CHARACTER_SET_NAME" IS 'Character set name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."ATTR_NO" IS 'Syntactical order number or position of the attribute as specified in the
type specification or CREATE TYPE statement (not to be used as ID number)';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_ATTRS"."INHERITED" IS 'Is the attribute inherited from the supertype ?';
   COMMENT ON TABLE "SYS"."ALL_SQLJ_TYPE_ATTRS"  IS 'Description of attributes of types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SQLJ_TYPE_METHODS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQLJ_TYPE_METHODS" ("OWNER", "TYPE_NAME", "METHOD_NAME", "EXTERNAL_VAR_NAME", "METHOD_NO", "METHOD_TYPE", "PARAMETERS", "RESULTS", "FINAL", "INSTANTIABLE", "OVERRIDING", "INHERITED") AS 
  select u.name, o.name, m.name, m.externVarName, m.method#,
       decode(bitand(m.properties, 512), 512, 'MAP',
              decode(bitand(m.properties, 2048), 2048, 'ORDER', 'PUBLIC')),
       m.parameters#, m.results,
       decode(bitand(m.properties, 8), 8, 'NO', 'YES'),
       decode(bitand(m.properties, 65536), 65536, 'NO', 'YES'),
       decode(bitand(m.properties, 131072), 131072, 'YES', 'NO'),
       decode(bitand(nvl(m.xflags,0), 1), 1, 'YES', 'NO')
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.type$ t, sys.method$ m
where o.owner# = u.user#
  and o.oid$ = m.toid
  and o.subname IS NULL -- get the latest version only
  and o.type# <> 10 -- must not be invalid
  and bitand(t.properties, 2048) = 0 -- not system-generated
  and t.toid = m.toid
  and t.version# = m.version#
  and t.externtype < 5
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."METHOD_NAME" IS 'Name of the method';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."EXTERNAL_VAR_NAME" IS 'Name of the external variable';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."METHOD_NO" IS 'Method number for distinguishing overloaded method (not to be used as ID number)';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."METHOD_TYPE" IS 'Type of the method';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."PARAMETERS" IS 'Number of parameters to the method';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."RESULTS" IS 'Number of results returned by the method';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."FINAL" IS 'Is the method final ?';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."INSTANTIABLE" IS 'Is the method instantiable ?';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."OVERRIDING" IS 'Is the method overriding a supertype method ?';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPE_METHODS"."INHERITED" IS 'Is the method inherited from the supertype ?';
   COMMENT ON TABLE "SYS"."ALL_SQLJ_TYPE_METHODS"  IS 'Description of methods of types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SQLJ_TYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQLJ_TYPES" ("OWNER", "TYPE_NAME", "TYPE_OID", "EXTERNAL_NAME", "USING", "TYPECODE", "ATTRIBUTES", "METHODS", "PREDEFINED", "INCOMPLETE", "FINAL", "INSTANTIABLE", "SUPERTYPE_OWNER", "SUPERTYPE_NAME", "LOCAL_ATTRIBUTES", "LOCAL_METHODS") AS 
  select decode(bitand(t.properties, 64), 64, null, u.name), o.name, t.toid,
       t.externname,
       decode(t.externtype, 1, 'SQLData',
                            2, 'CustomDatum',
                            3, 'Serializable',
                            4, 'Serializable Internal',
                            5, 'ORAData',
                            'unknown'),
       decode(t.typecode, 108, 'OBJECT',
                          122, 'COLLECTION',
                          o.name),
       t.attributes, t.methods,
       decode(bitand(t.properties, 16), 16, 'YES', 0, 'NO'),
       decode(bitand(t.properties, 256), 256, 'YES', 0, 'NO'),
       decode(bitand(t.properties, 8), 8, 'NO', 'YES'),
       decode(bitand(t.properties, 65536), 65536, 'NO', 'YES'),
       su.name, so.name, t.local_attrs, t.local_methods
from sys.user$ u, sys.type$ t, sys."_CURRENT_EDITION_OBJ" o,
     sys."_CURRENT_EDITION_OBJ" so, sys.user$ su
where o.owner# = u.user#
  and o.oid$ = t.tvoid
  and o.subname IS NULL -- only latest version
  and o.type# <> 10 -- must not be invalid
  and bitand(t.properties, 2048) = 0 -- not system-generated
  and t.supertoid = so.oid$ (+) and so.owner# = su.user# (+)
  and t.externtype < 5
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."TYPE_OID" IS 'Object identifier (OID) of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."EXTERNAL_NAME" IS 'External class name of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."USING" IS 'Representation of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."TYPECODE" IS 'Typecode of the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."ATTRIBUTES" IS 'Number of attributes in the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."METHODS" IS 'Number of methods in the type';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."PREDEFINED" IS 'Is the type a predefined type?';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."INCOMPLETE" IS 'Is the type an incomplete type?';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."FINAL" IS 'Is the type a final type?';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."INSTANTIABLE" IS 'Is the type an instantiable type?';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."SUPERTYPE_OWNER" IS 'Owner of the supertype (null if type is not a subtype)';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."SUPERTYPE_NAME" IS 'Name of the supertype (null if type is not a subtype)';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."LOCAL_ATTRIBUTES" IS 'Number of local (not inherited) attributes (if any) in the subtype';
   COMMENT ON COLUMN "SYS"."ALL_SQLJ_TYPES"."LOCAL_METHODS" IS 'Number of local (not inherited) methods (if any) in the subtype';
   COMMENT ON TABLE "SYS"."ALL_SQLJ_TYPES"  IS 'Description of types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SQLSET
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQLSET" ("NAME", "ID", "CON_DBID", "OWNER", "DESCRIPTION", "CREATED", "LAST_MODIFIED", "STATEMENT_COUNT") AS 
  select name, id, con_dbid, owner,
       description, created, last_modified, statement_count
  from WRI$_SQLSET_DEFINITIONS
  where owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
        EXISTS (select 1
                from   V$ENABLEDPRIVS
                where  priv_number in (-273 /*ADMINISTER ANY SQL TUNING SET*/))
;
--------------------------------------------------------
--  DDL for View ALL_SQLSET_BINDS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQLSET_BINDS" ("SQLSET_NAME", "SQLSET_OWNER", "SQLSET_ID", "CON_DBID", "SQL_ID", "FORCE_MATCHING_SIGNATURE", "PLAN_HASH_VALUE", "POSITION", "VALUE", "CAPTURED", "SQL_SEQ") AS 
  select name as sqlset_name, d.owner as sqlset_owner, sqlset_id, s.con_dbid,
         sql_id, force_matching_signature, p.plan_hash_value,
         b.position, b.value, p.binds_captured as captured, s.id as sql_seq
  from   WRI$_SQLSET_DEFINITIONS d, WRI$_SQLSET_STATEMENTS s,
         WRI$_SQLSET_PLANS p, WRI$_SQLSET_BINDS b
  where  d.id = s.sqlset_id AND
         s.id = p.stmt_id AND s.con_dbid = p.con_dbid AND
         p.stmt_id = b.stmt_id AND
         p.plan_hash_value = b.plan_hash_value AND
         p.con_dbid = b.con_dbid AND
         (d.owner = SYS_CONTEXT('USERENV', 'CURRENT_USER')  OR
         EXISTS (select 1
                 from  V$ENABLEDPRIVS
                 where priv_number in (-273 /*ADMINISTER ANY SQL TUNING SET*/)))
  UNION ALL
  select d.name as sqlset_name, d.owner as sqlset_owner, s.sqlset_id,
         s.con_dbid, s.sql_id, s.force_matching_signature, p.plan_hash_value,
         b.position, b.value_anydata as value, p.binds_captured as captured,
         s.id as sql_seq
  from   WRI$_SQLSET_DEFINITIONS d, WRI$_SQLSET_STATEMENTS s,
         WRI$_SQLSET_PLANS p, TABLE(dbms_sqltune.extract_binds(p.bind_data)) b
  where  d.id = s.sqlset_id AND s.id = p.stmt_id AND s.con_dbid = p.con_dbid
         AND (d.owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
         EXISTS (select 1
                 from  V$ENABLEDPRIVS
                 where priv_number in (-273 /*ADMINISTER ANY SQL TUNING SET*/)))
;
--------------------------------------------------------
--  DDL for View ALL_SQLSET_PLANS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQLSET_PLANS" ("SQLSET_NAME", "SQLSET_OWNER", "SQLSET_ID", "CON_DBID", "SQL_ID", "FORCE_MATCHING_SIGNATURE", "PLAN_HASH_VALUE", "SQL_SEQ", "STATEMENT_ID", "PLAN_ID", "TIMESTAMP", "REMARKS", "OPERATION", "OPTIONS", "OBJECT_NODE", "OBJECT_OWNER", "OBJECT_NAME", "OBJECT_ALIAS", "OBJECT_INSTANCE", "OBJECT_TYPE", "OPTIMIZER", "SEARCH_COLUMNS", "ID", "PARENT_ID", "DEPTH", "POSITION", "COST", "CARDINALITY", "BYTES", "OTHER_TAG", "PARTITION_START", "PARTITION_STOP", "PARTITION_ID", "OTHER", "DISTRIBUTION", "CPU_COST", "IO_COST", "TEMP_SPACE", "ACCESS_PREDICATES", "FILTER_PREDICATES", "PROJECTION", "TIME", "QBLOCK_NAME", "OTHER_XML", "EXECUTIONS", "STARTS", "OUTPUT_ROWS", "CR_BUFFER_GETS", "CU_BUFFER_GETS", "DISK_READS", "DISK_WRITES", "ELAPSED_TIME", "LAST_STARTS", "LAST_OUTPUT_ROWS", "LAST_CR_BUFFER_GETS", "LAST_CU_BUFFER_GETS", "LAST_DISK_READS", "LAST_DISK_WRITES", "LAST_ELAPSED_TIME", "POLICY", "ESTIMATED_OPTIMAL_SIZE", "ESTIMATED_ONEPASS_SIZE", "LAST_MEMORY_USED", "LAST_EXECUTION", "LAST_DEGREE", "TOTAL_EXECUTIONS", "OPTIMAL_EXECUTIONS", "ONEPASS_EXECUTIONS", "MULTIPASSES_EXECUTIONS", "ACTIVE_TIME", "MAX_TEMPSEG_SIZE", "LAST_TEMPSEG_SIZE") AS 
  select d.name as sqlset_name, d.owner as sqlset_owner, sqlset_id, s.con_dbid,
       sql_id, force_matching_signature, p.plan_hash_value, s.id as sql_seq,
       statement_id,
       plan_id,
       timestamp,
       remarks,
       operation,
       options,
       object_node,
       object_owner,
       object_name,
       object_alias,
       object_instance,
       object_type,
       optimizer,
       search_columns,
       l.id,
       parent_id,
       depth,
       position,
       cost,
       cardinality,
       bytes,
       other_tag,
       partition_start,
       partition_stop,
       partition_id,
       other,
       distribution,
       cpu_cost,
       io_cost,
       temp_space,
       access_predicates,
       filter_predicates,
       projection,
       time,
       qblock_name,
       other_xml,
       executions,
       starts,
       output_rows,
       cr_buffer_gets,
       cu_buffer_gets,
       disk_reads,
       disk_writes,
       elapsed_time,
       last_starts,
       last_output_rows,
       last_cr_buffer_gets,
       last_cu_buffer_gets,
       last_disk_reads,
       last_disk_writes,
       last_elapsed_time,
       policy,
       estimated_optimal_size,
       estimated_onepass_size,
       last_memory_used,
       last_execution,
       last_degree,
       total_executions,
       optimal_executions,
       onepass_executions,
       multipasses_executions,
       active_time,
       max_tempseg_size,
       last_tempseg_size
from   WRI$_SQLSET_DEFINITIONS d, WRI$_SQLSET_STATEMENTS s,
       WRI$_SQLSET_PLANS p, WRI$_SQLSET_PLAN_LINES l
where  d.id = s.sqlset_id  and s.id = p.stmt_id and
       s.con_dbid = p.con_dbid and
       p.stmt_id=l.stmt_id and p.plan_hash_value = l.plan_hash_value and
       p.con_dbid = l.con_dbid and
       (d.owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
       EXISTS (select 1
               from   V$ENABLEDPRIVS
               where  priv_number in (-273 /*ADMINISTER ANY SQL TUNING SET*/)))
;
--------------------------------------------------------
--  DDL for View ALL_SQLSET_REFERENCES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQLSET_REFERENCES" ("SQLSET_NAME", "SQLSET_OWNER", "SQLSET_ID", "ID", "OWNER", "DESCRIPTION", "CREATED") AS 
  select d.name as sqlset_name, d.owner as sqlset_owner, r.sqlset_id,
       r.id, r.owner, r.description, r.created
from   wri$_sqlset_definitions d, wri$_sqlset_references r
where d.id=r.sqlset_id AND
      (d.owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
       r.owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
       EXISTS (select 1
               from   V$ENABLEDPRIVS
               where  priv_number in (-273 /*ADMINISTER ANY SQL TUNING SET*/)))
;
--------------------------------------------------------
--  DDL for View ALL_SQLSET_STATEMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQLSET_STATEMENTS" ("SQLSET_NAME", "SQLSET_OWNER", "SQLSET_ID", "CON_DBID", "SQL_ID", "FORCE_MATCHING_SIGNATURE", "SQL_TEXT", "PARSING_SCHEMA_NAME", "PLAN_HASH_VALUE", "BIND_DATA", "BINDS_CAPTURED", "MODULE", "ACTION", "ELAPSED_TIME", "CPU_TIME", "BUFFER_GETS", "DISK_READS", "DIRECT_WRITES", "ROWS_PROCESSED", "FETCHES", "EXECUTIONS", "END_OF_FETCH_COUNT", "OPTIMIZER_COST", "OPTIMIZER_ENV", "PRIORITY", "COMMAND_TYPE", "FIRST_LOAD_TIME", "STAT_PERIOD", "ACTIVE_STAT_PERIOD", "OTHER", "PLAN_TIMESTAMP", "SQL_SEQ", "LAST_EXEC_START_TIME") AS 
  select f.name as sqlset_name, f.owner as sqlset_owner, s.sqlset_id, s.con_dbid,
       s.sql_id, s.force_matching_signature, t.sql_text,
       p.parsing_schema_name, p.plan_hash_value, p.bind_data,
       p.binds_captured,
       substrb(s.module, 1, (select ksumodlen from x$modact_length)) module,
       substrb(s.action, 1, (select ksuactlen from x$modact_length)) action,
       c.elapsed_time, c.cpu_time,
       c.buffer_gets, c.disk_reads, c.direct_writes, c.rows_processed,
       c.fetches, c.executions, c.end_of_fetch_count, c.optimizer_cost,
       p.optimizer_env, m.priority, s.command_type, c.first_load_time,
       c.stat_period, c.active_stat_period,
       m.other, p.plan_timestamp, s.id as sql_seq, c.last_exec_start_time
from   WRI$_SQLSET_DEFINITIONS f, WRI$_SQLSET_STATEMENTS s,
       WRI$_SQLSET_MASK m, WRH$_SQLTEXT t,
       WRI$_SQLSET_PLANS p, WRI$_SQLSET_STATISTICS c
where  s.id = p.stmt_id AND s.con_dbid = p.con_dbid AND
       p.stmt_id = c.stmt_id AND p.plan_hash_value = c.plan_hash_value AND
       p.con_dbid = c.con_dbid AND
       p.stmt_id = m.stmt_id AND p.plan_hash_value = m.plan_hash_value AND
       p.con_dbid = m.con_dbid AND
       s.sql_id = t.sql_id AND
       s.con_dbid = t.con_dbid AND
       t.dbid = f.con_dbid AND
       f.id = s.sqlset_id AND
       (owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
        EXISTS (select 1
                from   V$ENABLEDPRIVS
                where  priv_number in (-273 /*ADMINISTER ANY SQL TUNING SET*/)))
;
--------------------------------------------------------
--  DDL for View _ALL_SQLSET_STATEMENTS_ONLY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_SQLSET_STATEMENTS_ONLY" ("SQLSET_NAME", "SQLSET_OWNER", "SQLSET_ID", "CON_DBID", "SQL_ID", "FORCE_MATCHING_SIGNATURE", "COMMAND_TYPE", "PARSING_SCHEMA_NAME", "MODULE", "ACTION", "SQL_SEQ") AS 
  select d.name as sqlset_name,  d.owner as sqlset_owner, s.sqlset_id, s.con_dbid,
       s.sql_id, s.force_matching_signature, s.command_type,
       s.parsing_schema_name,
       substrb(module, 1, (select ksumodlen from x$modact_length)) module,
       substrb(action, 1, (select ksuactlen from x$modact_length)) action,
       s.id as sql_seq
from   WRI$_SQLSET_DEFINITIONS d, WRI$_SQLSET_STATEMENTS s
where  d.id = s.sqlset_id AND
       (d.owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
        EXISTS (select 1
                from   V$ENABLEDPRIVS
                where  priv_number in (-273 /*ADMINISTER ANY SQL TUNING SET*/)))
;
--------------------------------------------------------
--  DDL for View _ALL_SQLSET_STATEMENTS_PHV
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_SQLSET_STATEMENTS_PHV" ("SQLSET_NAME", "SQLSET_OWNER", "SQLSET_ID", "CON_DBID", "SQL_ID", "FORCE_MATCHING_SIGNATURE", "PLAN_HASH_VALUE", "COMMAND_TYPE", "PARSING_SCHEMA_NAME", "MODULE", "ACTION", "PLAN_TIMESTAMP", "BINDS_CAPTURED", "SQL_SEQ") AS 
  select d.name as sqlset_name, d.owner as sqlset_owner, s.sqlset_id, s.con_dbid,
       s.sql_id, s.force_matching_signature, p.plan_hash_value,
       s.command_type, p.parsing_schema_name,
       substrb(s.module, 1, (select ksumodlen from x$modact_length)) module,
       substrb(s.action, 1, (select ksuactlen from x$modact_length)) action,
       p.plan_timestamp, p.binds_captured, s.id as sql_seq
from   WRI$_SQLSET_DEFINITIONS d, WRI$_SQLSET_STATEMENTS s,
       WRI$_SQLSET_PLANS p
where  d.id = s.sqlset_id AND s.id = p.stmt_id AND
       (d.owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
        EXISTS (select 1
                from   V$ENABLEDPRIVS
                where  priv_number in (-273 /*ADMINISTER ANY SQL TUNING SET*/)))
;
--------------------------------------------------------
--  DDL for View _ALL_SQLSET_STATISTICS_ONLY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_SQLSET_STATISTICS_ONLY" ("SQLSET_ID", "CON_DBID", "SQL_SEQ", "PLAN_HASH_VALUE", "ELAPSED_TIME", "CPU_TIME", "BUFFER_GETS", "DISK_READS", "DIRECT_WRITES", "ROWS_PROCESSED", "FETCHES", "EXECUTIONS", "END_OF_FETCH_COUNT", "OPTIMIZER_COST", "FIRST_LOAD_TIME", "STAT_PERIOD", "ACTIVE_STAT_PERIOD", "PLAN_TIMESTAMP", "BINDS_CAPTURED", "LAST_EXEC_START_TIME") AS 
  SELECT stmts.sqlset_id, stmts.con_dbid, stat.stmt_id sql_seq,
         stat.plan_hash_value,
         stat.elapsed_time, stat.cpu_time, stat.buffer_gets, stat.disk_reads,
         stat.direct_writes, stat.rows_processed, stat.fetches, stat.executions,
         stat.end_of_fetch_count, stat.optimizer_cost, stat.first_load_time,
         stat.stat_period,
         stat.active_stat_period,
         plns.plan_timestamp, plns.binds_captured, stat.last_exec_start_time
  FROM   WRI$_SQLSET_STATISTICS stat, WRI$_SQLSET_STATEMENTS stmts,
         WRI$_SQLSET_PLANS plns, WRI$_SQLSET_DEFINITIONS defns
  WHERE  defns.id = stmts.sqlset_id AND
         stat.stmt_id = stmts.id AND
         stat.plan_hash_value = plns.plan_hash_value AND
         stat.stmt_id = plns.stmt_id  AND
         (defns.owner = SYS_CONTEXT('USERENV', 'CURRENT_USER') OR
          EXISTS(SELECT 1
                 FROM v$enabledprivs
                 WHERE priv_number = -273))
;
--------------------------------------------------------
--  DDL for View _ALL_SQLSET_STS_TOPACK
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_SQLSET_STS_TOPACK" ("SQLSET_ID", "NAME", "OWNER") AS 
  select sqlset_id, name, owner
from   WRI$_SQLSET_STS_TOPACK
;
--------------------------------------------------------
--  DDL for View ALL_SQL_TRANSLATION_PROFILES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQL_TRANSLATION_PROFILES" ("OWNER", "PROFILE_NAME", "TRANSLATOR", "FOREIGN_SQL_SYNTAX", "TRANSLATE_NEW_SQL", "RAISE_TRANSLATION_ERROR", "LOG_TRANSLATION_ERROR", "TRACE_TRANSLATION", "LOG_ERRORS") AS 
  select u.name, o.name,
       case when (s.txlrowner is null and s.txlrname is null) then
         null
       else
         '"'||s.txlrowner||'"."'||s.txlrname||'"'
       end,
       decode(bitand(s.flags, 1), 1, 'TRUE', 0, 'FALSE'),
       decode(bitand(s.flags, 2), 2, 'TRUE', 0, 'FALSE'),
       decode(bitand(s.flags, 4), 4, 'TRUE', 0, 'FALSE'),
       decode(bitand(s.flags, 8), 8, 'TRUE', 0, 'FALSE'),
       decode(bitand(s.flags, 16), 16, 'TRUE', 0, 'FALSE'),
       decode(bitand(s.flags, 32), 32, 'TRUE', 0, 'FALSE')
  from sys.sqltxl$ s, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u
 where s.obj# = o.obj# and
       o.owner# = u.user# and
       (
         o.owner# = userenv('SCHEMAID')
         or
         exists (select null from sys.objauth$ oa
                  where oa.obj# = o.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# in (0 /* ALTER */, 29 /* USE */))
         or
         exists (select null from v$enabledprivs
                 where priv_number in (
                                -335 /* CREATE ANY SQL TRANSLATION PROFILE */,
                                -336 /* ALTER ANY SQL TRANSLATION PROFILE  */,
                                -337 /* USE ANY SQL TRANSLATION PROFILE    */,
                                -338 /* DROP ANY SQL TRANSLATION PROFILE   */
                                      )
                )
       );

   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."OWNER" IS 'Owner of the SQL translation profile';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."PROFILE_NAME" IS 'Name of the SQL translation profile';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."TRANSLATOR" IS 'The translator package';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."FOREIGN_SQL_SYNTAX" IS 'Is the SQL syntax foreign?';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."TRANSLATE_NEW_SQL" IS 'Translate new SQL statements and errors using the translator?';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."RAISE_TRANSLATION_ERROR" IS 'Raise translation error?';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."LOG_TRANSLATION_ERROR" IS 'Log translation error?';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."TRACE_TRANSLATION" IS 'Trace translation?';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATION_PROFILES"."LOG_ERRORS" IS 'Log errors?';
   COMMENT ON TABLE "SYS"."ALL_SQL_TRANSLATION_PROFILES"  IS 'Describes all SQL translation profiles accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SQL_TRANSLATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SQL_TRANSLATIONS" ("OWNER", "PROFILE_NAME", "SQL_TEXT", "TRANSLATED_TEXT", "SQL_ID", "HASH_VALUE", "ENABLED", "REGISTRATION_TIME", "CLIENT_INFO", "MODULE", "ACTION", "PARSING_USER_ID", "PARSING_SCHEMA_ID", "COMMENTS", "ERROR_CODE", "ERROR_SOURCE", "TRANSLATION_METHOD", "DICTIONARY_SQL_ID") AS 
  select u.name, o.name, s.sqltext, s.txltext, s.sqlid, s.sqlhash,
       decode(bitand(s.flags, 1), 1, 'TRUE', 0, 'FALSE'),
       s.rtime, s.cinfo, s.module, s.action, s.puser#, s.pschema#, s.comment$,
       s.errcode#,
       decode(s.errsrc, 1, 'TRANSLATE', 2, 'PARSE', 3, 'EXECUTE'),
       decode(s.txlmthd, 1, 'TRANSLATOR', 2, 'DICTIONARY'),
       s.dictid
  from sys.sqltxl_sql$ s, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u
 where s.obj# = o.obj# and
       o.owner# = u.user# and
       (
         o.owner# = userenv('SCHEMAID')
         or
         exists (select null from sys.objauth$ oa
                  where oa.obj# = o.obj#
                    and oa.grantee# in (select kzsrorol from x$kzsro)
                    and oa.privilege# in (0 /* ALTER */, 29 /* USE */))
         or
         exists (select null from v$enabledprivs
                 where priv_number in (
                                -335 /* CREATE ANY SQL TRANSLATION PROFILE */,
                                -336 /* ALTER ANY SQL TRANSLATION PROFILE  */,
                                -337 /* USE ANY SQL TRANSLATION PROFILE    */,
                                -338 /* DROP ANY SQL TRANSLATION PROFILE   */
                                      )
                )
       );

   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."OWNER" IS 'Owner of the SQL translation profile';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."PROFILE_NAME" IS 'Name of the SQL translation profile';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."SQL_TEXT" IS 'The SQL text';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."TRANSLATED_TEXT" IS 'The translated SQL text';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."SQL_ID" IS 'SQL identifier of the SQL text';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."HASH_VALUE" IS 'Hash value of the SQL text';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."ENABLED" IS 'Is the translation enabled?';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."REGISTRATION_TIME" IS 'Time the translation was registered';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."CLIENT_INFO" IS 'Client information when the SQL was parsed and the translation was registered';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."MODULE" IS 'Module when the SQL was parsed and the translation was registered';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."ACTION" IS 'Action when the SQL was parsed and the translation was registered';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."PARSING_USER_ID" IS 'Current user ID when the SQL was parsed and the translation was registered';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."PARSING_SCHEMA_ID" IS 'Current schema ID when the SQL was parsed and the translation was registered';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."COMMENTS" IS 'Comment on the translation';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."ERROR_CODE" IS 'Last error code when the SQL was run';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."ERROR_SOURCE" IS 'Source of the last error';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."TRANSLATION_METHOD" IS 'Method used to translate the SQL during the last error';
   COMMENT ON COLUMN "SYS"."ALL_SQL_TRANSLATIONS"."DICTIONARY_SQL_ID" IS 'SQL identifier of the SQL text in translation dictionary used to translate the SQL during the last error';
   COMMENT ON TABLE "SYS"."ALL_SQL_TRANSLATIONS"  IS 'Describes all SQL translations accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_STATEMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STATEMENTS" ("OWNER", "SIGNATURE", "TYPE", "OBJECT_NAME", "OBJECT_TYPE", "USAGE_ID", "LINE", "COL", "USAGE_CONTEXT_ID", "SQL_ID", "HAS_HINT", "HAS_INTO_BULK", "HAS_INTO_RETURNING", "HAS_INTO_RECORD", "HAS_CURRENT_OF", "HAS_FOR_UPDATE", "HAS_IN_BINDS", "TEXT", "FULL_TEXT", "ORIGIN_CON_ID") AS 
  select OWNER, SIGNATURE, TYPE, OBJECT_NAME, OBJECT_TYPE,
USAGE_ID, LINE, COL, USAGE_CONTEXT_ID, SQL_ID, HAS_HINT, HAS_INTO_BULK,
HAS_INTO_RETURNING, HAS_INTO_RECORD, HAS_CURRENT_OF, HAS_FOR_UPDATE, HAS_IN_BINDS,
TEXT, FULL_TEXT, ORIGIN_CON_ID
from INT$DBA_STATEMENTS
where
  (
    OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
    or OWNER = 'PUBLIC'
    or
    (
      (
         (
          (OBJECT_TYPE#
           in (7 /* proc */, 8 /* func */, 9 /* pkg */, 13 /* type */))
          and
          OBJ_ID(OWNER, OBJECT_NAME, OBJECT_TYPE#, OBJECT_ID) in
          (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (12 /* EXECUTE */, 26 /* DEBUG */))
        )
        or
        (
          (OBJECT_TYPE# in (2 /* table */, 4 /* view */))
          and
          OBJ_ID(OWNER, OBJECT_NAME, OBJECT_TYPE#, OBJECT_ID) in
          (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (0 /* ALTER */, 6 /* INSERT */,
                                          9 /* SELECT */, 10 /* UPDATE */))
        )
        or
        (
          (OBJECT_TYPE# in (11 /* package body */, 14 /* type body */))
          and
          exists
          (
            select null from sys.obj$ specobj, sys.objauth$ oa, sys.user$ u
            where specobj.owner# = u.user#
              and u.name = OWNER
              and specobj.name = OBJECT_NAME
              and specobj.type# = decode(OBJECT_TYPE#,
                                         11 /* pkg body */, 9 /* pkg */,
                                         14 /* type body */, 13 /* type */,
                                         null)
              and oa.obj# = specobj.obj#
              and oa.grantee# in (select kzsrorol from x$kzsro)
              and oa.privilege# = 26 /* DEBUG */)
        )
        or
        (
          (OBJECT_TYPE# = 12 /* trigger */)
          and
          exists
          (
            select null
            from sys.trigger$ t, sys.obj$ tabobj, sys.objauth$ oa, sys.user$ u
            where t.obj# = OBJ_ID(OWNER, OBJECT_NAME, 12, OBJECT_ID)
              and tabobj.obj# = t.baseobject
              and tabobj.owner# = u.user#
              and u.name = OWNER
              and oa.obj# = tabobj.obj#
              and oa.grantee# in (select kzsrorol from x$kzsro)
              and oa.privilege# = 26 /* DEBUG */)
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (OBJECT_TYPE# = 7 or OBJECT_TYPE# = 8 or OBJECT_TYPE# = 9)
              and
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* package body */
              OBJECT_TYPE# = 11 and
              (
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type */
              OBJECT_TYPE# = 13
              and
              (
                privilege# = -184 /* EXECUTE ANY TYPE */
                or
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type body */
              OBJECT_TYPE# = 14 and
              (
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* triggers */
              OBJECT_TYPE# = 12 and
              (
                privilege# = -152 /* CREATE ANY TRIGGER */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* library */
              OBJECT_TYPE# = 22 and
              (
                privilege# = -189 /* CREATE ANY LIBRARY */
                or
                privilege# = -192 /* EXECUTE ANY LIBRARY */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."SIGNATURE" IS 'Signature of the statement';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."TYPE" IS 'Type of the statement';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."OBJECT_NAME" IS 'Name of the object where the statement usage occurred';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."OBJECT_TYPE" IS 'Type of the object where the statement usage occurred';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."USAGE_ID" IS 'Unique key for an statement usage within the object';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."LINE" IS 'Line number of the statement usage';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."COL" IS 'Column number of the statement usage';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."USAGE_CONTEXT_ID" IS 'Context USAGE_ID of an statement usage';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."SQL_ID" IS 'SQLID of the SQL statement';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."HAS_HINT" IS 'TRUE if the SQL statement contains a hint';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."TEXT" IS 'Varchar2 text of the SQL statement';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."FULL_TEXT" IS 'Clob text of the SQL statement';
   COMMENT ON COLUMN "SYS"."ALL_STATEMENTS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_STATEMENTS"  IS 'All SQL statements in stored objects accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_STAT_EXTENSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STAT_EXTENSIONS" ("OWNER", "TABLE_NAME", "EXTENSION_NAME", "EXTENSION", "CREATOR", "DROPPABLE") AS 
  SELECT
    u.name, o.name, c.name,
    sys.get_stats_extension(c.rowid),
    -- TODO use flags once it is available
    decode(substr(c.name, 1, 7), 'SYS_STU', 'USER', 'SYSTEM'),
    decode(substr(c.name, 1, 6), 'SYS_ST', 'YES', 'NO')
  FROM
    sys.col$ c, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u
  WHERE
      o.obj# = c.obj#
  and c.default$ is not null -- avoid join index columns
  and bitand(c.property, 8) = 8 -- virtual column
  and o.owner# = u.user#
  and bitand(o.flags, 128) = 0 -- not in recycle bin
  --  tables, excluding iot - overflow and nested tables
  and o.type# = 2
  and not exists (select null
                  from sys.tab$ t
                  where t.obj# = o.obj#
                  and (bitand(t.property, 512) = 512 or
                       bitand(t.property, 8192) = 8192))
  and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       );

   COMMENT ON COLUMN "SYS"."ALL_STAT_EXTENSIONS"."OWNER" IS 'Owner of the extension';
   COMMENT ON COLUMN "SYS"."ALL_STAT_EXTENSIONS"."TABLE_NAME" IS 'Name of the table to which the extension belongs';
   COMMENT ON COLUMN "SYS"."ALL_STAT_EXTENSIONS"."EXTENSION_NAME" IS 'The extension (the expression or column group)';
   COMMENT ON COLUMN "SYS"."ALL_STAT_EXTENSIONS"."DROPPABLE" IS 'Is this extension drppable using dbms_stats.drop_extended_stats ?';
   COMMENT ON TABLE "SYS"."ALL_STAT_EXTENSIONS"  IS 'Optimizer statistics extensions'
;
--------------------------------------------------------
--  DDL for View ALL_STORED_SETTINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STORED_SETTINGS" ("OWNER", "OBJECT_NAME", "OBJECT_ID", "OBJECT_TYPE", "PARAM_NAME", "PARAM_VALUE", "ORIGIN_CON_ID") AS 
  SELECT owner, object_name, object_id, object_type, param_name, param_value,
       origin_con_id
FROM int$dba_stored_settings int$dba_stored_settings
WHERE (
    int$dba_stored_settings.owner = 'PUBLIC'
    or
    (
      (
         (
          (int$dba_stored_settings.object_type# = 7 or
           int$dba_stored_settings.object_type# = 8 or
           int$dba_stored_settings.object_type# = 9 or
           int$dba_stored_settings.object_type# = 13)
          and
          obj_id(int$dba_stored_settings.owner,
                 int$dba_stored_settings.object_name,
                 int$dba_stored_settings.object_type#,
                 int$dba_stored_settings.object_id) in
                   (select obj# from sys.objauth$
                     where grantee# in (select kzsrorol from x$kzsro)
                       and privilege# in (12 /* EXECUTE */,
                                          26 /* DEBUG */))
        )
        or
        exists
        (
          select null from sys.sysauth$
          where grantee# in (select kzsrorol from x$kzsro)
          and
          (
            (
              /* procedure */
              (int$dba_stored_settings.object_type# = 7 or
               int$dba_stored_settings.object_type# = 8 or
               int$dba_stored_settings.object_type# = 9)
              and
              (
                privilege# = -144 /* EXECUTE ANY PROCEDURE */
                or
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* package body */
              int$dba_stored_settings.object_type# = 11 and
              (
                privilege# = -141 /* CREATE ANY PROCEDURE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type */
              int$dba_stored_settings.object_type# = 13
              and
              (
                privilege# = -184 /* EXECUTE ANY TYPE */
                or
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
            or
            (
              /* type body */
              int$dba_stored_settings.object_type# = 14 and
              (
                privilege# = -181 /* CREATE ANY TYPE */
                or
                privilege# = -241 /* DEBUG ANY PROCEDURE */
              )
            )
          )
        )
      )
    )
  );

   COMMENT ON COLUMN "SYS"."ALL_STORED_SETTINGS"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_STORED_SETTINGS"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_STORED_SETTINGS"."OBJECT_ID" IS 'Object number of the object';
   COMMENT ON COLUMN "SYS"."ALL_STORED_SETTINGS"."OBJECT_TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_STORED_SETTINGS"."PARAM_NAME" IS 'Name of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_STORED_SETTINGS"."PARAM_VALUE" IS 'Value of the parameter';
   COMMENT ON COLUMN "SYS"."ALL_STORED_SETTINGS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_STORED_SETTINGS"  IS 'Parameter settings for objects accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_COLUMNS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "SYNC_CAPTURE_VERSION", "SYNC_CAPTURE_REASON", "APPLY_VERSION", "APPLY_REASON") AS 
  select s."OWNER",s."TABLE_NAME",s."COLUMN_NAME",s."SYNC_CAPTURE_VERSION",s."SYNC_CAPTURE_REASON",s."APPLY_VERSION",s."APPLY_REASON" from dba_streams_columns s, all_objects a
    where s.owner = a.owner
      and s.table_name = a.object_name
      and a.object_type = 'TABLE';

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_COLUMNS"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_COLUMNS"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_COLUMNS"."SYNC_CAPTURE_VERSION" IS 'Version of sync capture which supports this column';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_COLUMNS"."SYNC_CAPTURE_REASON" IS 'Reason why this column is not supported by sync capture';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_COLUMNS"."APPLY_VERSION" IS 'Version of apply which supports this column';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_COLUMNS"."APPLY_REASON" IS 'Reason why this column is not supported by apply';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_COLUMNS"  IS 'Streams unsupported columns'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_GLOBAL_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_GLOBAL_RULES" ("STREAMS_NAME", "STREAMS_TYPE", "RULE_TYPE", "INCLUDE_TAGGED_LCR", "SOURCE_DATABASE", "RULE_NAME", "RULE_OWNER", "RULE_CONDITION") AS 
  select r.streams_name, r.streams_type, r.rule_type, r.include_tagged_lcr,
       r.source_database, r.rule_name, r.rule_owner, r.rule_condition
 from  dba_streams_global_rules r, "_ALL_STREAMS_PROCESSES" p, all_rules ar
 where r.streams_name = p.streams_name
   and r.streams_type = p.streams_type
   and ar.rule_owner = r.rule_owner
   and ar.rule_name = r.rule_name;

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_GLOBAL_RULES"."STREAMS_NAME" IS 'Name of the streams process: capture/propagation/apply process';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_GLOBAL_RULES"."STREAMS_TYPE" IS 'Type of the streams process: CAPTURE, PROPAGATION or APPLY';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_GLOBAL_RULES"."RULE_TYPE" IS 'Type of rule: DML, DDL or PROCEDURE';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_GLOBAL_RULES"."INCLUDE_TAGGED_LCR" IS 'Whether or not to include tagged LCR';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_GLOBAL_RULES"."SOURCE_DATABASE" IS 'Name of the database where the LCRs originated';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_GLOBAL_RULES"."RULE_NAME" IS 'Name of the rule to be applied';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_GLOBAL_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_GLOBAL_RULES"."RULE_CONDITION" IS 'Generated rule condition evaluated by the rules engine';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_GLOBAL_RULES"  IS 'Global rules created on the streams capture/apply/propagation process that interact with the queue visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_KEEP_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_KEEP_COLUMNS" ("RULE_OWNER", "RULE_NAME", "SCHEMA_NAME", "TABLE_NAME", "COLUMN_NAME", "VALUE_TYPE", "PRECEDENCE", "STEP_NUMBER") AS 
  select skc."RULE_OWNER",skc."RULE_NAME",skc."SCHEMA_NAME",skc."TABLE_NAME",skc."COLUMN_NAME",skc."VALUE_TYPE",skc."PRECEDENCE",skc."STEP_NUMBER"
  from DBA_STREAMS_KEEP_COLUMNS skc, ALL_APPLY aa, ALL_CAPTURE ca
  where (aa.apply_user = skc.rule_owner) or (ca.capture_user = skc.rule_owner);

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_KEEP_COLUMNS"."RULE_OWNER" IS 'Owner of the rule which has an associated transformation';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_KEEP_COLUMNS"."RULE_NAME" IS 'Name of the rule which has an associated transformation';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_KEEP_COLUMNS"."SCHEMA_NAME" IS 'The schema of the column to be kept';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_KEEP_COLUMNS"."TABLE_NAME" IS 'The table of the column to be kept';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_KEEP_COLUMNS"."COLUMN_NAME" IS 'The column to keep';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_KEEP_COLUMNS"."VALUE_TYPE" IS 'Whether to keep the old column value of the lcr, the new value, or both';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_KEEP_COLUMNS"."PRECEDENCE" IS 'Execution order relative to other declarative transformations on the same step_number';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_KEEP_COLUMNS"."STEP_NUMBER" IS 'The order that this transformation should be executed';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_KEEP_COLUMNS"  IS 'Keep columns transformations for the user'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_MESSAGE_CONSUMERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS" ("STREAMS_NAME", "QUEUE_NAME", "QUEUE_OWNER", "RULE_SET_NAME", "RULE_SET_OWNER", "NEGATIVE_RULE_SET_NAME", "NEGATIVE_RULE_SET_OWNER", "NOTIFICATION_TYPE", "NOTIFICATION_ACTION", "NOTIFICATION_CONTEXT") AS 
  select c."STREAMS_NAME",c."QUEUE_NAME",c."QUEUE_OWNER",c."RULE_SET_NAME",c."RULE_SET_OWNER",c."NEGATIVE_RULE_SET_NAME",c."NEGATIVE_RULE_SET_OWNER",c."NOTIFICATION_TYPE",c."NOTIFICATION_ACTION",c."NOTIFICATION_CONTEXT"
  from dba_streams_message_consumers c, all_queues q
 where c.queue_name = q.name
   and c.queue_owner = q.owner
   and ((c.rule_set_owner is null and c.rule_set_name is null) or
        ((c.rule_set_owner, c.rule_set_name) in
          (select r.rule_set_owner, r.rule_set_name
             from all_rule_sets r)))
   and ((c.negative_rule_set_owner is null and
         c.negative_rule_set_name is null) or
        ((c.negative_rule_set_owner, c.negative_rule_set_name) in
          (select r.rule_set_owner, r.rule_set_name
             from all_rule_sets r)));

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."STREAMS_NAME" IS 'Name of the consumer';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."QUEUE_NAME" IS 'Name of the queue';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."QUEUE_OWNER" IS 'Owner of the queue';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."RULE_SET_NAME" IS 'Name of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."NEGATIVE_RULE_SET_NAME" IS 'Name of the negative rule set';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."NEGATIVE_RULE_SET_OWNER" IS 'Owner of the negative rule set';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."NOTIFICATION_ACTION" IS 'Notification action';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"."NOTIFICATION_CONTEXT" IS 'Context for the notification action';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_MESSAGE_CONSUMERS"  IS 'Streams messaging consumers visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_MESSAGE_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_MESSAGE_RULES" ("STREAMS_NAME", "STREAMS_TYPE", "MESSAGE_TYPE_NAME", "MESSAGE_TYPE_OWNER", "MESSAGE_RULE_VARIABLE", "RULE_NAME", "RULE_OWNER", "RULE_CONDITION") AS 
  select mr."STREAMS_NAME",mr."STREAMS_TYPE",mr."MESSAGE_TYPE_NAME",mr."MESSAGE_TYPE_OWNER",mr."MESSAGE_RULE_VARIABLE",mr."RULE_NAME",mr."RULE_OWNER",mr."RULE_CONDITION"
  from dba_streams_message_rules mr, "_ALL_STREAMS_PROCESSES" p, all_rules ar
 where mr.rule_owner = ar.rule_owner
   and mr.rule_name  = ar.rule_name
   and mr.streams_name = p.streams_name
   and mr.streams_type = p.streams_type;

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_RULES"."STREAMS_NAME" IS 'Name of the streams process : propagation/apply/dequeue';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_RULES"."STREAMS_TYPE" IS 'Type of the streams process: PROPAGATION, APPLY, or DEQUEUE';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_RULES"."MESSAGE_TYPE_NAME" IS 'Name of the message type';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_RULES"."MESSAGE_TYPE_OWNER" IS 'Owner of the message type';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_RULES"."MESSAGE_RULE_VARIABLE" IS 'Name of variable in the message rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_RULES"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_MESSAGE_RULES"."RULE_CONDITION" IS 'Rule condition';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_MESSAGE_RULES"  IS 'Rules for Streams messaging visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_NEWLY_SUPPORTED
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_NEWLY_SUPPORTED" ("OWNER", "TABLE_NAME", "REASON", "COMPATIBLE") AS 
  select s."OWNER",s."TABLE_NAME",s."REASON",s."COMPATIBLE" from dba_streams_newly_supported s, all_objects a
    where s.owner = a.owner
      and s.table_name = a.object_name
      and a.object_type = 'TABLE';

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_NEWLY_SUPPORTED"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_NEWLY_SUPPORTED"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_NEWLY_SUPPORTED"."REASON" IS 'Reason why the object was not supported in some previous release';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_NEWLY_SUPPORTED"."COMPATIBLE" IS 'The least compatible setting when this object is supported';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_NEWLY_SUPPORTED"  IS 'List of objects that are newly supported by Streams'
;
--------------------------------------------------------
--  DDL for View _ALL_STREAMS_PROCESSES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_STREAMS_PROCESSES" ("STREAMS_TYPE", "STREAMS_NAME", "RULE_SET_OWNER", "RULE_SET_NAME", "NEGATIVE_RULE_SET_OWNER", "NEGATIVE_RULE_SET_NAME") AS 
  select 'CAPTURE' streams_type,
       capture_name, rule_set_owner, rule_set_name,
       negative_rule_set_owner, negative_rule_set_name
  from all_capture
union all
select 'SYNC_CAPTURE' streams_type,
       capture_name, rule_set_owner, rule_set_name,
       null negative_rule_set_owner, null negative_rule_set_name
  from all_sync_capture
union all
select 'APPLY', apply_name, rule_set_owner, rule_set_name,
       negative_rule_set_owner, negative_rule_set_name
  from all_apply
union all
select 'PROPAGATION', propagation_name, rule_set_owner, rule_set_name,
       negative_rule_set_owner, negative_rule_set_name
  from all_propagation
union all
select 'DEQUEUE', streams_name, rule_set_owner, rule_set_name,
       negative_rule_set_owner, negative_rule_set_name
  from all_streams_message_consumers
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_RULES" ("STREAMS_TYPE", "STREAMS_NAME", "RULE_SET_OWNER", "RULE_SET_NAME", "RULE_OWNER", "RULE_NAME", "RULE_CONDITION", "RULE_SET_TYPE", "STREAMS_RULE_TYPE", "SCHEMA_NAME", "OBJECT_NAME", "SUBSETTING_OPERATION", "DML_CONDITION", "INCLUDE_TAGGED_LCR", "SOURCE_DATABASE", "RULE_TYPE", "MESSAGE_TYPE_OWNER", "MESSAGE_TYPE_NAME", "MESSAGE_RULE_VARIABLE", "ORIGINAL_RULE_CONDITION", "SAME_RULE_CONDITION") AS 
  select r."STREAMS_TYPE",r."STREAMS_NAME",r."RULE_SET_OWNER",r."RULE_SET_NAME",r."RULE_OWNER",r."RULE_NAME",r."RULE_CONDITION",r."RULE_SET_TYPE",r."STREAMS_RULE_TYPE",r."SCHEMA_NAME",r."OBJECT_NAME",r."SUBSETTING_OPERATION",r."DML_CONDITION",r."INCLUDE_TAGGED_LCR",r."SOURCE_DATABASE",r."RULE_TYPE",r."MESSAGE_TYPE_OWNER",r."MESSAGE_TYPE_NAME",r."MESSAGE_RULE_VARIABLE",r."ORIGINAL_RULE_CONDITION",r."SAME_RULE_CONDITION"
  from dba_streams_rules r, "_ALL_STREAMS_PROCESSES" p
where r.streams_type = p.streams_type
  and r.streams_name = p.streams_name;

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."STREAMS_TYPE" IS 'Type of the streams process: CAPTURE, PROPAGATION, APPLY or DEQUEUE';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."STREAMS_NAME" IS 'Name of the Streams process';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."RULE_SET_NAME" IS 'Name of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."RULE_CONDITION" IS 'Current rule condition';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."RULE_SET_TYPE" IS 'Type of the rule set: POSITIVE or NEGATIVE';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."STREAMS_RULE_TYPE" IS 'For global, schema or table rules, type of rule: TABLE, SCHEMA or GLOBAL';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."SCHEMA_NAME" IS 'For table and schema rules, the schema name';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."OBJECT_NAME" IS 'For table rules, the table name';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."SUBSETTING_OPERATION" IS 'For subset rules, the type of operation: INSERT, UPDATE, or DELETE';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."DML_CONDITION" IS 'For subset rules, the row subsetting condition';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."INCLUDE_TAGGED_LCR" IS 'For global, schema or table rules, whether or not to include tagged LCRs';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."SOURCE_DATABASE" IS 'For global, schema or table rules, the name of the database where the LCRs originated';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."RULE_TYPE" IS 'For global, schema or table rules, type of rule: DML, DDL or PROCEDURE';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."MESSAGE_TYPE_OWNER" IS 'For message rules, the owner of the message type';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."MESSAGE_TYPE_NAME" IS 'For message rules, the name of the message type';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."MESSAGE_RULE_VARIABLE" IS 'For message rules, the name of the variable in the message rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."ORIGINAL_RULE_CONDITION" IS 'For rules created by Streams administrative APIs, the original rule condition when the rule was created';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_RULES"."SAME_RULE_CONDITION" IS 'For rules created by Streams administrative APIs, whether or not the current rule condition is the same as the original rule condition';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_RULES"  IS 'Rules used by streams processes'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_SCHEMA_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_SCHEMA_RULES" ("STREAMS_NAME", "STREAMS_TYPE", "SCHEMA_NAME", "RULE_TYPE", "INCLUDE_TAGGED_LCR", "SOURCE_DATABASE", "RULE_NAME", "RULE_OWNER", "RULE_CONDITION") AS 
  select sr.streams_name, sr.streams_type, sr.schema_name, sr.rule_type,
       sr.include_tagged_lcr, sr.source_database, sr.rule_name, sr.rule_owner,
       sr.rule_condition
  from dba_streams_schema_rules sr, "_ALL_STREAMS_PROCESSES" p, all_rules r
 where sr.rule_owner = r.rule_owner
   and sr.rule_name = r.rule_name
   and sr.streams_name = p.streams_name
   and sr.streams_type = p.streams_type;

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."STREAMS_NAME" IS 'Name of the streams process: capture/propagation/apply process';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."STREAMS_TYPE" IS 'Type of the streams process: CAPTURE, PROPAGATION or APPLY';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."SCHEMA_NAME" IS 'Name of the schema selected by this rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."RULE_TYPE" IS 'Type of rule: DML or DDL';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."INCLUDE_TAGGED_LCR" IS 'Whether or not to include tagged LCR';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."SOURCE_DATABASE" IS 'Name of the database where the LCRs originated';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."RULE_NAME" IS 'Name of the rule to be applied';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_SCHEMA_RULES"."RULE_CONDITION" IS 'Generated rule condition evaluated by the rules engine';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_SCHEMA_RULES"  IS 'Rules created by streams administrative APIs on all user schemas'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_TABLE_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_TABLE_RULES" ("STREAMS_NAME", "STREAMS_TYPE", "TABLE_OWNER", "TABLE_NAME", "RULE_TYPE", "DML_CONDITION", "SUBSETTING_OPERATION", "INCLUDE_TAGGED_LCR", "SOURCE_DATABASE", "RULE_NAME", "RULE_OWNER", "RULE_CONDITION") AS 
  select tr.streams_name, tr.streams_type, tr.table_owner, tr.table_name,
       tr.rule_type, tr.dml_condition, tr.subsetting_operation,
       tr.include_tagged_lcr, tr.source_database, tr.rule_name,
       tr.rule_owner, tr.rule_condition
  from dba_streams_table_rules tr, "_ALL_STREAMS_PROCESSES" p, all_rules ar
 where tr.rule_owner = ar.rule_owner
   and tr.rule_name = ar.rule_name
   and tr.streams_name = p.streams_name
   and tr.streams_type = p.streams_type;

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."STREAMS_NAME" IS 'Name of the streams process: capture/propagation/apply process';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."STREAMS_TYPE" IS 'Type of the streams process: CAPTURE, PROPAGATION or APPLY';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."TABLE_OWNER" IS 'Owner of the table selected by this rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."TABLE_NAME" IS 'Name of the table selected by this rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."RULE_TYPE" IS 'Type of rule: DML or DDL';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."DML_CONDITION" IS 'Row subsetting condition';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."SUBSETTING_OPERATION" IS 'DML operation for row subsetting';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."INCLUDE_TAGGED_LCR" IS 'Whether or not to include tagged LCR';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."SOURCE_DATABASE" IS 'Name of the database where the LCRs originated';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."RULE_NAME" IS 'Name of the rule to be applied';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TABLE_RULES"."RULE_CONDITION" IS 'Generated rule condition evaluated by the rules engine';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_TABLE_RULES"  IS 'Rules created by streams administrative APIs on tables visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_TRANSFORMATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_TRANSFORMATIONS" ("RULE_OWNER", "RULE_NAME", "TRANSFORM_TYPE", "FROM_SCHEMA_NAME", "TO_SCHEMA_NAME", "FROM_TABLE_NAME", "TO_TABLE_NAME", "SCHEMA_NAME", "TABLE_NAME", "FROM_COLUMN_NAME", "TO_COLUMN_NAME", "COLUMN_NAME", "COLUMN_VALUE", "COLUMN_TYPE", "COLUMN_FUNCTION", "VALUE_TYPE", "USER_FUNCTION_NAME", "SUBSETTING_OPERATION", "DML_CONDITION", "DECLARATIVE_TYPE", "PRECEDENCE", "STEP_NUMBER") AS 
  select st."RULE_OWNER",st."RULE_NAME",st."TRANSFORM_TYPE",st."FROM_SCHEMA_NAME",st."TO_SCHEMA_NAME",st."FROM_TABLE_NAME",st."TO_TABLE_NAME",st."SCHEMA_NAME",st."TABLE_NAME",st."FROM_COLUMN_NAME",st."TO_COLUMN_NAME",st."COLUMN_NAME",st."COLUMN_VALUE",st."COLUMN_TYPE",st."COLUMN_FUNCTION",st."VALUE_TYPE",st."USER_FUNCTION_NAME",st."SUBSETTING_OPERATION",st."DML_CONDITION",st."DECLARATIVE_TYPE",st."PRECEDENCE",st."STEP_NUMBER"
from  DBA_STREAMS_TRANSFORMATIONS st, ALL_APPLY aa, ALL_CAPTURE ca
  where (aa.apply_user = st.rule_owner) or (ca.capture_user = st.rule_owner);

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."RULE_OWNER" IS 'Owner of the rule which has an associated transformation';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."RULE_NAME" IS 'Name of the rule which has an associated transformation';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."TRANSFORM_TYPE" IS 'The type of transformation';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."FROM_SCHEMA_NAME" IS 'The schema to be renamed';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."TO_SCHEMA_NAME" IS 'The new schema name';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."FROM_TABLE_NAME" IS 'The table to be renamed';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."TO_TABLE_NAME" IS 'The new table name';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."SCHEMA_NAME" IS 'The schema of the column to be modified';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."TABLE_NAME" IS 'The table of the column to be modified';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."FROM_COLUMN_NAME" IS 'The column to rename';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."TO_COLUMN_NAME" IS 'The new column name';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."COLUMN_NAME" IS 'The column to add or delete';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."COLUMN_VALUE" IS 'The value of the column to add';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."COLUMN_TYPE" IS 'The type of the new column';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."COLUMN_FUNCTION" IS 'The name of the default function used to add a column';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."USER_FUNCTION_NAME" IS 'The name of the user-defined transformation function to run ';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."SUBSETTING_OPERATION" IS 'DML operation for row subsetting';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."DML_CONDITION" IS 'Row subsetting condition';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."DECLARATIVE_TYPE" IS 'The type of declarative transformation to run';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."PRECEDENCE" IS 'Execution order relative to other declarative transformations on the same step_number';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORMATIONS"."STEP_NUMBER" IS 'The order that this transformation should be executed';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_TRANSFORMATIONS"  IS 'Transformations defined on rules for the user'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_TRANSFORM_FUNCTION
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_TRANSFORM_FUNCTION" ("RULE_OWNER", "RULE_NAME", "VALUE_TYPE", "TRANSFORM_FUNCTION_NAME", "CUSTOM_TYPE") AS 
  select tf."RULE_OWNER",tf."RULE_NAME",tf."VALUE_TYPE",tf."TRANSFORM_FUNCTION_NAME",tf."CUSTOM_TYPE"
from   DBA_STREAMS_TRANSFORM_FUNCTION tf, ALL_RULES r
where  tf.rule_owner = r.rule_owner
and    tf.rule_name = r.rule_name;

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORM_FUNCTION"."RULE_OWNER" IS 'The owner of the rule associated with the transform function';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORM_FUNCTION"."RULE_NAME" IS 'The name of the rule associated with the transform function';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORM_FUNCTION"."VALUE_TYPE" IS 'The type of the transform function name.  This type must be VARCHAR2 for a rule-based transformation to work properly';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORM_FUNCTION"."TRANSFORM_FUNCTION_NAME" IS 'The name of the transform function, or NULL if the VALUE_TYPE is not VARCHAR2';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_TRANSFORM_FUNCTION"."CUSTOM_TYPE" IS 'The type of the transform function';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_TRANSFORM_FUNCTION"  IS 'Rules-based transform functions used by Streams'
;
--------------------------------------------------------
--  DDL for View ALL_STREAMS_UNSUPPORTED
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_STREAMS_UNSUPPORTED" ("OWNER", "TABLE_NAME", "REASON", "AUTO_FILTERED") AS 
  select s."OWNER",s."TABLE_NAME",s."REASON",s."AUTO_FILTERED" from DBA_STREAMS_UNSUPPORTED s, ALL_OBJECTS a
   where s.owner = a.owner
     and s.table_name = a.object_name
     and a.object_type = 'TABLE';

   COMMENT ON COLUMN "SYS"."ALL_STREAMS_UNSUPPORTED"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_UNSUPPORTED"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_UNSUPPORTED"."REASON" IS 'Reason why the object is not supported';
   COMMENT ON COLUMN "SYS"."ALL_STREAMS_UNSUPPORTED"."AUTO_FILTERED" IS 'Does Streams automatically filter out this object';
   COMMENT ON TABLE "SYS"."ALL_STREAMS_UNSUPPORTED"  IS 'List of all the tables that are not supported by Streams in this release'
;
--------------------------------------------------------
--  DDL for View ALL_SUBPART_COL_STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUBPART_COL_STATISTICS" ("OWNER", "TABLE_NAME", "SUBPARTITION_NAME", "COLUMN_NAME", "NUM_DISTINCT", "LOW_VALUE", "HIGH_VALUE", "DENSITY", "NUM_NULLS", "NUM_BUCKETS", "SAMPLE_SIZE", "LAST_ANALYZED", "GLOBAL_STATS", "USER_STATS", "NOTES", "AVG_COL_LEN", "HISTOGRAM") AS 
  select u.name, o.name, o.subname, tsp.cname, h.distcnt,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.lowval
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then  h.hival
            else null
       end,
       h.density, h.null_cnt,
       case when nvl(h.distcnt,0) = 0 then h.distcnt
            when h.row_cnt = 0 then 1
	    when exists(select 1 from sys."_HISTGRM_DEC" hg
                        where tsp.obj# = hg.obj# and tsp.intcol# = hg.intcol#
                          and hg.ep_repeat_count > 0 and rownum < 2) then h.row_cnt
            when bitand(h.spare2, 64) > 0
              then h.row_cnt
            when (bitand(h.spare2, 32) > 0 or h.bucket_cnt > 2049 or
                  (h.bucket_cnt >= h.distcnt and h.density*h.bucket_cnt < 1))
                then h.row_cnt
            else h.bucket_cnt
       end,
       h.sample_size, h.timestamp#,
       decode(bitand(h.spare2, 2), 2, 'YES', 'NO'),
       decode(bitand(h.spare2, 1), 1, 'YES', 'NO'),
       decode(bitand(h.spare2, 8), 8, 'INCREMENTAL ', '') ||
         decode(bitand(h.spare2, 128), 128, 'HIST_FOR_INCREM_STATS ', '') ||
         decode(bitand(h.spare2, 256), 256, 'HISTOGRAM_ONLY ', '') ||
         decode(bitand(h.spare2, 512), 512, 'STATS_ON_LOAD ', ''),
       h.avgcln,
       case when nvl(h.row_cnt,0) = 0 then 'NONE'
            when exists(select 1 from sys."_HISTGRM_DEC" hg
                        where tsp.obj# = hg.obj# and tsp.intcol# = hg.intcol#
                          and hg.ep_repeat_count > 0 and rownum < 2) then 'HYBRID'
            when bitand(h.spare2, 64) > 0
              then 'TOP-FREQUENCY'
            when (bitand(h.spare2, 32) > 0 or h.bucket_cnt > 2049 or
                  (h.bucket_cnt >= h.distcnt and h.density*h.bucket_cnt < 1))
                then 'FREQUENCY'
            else 'HEIGHT BALANCED'
       end
from sys.obj$ o, sys."_HIST_HEAD_DEC" h, tsp$ tsp, user$ u
where o.obj# = tsp.obj# and tsp.obj# = h.obj#(+)
  and tsp.intcol# = h.intcol#(+)
  and o.type# = 34 /* TABLE SUBPARTITION */
  and o.owner# = u.user#
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and (o.owner# = userenv('SCHEMAID')
        or tsp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
;
--------------------------------------------------------
--  DDL for View ALL_SUBPART_HISTOGRAMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUBPART_HISTOGRAMS" ("OWNER", "TABLE_NAME", "SUBPARTITION_NAME", "COLUMN_NAME", "BUCKET_NUMBER", "ENDPOINT_VALUE", "ENDPOINT_ACTUAL_VALUE", "ENDPOINT_ACTUAL_VALUE_RAW", "ENDPOINT_REPEAT_COUNT") AS 
  select u.name,
       o.name, o.subname,
       tsp.cname,
       h.bucket,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.endpoint
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then case when h.epvalue is not null then epvalue
                 else dbms_stats.conv_raw(h.epvalue_raw, tsp.type#) end
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.epvalue_raw
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.ep_repeat_count
            else null
       end
from sys.obj$ o, sys."_HISTGRM_DEC" h, sys.user$ u, tsp$ tsp
where o.obj# = tsp.obj# and tsp.obj# = h.obj#
  and tsp.intcol# = h.intcol#
  and o.type# = 34 /* TABLE SUBPARTITION */
  and o.owner# = u.user#
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and (o.owner# = userenv('SCHEMAID')
        or
        tsp.bo# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
union
select u.name,
       o.name, o.subname,
       tsp.cname,
       0,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.minimum
            else null
       end,
       null,
       null,
       0
from sys.obj$ o, sys."_HIST_HEAD_DEC" h, sys.user$ u, tsp$ tsp
where o.obj# = tsp.obj# and tsp.obj# = h.obj#
  and tsp.intcol# = h.intcol#
  and o.type# = 34 /* TABLE SUBPARTITION */
  and h.row_cnt = 0 and h.distcnt > 0
  and o.owner# = u.user#
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and (o.owner# = userenv('SCHEMAID')
        or
        tsp.bo# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
union
select u.name,
       o.name, o.subname,
       tsp.cname,
       1,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.maximum
            else null
       end,
       null,
       null,
       0
from sys.obj$ o, sys."_HIST_HEAD_DEC" h, sys.user$ u, tsp$ tsp
where o.obj# = tsp.obj# and tsp.obj# = h.obj#
  and tsp.intcol# = h.intcol#
  and o.type# = 34 /* TABLE SUBPARTITION */
  and h.row_cnt = 0 and h.distcnt > 0
  and o.owner# = u.user#
  and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
  and (o.owner# = userenv('SCHEMAID')
        or
        tsp.bo# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
;
--------------------------------------------------------
--  DDL for View ALL_SUBPARTITION_TEMPLATES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUBPARTITION_TEMPLATES" ("USER_NAME", "TABLE_NAME", "SUBPARTITION_NAME", "SUBPARTITION_POSITION", "TABLESPACE_NAME", "HIGH_BOUND", "COMPRESSION", "INDEXING", "READ_ONLY") AS 
  select u.name, o.name, st.spart_name, st.spart_position + 1, ts.name,
       st.hiboundval,
       decode(bitand(st.flags, 3), 2, 'NO', 1, 'YES', 'NONE'),
       decode(bitand(st.flags, 192), 128, 'OFF', 64, 'ON', 'NONE'),
       decode(bitand(st.flags, 402653184), 268435456, 'NO',
       134217728, 'YES', 'NONE')
from sys.obj$ o, sys.defsubpart$ st, sys.ts$ ts, sys.user$ u
where st.bo# = o.obj# and st.ts# = ts.ts#(+) and o.owner# = u.user# and
      o.subname IS NULL and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID') or
       o.obj# in (select oa.obj# from sys.objauth$ oa
                  where grantee# in ( select kzsrorol from x$kzsro )) or
       exists (select null from v$enabledprivs
               where priv_number in (-45 /* LOCK ANY TABLE */,
                                     -47 /* SELECT ANY TABLE */,
                                     -397/* READ ANY TABLE */,
                                     -48 /* INSERT ANY TABLE */,
                                     -49 /* UPDATE ANY TABLE */,
                                     -50 /* DELETE ANY TABLE */)))
;
--------------------------------------------------------
--  DDL for View ALL_SUBPART_KEY_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUBPART_KEY_COLUMNS" ("OWNER", "NAME", "OBJECT_TYPE", "COLUMN_NAME", "COLUMN_POSITION", "COLLATED_COLUMN_ID") AS 
  select
  OWNER, NAME, OBJECT_TYPE, COLUMN_NAME, COLUMN_POSITION, COLLATED_COLUMN_ID
from all_subpart_key_columns_v$
;
--------------------------------------------------------
--  DDL for View ALL_SUBPART_KEY_COLUMNS_V$
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUBPART_KEY_COLUMNS_V$" ("OWNER", "NAME", "OBJECT_TYPE", "COLUMN_NAME", "COLUMN_POSITION", "COLLATED_COLUMN_ID") AS 
  select u.name, o.name, 'TABLE',
  decode(bitand(c.property, 1), 1, a.name, c.name), spc.pos#,
  c.collintcol#
from   obj$ o, subpartcol$ spc, col$ c, user$ u, attrcol$ a
where  spc.obj# = o.obj# and spc.obj# = c.obj#
       and c.intcol# = spc.intcol#
       and u.user# = o.owner# and
       c.obj# = a.obj#(+) and c.intcol# = a.intcol#(+) and
       o.subname IS NULL and
       o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID')
       or spc.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
union
select u.name, o.name, 'INDEX',
  decode(bitand(c.property, 1), 1, a.name, c.name), spc.pos#,
  c.collintcol#
from   obj$ o, subpartcol$ spc, col$ c, user$ u, ind$ i, attrcol$ a
where spc.obj# = i.obj# and i.obj# = o.obj# and i.bo# = c.obj#
      and c.intcol# = spc.intcol#
      and u.user# = o.owner# and
      c.obj# = a.obj#(+) and c.intcol# = a.intcol#(+) and
      o.subname IS NULL and
      o.namespace = 4 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID')
       or i.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
  
;
--------------------------------------------------------
--  DDL for View ALL_SUMDELTA
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUMDELTA" ("TABLEOBJ#", "PARTITIONOBJ#", "DMLOPERATION", "SCN", "TIMESTAMP", "LOWROWID", "HIGHROWID", "SEQUENCE", "XID") AS 
  select s.TABLEOBJ#, s.PARTITIONOBJ#, s.DMLOPERATION, s.SCN,
          s.TIMESTAMP, s.LOWROWID, s.HIGHROWID, s.SEQUENCE, s.XID
from  sys.obj$ o, sys.sumdelta$ s
where o.type# = 2
  and s.tableobj# = o.obj#
  and (o.owner# = userenv('SCHEMAID')
    or o.obj# in
      (select oa.obj#
         from sys.objauth$ oa
         where grantee# in ( select kzsrorol from x$kzsro)
      )
    or /* user has system privileges */
      exists (select null from v$enabledprivs
        where priv_number in (-45 /* LOCK ANY TABLE */,
                              -47 /* SELECT ANY TABLE */,
                              -397/* READ ANY TABLE */,
                              -48 /* INSERT ANY TABLE */,
                              -49 /* UPDATE ANY TABLE */,
                              -50 /* DELETE ANY TABLE */)
              )
      );

   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."TABLEOBJ#" IS 'Object number of the table';
   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."PARTITIONOBJ#" IS 'Object number of table partitions (if the table is partitioned)';
   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."DMLOPERATION" IS 'Type of DML operation applied to the table';
   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."SCN" IS 'SCN when the bulk DML occurred';
   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."TIMESTAMP" IS 'Timestamp of log entry';
   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."LOWROWID" IS 'The start ROWID in the loaded rowid range';
   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."HIGHROWID" IS 'The end ROWID in the loaded rowid range';
   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."SEQUENCE" IS 'The sequence# of the direct load';
   COMMENT ON COLUMN "SYS"."ALL_SUMDELTA"."XID" IS 'The transaction ID of the direct load';
   COMMENT ON TABLE "SYS"."ALL_SUMDELTA"  IS 'Direct path load entries accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SUMMAP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUMMAP" ("XID", "COMMIT_SCN") AS 
  select XID, COMMIT_SCN from sys.snap_xcmt$;

   COMMENT ON COLUMN "SYS"."ALL_SUMMAP"."XID" IS 'The ID of a transaction';
   COMMENT ON COLUMN "SYS"."ALL_SUMMAP"."COMMIT_SCN" IS 'The commit SCN of a transaction';
   COMMENT ON TABLE "SYS"."ALL_SUMMAP"  IS 'mapping entries of transaction ID and commit SCN accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SUMMARIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUMMARIES" ("OWNER", "SUMMARY_NAME", "CONTAINER_OWNER", "CONTAINER_NAME", "LAST_REFRESH_SCN", "LAST_REFRESH_DATE", "REFRESH_METHOD", "SUMMARY", "FULLREFRESHTIM", "INCREFRESHTIM", "CONTAINS_VIEWS", "UNUSABLE", "RESTRICTED_SYNTAX", "INC_REFRESHABLE", "KNOWN_STALE", "QUERY_LEN", "QUERY") AS 
  select u.name, o.name, u.name, s.containernam,
       s.lastrefreshscn, s.lastrefreshdate,
       decode (s.refreshmode, 0, 'NONE', 1, 'ANY', 2, 'INCREMENTAL', 3,'FULL'),
       decode(bitand(s.pflags, 25165824), 25165824, 'N', 'Y'),
       s.fullrefreshtim, s.increfreshtim,
       decode(bitand(s.pflags, 48), 0, 'N', 'Y'),
       decode(bitand(s.mflags, 64), 0, 'N', 'Y'), /* QSMQSUM_UNUSABLE */
       decode(bitand(s.pflags, 1294319), 0, 'Y', 'N'),
       decode(bitand((select n.flag2 from sys.snap$ n
                      where n.vname=s.containernam and n.sowner=u.name), 67108864),
                     67108864,  /* primary CUBE mv? */
                     decode(bitand((select n2.flag from sys.snap$ n2
                            where n2.parent_sowner=u.name and n2.parent_vname=s.containernam), 256),
                            256, 'N', 'Y'), /* Its child mv's properties determin INC_REFRESHABLE */
                     /* Bug 2070729: change mask value from 236879743 to
                      * 236617599 (excludes flag QSMG_SUM_DETAIL_IS_SNAPSHOT).
                      * Same chang applies to the INC_REFRESHABLE
                      * column in other views.
                      */
                     decode(bitand(s.pflags, 236617599), 0, 'Y', 'N')),
       decode(bitand(s.mflags, 1), 0, 'N', 'Y'), /* QSMQSUM_KNOWNSTL */
       s.sumtextlen,s.sumtext
from sys.user$ u, sys.sum$ s, sys.obj$ o
where o.owner# = u.user#
  and o.obj# = s.obj#
  and bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."OWNER" IS 'Owner of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."SUMMARY_NAME" IS 'Name of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."CONTAINER_OWNER" IS 'Owner of the container table';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."CONTAINER_NAME" IS 'Name of the container table for this summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."LAST_REFRESH_SCN" IS 'The SCN of the last transaction to refresh the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."LAST_REFRESH_DATE" IS 'The date of the last refresh of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."REFRESH_METHOD" IS 'User declared method of refresh for the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."SUMMARY" IS 'Indicates the presence of either aggregation or a GROUP BY';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."FULLREFRESHTIM" IS 'The time that it took to fully refresh the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."INCREFRESHTIM" IS 'The time that it took to incrementally refresh the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."CONTAINS_VIEWS" IS 'This summary contains views in the FROM clause';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."UNUSABLE" IS 'This summary is unusable, the build was deferred';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."RESTRICTED_SYNTAX" IS 'This summary contains restrictive syntax';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."INC_REFRESHABLE" IS 'This summary is not restricted from being incrementally refreshed';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARIES"."KNOWN_STALE" IS 'This summary is directly stale';
   COMMENT ON TABLE "SYS"."ALL_SUMMARIES"  IS 'Description of the summaries accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_SUMMARY_AGGREGATES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUMMARY_AGGREGATES" ("OWNER", "SUMMARY_NAME", "POSITION_IN_SELECT", "CONTAINER_COLUMN", "AGG_FUNCTION", "DISTINCTFLAG", "MEASURE") AS 
  select u.name, o.name, sa.sumcolpos#, c.name,
       decode(sa.aggfunction, 15, 'AVG', 16, 'SUM', 17, 'COUNT',
                              18, 'MIN', 19, 'MAX',
                              97, 'VARIANCE', 98, 'STDDEV',
                              440, 'USER'),
       decode(sa.flags, 0, 'N', 'Y'),
       sa.aggtext
from sys.sumagg$ sa, sys.obj$ o, sys.user$ u, sys.sum$ s, sys.col$ c
where sa.sumobj# = o.obj#
  AND o.owner# = u.user#
  AND sa.sumobj# = s.obj#
  AND c.obj# = s.containerobj#
  AND c.col# = sa.containercol#
  AND (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
  AND bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */;

   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_AGGREGATES"."OWNER" IS 'Owner of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_AGGREGATES"."SUMMARY_NAME" IS 'Name of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_AGGREGATES"."POSITION_IN_SELECT" IS 'Position of this aggregated measure with the SELECT list';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_AGGREGATES"."CONTAINER_COLUMN" IS 'Name of this column in the container table';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_AGGREGATES"."AGG_FUNCTION" IS 'Name of the aggregation function, one of the following:
COUNT, SUM, MIN, MAX, AVG, VARIANCE, STDDEV';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_AGGREGATES"."DISTINCTFLAG" IS 'Set to Y is this is a DISTINCT aggregation';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_AGGREGATES"."MEASURE" IS 'The SQL text of the measure, excluding the aggregation function'
;
--------------------------------------------------------
--  DDL for View ALL_SUMMARY_DETAIL_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUMMARY_DETAIL_TABLES" ("OWNER", "SUMMARY_NAME", "DETAIL_OWNER", "DETAIL_RELATION", "DETAIL_TYPE", "DETAIL_ALIAS") AS 
  select u.name, o.name, du.name,  do.name,
       decode (sd.detailobjtype, 1, 'TABLE', 2, 'VIEW',
                                3, 'SNAPSHOT', 4, 'CONTAINER', 'UNDEFINED'),
       sd.detailalias
from sys.user$ u, sys.sumdetail$ sd, sys.obj$ o, sys.obj$ do,
sys.user$ du, sys.sum$ s
where o.owner# = u.user#
  and o.obj# = sd.sumobj#
  and do.obj# = sd.detailobj#
  and do.owner# = du.user#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
  and s.obj# = sd.sumobj#
  and bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */
  and bitand(sd.detaileut, 2147483648) = 0  /* NOT 2nd cube mv pct metadata */;

   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_DETAIL_TABLES"."OWNER" IS 'Owner of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_DETAIL_TABLES"."SUMMARY_NAME" IS 'Name of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_DETAIL_TABLES"."DETAIL_OWNER" IS 'Owner of the detail relation';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_DETAIL_TABLES"."DETAIL_RELATION" IS 'Name of the summary detail table';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_DETAIL_TABLES"."DETAIL_TYPE" IS 'Type of summary detail table type';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_DETAIL_TABLES"."DETAIL_ALIAS" IS 'Alias of the detail relation if used'
;
--------------------------------------------------------
--  DDL for View ALL_SUMMARY_JOINS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUMMARY_JOINS" ("OWNER", "SUMMARY_NAME", "DETAILOBJ1_OWNER", "DETAILOBJ1_RELATION", "DETAILOBJ1_COLUMN", "OPERATOR", "DETAILOBJ2_OWNER", "DETAILOBJ2_RELATION", "DETAILOBJ2_COLUMN") AS 
  select u.name, o.name,
       u1.name, o1.name, c1.name, '=',
       u2.name, o2.name, c2.name
from sys.sumjoin$ sj, sys.obj$ o, sys.user$ u,
     sys.obj$ o1, sys.user$ u1, sys.col$ c1,
     sys.obj$ o2, sys.user$ u2, sys.col$ c2,
     sys.sum$ s
where sj.sumobj# = o.obj#
  AND o.owner# = u.user#
  AND sj.tab1obj# = o1.obj#
  AND o1.owner# = u1.user#
  AND sj.tab1obj# = c1.obj#
  AND sj.tab1col# = c1.intcol#
  AND sj.tab2obj# = o2.obj#
  AND o2.owner# = u2.user#
  AND sj.tab2obj# = c2.obj#
  AND sj.tab2col# = c2.intcol#
  AND (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
  AND s.obj# = sj.sumobj#
  AND bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */;

   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."OWNER" IS 'Owner of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."SUMMARY_NAME" IS 'Name of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."DETAILOBJ1_OWNER" IS 'Owner of the 1st detail object';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."DETAILOBJ1_RELATION" IS 'Name of the 1st detail object';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."DETAILOBJ1_COLUMN" IS 'Name of the 1st detail object column';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."OPERATOR" IS 'Name of the join operator. Currently only = is defined';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."DETAILOBJ2_OWNER" IS 'Owner of the 2nd detail object';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."DETAILOBJ2_RELATION" IS 'Name of the 2nd detail object';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_JOINS"."DETAILOBJ2_COLUMN" IS 'Name of the 2nd detail object column'
;
--------------------------------------------------------
--  DDL for View ALL_SUMMARY_KEYS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SUMMARY_KEYS" ("OWNER", "SUMMARY_NAME", "POSITION_IN_SELECT", "CONTAINER_COLUMN", "DETAILOBJ_OWNER", "DETAILOBJ_NAME", "DETAILOBJ_ALIAS", "DETAILOBJ_TYPE", "DETAILOBJ_COLUMN") AS 
  select u1.name, o1.name, sk.sumcolpos#, c1.name,
       u2.name, o2.name, sd.detailalias,
       decode(sk.detailobjtype, 1, 'TABLE', 2, 'VIEW'), c2.name
from sys.sumkey$ sk, sys.obj$ o1, sys.user$ u1, sys.col$ c1, sys.sum$ s,
     sys.sumdetail$ sd, sys.obj$ o2, sys.user$ u2, sys.col$ c2
where sk.sumobj# = o1.obj#
  AND o1.owner# = u1.user#
  AND sk.sumobj# = s.obj#
  AND s.containerobj# = c1.obj#
  AND c1.col# = sk.containercol#
  AND sk.detailobj# = o2.obj#
  AND o2.owner# = u2.user#
  AND sk.sumobj# = sd.sumobj#
  AND sk.detailobj# = sd.detailobj#
  AND sk.detailobj# = c2.obj#
  AND sk.detailcol# = c2.intcol#
  AND sk.instance# = sd.instance#
  AND (o1.owner# = userenv('SCHEMAID')
       or o1.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege(o1.owner#, o1.type#) = 1
      )
  AND bitand(s.xpflags, 8388608) = 0 /* NOT REWRITE EQUIVALENCE SUMMARY */
  AND bitand(sk.detailcolfunction, 2147483648) = 0  /* NOT 2nd cube mv pct metadata */;

   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."OWNER" IS 'Owner of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."SUMMARY_NAME" IS 'Name of the summary';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."POSITION_IN_SELECT" IS 'Position of this key within the SELECT list';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."CONTAINER_COLUMN" IS 'Name of the column in the container table';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."DETAILOBJ_OWNER" IS 'Owner of the detail object';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."DETAILOBJ_NAME" IS 'Name of the detail object';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."DETAILOBJ_ALIAS" IS 'Alias of the detail object';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."DETAILOBJ_TYPE" IS 'Type of the detail object: VIEW or TABLE';
   COMMENT ON COLUMN "SYS"."ALL_SUMMARY_KEYS"."DETAILOBJ_COLUMN" IS 'Name of the detail object column'
;
--------------------------------------------------------
--  DDL for View ALL_SYNC_CAPTURE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SYNC_CAPTURE" ("CAPTURE_NAME", "QUEUE_NAME", "QUEUE_OWNER", "RULE_SET_NAME", "RULE_SET_OWNER", "CAPTURE_USER") AS 
  select c."CAPTURE_NAME",c."QUEUE_NAME",c."QUEUE_OWNER",c."RULE_SET_NAME",c."RULE_SET_OWNER",c."CAPTURE_USER"
  from dba_sync_capture c, all_queues q
 where c.queue_name = q.name
   and c.queue_owner = q.owner
   and ((c.rule_set_owner is null and c.rule_set_name is null) or
        ((c.rule_set_owner, c.rule_set_name) in
          (select r.rule_set_owner, r.rule_set_name
             from all_rule_sets r)));

   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE"."CAPTURE_NAME" IS 'Name of the capture process';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE"."QUEUE_NAME" IS 'Name of queue used for holding captured changes';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE"."QUEUE_OWNER" IS 'Owner of the queue used for holding captured changes';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE"."RULE_SET_NAME" IS 'Rule set used by capture process for filtering';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE"."CAPTURE_USER" IS 'Current user who is enqueuing captured messages';
   COMMENT ON TABLE "SYS"."ALL_SYNC_CAPTURE"  IS 'Details about each sync capture process that stores the captured changes in a queue visible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_SYNC_CAPTURE_PREPARED_TABS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SYNC_CAPTURE_PREPARED_TABS" ("TABLE_OWNER", "TABLE_NAME", "SCN", "TIMESTAMP") AS 
  select pt.table_owner, pt.table_name, pt.scn, pt.timestamp
  from all_tables at, dba_sync_capture_prepared_tabs pt
  where pt.table_name = at.table_name
    and pt.table_owner = at.owner;

   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE_PREPARED_TABS"."TABLE_OWNER" IS 'Owner of the table prepared for synchronous capture instantiation';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE_PREPARED_TABS"."TABLE_NAME" IS 'Name of the table prepared for synchronous capture instantiation';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE_PREPARED_TABS"."SCN" IS 'SCN from which changes can be captured';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE_PREPARED_TABS"."TIMESTAMP" IS 'Time at which the table was ready to be instantiated';
   COMMENT ON TABLE "SYS"."ALL_SYNC_CAPTURE_PREPARED_TABS"  IS 'All tables prepared for synchronous capture instantiation'
;
--------------------------------------------------------
--  DDL for View ALL_SYNC_CAPTURE_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SYNC_CAPTURE_TABLES" ("TABLE_OWNER", "TABLE_NAME", "ENABLED") AS 
  SELECT distinct sr.table_owner, sr.table_name,
   decode(bitand(t.trigflag, 32), 32, 'YES', 'NO')
 FROM all_streams_table_rules sr, obj$ tob, user$ tu, tab$ t
 WHERE streams_type = 'SYNC_CAPTURE'
   AND sr.table_owner = tu.name AND sr.table_name = tob.name
   AND tob.owner# = tu.user# AND tob.obj# = t.obj#;

   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE_TABLES"."TABLE_OWNER" IS 'Owner of the synchronous capture table';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE_TABLES"."TABLE_NAME" IS 'Name of the synchronous capture table';
   COMMENT ON COLUMN "SYS"."ALL_SYNC_CAPTURE_TABLES"."ENABLED" IS 'Is synchronous Streams capture enabled for this table?';
   COMMENT ON TABLE "SYS"."ALL_SYNC_CAPTURE_TABLES"  IS 'All tables that are captured by synchronous streams captures.'
;
--------------------------------------------------------
--  DDL for View ALL_SYNONYMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_SYNONYMS" ("OWNER", "SYNONYM_NAME", "TABLE_OWNER", "TABLE_NAME", "DB_LINK", "ORIGIN_CON_ID") AS 
  select OWNER, SYNONYM_NAME, TABLE_OWNER, TABLE_NAME, DB_LINK,
       ORIGIN_CON_ID
from INT$DBA_SYNONYMS
where (
       OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OWNER = 'PUBLIC'
       or /* local object, and user has system privileges */
         (DB_LINK is null
          and
          ora_check_sys_privilege ( ownerid, object_type#) = 1
         )
       or /* user has any privs on base object in local database */
        exists
        (select null
         from sys.objauth$ ba, sys."_CURRENT_EDITION_OBJ" bo, sys.user$ bu
         where DB_LINK is null
           and bu.name = TABLE_OWNER
           and bo.name = TABLE_NAME
           and bu.user# = bo.owner#
           and ba.obj# = bo.obj#
           and (   ba.grantee# in (select kzsrorol from x$kzsro)
                or ba.grantor# = USERENV('SCHEMAID')
               )
        )
      )
union
select st.SYN_OWNER, st.SYN_SYNONYM_NAME, st.SYN_TABLE_OWNER,
       st.SYN_TABLE_NAME, st.SYN_DB_LINK, st.ORIGIN_CON_ID
from sys."_ALL_SYNONYMS_TREE" st;

   COMMENT ON COLUMN "SYS"."ALL_SYNONYMS"."OWNER" IS 'Owner of the synonym';
   COMMENT ON COLUMN "SYS"."ALL_SYNONYMS"."SYNONYM_NAME" IS 'Name of the synonym';
   COMMENT ON COLUMN "SYS"."ALL_SYNONYMS"."TABLE_OWNER" IS 'Owner of the object referenced by the synonym';
   COMMENT ON COLUMN "SYS"."ALL_SYNONYMS"."TABLE_NAME" IS 'Name of the object referenced by the synonym';
   COMMENT ON COLUMN "SYS"."ALL_SYNONYMS"."DB_LINK" IS 'Name of the database link referenced in a remote synonym';
   COMMENT ON COLUMN "SYS"."ALL_SYNONYMS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_SYNONYMS"  IS 'All synonyms for base objects accessible to the user and session'
;
--------------------------------------------------------
--  DDL for View _ALL_SYNONYMS_FOR_AUTH_OBJECTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_SYNONYMS_FOR_AUTH_OBJECTS" ("OWNER", "SYNONYM_NAME", "BASE_OBJ_OWNER", "BASE_OBJ_NAME", "ORIGIN_CON_ID") AS 
  select OWNER, SYNONYM_NAME, BASE_OBJ_OWNER, BASE_OBJ_NAME, ORIGIN_CON_ID
from "_INT$_ALL_SYNONYMS_FOR_AO"
where
      ora_check_sys_privilege ( ownerid, object_type#) = 1
   or
      exists
        (select null
         from sys.objauth$ ba, sys."_CURRENT_EDITION_OBJ" bo, sys.user$ bu
         where bu.name = BASE_OBJ_OWNER
           and bo.name = BASE_OBJ_NAME
           and bu.user# = bo.owner#
           and ba.obj# = bo.obj#
           and (   ba.grantee# in (select kzsrorol from x$kzsro)
                or ba.grantor# = USERENV('SCHEMAID')
               )
        )
;
--------------------------------------------------------
--  DDL for View _ALL_SYNONYMS_FOR_SYNONYMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_SYNONYMS_FOR_SYNONYMS" ("SYN_OWNER", "SYN_SYNONYM_NAME", "SYN_TABLE_OWNER", "SYN_TABLE_NAME", "SYN_DB_LINK", "ORIGIN_CON_ID") AS 
  select SYN_OWNER, SYN_SYNONYM_NAME, SYN_TABLE_OWNER,
       SYN_TABLE_NAME, SYN_DB_LINK, ORIGIN_CON_ID
from   "_INT$_ALL_SYNONYMS_FOR_SYN"
;
--------------------------------------------------------
--  DDL for View _ALL_SYNONYMS_TREE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."_ALL_SYNONYMS_TREE" ("SYN_OWNER", "SYN_SYNONYM_NAME", "SYN_TABLE_OWNER", "SYN_TABLE_NAME", "SYN_DB_LINK", "ORIGIN_CON_ID") AS 
  select s.syn_owner, s.syn_synonym_name, s.syn_table_owner,
       s.syn_table_name, s.syn_db_link, s.origin_con_id
from sys."_ALL_SYNONYMS_FOR_SYNONYMS" s
/* user has any privs on ultimate base object */
start with exists (
  select /*+ NO_PUSH_SUBQ */ null
  from sys."_ALL_SYNONYMS_FOR_AUTH_OBJECTS" sa
  where s.syn_table_owner = sa.owner
    and s.syn_table_name = sa.synonym_name
  )
connect by nocycle prior s.syn_owner = s.syn_table_owner and
                   prior s.syn_synonym_name = s.syn_table_name
;
--------------------------------------------------------
--  DDL for View ALL_TAB_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_COLS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "DATA_TYPE", "DATA_TYPE_MOD", "DATA_TYPE_OWNER", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "NULLABLE", "COLUMN_ID", "DEFAULT_LENGTH", "DATA_DEFAULT", "NUM_DISTINCT", "LOW_VALUE", "HIGH_VALUE", "DENSITY", "NUM_NULLS", "NUM_BUCKETS", "LAST_ANALYZED", "SAMPLE_SIZE", "CHARACTER_SET_NAME", "CHAR_COL_DECL_LENGTH", "GLOBAL_STATS", "USER_STATS", "AVG_COL_LEN", "CHAR_LENGTH", "CHAR_USED", "V80_FMT_IMAGE", "DATA_UPGRADED", "HIDDEN_COLUMN", "VIRTUAL_COLUMN", "SEGMENT_COLUMN_ID", "INTERNAL_COLUMN_ID", "HISTOGRAM", "QUALIFIED_COL_NAME", "USER_GENERATED", "DEFAULT_ON_NULL", "IDENTITY_COLUMN", "EVALUATION_EDITION", "UNUSABLE_BEFORE", "UNUSABLE_BEGINNING", "COLLATION", "COLLATED_COLUMN_ID") AS 
  select
     OWNER, TABLE_NAME,
     COLUMN_NAME, DATA_TYPE, DATA_TYPE_MOD, DATA_TYPE_OWNER,
     DATA_LENGTH, DATA_PRECISION, DATA_SCALE, NULLABLE, COLUMN_ID,
     DEFAULT_LENGTH, DATA_DEFAULT, NUM_DISTINCT, LOW_VALUE, HIGH_VALUE,
     DENSITY, NUM_NULLS, NUM_BUCKETS, LAST_ANALYZED, SAMPLE_SIZE,
     CHARACTER_SET_NAME, CHAR_COL_DECL_LENGTH,
     GLOBAL_STATS,
     USER_STATS, AVG_COL_LEN, CHAR_LENGTH, CHAR_USED,
     V80_FMT_IMAGE, DATA_UPGRADED, HIDDEN_COLUMN, VIRTUAL_COLUMN,
     SEGMENT_COLUMN_ID, INTERNAL_COLUMN_ID, HISTOGRAM, QUALIFIED_COL_NAME,
     USER_GENERATED, DEFAULT_ON_NULL, IDENTITY_COLUMN,
     EVALUATION_EDITION, UNUSABLE_BEFORE, UNUSABLE_BEGINNING,
     COLLATION, COLLATED_COLUMN_ID
from all_tab_cols_v$;

   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."TABLE_NAME" IS 'Table, view or cluster name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."COLUMN_NAME" IS 'Column name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DATA_TYPE" IS 'Datatype of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DATA_TYPE_MOD" IS 'Datatype modifier of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DATA_TYPE_OWNER" IS 'Owner of the datatype of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DATA_LENGTH" IS 'Length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DATA_PRECISION" IS 'Length: decimal digits (NUMBER) or binary digits (FLOAT)';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DATA_SCALE" IS 'Digits to right of decimal point in a number';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."NULLABLE" IS 'Does column allow NULL values?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."COLUMN_ID" IS 'Sequence number of the column as created';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DEFAULT_LENGTH" IS 'Length of default value for the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DATA_DEFAULT" IS 'Default value for the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."NUM_DISTINCT" IS 'The number of distinct values in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."LOW_VALUE" IS 'The low value in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."HIGH_VALUE" IS 'The high value in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DENSITY" IS 'The density of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."NUM_NULLS" IS 'The number of nulls in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."NUM_BUCKETS" IS 'The number of buckets in histogram for the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."LAST_ANALYZED" IS 'The date of the most recent time this column was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."SAMPLE_SIZE" IS 'The sample size used in analyzing this column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."CHARACTER_SET_NAME" IS 'Character set name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."CHAR_COL_DECL_LENGTH" IS 'Declaration length of character type column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."AVG_COL_LEN" IS 'The average length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."CHAR_LENGTH" IS 'The maximum length of the column in characters';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."CHAR_USED" IS 'C if maximum length is specified in characters, B if in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."V80_FMT_IMAGE" IS 'Is column data in 8.0 image format?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DATA_UPGRADED" IS 'Has column data been upgraded to the latest type version format?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."HIDDEN_COLUMN" IS 'Is this a hidden column?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."VIRTUAL_COLUMN" IS 'Is this a virtual column?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."SEGMENT_COLUMN_ID" IS 'Sequence number of the column in the segment';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."INTERNAL_COLUMN_ID" IS 'Internal sequence number of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."QUALIFIED_COL_NAME" IS 'Qualified column name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."USER_GENERATED" IS 'Is this an user-generated column?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."DEFAULT_ON_NULL" IS 'Is this a default on null column?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."IDENTITY_COLUMN" IS 'Is this an identity column?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."EVALUATION_EDITION" IS 'Name of the evaluation edition assigned to the column expression';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."UNUSABLE_BEFORE" IS 'Name of the oldest edition in which the column is usable';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."UNUSABLE_BEGINNING" IS 'Name of the oldest edition in which the column becomes perpetually unusable';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."COLLATION" IS 'Collation name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLS"."COLLATED_COLUMN_ID" IS 'Reference to the actual collated column''s internal sequence number';
   COMMENT ON TABLE "SYS"."ALL_TAB_COLS"  IS 'Columns of user''s tables, views and clusters'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_COL_STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_COL_STATISTICS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "NUM_DISTINCT", "LOW_VALUE", "HIGH_VALUE", "DENSITY", "NUM_NULLS", "NUM_BUCKETS", "LAST_ANALYZED", "SAMPLE_SIZE", "GLOBAL_STATS", "USER_STATS", "NOTES", "AVG_COL_LEN", "HISTOGRAM", "SCOPE") AS 
  select owner, table_name, column_name, num_distinct, low_value, high_value,
       density, num_nulls, num_buckets, last_analyzed, sample_size,
       global_stats,
       user_stats,
       notes || case when (hh.analyzetime is not null) then
                  decode(hh.spare1, null, ' ADAPTIVE_SAMPLING ',
                         ' HYPERLOGLOG ')
                else
                  null
                end,
       avg_col_len, HISTOGRAM, 'SHARED'
from all_tab_cols_v$ v, sys.wri$_optstat_synopsis_head$  hh
where last_analyzed is not null
  and v.column_int_id = hh.intcol#(+) and v.table_id = hh.bo#(+)
  and hh.group#(+) = 0
union all
select /* fixed table column stats */
       'SYS', ft.kqftanam, c.kqfconam,
       h.distcnt, h.lowval, h.hival,
       h.density, h.null_cnt,
       case when nvl(h.distcnt,0) = 0 then h.distcnt
            when h.row_cnt = 0 then 1
	    when exists(select 1 from sys."_HISTGRM_DEC" hg
                        where c.kqfcotob = hg.obj# and c.kqfcocno = hg.intcol#
                          and hg.ep_repeat_count > 0 and rownum < 2) then h.row_cnt
             when (bitand(h.spare2, 32) > 0 or h.bucket_cnt > 2049 or
                   (h.bucket_cnt >= h.distcnt and h.density*h.bucket_cnt < 1))
                then h.row_cnt
            else h.bucket_cnt
       end,
       h.timestamp#, h.sample_size,
       decode(bitand(h.spare2, 2), 2, 'YES', 'NO'),
       decode(bitand(h.spare2, 1), 1, 'YES', 'NO'),
       null,  -- notes
       h.avgcln,
       case when nvl(h.row_cnt,0) = 0 then 'NONE'
            when exists(select 1 from sys."_HISTGRM_DEC" hg
                        where c.kqfcotob = hg.obj# and c.kqfcocno = hg.intcol#
                          and hg.ep_repeat_count > 0 and rownum < 2) then 'HYBRID'
             when (bitand(h.spare2, 32) > 0 or h.bucket_cnt > 2049 or
                   (h.bucket_cnt >= h.distcnt and h.density*h.bucket_cnt < 1))
                then 'FREQUENCY'
            else 'HEIGHT BALANCED'
       end,
       'SHARED'
from   sys.x$kqfta ft, sys.fixed_obj$ fobj,
         sys.x$kqfco c, sys."_HIST_HEAD_DEC" h
where
       ft.kqftaobj = fobj. obj#
       and c.kqfcotob = ft.kqftaobj
       and h.obj# = ft.kqftaobj
       and h.intcol# = c.kqfcocno
       /*
        * if fobj and st are not in sync (happens when db open read only
        * after upgrade), do not display stats.
        */
       and ft.kqftaver =
             fobj.timestamp - to_date('01-01-1991', 'DD-MM-YYYY')
       and h.timestamp# is not null
       and (userenv('SCHEMAID') = 0  /* SYS */
            or /* user has system privileges */
            exists (select null from v$enabledprivs
                    where priv_number in (-237 /* SELECT ANY DICTIONARY */)
                   )
           )
UNION ALL
select /* session private stats for GTT */
       u.name                  owner,
       o.name                  table_name,
       c.name                  column_name,
       h.distcnt_kxttst_cs     num_distinct,
       h.lowval_kxttst_cs      low_value,
       h.hival_kxttst_cs       high_value,
       h.density_kxttst_cs     density,
       h.null_cnt_kxttst_cs    num_nulls,
       case when nvl(h.distcnt_kxttst_cs,0) = 0 then h.distcnt_kxttst_cs
            when h.row_cnt_kxttst_cs = 0 then 1
            when exists(select 1 from sys.x$kxttstehs hg
                        where c.obj# = hg.obj#_kxttst_hs
                          and c.intcol# = hg.intcol#_kxttst_hs
                          and hg.ep_repeat_count_kxttst_hs > 0
                          and rownum < 2)
                 then h.row_cnt_kxttst_cs
            when bitand(h.spare2_kxttst_cs, 64) > 0
                then h.row_cnt_kxttst_cs
	    when (bitand(h.spare2_kxttst_cs, 32) > 0 or
                  h.bucket_cnt_kxttst_cs > 2049 or
                  (h.bucket_cnt_kxttst_cs > h.distcnt_kxttst_cs
                   and h.row_cnt_kxttst_cs = h.distcnt_kxttst_cs
                   and h.density_kxttst_cs*h.bucket_cnt_kxttst_cs < 1))
                then h.row_cnt_kxttst_cs
            else h.bucket_cnt_kxttst_cs
       end num_buckets,
       h.timestamp#_kxttst_cs  last_analyzed,
       h.sample_size_kxttst_cs sample_size,
       decode(bitand(h.spare2_kxttst_cs, 2), 2, 'YES', 'NO') global_stats,
       decode(bitand(h.spare2_kxttst_cs, 1), 1, 'YES', 'NO') user_stats,
       null, -- notes
       h.avgcln_kxttst_cs      avg_col_len,
       case when nvl(h.row_cnt_kxttst_cs,0) = 0 then 'NONE'
            when exists(select 1 from sys.x$kxttstehs hg
                        where c.obj# = hg.obj#_kxttst_hs
                          and c.intcol# = hg.intcol#_kxttst_hs
                          and hg.ep_repeat_count_kxttst_hs > 0
                          and rownum < 2) then 'HYBRID'
            when bitand(h.spare2_kxttst_cs, 64) > 0
              then 'TOP-FREQUENCY'
            when (bitand(h.spare2_kxttst_cs, 32) > 0 or
                  h.bucket_cnt_kxttst_cs > 2049 or
                  (h.bucket_cnt_kxttst_cs >= h.distcnt_kxttst_cs
                   and h.density_kxttst_cs*h.bucket_cnt_kxttst_cs < 1))
                then 'FREQUENCY'
            else 'HEIGHT BALANCED'
       end,
       'SESSION'               scope
from x$kxttstecs h, obj$ o, col$ c, user$ u, all_tables t
where h.obj#_kxttst_cs = o.obj# and
      o.owner# = u.user# and
      o.name = t.table_name and
      u.name = t.owner and
      c.obj# = o.obj# and
      h.intcol#_kxttst_cs = c.intcol#;

   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."OWNER" IS 'Table, view or cluster owner';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."TABLE_NAME" IS 'Table, view or cluster name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."COLUMN_NAME" IS 'Column name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."NUM_DISTINCT" IS 'The number of distinct values in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."LOW_VALUE" IS 'The low value in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."HIGH_VALUE" IS 'The high value in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."DENSITY" IS 'The density of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."NUM_NULLS" IS 'The number of nulls in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."NUM_BUCKETS" IS 'The number of buckets in histogram for the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."LAST_ANALYZED" IS 'The date of the most recent time this column was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."SAMPLE_SIZE" IS 'The sample size used in analyzing this column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."NOTES" IS 'Notes regarding special properties of the stats';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."AVG_COL_LEN" IS 'The average length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COL_STATISTICS"."SCOPE" IS 'whether statistics for the object is shared or session';
   COMMENT ON TABLE "SYS"."ALL_TAB_COL_STATISTICS"  IS 'Columns of user''s tables, views and clusters'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_COLS_V$
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_COLS_V$" ("OWNER", "TABLE_NAME", "TABLE_ID", "COLUMN_NAME", "COLUMN_INT_ID", "DATA_TYPE", "DATA_TYPE_MOD", "DATA_TYPE_OWNER", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "NULLABLE", "COLUMN_ID", "DEFAULT_LENGTH", "DATA_DEFAULT", "NUM_DISTINCT", "LOW_VALUE", "HIGH_VALUE", "DENSITY", "NUM_NULLS", "NUM_BUCKETS", "LAST_ANALYZED", "SAMPLE_SIZE", "CHARACTER_SET_NAME", "CHAR_COL_DECL_LENGTH", "GLOBAL_STATS", "USER_STATS", "NOTES", "AVG_COL_LEN", "CHAR_LENGTH", "CHAR_USED", "V80_FMT_IMAGE", "DATA_UPGRADED", "HIDDEN_COLUMN", "VIRTUAL_COLUMN", "SEGMENT_COLUMN_ID", "INTERNAL_COLUMN_ID", "HISTOGRAM", "QUALIFIED_COL_NAME", "USER_GENERATED", "DEFAULT_ON_NULL", "IDENTITY_COLUMN", "EVALUATION_EDITION", "UNUSABLE_BEFORE", "UNUSABLE_BEGINNING", "COLLATION", "COLLATED_COLUMN_ID") AS 
  select u.name, o.name, o.obj#,
       c.name, c.intcol#,
       decode(c.type#, 1, decode(c.charsetform, 2, 'NVARCHAR2', 'VARCHAR2'),
                       2, decode(c.scale, null,
                                 decode(c.precision#, null, 'NUMBER', 'FLOAT'),
                                 'NUMBER'),
                       8, 'LONG',
                       9, decode(c.charsetform, 2, 'NCHAR VARYING', 'VARCHAR'),
                       12, 'DATE',
                       23, 'RAW', 24, 'LONG RAW',
                       58, nvl2(ac.synobj#, (select o.name from obj$ o
                                where o.obj#=ac.synobj#), ot.name),
                       69, 'ROWID',
                       96, decode(c.charsetform, 2, 'NCHAR', 'CHAR'),
                       100, 'BINARY_FLOAT',
                       101, 'BINARY_DOUBLE',
                       105, 'MLSLABEL',
                       106, 'MLSLABEL',
                       111, nvl2(ac.synobj#, (select o.name from obj$ o
                                 where o.obj#=ac.synobj#), ot.name),
                       112, decode(c.charsetform, 2, 'NCLOB', 'CLOB'),
                       113, 'BLOB', 114, 'BFILE', 115, 'CFILE',
                       121, nvl2(ac.synobj#, (select o.name from obj$ o
                                 where o.obj#=ac.synobj#), ot.name),
                       122, nvl2(ac.synobj#, (select o.name from obj$ o
                                 where o.obj#=ac.synobj#), ot.name),
                       123, nvl2(ac.synobj#, (select o.name from obj$ o
                                 where o.obj#=ac.synobj#), ot.name),
                       178, 'TIME(' ||c.scale|| ')',
                       179, 'TIME(' ||c.scale|| ')' || ' WITH TIME ZONE',
                       180, 'TIMESTAMP(' ||c.scale|| ')',
                       181, 'TIMESTAMP(' ||c.scale|| ')' || ' WITH TIME ZONE',
                       231, 'TIMESTAMP(' ||c.scale|| ')' || ' WITH LOCAL TIME ZONE',
                       182, 'INTERVAL YEAR(' ||c.precision#||') TO MONTH',
                       183, 'INTERVAL DAY(' ||c.precision#||') TO SECOND(' ||
                             c.scale || ')',
                       208, 'UROWID',
                       'UNDEFINED'),
       decode(c.type#, 111, 'REF'),
       nvl2(ac.synobj#, (select u.name from "_BASE_USER" u, obj$ o
                         where o.owner#=u.user# and o.obj#=ac.synobj#),
            ut.name),
       c.length, c.precision#, c.scale,
       decode(sign(c.null$),-1,'D', 0, 'Y', 'N'),
       decode(c.col#, 0, to_number(null), c.col#), c.deflength,
       c.default$, h.distcnt,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.lowval
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.hival
            else null
       end,
       h.density, h.null_cnt,
       case when nvl(h.distcnt,0) = 0 then h.distcnt
            -- no histogram
            when h.row_cnt = 0 then 1
            -- hybrid
	    when exists(select 1 from sys.histgrm$ hg
                        where c.obj# = hg.obj# and c.intcol# = hg.intcol#
                          and hg.ep_repeat_count > 0 and rownum < 2) then h.row_cnt
            -- top-freq
            when bitand(h.spare2, 64) > 0
              then h.row_cnt
            -- freq
            when (bitand(h.spare2, 32) > 0 or h.bucket_cnt > 2049 or
                  (h.bucket_cnt >= h.distcnt and h.density*h.bucket_cnt < 1))
                then h.row_cnt
            -- height
            else h.bucket_cnt
       end,
       h.timestamp#, h.sample_size,
       decode(c.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(c.charsetid),
                             4, 'ARG:'||c.charsetid),
       decode(c.charsetid, 0, to_number(NULL),
                           nls_charset_decl_len(c.length, c.charsetid)),
       decode(bitand(h.spare2, 2), 2, 'YES', 'NO'), -- global stats
       decode(bitand(h.spare2, 1), 1, 'YES', 'NO'),
       decode(bitand(h.spare2, 8), 8, 'INCREMENTAL ', '') ||
         decode(bitand(h.spare2, 128), 128, 'HIST_FOR_INCREM_STATS ', '') ||
         decode(bitand(h.spare2, 256), 256, 'HISTOGRAM_ONLY ', '') ||
         decode(bitand(h.spare2, 512), 512, 'STATS_ON_LOAD ', '') ||
         decode(bitand(h.spare2, 2048), 2048, 'HYBRID_GLOBAL_NDV', ''),
       h.avgcln,
       c.spare3,
       decode(c.type#, 1, decode(bitand(c.property, 8388608), 0, 'B', 'C'),
                      96, decode(bitand(c.property, 8388608), 0, 'B', 'C'),
                      null),
       decode(bitand(ac.flags, 128), 128, 'YES', 'NO'),
       decode(o.status, 1, decode(bitand(ac.flags, 256), 256, 'NO', 'YES'),
                        decode(bitand(ac.flags, 2), 2, 'NO',
                               decode(bitand(ac.flags, 4), 4, 'NO',
                                      decode(bitand(ac.flags, 8), 8, 'NO',
                                             'N/A')))),
       decode(c.property, 0, 'NO', decode(bitand(c.property, 32), 32, 'YES',
                                          'NO')),
       decode(c.property, 0, 'NO', decode(bitand(c.property, 8), 8, 'YES',
                                          'NO')),
       decode(c.segcol#, 0, to_number(null), c.segcol#), c.intcol#,
       -- warning! If you update stats related info, make sure to also update
       -- GTT session private stats in cdoptim.sql
       case when nvl(h.row_cnt,0) = 0 then 'NONE'
            when exists(select 1 from sys.histgrm$ hg
                        where c.obj# = hg.obj# and c.intcol# = hg.intcol#
                          and hg.ep_repeat_count > 0 and rownum < 2) then 'HYBRID'
            when bitand(h.spare2, 64) > 0
              then 'TOP-FREQUENCY'
            when (bitand(h.spare2, 32) > 0 or h.bucket_cnt > 2049 or
                  (h.bucket_cnt >= h.distcnt and h.density*h.bucket_cnt < 1))
                then 'FREQUENCY'
            else 'HEIGHT BALANCED'
       end,
       decode(bitand(c.property, 1024), 1024,
              (select decode(bitand(cl.property, 1), 1, rc.name, cl.name)
               from sys.col$ cl, attrcol$ rc where cl.intcol# = c.intcol#-1
               and cl.obj# = c.obj# and c.obj# = rc.obj#(+) and
               cl.intcol# = rc.intcol#(+)),
              decode(bitand(c.property, 1), 0, c.name,
                     (select tc.name from sys.attrcol$ tc
                      where c.obj# = tc.obj# and c.intcol# = tc.intcol#))),
       decode(bitand(c.property, 17179869184), 17179869184, 'YES',
              decode(bitand(c.property, 32), 32, 'NO', 'YES')),
       decode(bitand(c.property, 68719476736), 68719476736, 'YES', 'NO'),
       decode(bitand(c.property, 137438953472 + 274877906944),
                     137438953472, 'YES', 274877906944, 'YES', 'NO'),
  
       case when c.evaledition# is null then null
         else (select name from obj$ where obj# = c.evaledition#) end,
       case when c.unusablebefore# is null then null
         else (select name from obj$ where obj# = c.unusablebefore#) end,
       case when c.unusablebeginning# is null then null
         else (select name from obj$ where obj# = c.unusablebeginning#) end,
         case when (c.type# in (1,8,9,96,112))
           then nls_collation_name(nvl(c.collid, 16382))
           else null end,
         c.collintcol# 
from sys.col$ c, sys."_CURRENT_EDITION_OBJ" o, sys."_HIST_HEAD_DEC" h, sys.user$ u,
     sys.coltype$ ac, sys.obj$ ot, sys."_BASE_USER" ut, sys.tab$ t
where o.obj# = c.obj#
  and o.obj# = t.obj#(+)
  and o.owner# = u.user#
  and c.obj# = h.obj#(+) and c.intcol# = h.intcol#(+)
  and c.obj# = ac.obj#(+) and c.intcol# = ac.intcol#(+)
  and ac.toid = ot.oid$(+)
  and ot.type#(+) = 13
  and ot.owner# = ut.user#(+)
  and bitand(o.flags, 128) = 0
  and (o.type# in (3, 4)                                     /* cluster, view */
       or
       (o.type# = 2     /* tables, excluding iot - overflow and nested tables */
        and
        not exists (select null
                      from sys.tab$ t
                     where t.obj# = o.obj#
                       and (bitand(t.property, 512) = 512 or
                            bitand(t.property, 8192) = 8192 or
                            bitand(t.property, power(2,65)) = power(2,65)))))
  and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
  
;
--------------------------------------------------------
--  DDL for View ALL_TAB_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_COLUMNS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "DATA_TYPE", "DATA_TYPE_MOD", "DATA_TYPE_OWNER", "DATA_LENGTH", "DATA_PRECISION", "DATA_SCALE", "NULLABLE", "COLUMN_ID", "DEFAULT_LENGTH", "DATA_DEFAULT", "NUM_DISTINCT", "LOW_VALUE", "HIGH_VALUE", "DENSITY", "NUM_NULLS", "NUM_BUCKETS", "LAST_ANALYZED", "SAMPLE_SIZE", "CHARACTER_SET_NAME", "CHAR_COL_DECL_LENGTH", "GLOBAL_STATS", "USER_STATS", "AVG_COL_LEN", "CHAR_LENGTH", "CHAR_USED", "V80_FMT_IMAGE", "DATA_UPGRADED", "HISTOGRAM", "DEFAULT_ON_NULL", "IDENTITY_COLUMN", "EVALUATION_EDITION", "UNUSABLE_BEFORE", "UNUSABLE_BEGINNING", "COLLATION") AS 
  select OWNER, TABLE_NAME,
       COLUMN_NAME, DATA_TYPE, DATA_TYPE_MOD, DATA_TYPE_OWNER,
       DATA_LENGTH, DATA_PRECISION, DATA_SCALE, NULLABLE, COLUMN_ID,
       DEFAULT_LENGTH, DATA_DEFAULT, NUM_DISTINCT, LOW_VALUE, HIGH_VALUE,
       DENSITY, NUM_NULLS, NUM_BUCKETS, LAST_ANALYZED, SAMPLE_SIZE,
       CHARACTER_SET_NAME, CHAR_COL_DECL_LENGTH,
       GLOBAL_STATS, USER_STATS, AVG_COL_LEN, CHAR_LENGTH, CHAR_USED,
       V80_FMT_IMAGE, DATA_UPGRADED, HISTOGRAM, DEFAULT_ON_NULL,
       IDENTITY_COLUMN, EVALUATION_EDITION, UNUSABLE_BEFORE,
       UNUSABLE_BEGINNING, COLLATION
  from ALL_TAB_COLS
 where USER_GENERATED = 'YES';

   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."TABLE_NAME" IS 'Table, view or cluster name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."COLUMN_NAME" IS 'Column name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DATA_TYPE" IS 'Datatype of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DATA_TYPE_MOD" IS 'Datatype modifier of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DATA_TYPE_OWNER" IS 'Owner of the datatype of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DATA_LENGTH" IS 'Length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DATA_PRECISION" IS 'Length: decimal digits (NUMBER) or binary digits (FLOAT)';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DATA_SCALE" IS 'Digits to right of decimal point in a number';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."NULLABLE" IS 'Does column allow NULL values?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."COLUMN_ID" IS 'Sequence number of the column as created';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DEFAULT_LENGTH" IS 'Length of default value for the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DATA_DEFAULT" IS 'Default value for the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."NUM_DISTINCT" IS 'The number of distinct values in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."LOW_VALUE" IS 'The low value in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."HIGH_VALUE" IS 'The high value in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DENSITY" IS 'The density of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."NUM_NULLS" IS 'The number of nulls in the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."NUM_BUCKETS" IS 'The number of buckets in histogram for the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."LAST_ANALYZED" IS 'The date of the most recent time this column was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."SAMPLE_SIZE" IS 'The sample size used in analyzing this column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."CHARACTER_SET_NAME" IS 'Character set name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."CHAR_COL_DECL_LENGTH" IS 'Declaration length of character type column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."AVG_COL_LEN" IS 'The average length of the column in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."CHAR_LENGTH" IS 'The maximum length of the column in characters';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."CHAR_USED" IS 'C if maximum length is specified in characters, B if in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."V80_FMT_IMAGE" IS 'Is column data in 8.0 image format?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DATA_UPGRADED" IS 'Has column data been upgraded to the latest type version format?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."DEFAULT_ON_NULL" IS 'Is this a default on null column?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."IDENTITY_COLUMN" IS 'Is this an identity column?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."EVALUATION_EDITION" IS 'Name of the evaluation edition assigned to the column expression';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."UNUSABLE_BEFORE" IS 'Name of the oldest edition in which the column is usable';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."UNUSABLE_BEGINNING" IS 'Name of the oldest edition in which the column becomes perpetually unusable';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COLUMNS"."COLLATION" IS 'Collation name';
   COMMENT ON TABLE "SYS"."ALL_TAB_COLUMNS"  IS 'Columns of user''s tables, views and clusters'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_COMMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_COMMENTS" ("OWNER", "TABLE_NAME", "TABLE_TYPE", "COMMENTS", "ORIGIN_CON_ID") AS 
  select OWNER, TABLE_NAME, TABLE_TYPE, COMMENTS, ORIGIN_CON_ID
from INT$DBA_TAB_COMMENTS
where (OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
        or
        OBJ_ID(OWNER, TABLE_NAME, OBJECT_TYPE#, OBJECT_ID)
        in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
           /* 2 is the type# for Table. See kgl.h for more info */
        ora_check_sys_privilege (ownerid, 2 ) = 1
       );

   COMMENT ON COLUMN "SYS"."ALL_TAB_COMMENTS"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COMMENTS"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COMMENTS"."TABLE_TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COMMENTS"."COMMENTS" IS 'Comment on the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_COMMENTS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON TABLE "SYS"."ALL_TAB_COMMENTS"  IS 'Comments on tables and views accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_HISTGRM_PENDING_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_HISTGRM_PENDING_STATS" ("OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "COLUMN_NAME", "ENDPOINT_NUMBER", "ENDPOINT_VALUE", "ENDPOINT_ACTUAL_VALUE", "ENDPOINT_ACTUAL_VALUE_RAW", "ENDPOINT_REPEAT_COUNT") AS 
  select u.name, o.name, null, null, c.name,
         h.bucket,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.endpoint
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then case when h.epvalue is not null then epvalue
                 else dbms_stats.conv_raw(h.epvalue_raw, c.type#) end
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.epvalue_raw
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.ep_repeat_count
            else null
       end
  from   sys.user$ u, sys.obj$ o, sys.col$ c,
         sys."_OPTSTAT_HISTGRM_HISTORY_DEC" h
  where  h.obj# = c.obj#
    and  h.intcol# = c.intcol#
    and  h.obj# = o.obj#
    and  o.owner# = u.user#
    and  o.type# = 2
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  -- partitions
  select u.name, o.name, o.subname, null, c.name,
         h.bucket,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.endpoint
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then case when h.epvalue is not null then epvalue
                   else dbms_stats.conv_raw(h.epvalue_raw, c.type#) end
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.epvalue_raw
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.ep_repeat_count
            else null
         end
  from   sys.user$ u, sys.obj$ o, sys.col$ c, sys.tabpart$ t,
         sys."_OPTSTAT_HISTGRM_HISTORY_DEC" h
  where  t.bo# = c.obj#
    and  t.obj# = o.obj#
    and  h.intcol# = c.intcol#
    and  h.obj# = o.obj#
    and  o.type# = 19
    and  o.owner# = u.user#
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  select u.name, o.name, o.subname, null, c.name,
         h.bucket,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.endpoint
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then case when h.epvalue is not null then epvalue
                   else dbms_stats.conv_raw(h.epvalue_raw, c.type#) end
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
              then h.epvalue_raw
              else null
         end,
         case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.ep_repeat_count
            else null
         end
  from   sys.user$ u, sys.obj$ o, sys.col$ c, sys.tabcompart$ t,
         sys."_OPTSTAT_HISTGRM_HISTORY_DEC" h
  where  t.bo# = c.obj#
    and  t.obj# = o.obj#
    and  h.intcol# = c.intcol#
    and  h.obj# = o.obj#
    and  o.type# = 19
    and  o.owner# = u.user#
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  -- sub partitions
  select u.name, op.name, op.subname, os.subname, c.name,
         h.bucket,
         case when SYS_OP_DV_CHECK(os.name, os.owner#) = 1
              then h.endpoint
              else null
         end,
         case when SYS_OP_DV_CHECK(os.name, os.owner#) = 1
              then case when h.epvalue is not null then epvalue
                   else dbms_stats.conv_raw(h.epvalue_raw, c.type#) end
              else null
         end,
         case when SYS_OP_DV_CHECK(os.name, os.owner#) = 1
              then h.epvalue_raw
              else null
         end,
         case when SYS_OP_DV_CHECK(os.name, os.owner#) = 1
            then h.ep_repeat_count
            else null
         end
  from  sys.obj$ os, sys.tabsubpart$ tsp, sys.tabcompart$ tcp,
        sys.user$ u, sys.col$ c, sys.obj$ op,
        sys."_OPTSTAT_HISTGRM_HISTORY_DEC" h
  where os.obj# = tsp.obj#
    and os.owner# = u.user#
    and h.obj#  = tsp.obj#
    and h.intcol#= c.intcol#
    and tsp.pobj#= tcp.obj#
    and tcp.bo#  = c.obj#
    and tcp.obj# = op.obj#
    and os.type# = 34
    and h.savtime > systimestamp
    and (os.owner# = userenv('SCHEMAID')
        or os.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
        );

   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"."OWNER" IS 'Name of the owner';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"."PARTITION_NAME" IS 'Name of the partition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"."SUBPARTITION_NAME" IS 'Name of the subpartition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"."COLUMN_NAME" IS 'Name of the column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"."ENDPOINT_NUMBER" IS 'Endpoint number';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"."ENDPOINT_VALUE" IS 'Normalized endpoint value';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"."ENDPOINT_ACTUAL_VALUE" IS 'Actual endpoint value';
   COMMENT ON TABLE "SYS"."ALL_TAB_HISTGRM_PENDING_STATS"  IS 'Pending statistics of tables, partitions, and subpartitions'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_HISTOGRAMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_HISTOGRAMS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "ENDPOINT_NUMBER", "ENDPOINT_VALUE", "ENDPOINT_ACTUAL_VALUE", "ENDPOINT_ACTUAL_VALUE_RAW", "ENDPOINT_REPEAT_COUNT", "SCOPE") AS 
  select /*+ ordered */ u.name,
       o.name,
       decode(bitand(c.property, 1), 1, a.name, c.name),
       hg.bucket,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then hg.endpoint
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then case when hg.epvalue is not null then epvalue
                 else dbms_stats.conv_raw(hg.epvalue_raw, c.type#) end
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then hg.epvalue_raw
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then hg.ep_repeat_count
            else null
       end,
       'SHARED'
from sys.user$ u, sys.obj$ o, sys.col$ c, sys."_HISTGRM_DEC" hg, sys.attrcol$ a
where o.obj# = c.obj#
  and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
  and o.owner# = u.user#
  and c.obj# = hg.obj# and c.intcol# = hg.intcol#
  and (o.type# in (3, 4)                                     /* cluster, view */
       or
       (o.type# = 2     /* tables, excluding iot - overflow and nested tables */
        and
        not exists (select null
                      from sys.tab$ t
                     where t.obj# = o.obj#
                       and (bitand(t.property, 512) = 512 or
                            bitand(t.property, 8192) = 8192))))
  and c.obj# = a.obj#(+)
  and c.intcol# = a.intcol#(+)
union all
select /*+ ordered */ u.name,
       o.name,
       decode(bitand(c.property, 1), 1, a.name, c.name),
       0,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.minimum
            else null
       end,
       null,
       null,
       0,
       'SHARED'
from sys.user$ u, sys.obj$ o, sys.col$ c, sys."_HIST_HEAD_DEC" h, sys.attrcol$ a
where o.obj# = c.obj#
  and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
  and o.owner# = u.user#
  and c.obj# = h.obj# and c.intcol# = h.intcol#
  and (o.type# in (3, 4)                                     /* cluster, view */
       or
       (o.type# = 2     /* tables, excluding iot - overflow and nested tables */
        and
        not exists (select null
                      from sys.tab$ t
                     where t.obj# = o.obj#
                       and (bitand(t.property, 512) = 512 or
                            bitand(t.property, 8192) = 8192))))
  and h.row_cnt = 0 and h.distcnt > 0
  and c.obj# = a.obj#(+)
  and c.intcol# = a.intcol#(+)
union all
select /*+ ordered */ u.name,
       o.name,
       decode(bitand(c.property, 1), 1, a.name, c.name),
       1,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.maximum
            else null
       end,
       null,
       null,
       0,
       'SHARED'
from sys.user$ u, sys.obj$ o, sys.col$ c, sys."_HIST_HEAD_DEC" h, sys.attrcol$ a
where o.obj# = c.obj#
  and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
  and o.owner# = u.user#
  and c.obj# = h.obj# and c.intcol# = h.intcol#
  and (o.type# in (3, 4)                                     /* cluster, view */
       or
       (o.type# = 2     /* tables, excluding iot - overflow and nested tables */
        and
        not exists (select null
                      from sys.tab$ t
                     where t.obj# = o.obj#
                       and (bitand(t.property, 512) = 512 or
                            bitand(t.property, 8192) = 8192))))
  and h.row_cnt = 0 and h.distcnt > 0
  and c.obj# = a.obj#(+)
  and c.intcol# = a.intcol#(+)
union all
select /*+ ordered */
       'SYS',
       ft.kqftanam,
       c.kqfconam,
       h.bucket,
       h.endpoint,
       case when h.epvalue is not null then epvalue
            else dbms_stats.conv_raw(h.epvalue_raw, c.KQFCODTY) end,
       h.epvalue_raw,
       h.ep_repeat_count,
       'SHARED'
from   sys.x$kqfta ft, sys.fixed_obj$ fobj, sys.x$kqfco c, sys."_HISTGRM_DEC" h
where  ft.kqftaobj = fobj. obj#
  and c.kqfcotob = ft.kqftaobj
  and h.obj# = ft.kqftaobj
  and h.intcol# = c.kqfcocno
  /*
   * if fobj and st are not in sync (happens when db open read only
   * after upgrade), do not display stats.
   */
  and ft.kqftaver =
         fobj.timestamp - to_date('01-01-1991', 'DD-MM-YYYY')
  and (userenv('SCHEMAID') = 0  /* SYS */
       or /* user has system privileges */
       exists (select null from v$enabledprivs
               where priv_number in (-237 /* SELECT ANY DICTIONARY */)
              )
      )
union all
select /*+ ordered */ u.name,
       o.name,
       decode(bitand(c.property, 1), 1, a.name, c.name),
       h.bucket_kxttst_hs,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.endpoint_kxttst_hs
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then dbms_stats.conv_raw(h.epvalue_raw_kxttst_hs, c.type#)
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.epvalue_raw_kxttst_hs
            else null
       end,
       case when SYS_OP_DV_CHECK(o.name, o.owner#) = 1
            then h.ep_repeat_count_kxttst_hs
            else null
       end,
       'SESSION'
from sys.user$ u, sys.obj$ o, sys.col$ c, sys.x$kxttstehs h, sys.attrcol$ a
where o.obj# = c.obj#
  and (o.owner# = userenv('SCHEMAID')
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                         from x$kzsro
                                       )
                  )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
       )
  and o.owner# = u.user#
  and c.obj# = h.obj#_kxttst_hs and c.intcol# = h.intcol#_kxttst_hs
  and (o.type# in (3, 4)                                     /* cluster, view */
       or
       (o.type# = 2     /* tables, excluding iot - overflow and nested tables */
        and
        not exists (select null
                      from sys.tab$ t
                     where t.obj# = o.obj#
                       and (bitand(t.property, 512) = 512 or
                            bitand(t.property, 8192) = 8192))))
  and c.obj# = a.obj#(+)
  and c.intcol# = a.intcol#(+);

   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTOGRAMS"."OWNER" IS 'Owner of table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTOGRAMS"."TABLE_NAME" IS 'Table name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTOGRAMS"."COLUMN_NAME" IS 'Column name or attribute of object column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTOGRAMS"."ENDPOINT_NUMBER" IS 'Endpoint number';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTOGRAMS"."ENDPOINT_VALUE" IS 'Normalized endpoint value';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTOGRAMS"."ENDPOINT_ACTUAL_VALUE" IS 'Actual endpoint value';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTOGRAMS"."ENDPOINT_ACTUAL_VALUE_RAW" IS 'Actual endpoint value in raw format';
   COMMENT ON COLUMN "SYS"."ALL_TAB_HISTOGRAMS"."SCOPE" IS 'whether statistics for the object is shared or session';
   COMMENT ON TABLE "SYS"."ALL_TAB_HISTOGRAMS"  IS 'Histograms on columns of all tables visible to user'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_IDENTITY_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_IDENTITY_COLS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "GENERATION_TYPE", "SEQUENCE_NAME", "IDENTITY_OPTIONS") AS 
  select u.name, o.name, c.name,
       decode(bitand(c.property, 137438953472 + 274877906944),
                     137438953472, 'ALWAYS',
                     274877906944, 'BY DEFAULT'),
       so.name,
       'START WITH: '     || i.startwith ||
       ', INCREMENT BY: ' || s.increment$ ||
       ', MAX_VALUE: '    || s.maxvalue ||
       ', MIN_VALUE: '    || s.minvalue ||
       ', CYCLE_FLAG: '   || decode (s.cycle#, 0, 'N', 1, 'Y') ||
       ', CACHE_SIZE: '   || s.cache ||
       ', ORDER_FLAG: '   || decode (s.order$, 0, 'N', 1, 'Y')  ||
       ', SCALE_FLAG: '   || decode (bitand(s.flags, 16), 16, 'Y', 'N') ||
       ', EXTEND_FLAG: '  || decode (bitand(s.flags, 2048), 2048, 'Y', 'N') ||
       ', SESSION_FLAG: ' || decode(bitand(s.flags, 64), 64, 'Y', 'N') ||
       ', KEEP_VALUE: '   || decode(bitand(s.flags, 512), 512, 'Y', 'N')
from sys.idnseq$ i, sys.obj$ o, sys.user$ u, sys.col$ c,
     sys.seq$ s, sys.obj$ so
where o.owner# = u.user#
and o.obj# = i.obj#
and c.intcol# = i.intcol#
and c.obj# = i.obj#
and s.obj# = i.seqobj#
and so.obj# = i.seqobj#
and (o.owner# = userenv('SCHEMAID')
     or o.obj# in
          (select oa.obj#
           from sys.objauth$ oa
           where grantee# in ( select kzsrorol
                               from x$kzsro
                             )
          )
     or /* user has system privileges */
     ora_check_sys_privilege ( o.owner#, o.type# ) = 1
    );

   COMMENT ON COLUMN "SYS"."ALL_TAB_IDENTITY_COLS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_IDENTITY_COLS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_IDENTITY_COLS"."COLUMN_NAME" IS 'Name of the identity column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_IDENTITY_COLS"."GENERATION_TYPE" IS 'Generation type of the identity column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_IDENTITY_COLS"."SEQUENCE_NAME" IS 'Name of the sequence associated with the identity column';
   COMMENT ON COLUMN "SYS"."ALL_TAB_IDENTITY_COLS"."IDENTITY_OPTIONS" IS 'Options of the identity column';
   COMMENT ON TABLE "SYS"."ALL_TAB_IDENTITY_COLS"  IS 'Describes all table identity columns'
;
--------------------------------------------------------
--  DDL for View ALL_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TABLES" ("OWNER", "TABLE_NAME", "TABLESPACE_NAME", "CLUSTER_NAME", "IOT_NAME", "STATUS", "PCT_FREE", "PCT_USED", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENTS", "MAX_EXTENTS", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "BACKED_UP", "NUM_ROWS", "BLOCKS", "EMPTY_BLOCKS", "AVG_SPACE", "CHAIN_CNT", "AVG_ROW_LEN", "AVG_SPACE_FREELIST_BLOCKS", "NUM_FREELIST_BLOCKS", "DEGREE", "INSTANCES", "CACHE", "TABLE_LOCK", "SAMPLE_SIZE", "LAST_ANALYZED", "PARTITIONED", "IOT_TYPE", "TEMPORARY", "SECONDARY", "NESTED", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "ROW_MOVEMENT", "GLOBAL_STATS", "USER_STATS", "DURATION", "SKIP_CORRUPT", "MONITORING", "CLUSTER_OWNER", "DEPENDENCIES", "COMPRESSION", "COMPRESS_FOR", "DROPPED", "READ_ONLY", "SEGMENT_CREATED", "RESULT_CACHE", "CLUSTERING", "ACTIVITY_TRACKING", "DML_TIMESTAMP", "HAS_IDENTITY", "CONTAINER_DATA", "INMEMORY", "INMEMORY_PRIORITY", "INMEMORY_DISTRIBUTE", "INMEMORY_COMPRESSION", "INMEMORY_DUPLICATE", "DEFAULT_COLLATION", "DUPLICATED", "SHARDED", "EXTERNAL", "CELLMEMORY", "CONTAINERS_DEFAULT", "CONTAINER_MAP", "EXTENDED_DATA_LINK", "EXTENDED_DATA_LINK_MAP", "INMEMORY_SERVICE", "INMEMORY_SERVICE_NAME", "CONTAINER_MAP_OBJECT", "MEMOPTIMIZE_READ", "MEMOPTIMIZE_WRITE", "HAS_SENSITIVE_COLUMN") AS 
  select u.name, o.name,
       decode(bitand(t.property,2151678048), 0, ts.name,
              decode(t.ts#, 0, null, ts.name)),
       decode(bitand(t.property, 1024), 0, null, co.name),
       decode((bitand(t.property, 512)+bitand(t.flags, 536870912)),
              0, null, co.name),
       decode(bitand(t.trigflag, 1073741824), 1073741824, 'UNUSABLE', 'VALID'),
       decode(bitand(t.property, 32+64), 0, mod(t.pctfree$, 100), 64, 0, null),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
          decode(bitand(t.property, 32+64), 0, t.pctused$, 64, 0, null)),
       decode(bitand(t.property, 32), 0, t.initrans, null),
       decode(bitand(t.property, 32), 0, t.maxtrans, null),
       decode(bitand(t.property, 17179869184), 17179869184,
                     ds.initial_stg * ts.blocksize,
                     s.iniexts * ts.blocksize),
       decode(bitand(t.property, 17179869184), 17179869184,
              ds.next_stg * ts.blocksize,
              s.extsize * ts.blocksize),
       decode(bitand(t.property, 17179869184), 17179869184,
              ds.minext_stg, s.minexts),
       decode(bitand(t.property, 17179869184), 17179869184,
              ds.maxext_stg, s.maxexts),
       decode(bitand(ts.flags, 3), 1, to_number(NULL),
              decode(bitand(t.property, 17179869184), 17179869184,
                            ds.pctinc_stg, s.extpct)),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
         decode(bitand(o.flags, 2), 2, 1,
                decode(bitand(t.property, 17179869184), 17179869184,
                       decode(ds.frlins_stg, 0, 1, ds.frlins_stg),
                       decode(s.lists, 0, 1, s.lists)))),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
         decode(bitand(o.flags, 2), 2, 1,
                decode(bitand(t.property, 17179869184), 17179869184,
                       decode(ds.maxins_stg, 0, 1, ds.maxins_stg),
                       decode(s.groups, 0, 1, s.groups)))),
       decode(bitand(t.property, 32+64), 0,
                decode(bitand(t.flags, 32), 0, 'YES', 'NO'), null),
       decode(bitand(t.flags,1), 0, 'Y', 1, 'N', '?'),
       t.rowcnt,
       decode(bitand(t.property, 64), 0, t.blkcnt, null),
       decode(bitand(t.property, 64), 0, t.empcnt, null),
       decode(bitand(t.property, 64), 0, t.avgspc, null),
       t.chncnt, t.avgrln, t.avgspc_flb,
       decode(bitand(t.property, 64), 0, t.flbcnt, null),
       lpad(decode(t.degree, 32767, 'DEFAULT', nvl(t.degree,1)),10),
       lpad(decode(t.instances, 32767, 'DEFAULT', nvl(t.instances,1)),10),
       lpad(decode(bitand(t.flags, 8), 8, 'Y', 'N'),5),
       decode(bitand(t.flags, 6), 0, 'ENABLED', 'DISABLED'),
       t.samplesize, t.analyzetime,
       decode(bitand(t.property, 32), 32, 'YES', 'NO'),
       decode(bitand(t.property, 64), 64, 'IOT',
               decode(bitand(t.property, 512), 512, 'IOT_OVERFLOW',
               decode(bitand(t.flags, 536870912), 536870912, 'IOT_MAPPING', null))),
       decode(bitand(o.flags, 2), 0, 'N', 2, 'Y', 'N'),
       decode(bitand(o.flags, 16), 0, 'N', 16, 'Y', 'N'),
       decode(bitand(t.property, 8192), 8192, 'YES',
              decode(bitand(t.property, 1), 0, 'NO', 'YES')),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
              decode(bitand(decode(bitand(t.property, 17179869184), 17179869184,
                            ds.bfp_stg, s.cachehint), 3),
                            1, 'KEEP', 2, 'RECYCLE', 'DEFAULT')),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
              decode(bitand(decode(bitand(t.property, 17179869184), 17179869184,
                            ds.bfp_stg, s.cachehint), 12)/4,
                            1, 'KEEP', 2, 'NONE', 'DEFAULT')),
       decode(bitand(o.flags, 2), 2, 'DEFAULT',
              decode(bitand(decode(bitand(t.property, 17179869184), 17179869184,
                            ds.bfp_stg, s.cachehint), 48)/16,
                            1, 'KEEP', 2, 'NONE', 'DEFAULT')),
       decode(bitand(t.flags, 131072), 131072, 'ENABLED', 'DISABLED'),
       decode(bitand(t.flags, 512), 0, 'NO', 'YES'),
       decode(bitand(t.flags, 256), 0, 'NO', 'YES'),
       decode(bitand(o.flags, 2), 0, NULL,
          decode(bitand(t.property, 8388608), 8388608,
                 'SYS$SESSION', 'SYS$TRANSACTION')),
       decode(bitand(t.flags, 1024), 1024, 'ENABLED', 'DISABLED'),
       decode(bitand(o.flags, 2), 2, 'NO',
           decode(bitand(t.property, 2147483648), 2147483648, 'NO',
              decode(ksppcv.ksppstvl, 'TRUE', 'YES', 'NO'))),
       decode(bitand(t.property, 1024), 0, null, cu.name),
       decode(bitand(t.flags, 8388608), 8388608, 'ENABLED', 'DISABLED'),
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
          decode(bitand(ds.flags_stg, 4), 4, 'ENABLED', 'DISABLED')
       else
         decode(bitand(s.spare1, 2048), 2048, 'ENABLED', 'DISABLED')
       end,
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
          decode(bitand(ds.flags_stg, 4), 4,
          case when bitand(ds.cmpflag_stg, 3) = 1 then 'BASIC'
               when bitand(ds.cmpflag_stg, 3) = 2 then 'ADVANCED'
               else concat(decode(ds.cmplvl_stg, 1, 'QUERY LOW',
                                                 2, 'QUERY HIGH',
                                                 3, 'ARCHIVE LOW',
                                                    'ARCHIVE HIGH'),
                           decode(bitand(ds.flags_stg, 524288), 524288,
                                  ' ROW LEVEL LOCKING', '')) end,
               null)
       else
         decode(bitand(s.spare1, 2048), 0, null,
         case when bitand(s.spare1, 16777216) = 16777216
                   then 'ADVANCED'
              when bitand(s.spare1, 100663296) = 33554432  -- 0x2000000
                   then concat('QUERY LOW',
                               decode(bitand(s.spare1, 2147483648),
                                      2147483648, ' ROW LEVEL LOCKING', ''))
              when bitand(s.spare1, 100663296) = 67108864  -- 0x4000000
                   then concat('QUERY HIGH',
                               decode(bitand(s.spare1, 2147483648),
                                      2147483648, ' ROW LEVEL LOCKING', ''))
              when bitand(s.spare1, 100663296) = 100663296 -- 0x2000000+0x4000000
                   then concat('ARCHIVE LOW',
                               decode(bitand(s.spare1, 2147483648),
                                      2147483648, ' ROW LEVEL LOCKING', ''))
              when bitand(s.spare1, 134217728) = 134217728 -- 0x8000000
                   then concat('ARCHIVE HIGH',
                               decode(bitand(s.spare1, 2147483648),
                                      2147483648, ' ROW LEVEL LOCKING', ''))
              else 'BASIC' end)
       end,
       decode(bitand(o.flags, 128), 128, 'YES', 'NO'),
       decode(bitand(t.trigflag, 2097152), 2097152, 'YES',
              decode(bitand(t.property, 32), 32, 'N/A', 'NO')),
       decode(bitand(t.property, 17179869184), 17179869184, 'NO',
              decode(bitand(t.property, 32), 32, 'N/A', 'YES')),
       decode(bitand(t.property,16492674416640),2199023255552,'FORCE',
                 4398046511104,'MANUAL','DEFAULT'),
       decode(bitand(t.property, 18014398509481984), 18014398509481984,
                     'YES', 'NO'),
       case when bitand(t.property, 1125899906842624) = 1125899906842624
                 then 'ROW ACCESS TRACKING'
            when bitand(t.property, 2251799813685248) = 2251799813685248
                 then 'SEGMENT ACCESS TRACKING'
       end,
       case when bitand(t.property, 844424930131968) = 844424930131968
                 then 'ROW CREATION/MODIFICATION'
            when bitand(t.property, 281474976710656) = 281474976710656
                 then 'ROW MODIFICATION'
            when bitand(t.property, 562949953421312) = 562949953421312
                 then 'ROW CREATION'
       end,
       decode(bitand(t.property, 288230376151711744), 288230376151711744,
              'YES', 'NO'),
       decode(bitand(t.property/4294967296, 134217728), 134217728, 'YES', 'NO'),
       -- INMEMORY
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 2147483648 ) = 2147483648) then
         decode(bitand(xt.property,16), 16, 'ENABLED', 'DISABLED')
       when (bitand(t.property, 17179869184) = 17179869184) then
         -- flags/imcflag_stg (stgdef.h)
         decode(bitand(ds.flags_stg, 6291456),
             2097152, 'ENABLED',
             4194304, 'DISABLED', 'DISABLED')
       else
         -- ktsscflg (ktscts.h)
         decode(bitand(s.spare1, 70373039144960),
             4294967296,     'ENABLED',
             70368744177664, 'DISABLED', 'DISABLED')
       end,
       -- INMEMORY_PRIORITY
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 4), 4,
                decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 7936),
                256, 'NONE',
                512, 'LOW',
                1024, 'MEDIUM',
                2048, 'HIGH',
                4096, 'CRITICAL', 'UNKNOWN'), null),
                'NONE'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 34359738368), 34359738368,
                decode(bitand(s.spare1, 61572651155456),
                8796093022208, 'LOW',
                17592186044416, 'MEDIUM',
                35184372088832, 'HIGH',
                52776558133248, 'CRITICAL', 'NONE'),
                'NONE'),
                null)
       end,
       -- INMEMORY_DISTRIBUTE
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 1), 1,
                       decode(bitand(ds.imcflag_stg, (16+32)),
                              16,  'BY ROWID RANGE',
                              32,  'BY PARTITION',
                              48,  'BY SUBPARTITION',
                               0,  'AUTO'),
                  null), null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 8589934592), 8589934592,
                        decode(bitand(s.spare1, 206158430208),
                        68719476736,   'BY ROWID RANGE',
                        137438953472,  'BY PARTITION',
                        206158430208,  'BY SUBPARTITION',
                        0,             'AUTO'),
                        'UNKNOWN'),
                  null)
       end,
       -- INMEMORY_COMPRESSION
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 2147483648 ) = 2147483648) then
             decode(bitand(xt.property, (16+32+64+128)),
                         (16+32), 'NO MEMCOMPRESS',
                         (16+64), 'FOR DML',
                      (16+32+64), 'FOR QUERY LOW',
                        (16+128), 'FOR QUERY HIGH',
                     (16+128+32), 'FOR CAPACITY LOW',
                     (16+128+64), 'FOR CAPACITY HIGH', NULL)
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, (2+8+64+128)),
                              2,   'NO MEMCOMPRESS',
                              8,  'FOR DML',
                              10,  'FOR QUERY LOW',
                              64, 'FOR QUERY HIGH',
                              66, 'FOR CAPACITY LOW',
                              72, 'FOR CAPACITY HIGH', 'UNKNOWN'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 841813590016),
                              17179869184,  'NO MEMCOMPRESS',
                              274877906944, 'FOR DML',
                              292057776128, 'FOR QUERY LOW',
                              549755813888, 'FOR QUERY HIGH',
                              566935683072, 'FOR CAPACITY LOW',
                              824633720832, 'FOR CAPACITY HIGH', 'UNKNOWN'),
                 null)
       end,
       -- INMEMORY_DUPLICATE
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
        decode(bitand(ds.flags_stg, 2097152), 2097152,
               decode(bitand(ds.imcflag_stg, (8192+16384)),
                              8192,   'NO DUPLICATE',
                              16384,  'DUPLICATE',
                              24576,  'DUPLICATE ALL',
                              'UNKNOWN'),
                null)
       else
          decode(bitand(s.spare1, 4294967296), 4294967296,
                   decode(bitand(s.spare1, 6597069766656),
                           2199023255552, 'NO DUPLICATE',
                           4398046511104, 'DUPLICATE',
                           6597069766656, 'DUPLICATE ALL', 'UNKNOWN'),
                 null)
       end,
       nls_collation_name(nvl(o.dflcollid, 16382)),
       decode(bitand(o.flags, 2147483648), 0, 'N', 2147483648, 'Y', 'N'),
       decode(bitand(o.flags, 1073741824), 0, 'N', 1073741824, 'Y', 'N'),
       decode(bitand(t.property, 2147483648), 2147483648, 'YES', 'NO'),
       -- CELLMEMORY
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         -- deferred segment: stgccflags (stgdef.h)
         decode(ccflag_stg,
             8194, 'NO MEMCOMPRESS',
             8196, 'MEMCOMPRESS FOR QUERY',
             8200, 'MEMCOMPRESS FOR CAPACITY',
             16384, 'DISABLED', null)
       else
         -- created segment: ktsscflg (ktscts.h)
         decode(bitand(s.spare1, 4362862139015168),
              281474976710656, 'DISABLED',
              703687441776640, 'NO MEMCOMPRESS',
             1266637395197952, 'MEMCOMPRESS FOR QUERY',
             2392537302040576, 'MEMCOMPRESS FOR CAPACITY', null)
       end,
       -- CONTAINERS_DEFAULT
       decode(bitand(t.property, power(2,72)), power(2,72), 'YES', 'NO'),
       -- CONTAINER_MAP
       decode(bitand(t.property, power(2,80)), power(2,80), 'YES', 'NO'),
       -- EXTENDED_DATA_LINK
       decode(bitand(t.property, power(2,52)), power(2,52), 'YES', 'NO'),
       -- EXTENDED_DATA_LINK_MAP
       decode(bitand(t.property, power(2,79)), power(2,79), 'YES', 'NO'),
       -- INMEMORY_SERVICE
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 32768), 32768,
                       decode(bitand(svc.svcflags, 7),
                              0, null,
                              1, 'DEFAULT',
                              2, 'NONE',
                              3, 'ALL',
                              4, 'USER_DEFINED', 'UNKNOWN'), 'DEFAULT'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 9007199254740992), 9007199254740992,
                       decode(bitand(svc.svcflags, 7),
                              0, null,
                              1, 'DEFAULT',
                              2, 'NONE',
                              3, 'ALL',
                              4, 'USER_DEFINED', 'UNKNOWN'), 'DEFAULT'),
                 null)
       end,
       -- INMEMORY_SERVICE_NAME
       case when (bitand(t.property, 32) = 32) then
         null
       when (bitand(t.property, 17179869184) = 17179869184) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 32768), 32768,
                       svc.svcname, null),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 9007199254740992), 9007199254740992,
                       svc.svcname, null),
                null)
       end,
       -- CONTAINER_MAP_OBJECT
       decode(bitand(t.property, power(2,87)), power(2,87), 'YES', 'NO'),
       -- MEMOPTIMIZE_READ
       case when bitand(t.property, 32) = 32
              then 'N/A'
       else
          decode(bitand(t.property, power(2,91)), power(2,91),
                        'ENABLED', 'DISABLED')
       end,
       -- MEMOPTIMIZE_WRITE
       case when bitand(t.property, 32) = 32
              then 'N/A'
       else
          decode(bitand(t.property, power(2,92)), power(2,92),
                        'ENABLED', 'DISABLED')
       end,
       -- HAS_SENSITIVE_COLUMN
       decode(bitand(t.property, power(2,89)), power(2,89), 'YES', 'NO')
from sys.user$ u, sys.ts$ ts, sys.seg$ s, sys.obj$ co, sys.tab$ t,
     sys.external_tab$ xt, sys."_CURRENT_EDITION_OBJ" o,
     sys.obj$ cx, sys.user$ cu,
     (select /*+ no_merge */ ksppcv.ksppstvl
      from x$ksppcv ksppcv, x$ksppi ksppi
      where ksppi.ksppinm = '_dml_monitoring_enabled' and
            ksppi.indx = ksppcv.indx
     ) ksppcv,
     sys.deferred_stg$ ds, sys.imsvc$ svc
where o.owner# = u.user#
  and o.obj# = t.obj#
  and t.obj# = xt.obj# (+)
  and bitand(t.property, 1) = 0
  and bitand(o.flags, 128) = 0
  and t.bobj# = co.obj# (+)
  and t.ts# = ts.ts#
  and t.obj# = ds.obj# (+)
  and t.file# = s.file# (+)
  and t.block# = s.block# (+)
  and t.ts# = s.ts# (+)
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_sys_privilege (o.owner#, o.type#) = 1
      )
  and t.dataobj# = cx.obj# (+)
  and cx.owner# = cu.user# (+)
  and bitand(t.property, power(2,65)) = 0 -- Do not show granular token sets
  and t.obj# = svc.obj# (+)
  and svc.subpart#(+) is null;

   COMMENT ON COLUMN "SYS"."ALL_TABLES"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."TABLESPACE_NAME" IS 'Name of the tablespace containing the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CLUSTER_NAME" IS 'Name of the cluster, if any, to which the table belongs';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."IOT_NAME" IS 'Name of the index-only table, if any, to which the overflow or mapping table entry belongs';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."STATUS" IS 'Status of the table will be UNUSABLE if a previous DROP TABLE operation failed,
VALID otherwise';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."PCT_FREE" IS 'Minimum percentage of free space in a block';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."PCT_USED" IS 'Minimum percentage of used space in a block';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INI_TRANS" IS 'Initial number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."MAX_TRANS" IS 'Maximum number of transactions';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INITIAL_EXTENT" IS 'Size of the initial extent in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."NEXT_EXTENT" IS 'Size of secondary extents in bytes';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."MIN_EXTENTS" IS 'Minimum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."MAX_EXTENTS" IS 'Maximum number of extents allowed in the segment';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."PCT_INCREASE" IS 'Percentage increase in extent size';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."FREELISTS" IS 'Number of process freelists allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."FREELIST_GROUPS" IS 'Number of freelist groups allocated in this segment';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."LOGGING" IS 'Logging attribute';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."BACKED_UP" IS 'Has table been backed up since last modification?';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."NUM_ROWS" IS 'The number of rows in the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."BLOCKS" IS 'The number of used blocks in the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."EMPTY_BLOCKS" IS 'The number of empty (never used) blocks in the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."AVG_SPACE" IS 'The average available free space in the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CHAIN_CNT" IS 'The number of chained rows in the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."AVG_ROW_LEN" IS 'The average row length, including row overhead';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."AVG_SPACE_FREELIST_BLOCKS" IS 'The average freespace of all blocks on a freelist';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."NUM_FREELIST_BLOCKS" IS 'The number of blocks on the freelist';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."DEGREE" IS 'The number of threads per instance for scanning the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INSTANCES" IS 'The number of instances across which the table is to be scanned';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CACHE" IS 'Whether the table is to be cached in the buffer cache';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."TABLE_LOCK" IS 'Whether table locking is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."SAMPLE_SIZE" IS 'The sample size used in analyzing this table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."LAST_ANALYZED" IS 'The date of the most recent time this table was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."PARTITIONED" IS 'Is this table partitioned? YES or NO';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."IOT_TYPE" IS 'If index-only table, then IOT_TYPE is IOT or IOT_OVERFLOW or IOT_MAPPING else NULL';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."TEMPORARY" IS 'Can the current session only see data that it place in this object itself?';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."SECONDARY" IS 'Is this table object created as part of icreate for domain indexes?';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."NESTED" IS 'Is the table a nested table?';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."BUFFER_POOL" IS 'The default buffer pool to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."FLASH_CACHE" IS 'The default flash cache hint to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CELL_FLASH_CACHE" IS 'The default cell flash cache hint to be used for table blocks';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."ROW_MOVEMENT" IS 'Whether partitioned row movement is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."DURATION" IS 'If temporary table, then duration is sys$session or sys$transaction else NULL';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."SKIP_CORRUPT" IS 'Whether skip corrupt blocks is enabled or disabled';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."MONITORING" IS 'Should we keep track of the amount of modification?';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CLUSTER_OWNER" IS 'Owner of the cluster, if any, to which the table belongs';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."DEPENDENCIES" IS 'Should we keep track of row level dependencies?';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."COMPRESSION" IS 'Whether table compression is enabled or not';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."COMPRESS_FOR" IS 'Compress what kind of operations';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."DROPPED" IS 'Whether table is dropped and is in Recycle Bin';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."READ_ONLY" IS 'Whether table is read only or not';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."SEGMENT_CREATED" IS 'Whether the table segment is created or not';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."RESULT_CACHE" IS 'The result cache mode annotation for the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CLUSTERING" IS 'Whether table has clustering clause or not';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."ACTIVITY_TRACKING" IS 'ILM activity tracking mode';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."DML_TIMESTAMP" IS 'ILM row modification or creation timestamp tracking mode';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."HAS_IDENTITY" IS 'Whether the table has an identity column';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CONTAINER_DATA" IS 'An indicator of whether the table contains Container-specific data';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INMEMORY" IS 'Whether in-memory is enabled or not';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INMEMORY_PRIORITY" IS 'User defined priority in which in-memory column store object is loaded';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INMEMORY_DISTRIBUTE" IS 'How the in-memory columnar store object is distributed';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INMEMORY_COMPRESSION" IS 'Compression level for the in-memory column store option';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INMEMORY_DUPLICATE" IS 'How the in-memory column store object is duplicated';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."DEFAULT_COLLATION" IS 'Default collation for the table';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."EXTERNAL" IS 'Whether the table is an  external table or not';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CELLMEMORY" IS 'Cell columnar cache';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CONTAINERS_DEFAULT" IS 'Whether the table is enabled for CONTAINERS() by default';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CONTAINER_MAP" IS 'Whether the table is enabled for use with container_map database property';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."EXTENDED_DATA_LINK" IS 'Whether the table is enabled for fetching extended data link from Root';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."EXTENDED_DATA_LINK_MAP" IS 'Whether the table is enabled for use with extended data link map';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INMEMORY_SERVICE" IS 'How the in-memory columnar store object is distributed for service';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."INMEMORY_SERVICE_NAME" IS 'Service on which the in-memory columnar store object is distributed';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."CONTAINER_MAP_OBJECT" IS 'Whether the table is used as the value of container_map database property';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."MEMOPTIMIZE_READ" IS 'Whether the table is enabled for Fast Key Based Access';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."MEMOPTIMIZE_WRITE" IS 'Whether the table is enabled for Fast Data Ingestion';
   COMMENT ON COLUMN "SYS"."ALL_TABLES"."HAS_SENSITIVE_COLUMN" IS 'Whether the table has one or more sensitive columns';
   COMMENT ON TABLE "SYS"."ALL_TABLES"  IS 'Description of relational tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_MODIFICATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_MODIFICATIONS" ("TABLE_OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "INSERTS", "UPDATES", "DELETES", "TIMESTAMP", "TRUNCATED", "DROP_SEGMENTS") AS 
  select u.name, o.name, null, null,
       m.inserts, m.updates, m.deletes, m.timestamp,
       decode(bitand(m.flags,1),1,'YES','NO'),
       m.drop_segments
from sys.mon_mods_v m, sys.obj$ o, sys.tab$ t, sys.user$ u
where o.obj# = m.obj# and o.obj# = t.obj# and o.owner# = u.user#
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in (select kzsrorol from x$kzsro))
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                       where priv_number in (-45 /* LOCK ANY TABLE */,
                                             -47 /* SELECT ANY TABLE */,
                                             -397/* READ ANY TABLE */,
                                             -48 /* INSERT ANY TABLE */,
                                             -49 /* UPDATE ANY TABLE */,
                                             -50 /* DELETE ANY TABLE */,
                                             -165/* ANALYZE ANY */))
          )
union all
select u.name, o.name, o.subname, null,
       m.inserts, m.updates, m.deletes, m.timestamp,
       decode(bitand(m.flags,1),1,'YES','NO'),
       m.drop_segments
from sys.mon_mods_v m, sys.obj$ o, sys.user$ u
where o.owner# = u.user# and o.obj# = m.obj# and o.type#=19
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in (select kzsrorol from x$kzsro))
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                       where priv_number in (-45 /* LOCK ANY TABLE */,
                                             -47 /* SELECT ANY TABLE */,
                                             -397/* READ ANY TABLE */,
                                             -48 /* INSERT ANY TABLE */,
                                             -49 /* UPDATE ANY TABLE */,
                                             -50 /* DELETE ANY TABLE */,
                                             -165/* ANALYZE ANY */))
          )
union all
select u.name, o.name, o2.subname, o.subname,
       m.inserts, m.updates, m.deletes, m.timestamp,
       decode(bitand(m.flags,1),1,'YES','NO'),
       m.drop_segments
from sys.mon_mods_v m, sys.obj$ o, sys.tabsubpart$ tsp, sys.obj$ o2,
     sys.user$ u
where o.obj# = m.obj# and o.owner# = u.user# and
      o.obj# = tsp.obj# and o2.obj# = tsp.pobj#
      and (o.owner# = userenv('SCHEMAID')
           or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in (select kzsrorol from x$kzsro))
           or /* user has system privileges */
             exists (select null from v$enabledprivs
                       where priv_number in (-45 /* LOCK ANY TABLE */,
                                             -47 /* SELECT ANY TABLE */,
                                             -397/* READ ANY TABLE */,
                                             -48 /* INSERT ANY TABLE */,
                                             -49 /* UPDATE ANY TABLE */,
                                             -50 /* DELETE ANY TABLE */,
                                             -165/* ANALYZE ANY */))
          );

   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."TABLE_OWNER" IS 'Owner of modified table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."TABLE_NAME" IS 'Modified table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."PARTITION_NAME" IS 'Modified partition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."SUBPARTITION_NAME" IS 'Modified subpartition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."INSERTS" IS 'Approximate number of rows inserted since last analyze';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."UPDATES" IS 'Approximate number of rows updated since last analyze';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."DELETES" IS 'Approximate number of rows deleted since last analyze';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."TIMESTAMP" IS 'Timestamp of last time this row was modified';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."TRUNCATED" IS 'Was this object truncated since the last analyze?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_MODIFICATIONS"."DROP_SEGMENTS" IS 'Number of (sub)partition segment dropped since the last analyze?';
   COMMENT ON TABLE "SYS"."ALL_TAB_MODIFICATIONS"  IS 'Information regarding modifications to tables'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_PARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_PARTITIONS" ("TABLE_OWNER", "TABLE_NAME", "COMPOSITE", "PARTITION_NAME", "SUBPARTITION_COUNT", "HIGH_VALUE", "HIGH_VALUE_LENGTH", "PARTITION_POSITION", "TABLESPACE_NAME", "PCT_FREE", "PCT_USED", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENT", "MAX_EXTENT", "MAX_SIZE", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "COMPRESSION", "COMPRESS_FOR", "NUM_ROWS", "BLOCKS", "EMPTY_BLOCKS", "AVG_SPACE", "CHAIN_CNT", "AVG_ROW_LEN", "SAMPLE_SIZE", "LAST_ANALYZED", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "GLOBAL_STATS", "USER_STATS", "IS_NESTED", "PARENT_TABLE_PARTITION", "INTERVAL", "SEGMENT_CREATED", "INDEXING", "READ_ONLY", "INMEMORY", "INMEMORY_PRIORITY", "INMEMORY_DISTRIBUTE", "INMEMORY_COMPRESSION", "INMEMORY_DUPLICATE", "CELLMEMORY", "INMEMORY_SERVICE", "INMEMORY_SERVICE_NAME", "MEMOPTIMIZE_READ", "MEMOPTIMIZE_WRITE") AS 
  select u.name, o.name, 'NO', o.subname, 0,
       tp.hiboundval, tp.hiboundlen,
       row_number() over (partition by u.name, o.name order by tp.part#),
       ts.name, tp.pctfree$,
       decode(bitand(ts.flags, 32), 32, to_number(NULL), tp.pctused$),
       tp.initrans, tp.maxtrans,
       decode(bitand(tp.flags, 65536), 65536,
              ds.initial_stg * ts.blocksize, s.iniexts * ts.blocksize),
       decode(bitand(tp.flags, 65536), 65536,
              ds.next_stg * ts.blocksize, s.extsize * ts.blocksize),
       decode(bitand(tp.flags, 65536), 65536, ds.minext_stg, s.minexts),
       decode(bitand(tp.flags, 65536), 65536, ds.maxext_stg, s.maxexts),
       decode(bitand(tp.flags, 65536), 65536,
              ds.maxsiz_stg * ts.blocksize,
              decode(bitand(s.spare1, 4194304), 4194304, bitmapranges, NULL)),
       decode(bitand(ts.flags, 3), 1, to_number(NULL),
              decode(bitand(tp.flags, 65536), 65536, ds.pctinc_stg, s.extpct)),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(tp.flags, 65536), 65536,
                     decode(ds.frlins_stg, 0, 1, ds.frlins_stg),
                     decode(s.lists, 0, 1, s.lists))),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(tp.flags, 65536), 65536,
                     decode(ds.maxins_stg, 0, 1, ds.maxins_stg),
                     decode(s.groups, 0, 1, s.groups))),
       decode(mod(trunc(tp.flags / 4), 2), 0, 'YES', 'NO'),
       case when (bitand(tp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 4), 4, 'ENABLED', 'DISABLED')
       else
         decode(bitand(s.spare1, 2048), 2048, 'ENABLED', 'DISABLED')
       end,
       case when (bitand(tp.flags, 65536) = 65536) then
          decode(bitand(ds.flags_stg, 4), 4,
          case when bitand(ds.cmpflag_stg, 3) = 1 then 'BASIC'
               when bitand(ds.cmpflag_stg, 3) = 2 then 'ADVANCED'
               else concat(decode(ds.cmplvl_stg, 1, 'QUERY LOW',
                                                 2, 'QUERY HIGH',
                                                 3, 'ARCHIVE LOW',
                                                    'ARCHIVE HIGH'),
                           decode(bitand(ds.flags_stg, 524288), 524288,
                                  ' ROW LEVEL LOCKING', '')) end,
           null)
       else
         decode(bitand(s.spare1, 2048), 0, null,
           case when bitand(s.spare1, 16777216) = 16777216
                     then 'ADVANCED'
                when bitand(s.spare1, 100663296) = 33554432  -- 0x2000000
                     then concat('QUERY LOW',
                                 decode(bitand(s.spare1, 2147483648),
                                        2147483648, ' ROW LEVEL LOCKING', ''))
                when bitand(s.spare1, 100663296) = 67108864  -- 0x4000000
                     then concat('QUERY HIGH',
                                 decode(bitand(s.spare1, 2147483648),
                                        2147483648, ' ROW LEVEL LOCKING', ''))
                when bitand(s.spare1, 100663296) = 100663296 -- 0x2000000+0x4000000
                     then concat('ARCHIVE LOW',
                                 decode(bitand(s.spare1, 2147483648),
                                        2147483648, ' ROW LEVEL LOCKING', ''))
                when bitand(s.spare1, 134217728) = 134217728 -- 0x8000000
                     then concat('ARCHIVE HIGH',
                                 decode(bitand(s.spare1, 2147483648),
                                        2147483648, ' ROW LEVEL LOCKING', ''))
                else 'BASIC' end)
       end,
       tp.rowcnt, tp.blkcnt, tp.empcnt, tp.avgspc, tp.chncnt, tp.avgrln,
       tp.samplesize, tp.analyzetime,
       decode(bitand(decode(bitand(tp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 3),
              1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(decode(bitand(tp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 12)/4,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(decode(bitand(tp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 48)/16,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(tp.flags, 16), 0, 'NO', 'YES'),
       decode(bitand(tp.flags, 8), 0, 'NO', 'YES'),
       decode(bitand(o.flags, 16384), 0, 'NO', 'YES'),
       case bitand(o.flags, 16384)   --is the object a nested table partition?
       when  16384 then
       (select o1.subname
        from obj$ o1
        where o1.obj#=
        (select tp1.obj#
         from tabpartv$ tp1, tabpartv$ tp2, ntab$ nt
         where tp2.bo# = tp.bo#
         and tp2.obj# = tp.obj#
         and tp1.part# = tp2.part#
         and tp1.bo#=nt.obj#
         and nt.ntab#=tp.bo#))
       else
         null
       end,
       decode(bitand(tp.flags, 32768), 32768, 'YES', 'NO'),
       decode(bitand(tp.flags, 65536), 65536, 'NO', 'YES'),
       decode(bitand(tp.flags, 2097152), 2097152, 'OFF', 'ON'),
       decode(bitand(tp.flags, 67108864), 67108864, 'YES', 'NO'),
       --INMEMORY
       case when (bitand(tp.flags, 65536) = 65536) then
          -- flags/imcflag_stg (stgdef.h
          decode(bitand(ds.flags_stg, 6291456),
                2097152, 'ENABLED',
                4194304, 'DISABLED', 'DISABLED')
       else
          -- ktsscflg (ktscts.h)
          decode(bitand(s.spare1, 70373039144960),
                4294967296, 'ENABLED',
                70368744177664, 'DISABLED', 'DISABLED')
       end,
       -- INMEMORY_PRIORITY
       case when (bitand(tp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 4), 4,
                decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 7936),
                256, 'NONE',
                512, 'LOW',
                1024, 'MEDIUM',
                2048, 'HIGH',
                4096, 'CRITICAL', 'UNKNOWN'), null),
                'NONE'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 34359738368), 34359738368,
                decode(bitand(s.spare1, 61572651155456),
                8796093022208, 'LOW',
                17592186044416, 'MEDIUM',
                35184372088832, 'HIGH',
                52776558133248, 'CRITICAL', 'NONE'),
                'NONE'),
                null)
       end,
       -- INMEMORY_DISTRIBUTE
       case when (bitand(tp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 1), 1,
                       decode(bitand(ds.imcflag_stg, (16+32)),
                              16,  'BY ROWID RANGE',
                              32,  'BY PARTITION',
                              48,  'BY SUBPARTITION',
                               0,  'AUTO'),
                  null), null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
               decode(bitand(s.spare1, 8589934592), 8589934592,
                        decode(bitand(s.spare1, 206158430208),
                        68719476736,   'BY ROWID RANGE',
                        137438953472,  'BY PARTITION',
                        206158430208,  'BY SUBPARTITION',
                        0,             'AUTO'),
                        null),
                  null)
       end,
       -- INMEMORY_COMPRESSION
       case when (bitand(tp.flags, 65536) = 65536) then
        decode(bitand(ds.flags_stg, 2097152), 2097152,
               decode(bitand(ds.imcflag_stg, (2+8+64+128)),
                              2,  'NO MEMCOMPRESS',
                              8,  'FOR DML',
                              10, 'FOR QUERY LOW',
                              64, 'FOR QUERY HIGH',
                              66, 'FOR CAPACITY LOW',
                              72, 'FOR CAPACITY HIGH', 'UNKNOWN'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 841813590016),
                              17179869184,  'NO MEMCOMPRESS',
                              274877906944, 'FOR DML',
                              292057776128, 'FOR QUERY LOW',
                              549755813888, 'FOR QUERY HIGH',
                              566935683072, 'FOR CAPACITY LOW',
                              824633720832, 'FOR CAPACITY HIGH', 'UNKNOWN'),
                 null)
       end,
       -- INMEMORY_DUPLICATE
       case when (bitand(tp.flags, 65536) = 65536) then
        decode(bitand(ds.flags_stg, 2097152), 2097152,
               decode(bitand(ds.imcflag_stg, (8192+16384)),
                              8192,   'NO DUPLICATE',
                              16384,  'DUPLICATE',
                              24576,  'DUPLICATE ALL',
                              'UNKNOWN'),
                null)
       else
          decode(bitand(s.spare1, 4294967296), 4294967296,
                   decode(bitand(s.spare1, 6597069766656),
                           2199023255552, 'NO DUPLICATE',
                           4398046511104, 'DUPLICATE',
                           6597069766656, 'DUPLICATE ALL', 'UNKNOWN'),
                null)
       end,
       -- CELLMEMORY
       case when (bitand(tp.flags, 65536) = 65536) then
         -- deferred segment: stgccflags (stgdef.h)
         decode(ccflag_stg,
             8194, 'NO MEMCOMPRESS',
             8196, 'MEMCOMPRESS FOR QUERY',
             8200, 'MEMCOMPRESS FOR CAPACITY',
             16384, 'DISABLED', null)
       else
         -- created segment: ktsscflg (ktscts.h)
         decode(bitand(s.spare1, 4362862139015168),
              281474976710656, 'DISABLED',
              703687441776640, 'NO MEMCOMPRESS',
             1266637395197952, 'MEMCOMPRESS FOR QUERY',
             2392537302040576, 'MEMCOMPRESS FOR CAPACITY', null)
       end,
       -- INMEMORY_SERVICE
       case when (bitand(tp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 32768), 32768,
                       decode(bitand(svc.svcflags, 7),
                              0, null,
                              1, 'DEFAULT',
                              2, 'NONE',
                              3, 'ALL',
                              4, 'USER_DEFINED', 'DEFAULT'), 'DEFAULT'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 9007199254740992), 9007199254740992,
                       decode(bitand(svc.svcflags, 7),
                              0, null,
                              1, 'DEFAULT',
                              2, 'NONE',
                              3, 'ALL',
                              4, 'USER_DEFINED', 'DEFAULT'), 'DEFAULT'),
                 null)
       end,
       -- INMEMORY_SERVICE_NAME
       case when (bitand(tp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 32768), 32768,
                       svc.svcname, null),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 9007199254740992), 9007199254740992,
                       svc.svcname, null),
                null)
       end,
       -- MEMOPTIMIZE_READ -> KKPACFRAGF_IMOLTP_KV
       decode(bitand(tp.flags, power(2,30)), power(2,30),
                               'ENABLED', 'DISABLED'),
       -- MEMOPTIMIZE_WRITE -> KKPACFRAGF_IMOLTP_INGEST
       decode(bitand(tp.flags, power(2,31)), power(2,31),
                               'ENABLED', 'DISABLED')
from   obj$ o, tabpart$ tp, ts$ ts, sys.seg$ s, user$ u, tab$ t,
       deferred_stg$ ds, imsvc$ svc
where  o.obj# = tp.obj# and ts.ts# = tp.ts# and u.user# = o.owner# and
       tp.obj# = ds.obj#(+) and
       tp.file#=s.file#(+) and tp.block#=s.block#(+) and tp.ts#=s.ts#(+) and
       bitand(t.property, 64) != 64 and
       tp.bo# = t.obj# and bitand(t.trigflag, 1073741824) != 1073741824 and
       o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
       bitand(tp.flags, 8388608) = 0 and   /* filter out hidden partitions */
       (o.owner# = userenv('SCHEMAID')
        or tp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      ) and o.obj# = svc.obj# (+) and svc.subpart#(+) is null
union all -- IOT PARTITIONS
select u.name, o.name, 'NO', o.subname, 0,
       tp.hiboundval, tp.hiboundlen,
       row_number() over (partition by u.name, o.name order by tp.part#), NULL,
       TO_NUMBER(NULL),TO_NUMBER(NULL),TO_NUMBER(NULL),TO_NUMBER(NULL),
       TO_NUMBER(NULL), TO_NUMBER(NULL),
       TO_NUMBER(NULL),TO_NUMBER(NULL),TO_NUMBER(NULL),TO_NUMBER(NULL),
       TO_NUMBER(NULL),TO_NUMBER(NULL),
       NULL,
       'N/A', 'N/A',
       tp.rowcnt, TO_NUMBER(NULL), TO_NUMBER(NULL), 0, tp.chncnt, tp.avgrln,
       tp.samplesize, tp.analyzetime, NULL, NULL, NULL,
       decode(bitand(tp.flags, 16), 0, 'NO', 'YES'),
       decode(bitand(tp.flags, 8), 0, 'NO', 'YES'),
       'N/A', 'N/A', 'N/A',
       decode(bitand(tp.flags, 65536), 65536, 'NO', 'YES'),
       decode(bitand(tp.flags, 2097152), 2097152, 'OFF', 'ON'),
       decode(bitand(tp.flags, 67108864), 67108864, 'YES', 'NO'),
       'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A', 'N/A',
       'N/A', 'N/A'
from   obj$ o, tabpart$ tp, user$ u, tab$ t
where  o.obj# = tp.obj# and o.owner# = u.user# and
       tp.bo# = t.obj# and
       bitand(t.trigflag, 1073741824) != 1073741824 and
       bitand(t.property, 64) = 64 and
       o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
       (o.owner# = userenv('SCHEMAID')
        or tp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
union all -- COMPOSITE PARTITIONS
select u.name, o.name, 'YES', o.subname, tcp.subpartcnt,
       tcp.hiboundval, tcp.hiboundlen,
       row_number() over (partition by u.name, o.name order by tcp.part#),
       ts.name, tcp.defpctfree,
       decode(bitand(ts.flags, 32), 32, to_number(NULL), tcp.defpctused),
       tcp.definitrans, tcp.defmaxtrans,
       tcp.definiexts, tcp.defextsize, tcp.defminexts, tcp.defmaxexts,
       tcp.defmaxsize, tcp.defextpct,
       decode(bitand(ts.flags, 32), 32, to_number(NULL), tcp.deflists),
       decode(bitand(ts.flags, 32), 32, to_number(NULL), tcp.defgroups),
       decode(tcp.deflogging, 0, 'NONE', 1, 'YES', 2, 'NO', 'UNKNOWN'),
       decode(bitand(tcp.spare2, 3), 1, 'ENABLED', 2, 'DISABLED', 'NONE'),
       decode(bitand(tcp.spare2, 1), 0, null,
         case bitand(tcp.spare2, 127) -- 1st 7 bits used
         when 1 then 'BASIC'                             -- 00000001
         when 5 then 'ADVANCED'                          -- 00000101
         when 9 then 'QUERY LOW'                         -- 00001001
         when 17 then 'QUERY HIGH'                       -- 00010001
         when 25 then 'ARCHIVE LOW'                      -- 00011001
         when 33 then 'ARCHIVE HIGH'                     -- 00100001
         when 73 then 'QUERY LOW ROW LEVEL LOCKING'      -- 01001001
         when 81 then 'QUERY HIGH ROW LEVEL LOCKING'     -- 01010001
         when 89 then 'ARCHIVE LOW ROW LEVEL LOCKING'    -- 01011001
         when 97 then 'ARCHIVE HIGH ROW LEVEL LOCKING'   -- 01100001
                 else 'UNKNOWN' end),                    -- internal
       tcp.rowcnt, tcp.blkcnt, tcp.empcnt, tcp.avgspc, tcp.chncnt, tcp.avgrln,
       tcp.samplesize, tcp.analyzetime,
       decode(bitand(tcp.defbufpool, 3), 1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(tcp.defbufpool, 12)/4, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(tcp.defbufpool, 48)/16, 1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(tcp.flags, 16), 0, 'NO', 'YES'),
       decode(bitand(tcp.flags, 8), 0, 'NO', 'YES'),
       'N/A', 'N/A',
       decode(bitand(tcp.flags, 32768), 32768, 'YES', 'NO'),
       decode(bitand(tcp.spare2, 768), 256, 'NO', 512, 'YES', 'NONE'),
       decode(bitand(tcp.spare2, 3072), 1024, 'ON', 2048, 'OFF', 'NONE'),
       decode(bitand(tcp.spare2, 12288), 4096, 'YES',8192, 'NO','NONE'),
       -- INMEMORY
       -- defimcflags_kkpacpcd
       decode(bitand(tcp.spare2, 196608),
              0,      'NONE',
              65536,  'ENABLED',
              131072, 'DISABLED', 'UNKNOWN'),
       -- INMEMORY_PRIORITY
       case bitand(mod(trunc(tcp.spare2/65536),4096), 17) -- bits 0,4
         when 0 then NULL
         when 1 then
           case bitand(mod(trunc(tcp.spare2/268435456),16), 7)
             when 0 then 'NONE'
             else NULL end
         when 17 then
           case bitand(mod(trunc(tcp.spare2/268435456),16), 7)
             when 0 then 'NONE'
             when 1 then 'LOW'
             when 2 then 'MEDIUM'
             when 3 then 'HIGH'
             when 4 then 'CRITICAL'
             else 'UNKNOWN' end
         else 'UNKNOWN' end,
       -- INMEMORY_DISTRIBUTE
       decode(bitand(tcp.spare2, 65536), 65536,
              decode(bitand(tcp.spare2, 262144), 262144,
                     decode(bitand(tcp.spare2, (2097152+4194304)),
                     0,         'AUTO',
                     2097152,   'BY ROWID RANGE',
                     4194304,   'BY PARTITION',
                     6291456,   'BY SUBPARTITION'),
              null), null),
       -- INMEMORY_COMPRESSION
       decode(bitand(tcp.spare2, 65536), 65536,
              decode(bitand(tcp.spare2, (524288+8388608+16777216)),
                              524288,             'NO MEMCOMPRESS',
                              8388608,            'FOR DML',
                              (524288+8388608),   'FOR QUERY LOW',
                              16777216,           'FOR QUERY HIGH',
                              (524288+16777216),  'FOR CAPACITY LOW',
                              (8388608+16777216), 'FOR CAPACITY HIGH',
                     null),
              null),
       -- INMEMORY_DUPLICATE
       decode (bitand(tcp.spare2, 65536), 65536,
               decode(bitand(tcp.spare2, (67108864+134217728)),
                              67108864,   'NO DUPLICATE',
                              134217728,  'DUPLICATE',
                              (67108864+134217728),  'DUPLICATE ALL',
                null), null),
       -- CELLMEMORY
       decode(bitand(tcp.spare2, 133143986176),
              8589934592,  'DISABLED',
              21474836480, 'NO MEMCOMPRESS',
              38654705664, 'MEMCOMPRESS FOR QUERY',
              73014444032, 'MEMCOMPRESS FOR CAPACITY',
              NULL),
       -- INMEMORY_SERVICE
       decode(bitand(tcp.spare2, 65536), 65536,
              decode(bitand(tcp.spare2, 1099511627776), 1099511627776,
                     decode(bitand(svc.svcflags, 7),
                            0, null,
                            1, 'DEFAULT',
                            2, 'NONE',
                            3, 'ALL',
                            4, 'USER_DEFINED',
                            'DEFAULT'),
                     null),
              null),
       -- INMEMORY_SERVICE_NAME
       decode(bitand(tcp.spare2, 65536), 65536,
              decode(bitand(tcp.spare2, 1099511627776), 1099511627776,
                     svc.svcname, null),
              null),
       'N/A', 'N/A'
from   obj$ o, tabcompart$ tcp, ts$ ts, user$ u, tab$ t, imsvc$ svc
where  o.obj# = tcp.obj# and tcp.defts# = ts.ts# and u.user# = o.owner# and
       tcp.bo# = t.obj#
       and bitand(t.trigflag, 1073741824) != 1073741824 and
       bitand(t.property, 64) != 64 and
       bitand(tcp.flags, 8388608) = 0 and   /* filter out hidden partitions */
       o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
       (o.owner# = userenv('SCHEMAID')
        or tcp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      ) and o.obj# = svc.obj# (+) and svc.subpart#(+) is null
;
--------------------------------------------------------
--  DDL for View ALL_TAB_PENDING_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_PENDING_STATS" ("OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "NUM_ROWS", "BLOCKS", "AVG_ROW_LEN", "IM_IMCU_COUNT", "IM_BLOCK_COUNT", "SCAN_RATE", "SAMPLE_SIZE", "LAST_ANALYZED") AS 
  select u.name, o.name, null, null, h.rowcnt, h.blkcnt, h.avgrln,
         h.im_imcu_count, h.im_block_count, h.scanrate, h.samplesize,
         h.analyzetime
  from   sys.user$ u, sys.obj$ o, sys.wri$_optstat_tab_history h
  where  h.obj# = o.obj# and o.type# = 2 and o.owner# = u.user#
    and  h.savtime > systimestamp
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  -- partitions
  select u.name, o.name, o.subname, null, h.rowcnt, h.blkcnt,
         h.avgrln, h.im_imcu_count, h.im_block_count, h.scanrate, h.samplesize,
         h.analyzetime
  from   sys.user$ u, sys.obj$ o, sys.obj$ ot,
         sys.wri$_optstat_tab_history h
  where h.obj# = o.obj# and o.type# = 19 and o.owner# = u.user#
        and ot.name = o.name and ot.type# = 2 and ot.owner# = u.user#
        and h.savtime > systimestamp
        and (ot.owner# = userenv('SCHEMAID')
        or ot.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                )
        )
  union all
  -- sub partitions
  select u.name, osp.name, ocp.subname, osp.subname, h.rowcnt,
         h.blkcnt, h.avgrln, h.im_imcu_count, h.im_block_count, h.scanrate,
         h.samplesize, h.analyzetime
  from  sys.user$ u, sys.obj$ osp, obj$ ocp,  sys.obj$ ot,
        sys.tabsubpart$ tsp, sys.wri$_optstat_tab_history h
  where h.obj# = osp.obj# and osp.type# = 34 and osp.obj# = tsp.obj# and
        tsp.pobj# = ocp.obj# and osp.owner# = u.user#
        and ot.name = ocp.name and ot.type# = 2 and ot.owner# = u.user#
        and  h.savtime > systimestamp
        and  (ot.owner# = userenv('SCHEMAID')
        or ot.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
        );

   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."OWNER" IS 'Name of the owner';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."PARTITION_NAME" IS 'Name of the partition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."SUBPARTITION_NAME" IS 'Name of the subpartition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."NUM_ROWS" IS 'Number of rows';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."BLOCKS" IS 'Number of blocks';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."AVG_ROW_LEN" IS 'Average row length';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."IM_IMCU_COUNT" IS 'Number of IMCUs in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."IM_BLOCK_COUNT" IS 'Number of inmemory blocks in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."SCAN_RATE" IS 'Scan rate for the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."SAMPLE_SIZE" IS 'Sample size';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PENDING_STATS"."LAST_ANALYZED" IS 'Time of last analyze';
   COMMENT ON TABLE "SYS"."ALL_TAB_PENDING_STATS"  IS 'Pending statistics of tables, partitions, and subpartitions'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_PRIVS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_PRIVS" ("GRANTOR", "GRANTEE", "TABLE_SCHEMA", "TABLE_NAME", "PRIVILEGE", "GRANTABLE", "HIERARCHY", "COMMON", "TYPE", "INHERITED") AS 
  select ur.name, ue.name, u.name, o.name,
       tpm.name,
       decode(mod(oa.option$,2), 1, 'YES', 'NO'),
       decode(bitand(oa.option$,2), 2, 'YES', 'NO'), 'NO',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW', 'UNKNOWN'),
       'NO'
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and oa.col# is null
  and u.user# = o.owner#
  and oa.privilege# = tpm.privilege
  and (oa.grantor# = userenv('SCHEMAID') or
       oa.grantee# in (select kzsrorol from x$kzsro) or
       o.owner# = userenv('SCHEMAID'))
  and bitand(nvl(oa.option$, 0), 4) = 0
  and (o.type# <> 13 or (o.type# = 13 and o.subname is null))
                                                      /* latest type version */
union all
/* Commonly granted Privileges */
select ur.name, ue.name, u.name, o.name,
       tpm.name,
       decode(bitand(oa.option$,16), 16, 'YES', 'NO'),
       decode(bitand(oa.option$,32), 32, 'YES', 'NO'), 'YES',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW', 'UNKNOWN'),
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and oa.col# is null
  and u.user# = o.owner#
  and oa.privilege# = tpm.privilege
  and (oa.grantor# = userenv('SCHEMAID') or
       oa.grantee# in (select kzsrorol from x$kzsro) or
       o.owner# = userenv('SCHEMAID'))
  and bitand(oa.option$,8) = 8
  and (o.type# <> 13 or (o.type# = 13 and o.subname is null))
                                                      /* latest type version */
union all
/* Federationally granted Privileges */
select ur.name, ue.name, u.name, o.name,
       tpm.name,
       decode(bitand(oa.option$,128), 128, 'YES', 'NO'),
       decode(bitand(oa.option$,256), 256, 'YES', 'NO'), 'YES',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW', 'UNKNOWN'),
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and oa.col# is null
  and u.user# = o.owner#
  and oa.privilege# = tpm.privilege
  and (oa.grantor# = userenv('SCHEMAID') or
       oa.grantee# in (select kzsrorol from x$kzsro) or
       o.owner# = userenv('SCHEMAID'))
  and bitand(oa.option$,64) = 64
  and (o.type# <> 13 or (o.type# = 13 and o.subname is null))
                                                      /* latest type version */
union all
/* Locally granted User privileges */
select ur.name, ue.name, u.name, u.name, upm.name,
       decode(bitand(ua.option$,1), 1, 'YES', 'NO'),
       'NO',
       'NO',
       'USER',
       'NO'
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and (ua.grantor# = userenv('SCHEMAID') or
       ua.grantee# in (select kzsrorol from x$kzsro) or
       ua.user# = userenv('SCHEMAID'))
  and bitand(nvl(ua.option$, 0), 4) = 0
union all
/* Commonly granted User privileges */
select ur.name, ue.name, u.name, u.name, upm.name,
       decode(bitand(ua.option$,16), 16, 'YES', 'NO'),
       'NO',
       'YES',
       'USER',
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and (ua.grantor# = userenv('SCHEMAID') or
       ua.grantee# in (select kzsrorol from x$kzsro) or
       ua.user# = userenv('SCHEMAID'))
  and bitand(ua.option$,8) = 8
union all
/* Federationally granted User privileges */
select ur.name, ue.name, u.name, u.name, upm.name,
       decode(bitand(ua.option$,128), 128, 'YES', 'NO'),
       'NO',
       'YES',
       'USER',
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and (ua.grantor# = userenv('SCHEMAID') or
       ua.grantee# in (select kzsrorol from x$kzsro) or
       ua.user# = userenv('SCHEMAID'))
  and bitand(ua.option$,64) = 64;

   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."GRANTOR" IS 'Name of the user who performed the grant';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."GRANTEE" IS 'Name of the user to whom access was granted';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."TABLE_SCHEMA" IS 'Schema of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."PRIVILEGE" IS 'Table Privilege';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."GRANTABLE" IS 'Privilege is grantable';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."HIERARCHY" IS 'Privilege is with hierarchy option';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."COMMON" IS 'Privilege was granted commonly';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS"."INHERITED" IS 'Was privilege grant inherited from another container';
   COMMENT ON TABLE "SYS"."ALL_TAB_PRIVS"  IS 'Grants on objects for which the user is the grantor, grantee, owner,
 or an enabled role or PUBLIC is the grantee'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_PRIVS_MADE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_PRIVS_MADE" ("GRANTEE", "OWNER", "TABLE_NAME", "GRANTOR", "PRIVILEGE", "GRANTABLE", "HIERARCHY", "COMMON", "TYPE", "INHERITED") AS 
  select ue.name, u.name, o.name,
       ur.name, tpm.name,
       decode(mod(oa.option$,2), 1, 'YES', 'NO'),
       decode(bitand(oa.option$,2), 2, 'YES', 'NO'), 'NO',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW', 'UNKNOWN'),
       'NO'
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.col# is null
  and oa.privilege# = tpm.privilege
  and userenv('SCHEMAID') in (o.owner#, oa.grantor#)
  and bitand(nvl(oa.option$, 0), 4) = 0
union all
/* Commonly granted Privileges */
select ue.name, u.name, o.name,
       ur.name, tpm.name,
       decode(bitand(oa.option$,16), 16, 'YES', 'NO'),
       decode(bitand(oa.option$,32), 32, 'YES', 'NO'), 'YES',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE', 'UNKNOWN'),
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.col# is null
  and oa.privilege# = tpm.privilege
  and userenv('SCHEMAID') in (o.owner#, oa.grantor#)
  and bitand(oa.option$,8) = 8
union all
/* Federationally granted Privileges */
select ue.name, u.name, o.name,
       ur.name, tpm.name,
       decode(bitand(oa.option$,128), 128, 'YES', 'NO'),
       decode(bitand(oa.option$,256), 256, 'YES', 'NO'), 'YES',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE', 'UNKNOWN'),
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.col# is null
  and oa.privilege# = tpm.privilege
  and userenv('SCHEMAID') in (o.owner#, oa.grantor#)
  and bitand(oa.option$,64) = 64
union all
/* Locally granted User privileges */
select ue.name, 'SYS', u.name,
       ur.name, upm.name,
       decode(bitand(ua.option$,1), 1, 'YES', 'NO'),
       'NO',
       'NO',
       'USER',
       'NO'
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and ua.user# = userenv('SCHEMAID')
  and bitand(nvl(ua.option$, 0), 4) = 0
union all
/* Commonly granted User privileges */
select ue.name, 'SYS', u.name,
       ur.name, upm.name,
       decode(bitand(ua.option$,16), 16, 'YES', 'NO'),
       'NO',
       'YES',
       'USER',
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and ua.user# = userenv('SCHEMAID')
  and bitand(nvl(ua.option$, 0), 8) = 8
union all
/* Federationally granted User privileges */
select ue.name, 'SYS', u.name,
       ur.name, upm.name,
       decode(bitand(ua.option$,128), 128, 'YES', 'NO'),
       'NO',
       'YES',
       'USER',
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and ua.user# = userenv('SCHEMAID')
  and bitand(nvl(ua.option$, 0), 64) = 64;

   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."GRANTEE" IS 'Name of the user to whom access was granted';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."GRANTOR" IS 'Name of the user who performed the grant';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."PRIVILEGE" IS 'Table Privilege';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."GRANTABLE" IS 'Privilege is grantable';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."HIERARCHY" IS 'Privilege is with hierarchy option';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."COMMON" IS 'Privilege was granted commonly';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_MADE"."INHERITED" IS 'Was privilege grant inherited from another container';
   COMMENT ON TABLE "SYS"."ALL_TAB_PRIVS_MADE"  IS 'User''s grants and grants on user''s objects'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_PRIVS_RECD
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_PRIVS_RECD" ("GRANTEE", "OWNER", "TABLE_NAME", "GRANTOR", "PRIVILEGE", "GRANTABLE", "HIERARCHY", "COMMON", "TYPE", "INHERITED") AS 
  select ue.name, u.name, o.name,
       ur.name, tpm.name,
       decode(mod(oa.option$,2), 1, 'YES', 'NO'),
       decode(bitand(oa.option$,2), 2, 'YES', 'NO'), 'NO',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW', 'UNKNOWN'),
       'NO'
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.col# is null
  and oa.privilege# = tpm.privilege
  and oa.grantee# in (select kzsrorol from x$kzsro)
  and bitand(nvl(oa.option$, 0), 4) = 0
union all
/* Commonly granted Privileges */
select ue.name, u.name, o.name,
       ur.name, tpm.name,
       decode(bitand(oa.option$,16), 16, 'YES', 'NO'),
       decode(bitand(oa.option$,32), 32, 'YES', 'NO'), 'YES',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE',
                      150, 'HIERARCHY',
                      151, 'ATTRIBUTE DIMENSION',
                      152, 'ANALYTIC VIEW', 'UNKNOWN'),
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.col# is null
  and oa.privilege# = tpm.privilege
  and oa.grantee# in (select kzsrorol from x$kzsro)
  and bitand(oa.option$,8) = 8
union all
/* Federationally granted Privileges */
select ue.name, u.name, o.name,
       ur.name, tpm.name,
       decode(bitand(oa.option$,128), 128, 'YES', 'NO'),
       decode(bitand(oa.option$,256), 256, 'YES', 'NO'), 'YES',
       decode (o.type#, 1, 'INDEX',
                        2, 'TABLE',
                        3, 'CLUSTER',
                        4, 'VIEW',
                        5, 'SYNONYM',
                        6, 'SEQUENCE',
                        7, 'PROCEDURE',
                        8, 'FUNCTION',
                        9, 'PACKAGE',
                       10, 'NON-EXISTENT',
                       11, 'PACKAGE BODY',
                       12, 'TRIGGER',
                       13, 'TYPE',
                       14, 'TYPE BODY',
                       19, 'TABLE PARTITION',
                       20, 'INDEX PARTITION',
                       21, 'LOB',
                       22, 'LIBRARY',
                       23, 'DIRECTORY',
                       24, 'QUEUE',
                       25, 'IOT',
                       26, 'REPLICATION OBJECT GROUP',
                       27, 'REPLICATION PROPAGATOR',
                       28, 'JAVA SOURCE',
                       29, 'JAVA CLASS',
                       30, 'JAVA RESOURCE',
                       31, 'JAVA JAR',
                       32, 'INDEXTYPE',
                       33, 'OPERATOR',
                       34, 'TABLE SUBPARTITION',
                       35, 'INDEX SUBPARTITION',
                       57, 'EDITION',
                       82, '(Data Mining) MODEL',
                       92, 'CUBE DIMENSION',
                       93, 'CUBE',
                       94, 'MEASURE FOLDER',
                       95, 'CUBE BUILD PROCESS',
                      100, 'FILE WATCHER',
                      101, 'DESTINATION',
                      114, 'SQL TRANSLATION PROFILE', 'UNKNOWN'),
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.objauth$ oa, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ ur,
     sys.user$ ue, table_privilege_map tpm
where oa.obj# = o.obj#
  and oa.grantor# = ur.user#
  and oa.grantee# = ue.user#
  and u.user# = o.owner#
  and oa.col# is null
  and oa.privilege# = tpm.privilege
  and oa.grantee# in (select kzsrorol from x$kzsro)
  and bitand(oa.option$,64) = 64
union all
/* Locally granted User privileges */
select ue.name, 'SYS', u.name,
       ur.name, upm.name,
       decode(bitand(ua.option$,1), 1, 'YES', 'NO'),
       'NO',
       'NO',
       'USER',
       'NO'
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and ua.grantee# in (select kzsrorol from x$kzsro)
  and bitand(nvl(ua.option$, 0), 4) = 0
union all
/* Commonly granted User privileges */
select ue.name, 'SYS', u.name,
       ur.name, upm.name,
       decode(bitand(ua.option$,16), 16, 'YES', 'NO'),
       'NO',
       'YES',
       'USER',
       decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES')
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and ua.grantee# in (select kzsrorol from x$kzsro)
  and bitand(ua.option$,8) = 8
union all
/* Federationally granted User privileges */
select ue.name, 'SYS', u.name,
       ur.name, upm.name,
       decode(bitand(ua.option$,128), 128, 'YES', 'NO'),
       'NO',
       'YES',
       'USER',
       decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'), 'YES', 'YES', 'NO')
from sys.userauth$ ua, sys.user$ u, sys.user$ ur,
     sys.user$ ue, sys.user_privilege_map upm
where ua.user# = u.user#
  and ua.grantor# = ur.user#
  and ua.grantee# = ue.user#
  and ua.privilege# = upm.privilege
  and ua.grantee# in (select kzsrorol from x$kzsro)
  and bitand(ua.option$,64) = 64;

   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."GRANTEE" IS 'Name of the user to whom access was granted';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."TABLE_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."GRANTOR" IS 'Name of the user who performed the grant';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."PRIVILEGE" IS 'Table Privilege';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."GRANTABLE" IS 'Privilege is grantable';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."HIERARCHY" IS 'Privilege is with hierarchy option';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."COMMON" IS 'Privilege was granted commonly';
   COMMENT ON COLUMN "SYS"."ALL_TAB_PRIVS_RECD"."INHERITED" IS 'Was privilege grant inherited from another container';
   COMMENT ON TABLE "SYS"."ALL_TAB_PRIVS_RECD"  IS 'Grants on objects for which the user, PUBLIC or enabled role is the grantee'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_STATISTICS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_STATISTICS" ("OWNER", "TABLE_NAME", "PARTITION_NAME", "PARTITION_POSITION", "SUBPARTITION_NAME", "SUBPARTITION_POSITION", "OBJECT_TYPE", "NUM_ROWS", "BLOCKS", "EMPTY_BLOCKS", "AVG_SPACE", "CHAIN_CNT", "AVG_ROW_LEN", "AVG_SPACE_FREELIST_BLOCKS", "NUM_FREELIST_BLOCKS", "AVG_CACHED_BLOCKS", "AVG_CACHE_HIT_RATIO", "IM_IMCU_COUNT", "IM_BLOCK_COUNT", "IM_STAT_UPDATE_TIME", "SCAN_RATE", "SAMPLE_SIZE", "LAST_ANALYZED", "GLOBAL_STATS", "USER_STATS", "STATTYPE_LOCKED", "STALE_STATS", "SCOPE") AS 
  SELECT /* TABLES */
    u.name, o.name, NULL, NULL, NULL, NULL, 'TABLE', t.rowcnt,
    decode(bitand(t.property, 64), 0, t.blkcnt, TO_NUMBER(NULL)),
    decode(bitand(t.property, 64), 0, t.empcnt, TO_NUMBER(NULL)),
    decode(bitand(t.property, 64), 0, t.avgspc, TO_NUMBER(NULL)),
    t.chncnt, t.avgrln, t.avgspc_flb,
    decode(bitand(t.property, 64), 0, t.flbcnt, TO_NUMBER(NULL)),
    ts.cachedblk, ts.cachehit, ts.im_imcu_count, ts.im_block_count,
    ts.im_stat_update_time, ts.scanrate, t.samplesize, t.analyzetime,
    decode(bitand(t.flags, 512), 0, 'NO', 'YES'),
    decode(bitand(t.flags, 256), 0, 'NO', 'YES'),
    decode(bitand(t.trigflag, 67108864) + bitand(t.trigflag, 134217728),
           0, NULL, 67108864, 'DATA', 134217728, 'CACHE', 'ALL'),
    case
      when t.analyzetime is null then null
      -- 1 represents metadata linked table in root
      -- 5 represents sharded Catalog
      -- for metadata linked table in root or sharded table in coordinator
      -- since the PDB/SHARDS will not actively notify the App Root or
      -- coordinator of their status, the staleness of at the App Root for
      -- metadata linked table or the stats for sharded table in coordinator
      -- is unknown.
      when (dbms_stats_internal.get_tab_share_type_view(o.flags, t.property)
        in (1,5)) then 'UNKNOWN'
      when (dbms_stats_internal.is_stale(t.obj#, null,
              null,
              (m.inserts + m.deletes + m.updates),
              t.rowcnt, m.flags) > 0) then 'YES'
      else  'NO'
    end,
    'SHARED'
  FROM
    sys.user$ u, sys.obj$ o, sys.tab$ t, sys.tab_stats$ ts, sys.mon_mods_v m
  WHERE
        o.owner# = u.user#
    and o.obj# = t.obj#
    and bitand(t.property, 1) = 0 /* not a typed table */
    and o.obj# = ts.obj# (+)
    and t.obj# = m.obj# (+)
    and o.subname IS NULL
    and bitand(o.flags, 128) = 0 -- not in recycle bin
    and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             FROM sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 FROM x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
    and bitand(o.flags, 131072) = 0 -- not a data link table
  UNION ALL
  SELECT /* PARTITIONS,  NOT IOT */
    u.name, o.name, o.subname, tp.part#, NULL, NULL, 'PARTITION',
    tp.rowcnt, tp.blkcnt, tp.empcnt, tp.avgspc,
    tp.chncnt, tp.avgrln, TO_NUMBER(NULL), TO_NUMBER(NULL),
    ts.cachedblk, ts.cachehit, ts.im_imcu_count, ts.im_block_count,
    ts.im_stat_update_time, ts.scanrate, tp.samplesize, tp.analyzetime,
    decode(bitand(tp.flags, 16), 0, 'NO', 'YES'),
    decode(bitand(tp.flags, 8), 0, 'NO', 'YES'),
    decode(
      /*
       * Following decode returns 1 if DATA stats locked for partition
       * or at table level
       */
      decode(bitand(tab.trigflag, 67108864) + bitand(tp.flags, 32), 0, 0, 1) +
      /*
       * Following decode returns 2 if CACHE stats locked for partition
       * or at table level
       */
      decode(bitand(tab.trigflag, 134217728) + bitand(tp.flags, 64), 0, 0, 2),
      /* if 0 => not locked, 3 => data and cache stats locked */
      0, NULL, 1, 'DATA', 2, 'CACHE', 'ALL'),
    case
      when tp.analyzetime is null then null
      when (dbms_stats_internal.is_stale(tab.obj#, null,
              null,
              (m.inserts + m.deletes + m.updates),
              tp.rowcnt, m.flags) > 0) then 'YES'
      else  'NO'
    end,
    'SHARED'
  FROM
    sys.user$ u, sys.obj$ o, sys.tabpartv$ tp, sys.tab_stats$ ts, sys.tab$ tab,
    sys.mon_mods_v m
  WHERE
        o.owner# = u.user#
    and o.obj# = tp.obj#
    and tp.bo# = tab.obj#
    and bitand(tab.property, 64) = 0
    and o.obj# = ts.obj# (+)
    and tp.obj# = m.obj# (+)
    and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
    and bitand(o.flags, 128) = 0 -- not in recycle bin
    and (o.owner# = userenv('SCHEMAID')
        or tp.bo# in
            (select oa.obj#
             FROM sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 FROM x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
  UNION ALL
  SELECT /* IOT Partitions */
    u.name, o.name, o.subname, tp.part#, NULL, NULL, 'PARTITION',
    tp.rowcnt, TO_NUMBER(NULL), TO_NUMBER(NULL), TO_NUMBER(NULL),
    tp.chncnt, tp.avgrln, TO_NUMBER(NULL), TO_NUMBER(NULL), TO_NUMBER(NULL),
    TO_NUMBER(NULL), TO_NUMBER(NULL), TO_NUMBER(NULL),
    TO_TIMESTAMP(NULL), TO_NUMBER(NULL), tp.samplesize, tp.analyzetime,
    decode(bitand(tp.flags, 16), 0, 'NO', 'YES'),
    decode(bitand(tp.flags, 8), 0, 'NO', 'YES'),
    decode(
      /*
       * Following decode returns 1 if DATA stats locked for partition
       * or at table level
       */
      decode(bitand(tab.trigflag, 67108864) + bitand(tp.flags, 32), 0, 0, 1) +
      /*
       * Following decode returns 2 if CACHE stats locked for partition
       * or at table level
       */
      decode(bitand(tab.trigflag, 134217728) + bitand(tp.flags, 64), 0, 0, 2),
      /* if 0 => not locked, 3 => data and cache stats locked */
      0, NULL, 1, 'DATA', 2, 'CACHE', 'ALL'),
    case
      when tp.analyzetime is null then null
      when (dbms_stats_internal.is_stale(tab.obj#, null,
              null,
              (m.inserts + m.deletes + m.updates),
              tp.rowcnt, m.flags) > 0) then 'YES'
      else 'NO'
    end,
    'SHARED'
  FROM
    sys.user$ u, sys.obj$ o, sys.tabpartv$ tp, sys.tab$ tab, sys.mon_mods_v m
  WHERE
        o.owner# = u.user#
    and o.obj# = tp.obj#
    and tp.bo# = tab.obj#
    and bitand(tab.property, 64) = 64
    and tp.obj# = m.obj# (+)
    and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
    and bitand(o.flags, 128) = 0 -- not in recycle bin
    and (o.owner# = userenv('SCHEMAID')
        or tp.bo# in
            (select oa.obj#
             FROM sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 FROM x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
  UNION ALL
  SELECT /* COMPOSITE PARTITIONS */
    u.name, o.name, o.subname, tcp.part#, NULL, NULL, 'PARTITION',
    tcp.rowcnt, tcp.blkcnt, tcp.empcnt, tcp.avgspc,
    tcp.chncnt, tcp.avgrln, NULL, NULL, ts.cachedblk, ts.cachehit,
    ts.im_imcu_count, ts.im_block_count,
    ts.im_stat_update_time, ts.scanrate, tcp.samplesize, tcp.analyzetime,
    decode(bitand(tcp.flags, 16), 0, 'NO', 'YES'),
    decode(bitand(tcp.flags, 8), 0, 'NO', 'YES'),
    decode(
      /*
       * Following decode returns 1 if DATA stats locked for partition
       * or at table level
       */
      decode(bitand(tab.trigflag, 67108864) + bitand(tcp.flags, 32), 0, 0, 1) +
      /*
       * Following decode returns 2 if CACHE stats locked for partition
       * or at table level
       */
      decode(bitand(tab.trigflag, 134217728) + bitand(tcp.flags, 64), 0, 0, 2),
      /* if 0 => not locked, 3 => data and cache stats locked */
      0, NULL, 1, 'DATA', 2, 'CACHE', 'ALL'),
    case
      when tcp.analyzetime is null then null
      when (dbms_stats_internal.is_stale(tab.obj#, null,
              null,
              (m.inserts + m.deletes + m.updates),
              tcp.rowcnt, m.flags) > 0) then 'YES'
      else 'NO'
    end,
    'SHARED'
  FROM
    sys.user$ u, sys.obj$ o, sys.tabcompartv$ tcp,
    sys.tab_stats$ ts, sys.tab$ tab, sys.mon_mods_v m
  WHERE
        o.owner# = u.user#
    and o.obj# = tcp.obj#
    and tcp.bo# = tab.obj#
    and o.obj# = ts.obj# (+)
    and tcp.obj# = m.obj# (+)
    and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
    and bitand(o.flags, 128) = 0 -- not in recycle bin
    and (o.owner# = userenv('SCHEMAID')
        or tcp.bo# in
            (select oa.obj#
             FROM sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 FROM x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
  UNION ALL
  SELECT /* SUBPARTITIONS */
    u.name, po.name, po.subname, tcp.part#,  so.subname, tsp.subpart#,
   'SUBPARTITION', tsp.rowcnt,
    tsp.blkcnt, tsp.empcnt, tsp.avgspc,
    tsp.chncnt, tsp.avgrln, NULL, NULL,
    ts.cachedblk, ts.cachehit, ts.im_imcu_count, ts.im_block_count,
    ts.im_stat_update_time, ts.scanrate, tsp.samplesize, tsp.analyzetime,
    decode(bitand(tsp.flags, 16), 0, 'NO', 'YES'),
    decode(bitand(tsp.flags, 8), 0, 'NO', 'YES'),
    decode(
      /*
       * Following decode returns 1 if DATA stats locked for partition
       * or at table level.
       * Note that dbms_stats does n't allow locking subpartition stats.
       * If the composite partition is locked, all subpartitions are
       * considered locked. Hence decode checks for tcp entry.
       */
      decode(bitand(tab.trigflag, 67108864) + bitand(tcp.flags, 32), 0, 0, 1) +
      /*
       * Following decode returns 2 if CACHE stats locked for partition
       * or at table level
       */
      decode(bitand(tab.trigflag, 134217728) + bitand(tcp.flags, 64), 0, 0, 2),
      /* if 0 => not locked, 3 => data and cache stats locked */
      0, NULL, 1, 'DATA', 2, 'CACHE', 'ALL'),
    case
      when tsp.analyzetime is null then null
      when (dbms_stats_internal.is_stale(tab.obj#, null,
              null,
              (m.inserts + m.deletes + m.updates),
              tsp.rowcnt, m.flags) > 0) then 'YES'
      else  'NO'
    end,
    'SHARED'
  FROM
    sys.user$ u, sys.obj$ po, sys.obj$ so, sys.tabcompartv$ tcp,
    sys.tabsubpartv$ tsp,  sys.tab_stats$ ts, sys.tab$ tab, sys.mon_mods_v m
  WHERE
        so.obj# = tsp.obj#
    and po.obj# = tcp.obj#
    and tcp.obj# = tsp.pobj#
    and tcp.bo# = tab.obj#
    and u.user# = po.owner#
    and bitand(tab.property, 64) = 0
    and so.obj# = ts.obj# (+)
    and tsp.obj# = m.obj# (+)
    and po.namespace = 1 and po.remoteowner IS NULL and po.linkname IS NULL
    and bitand(po.flags, 128) = 0 -- not in recycle bin
    and (po.owner# = userenv('SCHEMAID')
         or tcp.bo# in
            (select oa.obj#
             FROM sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 FROM x$kzsro
                               )
            )
        or /* user has system privileges */
          exists (select null FROM v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
       )
  UNION ALL
  SELECT /* FIXED TABLES */
    'SYS', t.kqftanam, NULL, NULL, NULL, NULL, 'FIXED TABLE',
    decode(nvl(fobj.obj#, 0), 0, TO_NUMBER(NULL), st.rowcnt),
    TO_NUMBER(NULL), TO_NUMBER(NULL), TO_NUMBER(NULL), TO_NUMBER(NULL),
    decode(nvl(fobj.obj#, 0), 0, TO_NUMBER(NULL), st.avgrln),
    TO_NUMBER(NULL), TO_NUMBER(NULL), TO_NUMBER(NULL), TO_NUMBER(NULL),
    TO_NUMBER(NULL), TO_NUMBER(NULL), TO_TIMESTAMP(NULL), TO_NUMBER(NULL),
    decode(nvl(fobj.obj#, 0), 0, TO_NUMBER(NULL), st.samplesize),
    decode(nvl(fobj.obj#, 0), 0, TO_DATE(NULL), st.analyzetime),
    decode(nvl(fobj.obj#, 0), 0, NULL,
           decode(nvl(st.obj#, 0), 0, NULL, 'YES')),
    decode(nvl(fobj.obj#, 0), 0, NULL,
           decode(nvl(st.obj#, 0), 0, NULL,
                  decode(bitand(st.flags, 1), 0, 'NO', 'YES'))),
    decode(nvl(fobj.obj#, 0), 0, NULL,
           decode (bitand(fobj.flags, 67108864) +
                     bitand(fobj.flags, 134217728),
                   0, NULL, 67108864, 'DATA', 134217728, 'CACHE', 'ALL')),
    NULL,
    'SHARED'
    FROM sys.x$kqfta t, sys.fixed_obj$ fobj, sys.tab_stats$ st
    where
    t.kqftaobj = fobj.obj#(+)
    /*
     * if fobj and st are not in sync (happens when db open read only
     * after upgrade), do not display stats.
     */
    and t.kqftaver = fobj.timestamp (+) - to_date('01-01-1991', 'DD-MM-YYYY')
    and t.kqftaobj = st.obj#(+)
    and (userenv('SCHEMAID') = 0  /* SYS */
         or /* user has system privileges */
         exists (select null FROM v$enabledprivs
                 where priv_number in (-237 /* SELECT ANY DICTIONARY */)
                 )
        )
  UNION ALL
  SELECT /* session private stats for GTT */
    u.name, o.name, NULL, NULL, NULL, NULL, 'TABLE', ses.rowcnt_kxttst_ts,
    decode(bitand(t.property, 64), 0, ses.blkcnt_kxttst_ts, TO_NUMBER(NULL)),
                                         /* property is 64 when IOT */
    decode(bitand(t.property, 64), 0, ses.empcnt_kxttst_ts, TO_NUMBER(NULL)),
    decode(bitand(t.property, 64), 0, ses.avgspc_kxttst_ts, TO_NUMBER(NULL)),
    ses.chncnt_kxttst_ts, ses.avgrln_kxttst_ts, ses.avgspc_flb_kxttst_ts,
    decode(bitand(t.property, 64), 0, ses.flbcnt_kxttst_ts, TO_NUMBER(NULL)),
    ses.cachedblk_kxttst_ts, ses.cachehit_kxttst_ts, null, null, null, null,
    ses.samplesize_kxttst_ts, ses.analyzetime_kxttst_ts,
    /* kketsflg = 8 (KQLDTVCF_GLS) */
    decode(bitand(ses.flags_kxttst_ts, 8), 0, 'NO', 'YES'),
    /* kketsflg = 4 (KQLDTVCF_USS) */
    decode(bitand(ses.flags_kxttst_ts, 4), 0, 'NO', 'YES'),
    null,  /* no lock on session private stats */
    null,  /* session based dml monitoring not available */
    'SESSION'
  FROM
    sys.x$kxttstets ses,
    sys.user$ u, sys.obj$ o, sys.tab$ t
  WHERE
        o.owner# = u.user#
    and o.obj# = t.obj#
    and t.obj# = ses.obj#_kxttst_ts
    and bitand(t.property, 1) = 0 /* not a typed table */
    and o.subname IS NULL
    and bitand(o.flags, 128) = 0 -- not in recycle bin
    and o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             FROM sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 FROM x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null FROM v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
  UNION ALL
  SELECT /* Data link table statistics */
    owner, table_name, NULL, NULL, NULL,
    NULL, object_type, num_rows, blocks, empty_blocks,
    avg_space, chain_cnt, avg_row_len, avg_space_freelist_blocks,
    num_freelist_blocks, avg_cached_blocks, avg_cache_hit_ratio, im_imcu_count,
    im_block_count, im_stat_update_time, scan_rate, sample_size, last_analyzed,
    global_stats, user_stats, stattype_locked, stale_stats, scope
  FROM INT$DATA_LINK_TAB_STATISTICS
  WHERE (owner = sys_context('USERENV', 'CURRENT_USER')
         or OBJ_ID(owner, table_name, object_type#, object_id) in
            (select oa.obj#
             FROM sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 FROM x$kzsro
                               )
            )
         or /* user has system privileges */
         ora_check_sys_privilege (sys_context('USERENV', 'CURRENT_USERID'),
                                  object_type#) = 1
        )
    and (
         (APPLICATION = 1 and
          (SYS_CONTEXT('USERENV','IS_APPLICATION_ROOT') = 'YES' or
           ORIGIN_CON_ID = CON_NAME_TO_ID(SYS_CONTEXT('USERENV',
                                                      'APPLICATION_NAME'))))
         or
         (APPLICATION = 0 and ORIGIN_CON_ID = 1)
        );

   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."PARTITION_NAME" IS 'Name of the partition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."PARTITION_POSITION" IS 'Position of the partition within table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."SUBPARTITION_NAME" IS 'Name of the subpartition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."SUBPARTITION_POSITION" IS 'Position of the subpartition within partition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."OBJECT_TYPE" IS 'Type of the object (TABLE, PARTITION, SUBPARTITION)';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."NUM_ROWS" IS 'The number of rows in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."BLOCKS" IS 'The number of used blocks in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."EMPTY_BLOCKS" IS 'The number of empty blocks in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."AVG_SPACE" IS 'The average available free space in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."CHAIN_CNT" IS 'The number of chained rows in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."AVG_ROW_LEN" IS 'The average row length, including row overhead';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."AVG_SPACE_FREELIST_BLOCKS" IS 'The average freespace of all blocks on a freelist';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."NUM_FREELIST_BLOCKS" IS 'The number of blocks on the freelist';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."AVG_CACHED_BLOCKS" IS 'Average number of blocks in buffer cache';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."AVG_CACHE_HIT_RATIO" IS 'Average cache hit ratio for the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."IM_IMCU_COUNT" IS 'Number of IMCUs in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."IM_BLOCK_COUNT" IS 'Number of inmemory blocks in the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."IM_STAT_UPDATE_TIME" IS 'The timestamp of the most recent update to the inmemory statistics';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."SCAN_RATE" IS 'Scan rate for the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."SAMPLE_SIZE" IS 'The sample size used in analyzing this table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."LAST_ANALYZED" IS 'The date of the most recent time this table was analyzed';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."GLOBAL_STATS" IS 'Are the statistics calculated without merging underlying partitions?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."USER_STATS" IS 'Were the statistics entered directly by the user?';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."STATTYPE_LOCKED" IS 'type of statistics lock';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."STALE_STATS" IS 'Whether statistics for the object is stale or not';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATISTICS"."SCOPE" IS 'whether statistics for the object is shared or session';
   COMMENT ON TABLE "SYS"."ALL_TAB_STATISTICS"  IS 'Optimizer statistics for all tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_STAT_PREFS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_STAT_PREFS" ("OWNER", "TABLE_NAME", "PREFERENCE_NAME", "PREFERENCE_VALUE") AS 
  select u.name, o.name, p.pname, p.valchar
from  sys.optstat_user_prefs$ p, obj$ o, user$ u
where p.obj#=o.obj#
  and u.user#=o.owner#
  and o.type#=2
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
        );

   COMMENT ON COLUMN "SYS"."ALL_TAB_STAT_PREFS"."OWNER" IS 'Name of the owner';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STAT_PREFS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STAT_PREFS"."PREFERENCE_NAME" IS 'Preference name';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STAT_PREFS"."PREFERENCE_VALUE" IS 'Preference value';
   COMMENT ON TABLE "SYS"."ALL_TAB_STAT_PREFS"  IS 'Statistics preferences for tables'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_STATS_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_STATS_HISTORY" ("OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "STATS_UPDATE_TIME") AS 
  select /*+ rule */ u.name, o.name, null, null, h.savtime
  from sys.user$ u, sys.obj$ o, sys.wri$_optstat_tab_history h
  where  h.obj# = o.obj# and o.type# = 2 and o.owner# = u.user#
    and  h.savtime <= systimestamp  -- exclude pending statistics
    and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      )
  union all
  -- partitions
  select u.name, o.name, o.subname, null, h.savtime
  from  sys.user$ u, sys.obj$ o, sys.obj$ ot,
        sys.wri$_optstat_tab_history h
  where h.obj# = o.obj# and o.type# = 19 and o.owner# = u.user#
        and ot.name = o.name and ot.type# = 2 and ot.owner# = u.user#
        and h.savtime <= systimestamp  -- exclude pending statistics
        and (ot.owner# = userenv('SCHEMAID')
        or ot.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                )
        )
  union all
  -- sub partitions
  select u.name, osp.name, ocp.subname, osp.subname, h.savtime
  from  sys.user$ u, sys.obj$ osp, obj$ ocp,  sys.obj$ ot,
        sys.tabsubpart$ tsp, sys.wri$_optstat_tab_history h
  where h.obj# = osp.obj# and osp.type# = 34 and osp.obj# = tsp.obj#
        and tsp.pobj# = ocp.obj# and osp.owner# = u.user#
        and ot.name = ocp.name and ot.type# = 2 and ot.owner# = u.user#
        and h.savtime <= systimestamp  -- exclude pending statistics
        and (ot.owner# = userenv('SCHEMAID')
        or ot.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                 )
        )
  union all
  -- fixed tables
  select 'SYS', t.kqftanam, null, null, h.savtime
  from  sys.x$kqfta t, sys.wri$_optstat_tab_history h
  where t.kqftaobj = h.obj#
    and  h.savtime <= systimestamp  -- exclude pending statistics
    and (userenv('SCHEMAID') = 0  /* SYS */
         or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-237 /* SELECT ANY DICTIONARY */)
                 )
        );

   COMMENT ON COLUMN "SYS"."ALL_TAB_STATS_HISTORY"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATS_HISTORY"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATS_HISTORY"."PARTITION_NAME" IS 'Name of the partition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATS_HISTORY"."SUBPARTITION_NAME" IS 'Name of the subpartition';
   COMMENT ON COLUMN "SYS"."ALL_TAB_STATS_HISTORY"."STATS_UPDATE_TIME" IS 'Time of statistics update';
   COMMENT ON TABLE "SYS"."ALL_TAB_STATS_HISTORY"  IS 'History of table statistics modifications'
;
--------------------------------------------------------
--  DDL for View ALL_TAB_SUBPARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TAB_SUBPARTITIONS" ("TABLE_OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "HIGH_VALUE", "HIGH_VALUE_LENGTH", "PARTITION_POSITION", "SUBPARTITION_POSITION", "TABLESPACE_NAME", "PCT_FREE", "PCT_USED", "INI_TRANS", "MAX_TRANS", "INITIAL_EXTENT", "NEXT_EXTENT", "MIN_EXTENT", "MAX_EXTENT", "MAX_SIZE", "PCT_INCREASE", "FREELISTS", "FREELIST_GROUPS", "LOGGING", "COMPRESSION", "COMPRESS_FOR", "NUM_ROWS", "BLOCKS", "EMPTY_BLOCKS", "AVG_SPACE", "CHAIN_CNT", "AVG_ROW_LEN", "SAMPLE_SIZE", "LAST_ANALYZED", "BUFFER_POOL", "FLASH_CACHE", "CELL_FLASH_CACHE", "GLOBAL_STATS", "USER_STATS", "INTERVAL", "SEGMENT_CREATED", "INDEXING", "READ_ONLY", "INMEMORY", "INMEMORY_PRIORITY", "INMEMORY_DISTRIBUTE", "INMEMORY_COMPRESSION", "INMEMORY_DUPLICATE", "INMEMORY_SERVICE", "INMEMORY_SERVICE_NAME", "CELLMEMORY", "MEMOPTIMIZE_READ", "MEMOPTIMIZE_WRITE") AS 
  select u.name, po.name, po.subname, so.subname,
       tsp.hiboundval, tsp.hiboundlen,
       dense_rank() over (partition by po.name order by tcp.part#),
       row_number() over (partition by u.name, po.name, po.subname
                          order by tsp.subpart#),
       ts.name, tsp.pctfree$,
       decode(bitand(ts.flags, 32), 32, to_number(NULL), tsp.pctused$),
       tsp.initrans, tsp.maxtrans,
       decode(bitand(tsp.flags, 65536), 65536,
              ds.initial_stg * ts.blocksize, s.iniexts * ts.blocksize),
       decode(bitand(tsp.flags, 65536), 65536,
              ds.next_stg * ts.blocksize, s.extsize * ts.blocksize),
       decode(bitand(tsp.flags, 65536), 65536, ds.minext_stg, s.minexts),
       decode(bitand(tsp.flags, 65536), 65536, ds.maxext_stg, s.maxexts),
       decode(bitand(tsp.flags, 65536), 65536,
              ds.maxsiz_stg * ts.blocksize,
              decode(bitand(s.spare1, 4194304), 4194304, bitmapranges, NULL)),
       decode(bitand(ts.flags, 3), 1, to_number(NULL),
              decode(bitand(tsp.flags, 65536), 65536, ds.pctinc_stg, s.extpct)),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(tsp.flags, 65536), 65536,
                     decode(ds.frlins_stg, 0, 1, ds.frlins_stg),
                     decode(s.lists, 0, 1, s.lists))),
       decode(bitand(ts.flags, 32), 32, to_number(NULL),
              decode(bitand(tsp.flags, 65536), 65536,
                     decode(ds.maxins_stg, 0, 1, ds.maxins_stg),
                     decode(s.groups, 0, 1, s.groups))),
       decode(mod(trunc(tsp.flags / 4), 2), 0, 'YES', 'NO'),
       case when (bitand(tsp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 4), 4, 'ENABLED', 'DISABLED')
       else
         decode(bitand(s.spare1, 2048), 2048, 'ENABLED', 'DISABLED')
       end,
       case when (bitand(tsp.flags, 65536) = 65536) then
          decode(bitand(ds.flags_stg, 4), 4,
          case when bitand(ds.cmpflag_stg, 3) = 1 then 'BASIC'
               when bitand(ds.cmpflag_stg, 3) = 2 then 'ADVANCED'
               else concat(decode(ds.cmplvl_stg, 1, 'QUERY LOW',
                                                 2, 'QUERY HIGH',
                                                 3, 'ARCHIVE LOW',
                                                    'ARCHIVE HIGH'),
                           decode(bitand(ds.flags_stg, 524288), 524288,
                                  ' ROW LEVEL LOCKING', '')) end,
           null)
       else
         decode(bitand(s.spare1, 2048), 0, null,
           case when bitand(s.spare1, 16777216) = 16777216
                     then 'ADVANCED'
                when bitand(s.spare1, 100663296) = 33554432  -- 0x2000000
                     then concat('QUERY LOW',
                                 decode(bitand(s.spare1, 2147483648),
                                        2147483648, ' ROW LEVEL LOCKING', ''))
                when bitand(s.spare1, 100663296) = 67108864  -- 0x4000000
                     then concat('QUERY HIGH',
                                 decode(bitand(s.spare1, 2147483648),
                                        2147483648, ' ROW LEVEL LOCKING', ''))
                when bitand(s.spare1, 100663296) = 100663296 -- 0x2000000+0x4000000
                     then concat('ARCHIVE LOW',
                                 decode(bitand(s.spare1, 2147483648),
                                        2147483648, ' ROW LEVEL LOCKING', ''))
                when bitand(s.spare1, 134217728) = 134217728 -- 0x8000000
                     then concat('ARCHIVE HIGH',
                                 decode(bitand(s.spare1, 2147483648),
                                        2147483648, ' ROW LEVEL LOCKING', ''))
                else 'BASIC' end)
       end,
       tsp.rowcnt, tsp.blkcnt, tsp.empcnt, tsp.avgspc, tsp.chncnt,
       tsp.avgrln, tsp.samplesize, tsp.analyzetime,
       decode(bitand(decode(bitand(tsp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 3),
              1, 'KEEP', 2, 'RECYCLE', 'DEFAULT'),
       decode(bitand(decode(bitand(tsp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 12)/4,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(decode(bitand(tsp.flags, 65536), 65536, ds.bfp_stg, s.cachehint), 48)/16,
              1, 'KEEP', 2, 'NONE', 'DEFAULT'),
       decode(bitand(tsp.flags, 16), 0, 'NO', 'YES'),
       decode(bitand(tsp.flags, 8), 0, 'NO', 'YES'),
       decode(bitand(tsp.flags, 32768), 32768, 'YES', 'NO'),
       decode(bitand(tsp.flags, 65536), 65536, 'NO', 'YES'),
       decode(bitand(tsp.flags, 2097152), 2097152, 'OFF', 'ON'),
       decode(bitand(tsp.flags, 67108864), 67108864, 'YES', 'NO'),
       --INMEMORY
       case when (bitand(tsp.flags, 65536) = 65536) then
          -- flags/imcflag_stg (stgdef.h
          decode(bitand(ds.flags_stg, 6291456),
                2097152, 'ENABLED',
                4194304, 'DISABLED', 'DISABLED')
       else
          -- ktsscflg (ktscts.h)
          decode(bitand(s.spare1, 70373039144960),
                4294967296, 'ENABLED',
                70368744177664, 'DISABLED', 'DISABLED')
       end,
       -- INMEMORY_PRIORITY
       case when (bitand(tsp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 4), 4,
                decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 7936),
                256, 'NONE',
                512, 'LOW',
                1024, 'MEDIUM',
                2048, 'HIGH',
                4096, 'CRITICAL', 'UNKNOWN'), null),
                'NONE'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 34359738368), 34359738368,
                decode(bitand(s.spare1, 61572651155456),
                8796093022208, 'LOW',
                17592186044416, 'MEDIUM',
                35184372088832, 'HIGH',
                52776558133248, 'CRITICAL', 'NONE'),
                'NONE'),
                null)
       end,
       -- INMEMORY_DISTRIBUTE
       case when (bitand(tsp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 1), 1,
                       decode(bitand(ds.imcflag_stg, (16+32)),
                              16,  'BY ROWID RANGE',
                              32,  'BY PARTITION',
                              48,  'BY SUBPARTITION',
                               0,  'AUTO'),
                  null), null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
               decode(bitand(s.spare1, 8589934592), 8589934592,
                        decode(bitand(s.spare1, 206158430208),
                        68719476736,   'BY ROWID RANGE',
                        137438953472,  'BY PARTITION',
                        206158430208,  'BY SUBPARTITION',
                        0,             'AUTO'),
                        null),
                  null)
       end,
       -- INMEMORY_COMPRESSION
       case when (bitand(tsp.flags, 65536) = 65536) then
        decode(bitand(ds.flags_stg, 2097152), 2097152,
               decode(bitand(ds.imcflag_stg, (2+8+64+128)),
                              2,   'NO MEMCOMPRESS',
                              8,  'FOR DML',
                              10,  'FOR QUERY LOW',
                              64, 'FOR QUERY HIGH',
                              66, 'FOR CAPACITY LOW',
                              72, 'FOR CAPACITY HIGH', 'UNKNOWN'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 841813590016),
                              17179869184,  'NO MEMCOMPRESS',
                              274877906944, 'FOR DML',
                              292057776128, 'FOR QUERY LOW',
                              549755813888, 'FOR QUERY HIGH',
                              566935683072, 'FOR CAPACITY LOW',
                              824633720832, 'FOR CAPACITY HIGH', 'UNKNOWN'),
                 null)
       end,
       -- INMEMORY_DUPLICATE
       case when (bitand(tsp.flags, 65536) = 65536) then
        decode(bitand(ds.flags_stg, 2097152), 2097152,
               decode(bitand(ds.imcflag_stg, (8192+16384)),
                              8192,   'NO DUPLICATE',
                              16384,  'DUPLICATE',
                              24576,  'DUPLICATE ALL',
                              null),
                null)
       else
          decode(bitand(s.spare1, 4294967296), 4294967296,
                   decode(bitand(s.spare1, 6597069766656),
                           2199023255552, 'NO DUPLICATE',
                           4398046511104, 'DUPLICATE',
                           6597069766656, 'DUPLICATE ALL', null),
                null)
       end,
       -- INMEMORY_SERVICE
       case when (bitand(tsp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 32768), 32768,
                       decode(bitand(svc.svcflags, 7),
                              0, null,
                              1, 'DEFAULT',
                              2, 'NONE',
                              3, 'ALL',
                              4, 'USER_DEFINED', 'DEFAULT'), 'DEFAULT'),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 9007199254740992), 9007199254740992,
                       decode(bitand(svc.svcflags, 7),
                              0, null,
                              1, 'DEFAULT',
                              2, 'NONE',
                              3, 'ALL',
                              4, 'USER_DEFINED', 'DEFAULT'), 'DEFAULT'),
                 null)
       end,
       -- INMEMORY_SERVICE_NAME
       case when (bitand(tsp.flags, 65536) = 65536) then
         decode(bitand(ds.flags_stg, 2097152), 2097152,
                decode(bitand(ds.imcflag_stg, 32768), 32768,
                       svc.svcname, null),
                null)
       else
         decode(bitand(s.spare1, 4294967296), 4294967296,
                decode(bitand(s.spare1, 9007199254740992), 9007199254740992,
                       svc.svcname, null),
                null)
       end,
       -- CELLMEMORY
       case when (bitand(tsp.flags, 65536) = 65536) then
         -- deferred segment: stgccflags (stgdef.h)
         decode(ccflag_stg,
             8194, 'NO MEMCOMPRESS',
             8196, 'MEMCOMPRESS FOR QUERY',
             8200, 'MEMCOMPRESS FOR CAPACITY',
             16384, 'DISABLED', null)
       else
         -- created segment: ktsscflg (ktscts.h)
         decode(bitand(s.spare1, 4362862139015168),
              281474976710656, 'DISABLED',
              703687441776640, 'NO MEMCOMPRESS',
             1266637395197952, 'MEMCOMPRESS FOR QUERY',
             2392537302040576, 'MEMCOMPRESS FOR CAPACITY', null)
       end,
       -- MEMOPTIMIZE_READ -> KKPACFRAGF_IMOLTP_KV
       decode(bitand(tsp.flags, power(2,30)), power(2,30),
                                'ENABLED', 'DISABLED'),
       -- MEMOPTIMIZE_WRITE -> KKPACFRAGF_IMOLTP_INGEST
       decode(bitand(tsp.flags, power(2,31)), power(2,31),
                                'ENABLED', 'DISABLED')
from   obj$ po, obj$ so, tabcompart$ tcp, tabsubpart$ tsp, tab$ t,
       ts$ ts, sys.seg$ s, user$ u, sys.deferred_stg$ ds, sys.imsvc$ svc
where  so.obj# = tsp.obj# and po.obj# = tcp.obj# and tcp.obj# = tsp.pobj# and
       tcp.bo# = t.obj# and bitand(t.trigflag, 1073741824) != 1073741824 and
       ts.ts# = tsp.ts# and u.user# = po.owner# and tsp.file# = s.file#(+) and
       tsp.block# = s.block#(+) and tsp.ts# = s.ts#(+) and
       tsp.obj# = ds.obj#(+) and
       bitand(tcp.flags, 8388608) = 0 and   /* filter out hidden partitions */
       bitand(tsp.flags, 8388608) = 0 and   /* filter out hidden partitions */
       po.namespace = 1 and po.remoteowner IS NULL and po.linkname IS NULL and
       so.namespace = 1 and so.remoteowner IS NULL and so.linkname IS NULL and
       ((po.owner# = userenv('SCHEMAID') and so.owner# = userenv('SCHEMAID'))
        or tcp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */,
                                       -48 /* INSERT ANY TABLE */,
                                       -49 /* UPDATE ANY TABLE */,
                                       -50 /* DELETE ANY TABLE */)
                 )
      ) and tsp.obj# = svc.obj# (+) and svc.subpart#(+) is null
;
--------------------------------------------------------
--  DDL for View ALL_TRANSFORMATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TRANSFORMATIONS" ("TRANSFORMATION_ID", "OWNER", "NAME", "FROM_TYPE", "TO_TYPE") AS 
  select  t.transformation_id, t.owner, t.name, t.from_type,
        t.to_type from transformations$ t, sys.user$ u
where
u.user# = USERENV('SCHEMAID')
and (u.name = t.owner                                        /* user is the owner */
or (exists (select null from v$enabledprivs          /* user has system privelege */
               where priv_number in (-184 /* EXECUTE ANY TYPE */)))
or
(t.from_type in                                  /* user has execute on from type */
(
select t.from_type from transformations$ t, obj$ o, objauth$ oa
where
o.obj# = oa.obj# and
t.from_type = o.name and
(oa.grantor# = userenv('SCHEMAID') OR
    oa.obj# in
         (select ro.obj#
          from sys.objauth$ ro
          where grantee# in (select kzsrorol from x$kzsro))
)
and t.to_type in                                /* user has execute on to type */
(
select t.to_type from transformations$ t, obj$ o, objauth$ oa
where
o.obj# = oa.obj# and
t.to_type = o.name and
(oa.grantor# = userenv('SCHEMAID') OR
    oa.obj# in
         (select ro.obj#
          from sys.objauth$ ro
          where grantee# in (select kzsrorol from x$kzsro))))))
)
;
--------------------------------------------------------
--  DDL for View ALL_TRIGGER_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TRIGGER_COLS" ("TRIGGER_OWNER", "TRIGGER_NAME", "TABLE_OWNER", "TABLE_NAME", "COLUMN_NAME", "COLUMN_LIST", "COLUMN_USAGE") AS 
  select /*+ ORDERED NOCOST */ u.name, o.name, u2.name, o2.name, c.name,
   max(decode(tc.type#,0,'YES','NO')) COLUMN_LIST,
   decode(sum(decode(tc.type#, 5,  1, -- one occurrence of new in
                              6,  2, -- one occurrence of old in
                              9,  4, -- one occurrence of new out
                             10,  8, -- one occurrence of old out (impossible)
                             13,  5, -- one occurrence of new in out
                             14, 10, -- one occurrence of old in out (imp.)
                             20, 16, -- one occurrence of parent in
                             24, 32, -- one occurrence of parent out (imp)
                             28, 64, -- one occurrence of parent in out (imp)
                              null)
                ), -- result in the following combinations across occurrences
           1, 'NEW IN',
           2, 'OLD IN',
           3, 'NEW IN OLD IN',
           4, 'NEW OUT',
           5, 'NEW IN OUT',
           6, 'NEW OUT OLD IN',
           7, 'NEW IN OUT OLD IN',
          16, 'PARENT IN',
          'NONE')
from sys.trigger$ t, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ u2,
     sys.col$ c, sys."_CURRENT_EDITION_OBJ" o2, sys.triggercol$ tc
where t.obj# = tc.obj#                -- find corresponding trigger definition
  and o.obj# = t.obj#                --    and corresponding trigger name
  and c.obj# = t.baseobject         -- and corresponding row in COL$ of
  and c.intcol# = tc.intcol#        --    the referenced column
  and bitand(c.property,32768) != 32768   -- not unused columns
  and bitand(o.flags, 128) = 0 -- not in recycle bin
  and o2.obj# = t.baseobject        -- and name of the table containing the trigger
  and u2.user# = o2.owner#        -- and name of the user who owns the table
  and u.user# = o.owner#        -- and name of user who owns the trigger
  and bitand(c.property,1) <> 1  -- and the col is not an ADT column
  and (bitand(t.property,32) <> 32 -- and it is not a nested table col
       or
      bitand(tc.type#,16) = 16) -- or it is a PARENT type column
    -- exclude TRIGGERCOL$ rows inserted to represent base table column
    -- for a DML trigger defined on a view
  and (bitand(tc.type#, 1024) = 0)
  and
  ( o.owner# = userenv('SCHEMAID') or o2.owner# = userenv('SCHEMAID')
    or
    exists    -- an enabled role (or current user) with CREATE ANY TRIGGER priv
     ( select null from sys.sysauth$ sa    -- does
       where privilege# = -152             -- CREATE ANY TRIGGER privilege exist
       and (grantee# in                    -- for current user or public
            (select kzsrorol from x$kzsro) -- currently enabled role
           )
      )
   )
group by u.name, o.name, u2.name, o2.name,c.name
union all
select /*+ ORDERED NOCOST */ u.name, o.name, u2.name, o2.name,ac.name,
   max(decode(tc.type#,0,'YES','NO')) COLUMN_LIST,
   decode(sum(decode(tc.type#, 5,  1, -- one occurrence of new in
                              6,  2, -- one occurrence of old in
                              9,  4, -- one occurrence of new out
                             10,  8, -- one occurrence of old out (impossible)
                             13,  5, -- one occurrence of new in out
                             14, 10, -- one occurrence of old in out (imp.)
                             20, 16, -- one occurrence of parent in
                             24, 32, -- one occurrence of parent out (imp)
                             28, 64, -- one occurrence of parent in out (imp)
                              null)
                ), -- result in the following combinations across occurrences
           1, 'NEW IN',
           2, 'OLD IN',
           3, 'NEW IN OLD IN',
           4, 'NEW OUT',
           5, 'NEW IN OUT',
           6, 'NEW OUT OLD IN',
           7, 'NEW IN OUT OLD IN',
          16, 'PARENT IN',
          'NONE')
from sys.trigger$ t, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ u2,
     sys.col$ c, sys.obj$ o2, sys.triggercol$ tc, sys.attrcol$ ac
where t.obj# = tc.obj#                -- find corresponding trigger definition
  and o.obj# = t.obj#                --    and corresponding trigger name
  and c.obj# = t.baseobject         -- and corresponding row in COL$ of
  and c.intcol# = tc.intcol#        --    the referenced column
  and bitand(c.property,32768) != 32768   -- not unused columns
  and bitand(o.flags, 128) = 0 -- not in recycle bin
  and o2.obj# = t.baseobject        -- and name of the table containing the trigger
  and u2.user# = o2.owner#        -- and name of the user who owns the table
  and u.user# = o.owner#        -- and name of user who owns the trigger
  and bitand(c.property,1) = 1  -- and it is an ADT attribute
  and ac.intcol# = c.intcol#    -- and the attribute name
  and (bitand(t.property,32) <> 32 -- and it is not a nested table col
       or
      bitand(tc.type#,16) = 16) -- or it is a PARENT type column
  and
  ( o.owner# = userenv('SCHEMAID') or o2.owner# = userenv('SCHEMAID')
    or
    exists    -- an enabled role (or current user) with CREATE ANY TRIGGER priv
     ( select null from sys.sysauth$ sa    -- does
       where privilege# = -152             -- CREATE ANY TRIGGER privilege exist
       and (grantee# in                    -- for current user or public
            (select kzsrorol from x$kzsro) -- currently enabled role
           )
      )
   )
group by u.name, o.name, u2.name, o2.name,ac.name
union all
select /*+ ORDERED NOCOST */ u.name, o.name, u2.name, o2.name,attr.name,
   max(decode(tc.type#,0,'YES','NO')) COLUMN_LIST,
   decode(sum(decode(tc.type#, 5,  1, -- one occurrence of new in
                              6,  2, -- one occurrence of old in
                              9,  4, -- one occurrence of new out
                             10,  8, -- one occurrence of old out (impossible)
                             13,  5, -- one occurrence of new in out
                             14, 10, -- one occurrence of old in out (imp.)
                              null)
                ), -- result in the following combinations across occurrences
           1, 'NEW IN',
           2, 'OLD IN',
           3, 'NEW IN OLD IN',
           4, 'NEW OUT',
           5, 'NEW IN OUT',
           6, 'NEW OUT OLD IN',
           7, 'NEW IN OUT OLD IN',
          'NONE')
from sys.trigger$ t, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ u2,
     sys.obj$ o2, sys.triggercol$ tc,
     sys.collection$ coll, sys.coltype$ ctyp, sys.attribute$ attr
where t.obj# = tc.obj#                -- find corresponding trigger definition
  and o.obj# = t.obj#                --    and corresponding trigger name
  and o2.obj# = t.baseobject        -- and name of the table containing the trigger
  and u2.user# = o2.owner#        -- and name of the user who owns the table
  and u.user# = o.owner#        -- and name of user who owns the trigger
  and bitand(t.property,32) = 32 -- and it is a nested table col
  and bitand(o.flags, 128) = 0 -- not in recycle bin
  and bitand(tc.type#,16) <> 16  -- and it is not a PARENT type column
  and ctyp.obj# = t.baseobject   -- find corresponding column type definition
  and ctyp.intcol# = t.nttrigcol -- and get the column type for the nested table
  and ctyp.toid = coll.toid      -- get the collection toid
  and ctyp.version# = coll.version# -- get the collection version
  and attr.attribute# = tc.intcol#  -- get the attribute number
  and attr.toid  = coll.elem_toid  -- get the attribute toid
  and attr.version# = coll.version#  -- get the attribute version
  and
  ( o.owner# = userenv('SCHEMAID') or o2.owner# = userenv('SCHEMAID')
    or
    exists    -- an enabled role (or current user) with CREATE ANY TRIGGER priv
     ( select null from sys.sysauth$ sa    -- does
       where privilege# = -152             -- CREATE ANY TRIGGER privilege exist
       and (grantee# in                    -- for current user or public
            (select kzsrorol from x$kzsro) -- currently enabled role
           )
      )
   )
group by u.name, o.name, u2.name, o2.name,attr.name
union all
select /*+ ORDERED NOCOST */ u.name, o.name, u2.name, o2.name,'COLUMN_VALUE',
   max(decode(tc.type#,0,'YES','NO')) COLUMN_LIST,
   decode(sum(decode(tc.type#, 5,  1, -- one occurrence of new in
                              6,  2, -- one occurrence of old in
                              9,  4, -- one occurrence of new out
                             10,  8, -- one occurrence of old out (impossible)
                             13,  5, -- one occurrence of new in out
                             14, 10, -- one occurrence of old in out (imp.)
                              null)
                ), -- result in the following combinations across occurrences
           1, 'NEW IN',
           2, 'OLD IN',
           3, 'NEW IN OLD IN',
           4, 'NEW OUT',
           5, 'NEW IN OUT',
           6, 'NEW OUT OLD IN',
           7, 'NEW IN OUT OLD IN',
          'NONE')
from sys.trigger$ t, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.user$ u2,
     sys.obj$ o2, sys.triggercol$ tc
where t.obj# = tc.obj#                -- find corresponding trigger definition
  and o.obj# = t.obj#                --    and corresponding trigger name
  and o2.obj# = t.baseobject        -- and name of the table containing the trigger
  and u2.user# = o2.owner#        -- and name of the user who owns the table
  and u.user# = o.owner#        -- and name of user who owns the trigger
  and bitand(t.property,32) = 32 -- and it is not a nested table col
  and bitand(o.flags, 128) = 0 -- not in recycle bin
  and bitand(tc.type#,16) <> 16  -- and it is not a PARENT type column
  and tc.intcol# = 0
  and
  ( o.owner# = userenv('SCHEMAID') or o2.owner# = userenv('SCHEMAID')
    or
    exists    -- an enabled role (or current user) with CREATE ANY TRIGGER priv
     ( select null from sys.sysauth$ sa    -- does
       where privilege# = -152             -- CREATE ANY TRIGGER privilege exist
       and (grantee# in                    -- for current user or public
            (select kzsrorol from x$kzsro) -- currently enabled role
           )
      )
   )
group by u.name, o.name, u2.name, o2.name,'COLUMN_VALUE';

   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_COLS"."TRIGGER_OWNER" IS 'Owner of the trigger';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_COLS"."TRIGGER_NAME" IS 'Name of the trigger';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_COLS"."TABLE_OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_COLS"."TABLE_NAME" IS 'Name of the table on which the trigger is defined';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_COLS"."COLUMN_NAME" IS 'Name of the column or the attribute of the ADT column used in trigger definition';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_COLS"."COLUMN_LIST" IS 'Is column specified in UPDATE OF clause?';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_COLS"."COLUMN_USAGE" IS 'Usage of column within trigger body';
   COMMENT ON TABLE "SYS"."ALL_TRIGGER_COLS"  IS 'Column usage in user''s triggers or in triggers on user''s tables'
;
--------------------------------------------------------
--  DDL for View ALL_TRIGGER_ORDERING
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TRIGGER_ORDERING" ("TRIGGER_OWNER", "TRIGGER_NAME", "REFERENCED_TRIGGER_OWNER", "REFERENCED_TRIGGER_NAME", "ORDERING_TYPE") AS 
  select trigger_owner, trigger_name, referenced_trigger_owner,
  referenced_trigger_name, ordering_type
from sys."_DBA_TRIGGER_ORDERING"
where trigger_owner# = userenv('SCHEMAID') or
      table_owner# = userenv('SCHEMAID') or
      table_obj# in
        (select oa1.obj# from sys.objauth$ oa1 where grantee# in
           (select kzsrorol from x$kzsro)) or
      exists (select null from v$enabledprivs
              where priv_number = -152 /* CREATE ANY TRIGGER */);

   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_ORDERING"."TRIGGER_OWNER" IS 'Owner of the trigger';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_ORDERING"."REFERENCED_TRIGGER_OWNER" IS 'Owner of the referenced trigger';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_ORDERING"."REFERENCED_TRIGGER_NAME" IS 'Name of the referenced trigger';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGER_ORDERING"."ORDERING_TYPE" IS 'Type of the ordering between the trigger and the reference trigger';
   COMMENT ON TABLE "SYS"."ALL_TRIGGER_ORDERING"  IS 'Triggers having FOLLOWS or PRECEDES ordering accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_TRIGGERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TRIGGERS" ("OWNER", "TRIGGER_NAME", "TRIGGER_TYPE", "TRIGGERING_EVENT", "TABLE_OWNER", "BASE_OBJECT_TYPE", "TABLE_NAME", "COLUMN_NAME", "REFERENCING_NAMES", "WHEN_CLAUSE", "STATUS", "DESCRIPTION", "ACTION_TYPE", "TRIGGER_BODY", "CROSSEDITION", "BEFORE_STATEMENT", "BEFORE_ROW", "AFTER_ROW", "AFTER_STATEMENT", "INSTEAD_OF_ROW", "FIRE_ONCE", "APPLY_SERVER_ONLY") AS 
  select triguser.name, trigobj.name,
decode(t.type#, 0, 'BEFORE STATEMENT',
                1, 'BEFORE EACH ROW',
                2, 'AFTER STATEMENT',
                3, 'AFTER EACH ROW',
                4, 'INSTEAD OF',
                5, 'COMPOUND',
                   'UNDEFINED'),
decode(decode(bitand(t.property, 524288), 524288, 1000, 0) + t.insert$*100 + t.update$*10 + t.delete$,
                 0100, 'INSERT',
                 0010, 'UPDATE',
                 0001, 'DELETE',
                 0110, 'INSERT OR UPDATE',
                 0101, 'INSERT OR DELETE',
                 0011, 'UPDATE OR DELETE',
                 0111, 'INSERT OR UPDATE OR DELETE',
                 1000, 'LOGICAL LOB UPDATE',
                 'ERROR'),
tabuser.name,
decode(bitand(t.property, 1), 1, 'VIEW',
                              0, 'TABLE',
                                 'UNDEFINED'),
tabobj.name, NULL,
'REFERENCING NEW AS '||t.refnewname||' OLD AS '||t.refoldname,
t.whenclause,decode(t.enabled, 0, 'DISABLED', 1, 'ENABLED', 'ERROR'),
t.definition,
decode(bitand(t.property, 2), 2, 'CALL',
                                 'PL/SQL     '),
t.action#,
decode(bitand(t.property, 8192),
       8192, decode(bitand(t.property, 131072),
                    131072, 'REVERSE', 'FORWARD'), 'NO'),
decode(bitand(t.property, 256),
             256, 'YES', 'NO'),
decode(bitand(t.property, 512),
             512, 'YES', 'NO'),
decode(bitand(t.property, 1024),
             1024, 'YES', 'NO'),
decode(bitand(t.property, 2048),
             2048, 'YES', 'NO'),
decode(bitand(t.property, 4096 ),
             4096, 'YES', 'NO'),
decode(bitand(t.property, 128),    /* FOO */
             128, 'YES', 'NO'),
decode(bitand(t.property, 262144), /* ASO */
             262144, 'YES', 'NO')
  from sys."_CURRENT_EDITION_OBJ" trigobj,
  sys."_CURRENT_EDITION_OBJ" tabobj,
  sys.trigger$ t,
  sys.user$ tabuser,
  sys.user$ triguser
where (trigobj.obj#   = t.obj# and
       tabobj.obj#    = t.baseobject and
       trigobj.owner# = triguser.user# and
       tabobj.owner#  = tabuser.user# and
       bitand(trigobj.flags, 128) = 0 and
       bitand(t.property, 63)    < 8  and
       (
        trigobj.owner# = userenv('SCHEMAID') or
        tabobj.owner# = userenv('SCHEMAID') or
        tabobj.obj# in
          (select oa1.obj# from sys.objauth$ oa1 where grantee# in
             (select kzsrorol from x$kzsro)) or
        exists (select null from v$enabledprivs
                where priv_number = -152 /* CREATE ANY TRIGGER */)))
union all
select triguser.name, trigobj.name,
decode(t.type#, 0, 'BEFORE EVENT',
                2, 'AFTER EVENT',
                   'UNDEFINED'),
decode(bitand(t.sys_evts, 1), 1, 'STARTUP ') ||
decode(bitand(t.sys_evts, 2), 2,
       decode(sign(bitand(t.sys_evts, 1)), 1, 'OR SHUTDOWN ',
                                               'SHUTDOWN ')) ||
decode(bitand(t.sys_evts, 4), 4,
       decode(sign(bitand(t.sys_evts, 3)), 1, 'OR ERROR ',
                                              'ERROR ')) ||
decode(bitand(t.sys_evts, 8), 8,
       decode(sign(bitand(t.sys_evts, 7)), 1, 'OR LOGON ',
                                              'LOGON ')) ||
decode(bitand(t.sys_evts, 16), 16,
       decode(sign(bitand(t.sys_evts, 15)), 1, 'OR LOGOFF ',
                                               'LOGOFF ')) ||
decode(bitand(t.sys_evts, 262176), 32,
       decode(sign(bitand(t.sys_evts, 31)), 1, 'OR CREATE ',
                                               'CREATE ')) ||
decode(bitand(t.sys_evts, 262208), 64,
       decode(sign(bitand(t.sys_evts, 63)), 1, 'OR ALTER ',
                                               'ALTER ')) ||
decode(bitand(t.sys_evts, 262272), 128,
       decode(sign(bitand(t.sys_evts, 127)), 1, 'OR DROP ',
                                                'DROP ')) ||
decode (bitand(t.sys_evts, 262400), 256,
        decode(sign(bitand(t.sys_evts, 255)), 1, 'OR ANALYZE ',
                                                 'ANALYZE ')) ||
decode (bitand(t.sys_evts, 262656), 512,
        decode(sign(bitand(t.sys_evts, 511)), 1, 'OR COMMENT ',
                                                 'COMMENT ')) ||
decode (bitand(t.sys_evts, 263168), 1024,
        decode(sign(bitand(t.sys_evts, 1023)), 1, 'OR GRANT ',
                                                  'GRANT ')) ||
decode (bitand(t.sys_evts, 264192), 2048,
        decode(sign(bitand(t.sys_evts, 2047)), 1, 'OR REVOKE ',
                                                  'REVOKE ')) ||
decode (bitand(t.sys_evts, 266240), 4096,
        decode(sign(bitand(t.sys_evts, 4095)), 1, 'OR TRUNCATE ',
                                                  'TRUNCATE ')) ||
decode (bitand(t.sys_evts, 270336), 8192,
        decode(sign(bitand(t.sys_evts, 8191)), 1, 'OR RENAME ',
                                                  'RENAME ')) ||
decode (bitand(t.sys_evts, 278528), 16384,
        decode(sign(bitand(t.sys_evts, 16383)), 1, 'OR ASSOCIATE STATISTICS ',
                                                   'ASSOCIATE STATISTICS ')) ||
decode (bitand(t.sys_evts, 294912), 32768,
        decode(sign(bitand(t.sys_evts, 32767)), 1, 'OR AUDIT ',
                                                   'AUDIT ')) ||
decode (bitand(t.sys_evts, 327680), 65536,
        decode(sign(bitand(t.sys_evts, 65535)), 1,
               'OR DISASSOCIATE STATISTICS ', 'DISASSOCIATE STATISTICS ')) ||
decode (bitand(t.sys_evts, 393216), 131072,
        decode(sign(bitand(t.sys_evts, 131071)), 1, 'OR NOAUDIT ',
                                                    'NOAUDIT ')) ||
decode (bitand(t.sys_evts, 262144), 262144,
        decode(sign(bitand(t.sys_evts, 31)), 1, 'OR DDL ',
                                                   'DDL ')) ||
decode (bitand(t.sys_evts, 8388608), 8388608,
        decode(sign(bitand(t.sys_evts, 8388607)), 1, 'OR SUSPEND ',
                                                     'SUSPEND ')) ||
decode (bitand(t.sys_evts, 33554432), 33554432,
        decode(sign(bitand(t.sys_evts, 33554431)), 1, 'OR CLONE ',
                                                      'CLONE ')) ||
decode (bitand(t.sys_evts, 67108864), 67108864,
        decode(sign(bitand(t.sys_evts, 67108863)), 1, 'OR UNPLUG ',
                                                      'UNPLUG ')),
'SYS',
decode(bitand(t.property, 8), 8, 'DATABASE        ', 'PLUGGABLE DATABASE'),
NULL,
NULL,
'REFERENCING NEW AS '||t.refnewname||' OLD AS '||t.refoldname,
t.whenclause,decode(t.enabled, 0, 'DISABLED', 1, 'ENABLED', 'ERROR'),
t.definition,
decode(bitand(t.property, 2), 2, 'CALL',
                                 'PL/SQL     '),
t.action#,
  'NO',
  'NO',
  'NO',
  'NO',
  'NO',
  'NO',
  'NO',
  'NO'
  from sys."_CURRENT_EDITION_OBJ" trigobj,
  sys.trigger$ t,
  sys.user$ triguser
where (trigobj.obj#    = t.obj# and
       trigobj.owner#  = triguser.user# and
       bitand(t.property, 48) = 0 and bitand(t.property, 1048584) != 0 and
       bitand(trigobj.flags, 128) = 0 and
       (
        trigobj.owner# = userenv('SCHEMAID') or
        exists (select null from v$enabledprivs
                where priv_number = -152 /* CREATE ANY TRIGGER */)))
union all
select triguser.name, trigobj.name,
decode(t.type#, 0, 'BEFORE EVENT',
                2, 'AFTER EVENT',
                   'UNDEFINED'),
decode(bitand(t.sys_evts, 1), 1, 'STARTUP ') ||
decode(bitand(t.sys_evts, 2), 2,
       decode(sign(bitand(t.sys_evts, 1)), 1, 'OR SHUTDOWN ',
                                               'SHUTDOWN ')) ||
decode(bitand(t.sys_evts, 4), 4,
       decode(sign(bitand(t.sys_evts, 3)), 1, 'OR ERROR ',
                                              'ERROR ')) ||
decode(bitand(t.sys_evts, 8), 8,
       decode(sign(bitand(t.sys_evts, 7)), 1, 'OR LOGON ',
                                              'LOGON ')) ||
decode(bitand(t.sys_evts, 16), 16,
       decode(sign(bitand(t.sys_evts, 15)), 1, 'OR LOGOFF ',
                                               'LOGOFF ')) ||
decode(bitand(t.sys_evts, 262176), 32,
       decode(sign(bitand(t.sys_evts, 31)), 1, 'OR CREATE ',
                                               'CREATE ')) ||
decode(bitand(t.sys_evts, 262208), 64,
       decode(sign(bitand(t.sys_evts, 63)), 1, 'OR ALTER ',
                                               'ALTER ')) ||
decode(bitand(t.sys_evts, 262272), 128,
       decode(sign(bitand(t.sys_evts, 127)), 1, 'OR DROP ',
                                                'DROP ')) ||
decode (bitand(t.sys_evts, 262400), 256,
        decode(sign(bitand(t.sys_evts, 255)), 1, 'OR ANALYZE ',
                                                 'ANALYZE ')) ||
decode (bitand(t.sys_evts, 262656), 512,
        decode(sign(bitand(t.sys_evts, 511)), 1, 'OR COMMENT ',
                                                 'COMMENT ')) ||
decode (bitand(t.sys_evts, 263168), 1024,
        decode(sign(bitand(t.sys_evts, 1023)), 1, 'OR GRANT ',
                                                  'GRANT ')) ||
decode (bitand(t.sys_evts, 264192), 2048,
        decode(sign(bitand(t.sys_evts, 2047)), 1, 'OR REVOKE ',
                                                  'REVOKE ')) ||
decode (bitand(t.sys_evts, 266240), 4096,
        decode(sign(bitand(t.sys_evts, 4095)), 1, 'OR TRUNCATE ',
                                                  'TRUNCATE ')) ||
decode (bitand(t.sys_evts, 270336), 8192,
        decode(sign(bitand(t.sys_evts, 8191)), 1, 'OR RENAME ',
                                                  'RENAME ')) ||
decode (bitand(t.sys_evts, 278528), 16384,
        decode(sign(bitand(t.sys_evts, 16383)), 1, 'OR ASSOCIATE STATISTICS ',
                                                   'ASSOCIATE STATISTICS ')) ||
decode (bitand(t.sys_evts, 294912), 32768,
        decode(sign(bitand(t.sys_evts, 32767)), 1, 'OR AUDIT ',
                                                   'AUDIT ')) ||
decode (bitand(t.sys_evts, 327680), 65536,
        decode(sign(bitand(t.sys_evts, 65535)), 1,
               'OR DISASSOCIATE STATISTICS ', 'DISASSOCIATE STATISTICS ')) ||
decode (bitand(t.sys_evts, 393216), 131072,
        decode(sign(bitand(t.sys_evts, 131071)), 1, 'OR NOAUDIT ',
                                                    'NOAUDIT ')) ||
decode (bitand(t.sys_evts, 262144), 262144,
        decode(sign(bitand(t.sys_evts, 31)), 1, 'OR DDL ',
                                                   'DDL ')) ||
decode (bitand(t.sys_evts, 8388608), 8388608,
        decode(sign(bitand(t.sys_evts, 8388607)), 1, 'OR SUSPEND ',
                                                     'SUSPEND ')),
tabuser.name,
'SCHEMA',
NULL,
NULL,
'REFERENCING NEW AS '||t.refnewname||' OLD AS '||t.refoldname,
t.whenclause,decode(t.enabled, 0, 'DISABLED', 1, 'ENABLED', 'ERROR'),
t.definition,
decode(bitand(t.property, 2), 2, 'CALL',
                                 'PL/SQL     '),
t.action#,
  'NO',
  'NO',
  'NO',
  'NO',
  'NO',
  'NO',
  'NO',
  'NO'
  from sys."_CURRENT_EDITION_OBJ" trigobj,
  sys.trigger$ t,
  sys.user$ tabuser,
  sys.user$ triguser
where (trigobj.obj#    = t.obj# and
       trigobj.owner#  = triguser.user# and
       tabuser.user#   = t.baseobject and
       bitand(t.property, 63)     >= 16 and bitand(t.property, 63) < 32 and
       bitand(trigobj.flags, 128) = 0 and
       (
         trigobj.owner# = userenv('SCHEMAID') or
        tabuser.user#  = userenv('SCHEMAID') or
        exists (select null from v$enabledprivs
                where priv_number = -152 /* CREATE ANY TRIGGER */)))
union all
select triguser.name, trigobj.name,
decode(t.type#, 0, 'BEFORE STATEMENT',
               1, 'BEFORE EACH ROW',
               2, 'AFTER STATEMENT',
               3, 'AFTER EACH ROW',
               4, 'INSTEAD OF',
               5, 'COMPOUND',
                  'UNDEFINED'),
decode(t.insert$*100 + t.update$*10 + t.delete$,
                 100, 'INSERT',
                 010, 'UPDATE',
                 001, 'DELETE',
                 110, 'INSERT OR UPDATE',
                 101, 'INSERT OR DELETE',
                 011, 'UPDATE OR DELETE',
                 111, 'INSERT OR UPDATE OR DELETE', 'ERROR'),
tabuser.name,
decode(bitand(t.property, 1), 1, 'VIEW',
                              0, 'TABLE',
                                 'UNDEFINED'),
tabobj.name, ntcol.name,
'REFERENCING NEW AS '||t.refnewname||' OLD AS '||t.refoldname ||
  ' PARENT AS ' || t.refprtname,
t.whenclause,decode(t.enabled, 0, 'DISABLED', 1, 'ENABLED', 'ERROR'),
t.definition,
decode(bitand(t.property, 2), 2, 'CALL',
                                 'PL/SQL     '),
t.action#,
decode(bitand(t.property, 8192),
       8192, decode(bitand(t.property, 131072),
                    131072, 'REVERSE', 'FORWARD'), 'NO'),
decode(bitand(t.property, 256),
             256, 'YES', 'NO'),
decode(bitand(t.property, 512),
             512, 'YES', 'NO'),
decode(bitand(t.property, 1024),
             1024, 'YES', 'NO'),
decode(bitand(t.property, 2048),
             2048, 'YES', 'NO'),
decode(bitand(t.property, 4096 ),
             4096, 'YES', 'NO'),
decode(bitand(t.property, 128),    /* FOO */
             128, 'YES', 'NO'),
decode(bitand(t.property, 262144), /* ASO */
             262144, 'YES', 'NO')
  from sys."_CURRENT_EDITION_OBJ" trigobj,
  sys."_CURRENT_EDITION_OBJ" tabobj,
  sys.trigger$ t,
  sys.user$ tabuser,
  sys.user$ triguser,
     sys.viewtrcol$ ntcol
where (trigobj.obj#   = t.obj# and
       tabobj.obj#    = t.baseobject and
       trigobj.owner# = triguser.user# and
       tabobj.owner#  = tabuser.user# and
       bitand(t.property, 63)    >=  32  and
       bitand(trigobj.flags, 128) = 0 and
       t.nttrigcol = ntcol.intcol# and
       t.nttrigatt = ntcol.attribute# and
       t.baseobject = ntcol.obj# and
       (
        trigobj.owner# = userenv('SCHEMAID') or
        tabobj.owner# = userenv('SCHEMAID') or
        tabobj.obj# in
          (select oa3.obj# from sys.objauth$ oa3 where grantee# in
             (select kzsrorol from x$kzsro)) or
        exists (select null from v$enabledprivs
                where priv_number = -152 /* CREATE ANY TRIGGER */)));

   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."OWNER" IS 'Owner of the trigger';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."TRIGGER_NAME" IS 'Name of the trigger';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."TRIGGER_TYPE" IS 'When the trigger fires - BEFORE/AFTER and STATEMENT/ROW';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."TRIGGERING_EVENT" IS 'Statement that will fire the trigger - INSERT, UPDATE and/or DELETE';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."TABLE_OWNER" IS 'Owner of the table that this trigger is associated with';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."TABLE_NAME" IS 'Name of the table that this trigger is associated with';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."COLUMN_NAME" IS 'The name of the column on which the trigger is defined over';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."REFERENCING_NAMES" IS 'Names used for referencing to OLD and NEW values within the trigger';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."WHEN_CLAUSE" IS 'WHEN clause must evaluate to true in order for triggering body to execute';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."STATUS" IS 'If DISABLED then trigger will not fire';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."DESCRIPTION" IS 'Trigger description, useful for re-creating trigger creation statement';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."TRIGGER_BODY" IS 'Action taken by this trigger when it fires';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."CROSSEDITION" IS 'Type of crossedition trigger - FORWARD, REVERSE or NO';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."FIRE_ONCE" IS 'If NO then the trigger will also fire in replication apply processes';
   COMMENT ON COLUMN "SYS"."ALL_TRIGGERS"."APPLY_SERVER_ONLY" IS 'If YES then the trigger will only fire in replication apply processes';
   COMMENT ON TABLE "SYS"."ALL_TRIGGERS"  IS 'Triggers accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_TSTZ_TAB_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TSTZ_TAB_COLS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "QUALIFIED_COL_NAME", "NESTED", "VIRTUAL_COLUMN", "SCALAR_COLUMN", "UNUSED_COLUMN") AS 
  with rw (p_obj#, d_obj#, property)  as
 (
     select p_obj#, d_obj#, property
     from sys.dependency$
     where p_obj# in
          (
          select distinct o.obj#
          from sys.obj$ o, sys.attribute$ a
          where o.oid$ = a.toid
            and a.attr_toid = '0000000000000000000000000000003E'
          union all
          select distinct o.obj#
          from sys.obj$ o, sys.collection$ c
          where o.oid$ = c.toid
            and c.elem_toid = '0000000000000000000000000000003E'
        )
 union all
     select d.p_obj#, d.d_obj#, d.property
     from rw, sys.dependency$ d
     where rw.d_obj# = d.p_obj# and bitand(rw.property, 1) = 1
 ),
 va_of_tstz_typ (name) as
 (
   select distinct o.name
   from rw, sys.obj$ o, sys.coltype$ c
   where rw.p_obj# = o.obj#
     and o.oid$ = c.toid
     and bitand(c.flags, 8) = 8
 ),
 all_tstz_candiate_tab_cols
     (owner, table_name, table_property, table_nested, column_name, data_type,
     qualified_col_name, virtual_column, scalar_column, unused_column) as
 (
   select u.name, o.name, t.property,
      case when bitand(t.property, 8192) = 8192 then 1 else 0 end,
      c.name,
      case when c.type# = 181 then
                   'TIMESTAMP(' ||c.scale|| ')' || ' WITH TIME ZONE'
           when c.type# in (58, 111, 121, 122, 123) then
                   nvl2(ac.synobj#, (select o.name from obj$ o
                                     where o.obj#=ac.synobj#), ot.name)
           else 'UNDEFINED'
      end,
      decode(bitand(c.property, 1024), 1024,
             (select decode(bitand(cl.property, 1), 1, rc.name, cl.name)
              from sys.col$ cl, attrcol$ rc where cl.intcol# = c.intcol#-1
              and cl.obj# = c.obj# and c.obj# = rc.obj#(+) and
              cl.intcol# = rc.intcol#(+)),
             decode(bitand(c.property, 1), 0, c.name,
                    (select tc.name from sys.attrcol$ tc
                     where c.obj# = tc.obj# and c.intcol# = tc.intcol#))),
      decode(c.property, 0, 0, decode(bitand(c.property, 8), 8, 1, 0)),
      case when (c.type# not in (58, 111, 121, 122, 123) and
                 bitand(c.property,1)=0 and -- ADT attribute column
                 bitand(c.property,2)=0 and -- OID column
                 bitand(c.property,4)=0 and -- nested table column
                 bitand(t.property,1)=0 and -- typed table
                 bitand(t.property,8192)=0) -- nested table
           then 1 else 0
      end,
      decode(c.property, 0, 0, decode(bitand(c.property, 32768), 32768, 1, 0))
 from sys.col$ c, sys."_CURRENT_EDITION_OBJ" o, sys.user$ u,
      sys.coltype$ ac, sys.obj$ ot, sys.tab$ t
 where o.obj# = c.obj#
   and o.owner# = u.user#
   and c.obj# = ac.obj#(+) and c.intcol# = ac.intcol#(+)
   and ac.toid = ot.oid$(+)
   and ot.type#(+) = 13
   and o.obj# = t.obj#
   and c.type# in (58, 111, 121, 122, 123, 181)
 )
select /*+ OPT_PARAM('_recursive_with_branch_iterations' 1) */
       owner, table_name, column_name,
       qualified_col_name, table_nested, virtual_column,
       scalar_column, unused_column
from  all_tstz_candiate_tab_cols
    where data_type like 'TIMESTAMP%WITH TIME ZONE'
       or data_type in (select name from va_of_tstz_typ);

   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TAB_COLS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TAB_COLS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TAB_COLS"."COLUMN_NAME" IS 'Column name';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TAB_COLS"."QUALIFIED_COL_NAME" IS 'Qualified column name';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TAB_COLS"."NESTED" IS 'Nested table column?';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TAB_COLS"."VIRTUAL_COLUMN" IS 'Is this a virtual column?';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TAB_COLS"."SCALAR_COLUMN" IS 'Is this a scalar type column?';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TAB_COLS"."UNUSED_COLUMN" IS 'Is this an unused column?';
   COMMENT ON TABLE "SYS"."ALL_TSTZ_TAB_COLS"  IS 'Columns of user''s tables, which have column(s) defined on timestamp with time zone data type or ADT type containing attribute(s) of timestamp with time zone data type'
;
--------------------------------------------------------
--  DDL for View ALL_TSTZ_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TSTZ_TABLES" ("OWNER", "TABLE_NAME", "UPGRADE_IN_PROGRESS") AS 
  select /*+ leading(actt, o, u, t) */ attc.owner, attc.table_name,
       decode(bitand(t.property, 137438953472), 137438953472, 'YES', 'NO')
from (select distinct owner, table_name from all_tstz_tab_cols) attc, sys.obj$ o, sys.user$ u, sys.tab$ t
where attc.table_name = o.name
  and attc.owner = u.name
  and o.owner# = u.user#
  and o.obj# = t.obj#;

   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TABLES"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TABLES"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_TSTZ_TABLES"."UPGRADE_IN_PROGRESS" IS 'Is table upgrade in progress?';
   COMMENT ON TABLE "SYS"."ALL_TSTZ_TABLES"  IS 'Description of tables accessible to the user, which have column(s) defined on timestamp with time zone data type or ADT type containing attribute(s) of timestamp with time zone data type'
;
--------------------------------------------------------
--  DDL for View ALL_TYPE_ATTRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TYPE_ATTRS" ("OWNER", "TYPE_NAME", "ATTR_NAME", "ATTR_TYPE_MOD", "ATTR_TYPE_OWNER", "ATTR_TYPE_NAME", "LENGTH", "PRECISION", "SCALE", "CHARACTER_SET_NAME", "ATTR_NO", "INHERITED", "CHAR_USED") AS 
  select u.name , o.name, a.name,
       decode(bitand(a.properties, 32768), 32768, 'REF',
              decode(bitand(a.properties, 16384), 16384, 'POINTER')),
       nvl2(a.synobj#, (select u.name from user$ u, "_CURRENT_EDITION_OBJ" o
            where o.owner#=u.user# and o.obj#=a.synobj#),
            decode(bitand(at.properties, 64), 64, null, au.name)),
       nvl2(a.synobj#, (select o.name from "_CURRENT_EDITION_OBJ" o
                        where o.obj#=a.synobj#),
            decode(at.typecode,
                   9, decode(a.charsetform, 2, 'NVARCHAR2', ao.name),
                   96, decode(a.charsetform, 2, 'NCHAR', ao.name),
                   112, decode(a.charsetform, 2, 'NCLOB', ao.name),
                   ao.name)),
       a.length, a.precision#, a.scale,
       decode(a.charsetform, 1, 'CHAR_CS',
                             2, 'NCHAR_CS',
                             3, NLS_CHARSET_NAME(a.charsetid),
                             4, 'ARG:'||a.charsetid),
       a.attribute#, decode(bitand(nvl(a.xflags,0), 1), 1, 'YES', 'NO'),
       decode(bitand(a.properties, 4096), 4096, 'C', 'B')
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.type$ t, sys.attribute$ a,
     sys."_CURRENT_EDITION_OBJ" ao, sys.user$ au, sys.type$ at
where bitand(t.properties, 64) != 64 -- u.name
  and o.owner# = u.user#
  and o.oid$ = t.toid
  and o.subname IS NULL -- get the latest version only
  and o.type# <> 10 -- must not be invalid
  and bitand(t.properties, 2048) = 0 -- not system-generated
  and t.toid = a.toid
  and t.version# = a.version#
  and t.package_obj# IS NULL -- filter out plsql types
  and a.attr_toid = ao.oid$
  and ao.owner# = au.user#
  and a.attr_toid = at.tvoid
  and a.attr_version# = at.version#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."ATTR_NAME" IS 'Name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."ATTR_TYPE_MOD" IS 'Type modifier of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."ATTR_TYPE_OWNER" IS 'Owner of the type of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."ATTR_TYPE_NAME" IS 'Name of the type of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."LENGTH" IS 'Length of the CHAR attribute or maximum length of the VARCHAR
or VARCHAR2 attribute';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."PRECISION" IS 'Decimal precision of the NUMBER or DECIMAL attribute or
binary precision of the FLOAT attribute';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."SCALE" IS 'Scale of the NUMBER or DECIMAL attribute';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."CHARACTER_SET_NAME" IS 'Character set name of the attribute';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."ATTR_NO" IS 'Syntactical order number or position of the attribute as specified in the
type specification or CREATE TYPE statement (not to be used as ID number)';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."INHERITED" IS 'Is the attribute inherited from the supertype ?';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_ATTRS"."CHAR_USED" IS 'C if the width was specified in characters, B if in bytes';
   COMMENT ON TABLE "SYS"."ALL_TYPE_ATTRS"  IS 'Description of attributes of types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_TYPE_METHODS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TYPE_METHODS" ("OWNER", "TYPE_NAME", "METHOD_NAME", "METHOD_NO", "METHOD_TYPE", "PARAMETERS", "RESULTS", "FINAL", "INSTANTIABLE", "OVERRIDING", "INHERITED") AS 
  select u.name, o.name, m.name, m.method#,
       decode(bitand(m.properties, 512), 512, 'MAP',
              decode(bitand(m.properties, 2048), 2048, 'ORDER', 'PUBLIC')),
       m.parameters#, m.results,
       decode(bitand(m.properties, 8), 8, 'NO', 'YES'),
       decode(bitand(m.properties, 65536), 65536, 'NO', 'YES'),
       decode(bitand(m.properties, 131072), 131072, 'YES', 'NO'),
       decode(bitand(nvl(m.xflags,0), 1), 1, 'YES', 'NO')
from sys.user$ u, sys."_CURRENT_EDITION_OBJ" o, sys.method$ m
where o.owner# = u.user#
  and o.type# <> 10 -- must not be invalid
  and o.oid$ = m.toid
  and o.subname IS NULL -- get the latest version only
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."METHOD_NAME" IS 'Name of the method';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."METHOD_NO" IS 'Method number for distinguishing overloaded method (not to be used as ID number)';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."METHOD_TYPE" IS 'Type of the method';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."PARAMETERS" IS 'Number of parameters to the method';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."RESULTS" IS 'Number of results returned by the method';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."FINAL" IS 'Is the method final ?';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."INSTANTIABLE" IS 'Is the method instantiable ?';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."OVERRIDING" IS 'Is the method overriding a supertype method ?';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_METHODS"."INHERITED" IS 'Is the method inherited from the supertype ?';
   COMMENT ON TABLE "SYS"."ALL_TYPE_METHODS"  IS 'Description of methods of types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_TYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TYPES" ("OWNER", "TYPE_NAME", "TYPE_OID", "TYPECODE", "ATTRIBUTES", "METHODS", "PREDEFINED", "INCOMPLETE", "FINAL", "INSTANTIABLE", "PERSISTABLE", "SUPERTYPE_OWNER", "SUPERTYPE_NAME", "LOCAL_ATTRIBUTES", "LOCAL_METHODS", "TYPEID") AS 
  select u.name, o.name, t.toid,
       decode(t.typecode, 108, 'OBJECT',
                          122, 'COLLECTION',
                          o.name),
       t.attributes, t.methods,
       decode(bitand(t.properties, 16), 16, 'YES', 0, 'NO'),
       decode(bitand(t.properties, 256), 256, 'YES', 0, 'NO'),
       decode(bitand(t.properties, 8), 8, 'NO', 'YES'),
       decode(bitand(t.properties, 65536), 65536, 'NO', 'YES'),
       decode(bitand(t.properties, 268435456), 268435456, 'NO', 'YES'),
       su.name, so.name, t.local_attrs, t.local_methods, t.typeid
from sys.user$ u, sys.type$ t, sys."_CURRENT_EDITION_OBJ" o,
     sys."_CURRENT_EDITION_OBJ" so, sys.user$ su
where bitand(t.properties, 64) != 64 -- u.name
  and o.owner# = u.user#
  and o.oid$ = t.tvoid
  and o.subname IS NULL -- only the most recent version
  and o.type# <> 10 -- must not be invalid
  and bitand(t.properties, 2048) = 0 -- not system-generated
  and t.supertoid = so.oid$ (+) and so.owner# = su.user# (+)
  and t.package_obj# IS NULL  -- no PL/SQL types
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
       )
UNION
select null, o.name, t.toid,
       decode(t.typecode, 108, 'OBJECT',
                          122, 'COLLECTION',
                          o.name),
       t.attributes, t.methods,
       decode(bitand(t.properties, 16), 16, 'YES', 0, 'NO'),
       decode(bitand(t.properties, 256), 256, 'YES', 0, 'NO'),
       decode(bitand(t.properties, 8), 8, 'NO', 'YES'),
       decode(bitand(t.properties, 65536), 65536, 'NO', 'YES'),
       decode(bitand(t.properties, 268435456), 268435456, 'NO', 'YES'),
       su.name, so.name, t.local_attrs, t.local_methods, t.typeid
from sys.type$ t, sys."_CURRENT_EDITION_OBJ" o,
     sys."_CURRENT_EDITION_OBJ" so, sys.user$ su
where bitand(t.properties, 64) = 64  -- u.name is null
  and o.oid$ = t.tvoid
  and o.subname IS NULL -- only the most recent version
  and o.type# <> 10 -- must not be invalid
  and bitand(t.properties, 2048) = 0 -- not system-generated
  and t.supertoid = so.oid$ (+) and so.owner# = su.user# (+)
  and t.package_obj# IS NULL  -- no PL/SQL types
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_TYPES"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."TYPE_OID" IS 'Object identifier (OID) of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."TYPECODE" IS 'Typecode of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."ATTRIBUTES" IS 'Number of attributes in the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."METHODS" IS 'Number of methods in the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."PREDEFINED" IS 'Is the type a predefined type?';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."INCOMPLETE" IS 'Is the type an incomplete type?';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."FINAL" IS 'Is the type a final type?';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."INSTANTIABLE" IS 'Is the type an instantiable type?';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."PERSISTABLE" IS 'Is the type a persistable type?';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."SUPERTYPE_OWNER" IS 'Owner of the supertype (null if type is not a subtype)';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."SUPERTYPE_NAME" IS 'Name of the supertype (null if type is not a subtype)';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."LOCAL_ATTRIBUTES" IS 'Number of local (not inherited) attributes (if any) in the subtype';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."LOCAL_METHODS" IS 'Number of local (not inherited) methods (if any) in the subtype';
   COMMENT ON COLUMN "SYS"."ALL_TYPES"."TYPEID" IS 'Type id value of the type';
   COMMENT ON TABLE "SYS"."ALL_TYPES"  IS 'Description of types accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_TYPE_VERSIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_TYPE_VERSIONS" ("OWNER", "TYPE_NAME", "VERSION#", "TYPECODE", "STATUS", "LINE", "TEXT", "HASHCODE") AS 
  select u.name, o.name, t.version#,
       decode(t.typecode, 108, 'OBJECT',
                          122, 'COLLECTION',
                          o.name),
       decode(o.status, 0, 'N/A', 1, 'VALID', 'INVALID'),
       s.line, s.source,
       t.hashcode
from sys."_CURRENT_EDITION_OBJ" o, sys.source$ s, sys.type$ t, user$ u
  where o.obj# = s.obj# and o.oid$ = t.tvoid and o.type# = 13
  and o.owner# = u.user#
  and (o.owner# = userenv('SCHEMAID')
       or
       o.obj# in (select oa.obj#
                  from sys.objauth$ oa
                  where grantee# in (select kzsrorol
                                     from x$kzsro))
       or /* user has system privileges */
          ora_check_sys_privilege (o.owner#, o.type#) = 1
  );

   COMMENT ON COLUMN "SYS"."ALL_TYPE_VERSIONS"."OWNER" IS 'Owner of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_VERSIONS"."TYPE_NAME" IS 'Name of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_VERSIONS"."VERSION#" IS 'Internal version number of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_VERSIONS"."TYPECODE" IS 'Typecode of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_VERSIONS"."STATUS" IS 'Status of the type';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_VERSIONS"."LINE" IS 'Line number of the type''s spec';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_VERSIONS"."TEXT" IS 'Text of the type''s spec';
   COMMENT ON COLUMN "SYS"."ALL_TYPE_VERSIONS"."HASHCODE" IS 'Hashcode of the type';
   COMMENT ON TABLE "SYS"."ALL_TYPE_VERSIONS"  IS 'Description of each type version accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_UNUSED_COL_TABS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_UNUSED_COL_TABS" ("OWNER", "TABLE_NAME", "COUNT") AS 
  select u.name, o.name, count(*)
from sys.user$ u, sys.obj$ o, sys.col$ c
where o.owner# = u.user#
  and o.obj# = c.obj#
  and bitand(c.property,32768) = 32768              -- is unused column
  and bitand(c.property, 1) != 1                    -- not ADT attribute col
  and bitand(c.property, 1024) != 1024              -- not NTAB's setid col
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
       ora_check_sys_privilege ( o.owner#, o.type# ) = 1
      )
  group by u.name, o.name;

   COMMENT ON COLUMN "SYS"."ALL_UNUSED_COL_TABS"."OWNER" IS 'Owner of the table';
   COMMENT ON COLUMN "SYS"."ALL_UNUSED_COL_TABS"."TABLE_NAME" IS 'Name of the table';
   COMMENT ON COLUMN "SYS"."ALL_UNUSED_COL_TABS"."COUNT" IS 'Number of unused columns in table';
   COMMENT ON TABLE "SYS"."ALL_UNUSED_COL_TABS"  IS 'All tables with unused columns accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_UPDATABLE_COLUMNS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_UPDATABLE_COLUMNS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "UPDATABLE", "INSERTABLE", "DELETABLE") AS 
  select u.name, o.name, c.name,
      decode(bitand(c.fixedstorage,2),
             2,
             case when
               exists
                 (select 1 from trigger$ t, "_CURRENT_EDITION_OBJ" trigobj
                  where     t.obj# = trigobj.obj#  /* trigger in edition */
                        and t.type# = 4            /* and insted of trigger */
                        and t.enabled = 1          /* and enabled */
                        and t.baseobject = o.obj#  /* on selected object */
                        and t.update$ <> 0)        /* triggers on update */
               then
                 'YES'
               else
                 'NO'
             end,
             decode(bitand(c.property,4096),4096,'NO','YES')),
      decode(bitand(c.fixedstorage,2),
             2,
             case when
               exists
                 (select 1 from trigger$ t, "_CURRENT_EDITION_OBJ" trigobj
                  where     t.obj# = trigobj.obj#  /* trigger in edition */
                        and t.type# = 4            /* and insted of trigger */
                        and t.enabled = 1          /* and enabled */
                        and t.baseobject = o.obj#  /* on selected object */
                        and t.insert$ <> 0)        /* triggers on insert */
               then
                 'YES'
               else
                 'NO'
             end,
             decode(bitand(c.property,2048),2048,'NO','YES')),
      decode(bitand(c.fixedstorage,2),
             2,
             case when
               exists
                 (select 1 from trigger$ t, "_CURRENT_EDITION_OBJ" trigobj
                  where     t.obj# = trigobj.obj#  /* trigger in edition */
                        and t.type# = 4            /* and insted of trigger */
                        and t.enabled = 1          /* and enabled */
                        and t.baseobject = o.obj#  /* on selected object */
                        and t.delete$ <> 0)        /* triggers on delete */
               then
                 'YES'
               else
                 'NO'
             end,
             decode(bitand(c.property,8192),8192,'NO','YES'))
from sys."_CURRENT_EDITION_OBJ" o, sys.user$ u, sys.col$ c
where o.owner# = u.user#
  and o.obj#  = c.obj#
  and bitand(c.property, 32) = 0 /* not hidden column */
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
       ora_check_sys_privilege ( o.owner#, o.type# ) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_UPDATABLE_COLUMNS"."OWNER" IS 'Table owner';
   COMMENT ON COLUMN "SYS"."ALL_UPDATABLE_COLUMNS"."TABLE_NAME" IS 'Table name';
   COMMENT ON COLUMN "SYS"."ALL_UPDATABLE_COLUMNS"."COLUMN_NAME" IS 'Column name';
   COMMENT ON COLUMN "SYS"."ALL_UPDATABLE_COLUMNS"."UPDATABLE" IS 'Is the column updatable?';
   COMMENT ON COLUMN "SYS"."ALL_UPDATABLE_COLUMNS"."INSERTABLE" IS 'Is the column insertable?';
   COMMENT ON COLUMN "SYS"."ALL_UPDATABLE_COLUMNS"."DELETABLE" IS 'Is the column deletable?';
   COMMENT ON TABLE "SYS"."ALL_UPDATABLE_COLUMNS"  IS 'Description of all updatable columns'
;
--------------------------------------------------------
--  DDL for View ALL_USERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_USERS" ("USERNAME", "USER_ID", "CREATED", "COMMON", "ORACLE_MAINTAINED", "INHERITED", "DEFAULT_COLLATION", "IMPLICIT", "ALL_SHARD") AS 
  select u.name, u.user#, u.ctime,
       decode(bitand(u.spare1, 4224), 0, 'NO', 'YES'),
       decode(bitand(u.spare1, 256), 256, 'Y', 'N'),
       decode(bitand(u.spare1, 4224),
              128, decode(SYS_CONTEXT('USERENV', 'CON_ID'), 1, 'NO', 'YES'),
              4224, decode(SYS_CONTEXT('USERENV', 'IS_APPLICATION_PDB'),
                           'YES', 'YES', 'NO'),
              'NO'),
       nls_collation_name(nvl(u.spare3, 16382)),
       -- IMPLICIT
       decode(bitand(u.spare1, 32768), 32768, 'YES', 'NO'),
       -- ALL_SHARD
       decode(bitand(u.spare1, 16384), 16384, 'YES', 'NO')
from sys.user$ u
where u.type# = 1;

   COMMENT ON COLUMN "SYS"."ALL_USERS"."USERNAME" IS 'Name of the user';
   COMMENT ON COLUMN "SYS"."ALL_USERS"."USER_ID" IS 'ID number of the user';
   COMMENT ON COLUMN "SYS"."ALL_USERS"."CREATED" IS 'User creation date';
   COMMENT ON COLUMN "SYS"."ALL_USERS"."COMMON" IS 'Indicates whether this user is Common';
   COMMENT ON COLUMN "SYS"."ALL_USERS"."ORACLE_MAINTAINED" IS 'Denotes whether the user was created, and is maintained, by Oracle-supplied scripts. A user for which this has the value Y must not be changed in any way except by running an Oracle-supplied script.';
   COMMENT ON COLUMN "SYS"."ALL_USERS"."INHERITED" IS 'Was user definition inherited from another container';
   COMMENT ON COLUMN "SYS"."ALL_USERS"."DEFAULT_COLLATION" IS 'User default collation';
   COMMENT ON COLUMN "SYS"."ALL_USERS"."IMPLICIT" IS 'Is this user a common user created by an implicit application';
   COMMENT ON COLUMN "SYS"."ALL_USERS"."ALL_SHARD" IS 'Is this user an all-shard user';
   COMMENT ON TABLE "SYS"."ALL_USERS"  IS 'Information about all users of the database'
;
--------------------------------------------------------
--  DDL for View ALL_USTATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_USTATS" ("OBJECT_OWNER", "OBJECT_NAME", "PARTITION_NAME", "OBJECT_TYPE", "ASSOCIATION", "COLUMN_NAME", "STATSTYPE_SCHEMA", "STATSTYPE_NAME", "STATISTICS") AS 
  select u.name, o.name, o.subname,
         decode (bitand(s.property, 3), 1, 'INDEX', 2, 'COLUMN'),
         decode (bitand(s.property, 12), 8, 'DIRECT', 4, 'IMPLICIT'),
         c.name, u1.name, o1.name, s.statistics
  from   sys.user$ u, sys.obj$ o, sys.col$ c, sys.ustats$ s,
         sys.user$ u1, sys.obj$ o1
  where  bitand(s.property, 3)=2 and s.obj#=o.obj# and o.owner#=u.user#
  and    s.intcol#=c.intcol# and s.statstype#=o1.obj#
  and    o1.owner#=u1.user# and c.obj#=s.obj#
  and    ( o.owner#=userenv('SCHEMAID')
           or
        o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
       ( o.type# in (2)  /* table */
         and
         exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */,
                                        -42 /* ALTER ANY TABLE */)
                 )
       )
    )
union all    -- partition case
  select u.name, o.name, o.subname,
         decode (bitand(s.property, 3), 1, 'INDEX', 2, 'COLUMN'),
         decode (bitand(s.property, 12), 8, 'DIRECT', 4, 'IMPLICIT'),
         c.name, u1.name, o1.name, s.statistics
  from   sys.user$ u, sys.user$ u1, sys.obj$ o, sys.obj$ o1, sys.col$ c,
         sys.ustats$ s, sys.tabpart$ t, sys.obj$ o2
  where  bitand(s.property, 3)=2 and s.obj# = o.obj#
  and    s.obj# = t.obj# and t.bo# = o2.obj# and o2.owner# = u.user#
  and    s.intcol# = c.intcol# and s.statstype#=o1.obj# and o1.owner#=u1.user#
  and    t.bo#=c.obj#
  and    ( o.owner#=userenv('SCHEMAID')
           or
        o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
       ( o.type# in (2)  /* table */
         and
         exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */,
                                        -42 /* ALTER ANY TABLE */)
                 )
       )
    )
union all
  select u.name, o.name, o.subname,
         decode (bitand(s.property, 3), 1, 'INDEX', 2, 'COLUMN'),
         decode (bitand(s.property, 12), 8, 'DIRECT', 4, 'IMPLICIT'),
          NULL, u1.name, o1.name, s.statistics
  from   sys.user$ u, sys.obj$ o, sys.ustats$ s,
         sys.user$ u1, sys.obj$ o1
  where  bitand(s.property, 3)=1 and s.obj#=o.obj# and o.owner#=u.user#
  and    s.statstype#=o1.obj# and o1.owner#=u1.user# and o.type#=1
  and    ( o.owner#=userenv('SCHEMAID')
           or
        o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
       ( o.type# in (1)  /* index */
         and
         exists (select null from v$enabledprivs
                  where priv_number in (-71 /* CREATE ANY INDEX */,
                                        -72 /* ALTER ANY INDEX */,
                                        -73 /* DROP ANY INDEX */)
                 )
       )
    )
union all -- index partition
  select u.name, o.name, o.subname,
         decode (bitand(s.property, 3), 1, 'INDEX', 2, 'COLUMN'),
         decode (bitand(s.property, 12), 8, 'DIRECT', 4, 'IMPLICIT'),
         NULL, u1.name, o1.name, s.statistics
  from   sys.user$ u, sys.user$ u1, sys.obj$ o, sys.obj$ o1,
         sys.ustats$ s, sys.indpart$ i, sys.obj$ o2
  where  bitand(s.property, 3)=1 and s.obj# = o.obj#
  and    s.obj# = i.obj# and i.bo# = o2.obj# and o2.owner# = u.user#
  and    s.statstype#=o1.obj# and o1.owner#=u1.user#
  and    ( o.owner#=userenv('SCHEMAID')
           or
        o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or
       ( o.type# in (1)  /* index */
         and
         exists (select null from v$enabledprivs
                  where priv_number in (-71 /* CREATE ANY INDEX */,
                                        -72 /* ALTER ANY INDEX */,
                                        -73 /* DROP ANY INDEX */)
                 )
       )
    );

   COMMENT ON COLUMN "SYS"."ALL_USTATS"."OBJECT_OWNER" IS 'Owner of the table or index for which the statistics have been collected';
   COMMENT ON COLUMN "SYS"."ALL_USTATS"."OBJECT_NAME" IS 'Name of the table or index for which the statistics have been collected';
   COMMENT ON COLUMN "SYS"."ALL_USTATS"."PARTITION_NAME" IS 'Name of the partition (if applicable) for which the stats have been collected';
   COMMENT ON COLUMN "SYS"."ALL_USTATS"."OBJECT_TYPE" IS 'Type of the object - Column or Index';
   COMMENT ON COLUMN "SYS"."ALL_USTATS"."ASSOCIATION" IS 'If the statistics type association is direct or implicit';
   COMMENT ON COLUMN "SYS"."ALL_USTATS"."COLUMN_NAME" IS 'Column name, if property is column for which statistics have been collected';
   COMMENT ON COLUMN "SYS"."ALL_USTATS"."STATSTYPE_SCHEMA" IS 'Schema of statistics type which was used to collect the statistics ';
   COMMENT ON COLUMN "SYS"."ALL_USTATS"."STATSTYPE_NAME" IS 'Name of statistics type which was used to collect statistics';
   COMMENT ON COLUMN "SYS"."ALL_USTATS"."STATISTICS" IS 'User collected statistics for the object';
   COMMENT ON TABLE "SYS"."ALL_USTATS"  IS 'All statistics'
;
--------------------------------------------------------
--  DDL for View ALL_VARRAYS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_VARRAYS" ("OWNER", "PARENT_TABLE_NAME", "PARENT_TABLE_COLUMN", "TYPE_OWNER", "TYPE_NAME", "LOB_NAME", "STORAGE_SPEC", "RETURN_TYPE", "ELEMENT_SUBSTITUTABLE") AS 
  select u.name, op.name, ac.name,
       nvl2(ct.synobj#, (select u.name from "_BASE_USER" u, obj$ o
            where o.owner#=u.user# and o.obj#=ct.synobj#), ut.name),
       nvl2(ct.synobj#, (select o.name from obj$ o where o.obj#=ct.synobj#),
            ot.name),
       NULL,
       lpad(decode(bitand(ct.flags, 64), 64, 'USER_SPECIFIED', 'DEFAULT'), 30),
       lpad(decode(bitand(ct.flags, 32), 32, 'LOCATOR', 'VALUE'), 20),
       lpad((case when bitand(ct.flags, 5120)=0 and bitand(t.properties, 8)= 8
       then 'Y' else 'N' end), 25)
from sys."_CURRENT_EDITION_OBJ" op, sys.obj$ ot, sys.col$ c, sys.coltype$ ct,
  sys.user$ u, sys."_BASE_USER" ut, sys.attrcol$ ac, sys.type$ t,
  sys.collection$ cl
where op.owner# = u.user#
  and c.obj# = op.obj#
  and c.obj# = ac.obj#
  and c.intcol# = ac.intcol#
  and op.obj# = ct.obj#
  and ct.toid = ot.oid$
  and ct.intcol#=c.intcol#
  and ot.owner# = ut.user#
  and ct.toid=cl.toid
  and cl.elem_toid=t.tvoid
  and bitand(ct.flags,8)=8
  and bitand(c.property, 128) != 128
  and bitand(c.property,32768) != 32768           /* not unused column */
  and (op.owner# = userenv('SCHEMAID')
       or op.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege (op.owner#, op.type#) = 1
      )
union all
select u.name, op.name, ac.name,
       nvl2(ct.synobj#, (select u.name from "_BASE_USER" u, obj$ o
            where o.owner#=u.user# and o.obj#=ct.synobj#), ut.name),
       nvl2(ct.synobj#, (select o.name from obj$ o where o.obj#=ct.synobj#),
            ot.name),
       o.name,
       lpad(decode(bitand(ct.flags, 64), 64, 'USER_SPECIFIED', 'DEFAULT'), 30),
       lpad(decode(bitand(ct.flags, 32), 32, 'LOCATOR', 'VALUE'), 20),
       lpad((case when bitand(ct.flags, 5120)=0 and bitand(t.properties, 8)= 8
       then 'Y' else 'N' end), 25)
from sys.lob$ l, sys."_CURRENT_EDITION_OBJ" o, sys."_CURRENT_EDITION_OBJ" op,
  sys.obj$ ot, sys.col$ c, sys.coltype$ ct, sys.user$ u, sys."_BASE_USER" ut,
  sys.attrcol$ ac, sys.type$ t, sys.collection$ cl
where o.owner# = u.user#
  and l.obj# = op.obj#
  and l.lobj# = o.obj#
  and c.obj# = op.obj#
  and l.intcol# = c.intcol#
  and c.obj# = ac.obj#
  and c.intcol# = ac.intcol#
  and op.obj# = ct.obj#
  and ct.toid = ot.oid$
  and ct.intcol#=l.intcol#
  and ot.owner# = ut.user#
  and ct.toid=cl.toid
  and cl.elem_toid=t.tvoid
  and bitand(ct.flags,8)=8
  and bitand(c.property, 128) = 128
  and bitand(c.property,32768) != 32768           /* not unused column */
  and (op.owner# = userenv('SCHEMAID')
       or op.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege (op.owner#, op.type#) = 1
      )
union all
select u.name, op.name, c.name,
       nvl2(ct.synobj#, (select u.name from "_BASE_USER" u, obj$ o
            where o.owner#=u.user# and o.obj#=ct.synobj#), ut.name),
       nvl2(ct.synobj#, (select o.name from obj$ o where o.obj#=ct.synobj#),
            ot.name),
       NULL,
       lpad(decode(bitand(ct.flags, 64), 64, 'USER_SPECIFIED', 'DEFAULT'), 30),
       lpad(decode(bitand(ct.flags, 32), 32, 'LOCATOR', 'VALUE'), 20),
       lpad((case when bitand(ct.flags, 5120)=0 and bitand(t.properties, 8)= 8
       then 'Y' else 'N' end), 25)
from sys."_CURRENT_EDITION_OBJ" op, sys.obj$ ot, sys.col$ c, sys.coltype$ ct,
  sys.user$ u, sys."_BASE_USER" ut, sys.type$ t, sys.collection$ cl
where op.owner# = u.user#
  and c.obj# = op.obj#
  and bitand(c.property,1)=0
  and op.obj# = ct.obj#
  and ct.toid = ot.oid$
  and ct.intcol#=c.intcol#
  and ot.owner# = ut.user#
  and ct.toid=cl.toid
  and cl.elem_toid=t.tvoid
  and bitand(ct.flags,8)=8
  and bitand(c.property, 128) != 128
  and bitand(c.property,32768) != 32768           /* not unused column */
  and (op.owner# = userenv('SCHEMAID')
       or op.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege (op.owner#, op.type#) = 1
      )
union all
select u.name, op.name, c.name,
       nvl2(ct.synobj#, (select u.name from "_BASE_USER" u, obj$ o
            where o.owner#=u.user# and o.obj#=ct.synobj#), ut.name),
       nvl2(ct.synobj#, (select o.name from obj$ o where o.obj#=ct.synobj#),
            ot.name),
       o.name,
       lpad(decode(bitand(ct.flags, 64), 64, 'USER_SPECIFIED', 'DEFAULT'), 30),
       lpad(decode(bitand(ct.flags, 32), 32, 'LOCATOR', 'VALUE'), 20),
       lpad((case when bitand(ct.flags, 5120)=0 and bitand(t.properties, 8)= 8
       then 'Y' else 'N' end), 25)
from sys.lob$ l, sys."_CURRENT_EDITION_OBJ" o, sys."_CURRENT_EDITION_OBJ" op,
  sys.obj$ ot, sys.col$ c, sys.coltype$ ct, sys.user$ u, sys."_BASE_USER" ut,
  sys.type$ t, sys.collection$ cl
where o.owner# = u.user#
  and l.obj# = op.obj#
  and l.lobj# = o.obj#
  and c.obj# = op.obj#
  and l.intcol# = c.intcol#
  and bitand(c.property,1)=0
  and op.obj# = ct.obj#
  and ct.toid = ot.oid$
  and ct.intcol#=l.intcol#
  and ot.owner# = ut.user#
  and ct.toid=cl.toid
  and cl.elem_toid=t.tvoid
  and bitand(ct.flags,8)=8
  and bitand(c.property, 128) = 128
  and bitand(c.property,32768) != 32768           /* not unused column */
  and (op.owner# = userenv('SCHEMAID')
       or op.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
          ora_check_sys_privilege (op.owner#, op.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."OWNER" IS 'Owner of the varray';
   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."PARENT_TABLE_NAME" IS 'Name of the parent table containing the varray';
   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."PARENT_TABLE_COLUMN" IS 'Column name of the parent table that corresponds to the varray';
   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."TYPE_OWNER" IS 'Owner of the type of which the varray was created';
   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."TYPE_NAME" IS 'Name of the type of the varray';
   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."LOB_NAME" IS 'Name of the lob if varray is stored in a lob';
   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."STORAGE_SPEC" IS 'Indication of default or user-specified storage for the varray';
   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."RETURN_TYPE" IS 'Return type of the varray column locator or value';
   COMMENT ON COLUMN "SYS"."ALL_VARRAYS"."ELEMENT_SUBSTITUTABLE" IS 'Indication of whether the varray element is substitutable or not';
   COMMENT ON TABLE "SYS"."ALL_VARRAYS"  IS 'Description of varrays in tables accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_VIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_VIEWS" ("OWNER", "VIEW_NAME", "TEXT_LENGTH", "TEXT", "TEXT_VC", "TYPE_TEXT_LENGTH", "TYPE_TEXT", "OID_TEXT_LENGTH", "OID_TEXT", "VIEW_TYPE_OWNER", "VIEW_TYPE", "SUPERVIEW_NAME", "EDITIONING_VIEW", "READ_ONLY", "CONTAINER_DATA", "BEQUEATH", "ORIGIN_CON_ID", "DEFAULT_COLLATION", "CONTAINERS_DEFAULT", "CONTAINER_MAP", "EXTENDED_DATA_LINK", "EXTENDED_DATA_LINK_MAP", "HAS_SENSITIVE_COLUMN") AS 
  select OWNER, VIEW_NAME, TEXT_LENGTH, TEXT, TEXT_VC,TYPE_TEXT_LENGTH, TYPE_TEXT,
       OID_TEXT_LENGTH, OID_TEXT, VIEW_TYPE_OWNER, VIEW_TYPE, SUPERVIEW_NAME,
       EDITIONING_VIEW, READ_ONLY,  CONTAINER_DATA, BEQUEATH,
       ORIGIN_CON_ID, DEFAULT_COLLATION, CONTAINERS_DEFAULT, CONTAINER_MAP,
       EXTENDED_DATA_LINK, EXTENDED_DATA_LINK_MAP, HAS_SENSITIVE_COLUMN
from int$dba_views
where (OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OBJ_ID(OWNER, VIEW_NAME, 4, OBJECT_ID) in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
           /* 4 is the type# for Views. See kgl.h for more info */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
      );

   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."OWNER" IS 'Owner of the view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."VIEW_NAME" IS 'Name of the view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."TEXT_LENGTH" IS 'Length of the view text';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."TEXT" IS 'View text';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."TEXT_VC" IS 'Possibly truncated view text as VARCHAR2';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."TYPE_TEXT_LENGTH" IS 'Length of the type clause of the object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."TYPE_TEXT" IS 'Type clause of the object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."OID_TEXT_LENGTH" IS 'Length of the WITH OBJECT OID clause of the object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."OID_TEXT" IS 'WITH OBJECT OID clause of the object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."VIEW_TYPE_OWNER" IS 'Owner of the type of the view if the view is an object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."VIEW_TYPE" IS 'Type of the view if the view is an object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."SUPERVIEW_NAME" IS 'Name of the superview, if view is a subview';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."EDITIONING_VIEW" IS 'An indicator of whether the view is an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."READ_ONLY" IS 'An indicator of whether the view is a Read Only View';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."CONTAINER_DATA" IS 'An indicator of whether the view contains Container-specific data';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."BEQUEATH" IS 'An indicator of whether the view is invoker rights';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."DEFAULT_COLLATION" IS 'Default collation for the view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."CONTAINERS_DEFAULT" IS 'Whether the view is enabled for CONTAINERS() by default';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."CONTAINER_MAP" IS 'Whether the view is enabled for use with container_map database property';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."EXTENDED_DATA_LINK" IS 'Whether the view is enabled for fetching extended data link from Root';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."EXTENDED_DATA_LINK_MAP" IS 'Whether the view is enabled for use with extended data link map';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS"."HAS_SENSITIVE_COLUMN" IS 'Whether the view has one or more sensitive columns';
   COMMENT ON TABLE "SYS"."ALL_VIEWS"  IS 'Description of views accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_VIEWS_AE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_VIEWS_AE" ("OWNER", "VIEW_NAME", "TEXT_LENGTH", "TEXT", "TEXT_VC", "TYPE_TEXT_LENGTH", "TYPE_TEXT", "OID_TEXT_LENGTH", "OID_TEXT", "VIEW_TYPE_OWNER", "VIEW_TYPE", "SUPERVIEW_NAME", "EDITIONING_VIEW", "READ_ONLY", "EDITION_NAME", "CONTAINER_DATA", "BEQUEATH", "ORIGIN_CON_ID", "DEFAULT_COLLATION", "CONTAINERS_DEFAULT", "CONTAINER_MAP", "EXTENDED_DATA_LINK", "EXTENDED_DATA_LINK_MAP", "HAS_SENSITIVE_COLUMN") AS 
  select OWNER, VIEW_NAME, TEXT_LENGTH, TEXT, TEXT_VC,TYPE_TEXT_LENGTH, TYPE_TEXT,
       OID_TEXT_LENGTH, OID_TEXT, VIEW_TYPE_OWNER, VIEW_TYPE, SUPERVIEW_NAME,
       EDITIONING_VIEW, READ_ONLY, edition_name,  CONTAINER_DATA, BEQUEATH,
       ORIGIN_CON_ID, DEFAULT_COLLATION, CONTAINERS_DEFAULT, CONTAINER_MAP,
       EXTENDED_DATA_LINK, EXTENDED_DATA_LINK_MAP, HAS_SENSITIVE_COLUMN
from int$dba_views_ae
where (OWNER = SYS_CONTEXT('USERENV', 'CURRENT_USER')
       or OBJ_ID(OWNER, VIEW_NAME, 4, OBJECT_ID) in
            (select oa.obj#
             from sys.objauth$ oa
             where oa.grantee# in ( select kzsrorol
                                         from x$kzsro
                                  )
            )
        or /* user has system privileges */
           /* 4 is the type# for Views. See kgl.h for more info */
          exists (select null from v$enabledprivs
                  where priv_number in (-45 /* LOCK ANY TABLE */,
                                        -47 /* SELECT ANY TABLE */,
                                        -397/* READ ANY TABLE */,
                                        -48 /* INSERT ANY TABLE */,
                                        -49 /* UPDATE ANY TABLE */,
                                        -50 /* DELETE ANY TABLE */)
                  )
      );

   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."OWNER" IS 'Owner of the view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."VIEW_NAME" IS 'Name of the view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."TEXT_LENGTH" IS 'Length of the view text';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."TEXT" IS 'View text';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."TEXT_VC" IS 'Possibly truncated view text as VARCHAR2';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."TYPE_TEXT_LENGTH" IS 'Length of the type clause of the object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."TYPE_TEXT" IS 'Type clause of the object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."OID_TEXT_LENGTH" IS 'Length of the WITH OBJECT OID clause of the object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."OID_TEXT" IS 'WITH OBJECT OID clause of the object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."VIEW_TYPE_OWNER" IS 'Owner of the type of the view if the view is an object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."VIEW_TYPE" IS 'Type of the view if the view is an object view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."SUPERVIEW_NAME" IS 'Name of the superview, if view is a subview';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."EDITIONING_VIEW" IS 'An indicator of whether the view is an Editioning View';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."READ_ONLY" IS 'An indicator of whether the view is a Read Only View';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."EDITION_NAME" IS 'Name of the Application Edition where the object is defined';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."CONTAINER_DATA" IS 'An indicator of whether the view contains Container-specific data';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."BEQUEATH" IS 'An indicator of whether the view is invoker rights';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."ORIGIN_CON_ID" IS 'ID of Container where row originates';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."DEFAULT_COLLATION" IS 'Default collation for the view';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."CONTAINERS_DEFAULT" IS 'Whether the view is enabled for CONTAINERS() by default';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."CONTAINER_MAP" IS 'Whether the view is enabled for use with container_map database property';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."EXTENDED_DATA_LINK" IS 'Whether the view is enabled for fetching extended data link from Root';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."EXTENDED_DATA_LINK_MAP" IS 'Whether the view is enabled for use with extended data link map';
   COMMENT ON COLUMN "SYS"."ALL_VIEWS_AE"."HAS_SENSITIVE_COLUMN" IS 'Whether the view has one or more sensitive columns';
   COMMENT ON TABLE "SYS"."ALL_VIEWS_AE"  IS 'Description of views accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_WARNING_SETTINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_WARNING_SETTINGS" ("OWNER", "OBJECT_NAME", "OBJECT_ID", "OBJECT_TYPE", "WARNING", "SETTING") AS 
  SELECT u.name, o.name, o.obj#,
         DECODE(o.type#,
                 7, 'PROCEDURE',
                 8, 'FUNCTION',
                 9, 'PACKAGE',
                11, 'PACKAGE BODY',
                12, 'TRIGGER',
                13, 'TYPE',
                14, 'TYPE BODY',
                    'UNDEFINED'),
         DECODE(w.warning,
                -1, 'INFORMATIONAL',
                -2, 'PERFORMANCE',
                -3, 'SEVERE',
                -4, 'ALL',
                w.warning),
         DECODE(w.setting,
                0, 'DISABLE',
                1, 'ENABLE',
                2, 'ERROR',
                   'INVALID')
    FROM sys."_CURRENT_EDITION_OBJ" o, sys.user$ u,
    TABLE(dbms_warning_internal.show_warning_settings(o.obj#)) w
    WHERE o.owner# = u.user#
    AND o.linkname IS NULL
    AND o.type# IN (7, 8, 9, 11, 12, 13, 14)
    AND w.obj_no = o.obj#
    AND
    (
      o.owner# IN (userenv('SCHEMAID'), 1 /* PUBLIC */)
      OR
      (
        (
          (
            (o.type# = 7 OR o.type# = 8 OR o.type# = 9 OR o.type# = 13)
             and
             o.obj# in (select obj# from sys.objauth$
             where grantee# in (select kzsrorol from x$kzsro)
                   and privilege#  = 12 /* EXECUTE */)
           )
           or
           exists
           (
              select null from sys.sysauth$
                where grantee# in (select kzsrorol from x$kzsro)
                      and
                      (
                        (
                          /* procedure */
                          (o.type# = 7 or o.type# = 8 or o.type# = 9)
                          and
                          (
                             privilege# = -144 /* EXECUTE ANY PROCEDURE */
                             or
                             privilege# = -141 /* CREATE ANY PROCEDURE */
                          )
                        )
                        or
                        (
                          /* package body */
                          o.type# = 11 and
                          privilege# = -141 /* CREATE ANY PROCEDURE */
                        )
                        or
                        (
                          /* type */
                          o.type# = 13
                          and
                          (
                             privilege# = -184 /* EXECUTE ANY TYPE */
                             or
                             privilege# = -181 /* CREATE ANY TYPE */
                          )
                        )
                        or
                        (
                          /* type body */
                          o.type# = 14 and
                          privilege# = -181 /* CREATE ANY TYPE */
                        )
                      )
           )
        )
      )
    );

   COMMENT ON COLUMN "SYS"."ALL_WARNING_SETTINGS"."OWNER" IS 'Username of the owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_WARNING_SETTINGS"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_WARNING_SETTINGS"."OBJECT_ID" IS 'Object number of the object';
   COMMENT ON COLUMN "SYS"."ALL_WARNING_SETTINGS"."OBJECT_TYPE" IS 'Type of the object';
   COMMENT ON COLUMN "SYS"."ALL_WARNING_SETTINGS"."WARNING" IS 'Warning number or category';
   COMMENT ON COLUMN "SYS"."ALL_WARNING_SETTINGS"."SETTING" IS 'Value of the warning setting';
   COMMENT ON TABLE "SYS"."ALL_WARNING_SETTINGS"  IS 'Warnings ettings for objects accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_XDS_ACL_REFRESH
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XDS_ACL_REFRESH" ("SCHEMA_NAME", "TABLE_NAME", "ACL_MVIEW_NAME", "REFRESH_MODE", "REFRESH_ABILITY", "ACL_STATUS", "USER_SUPPLIED_MV", "START_DATE", "REPEAT_INTERVAL", "REFRESH_COUNT", "COMMENTS") AS 
  select s.schema_name,
          s.table_name,
          s.acl_mview_name,
          s.refresh_mode,
          s.refresh_ability,
          s.acl_status,
          s.user_supplied_mv,
          s.start_date,
          s.repeat_interval,
          s.refresh_count,
          s.comments
from dba_xds_acl_refresh s, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and s.table_name = o.name
  and u.name       = s.schema_name
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
;
--------------------------------------------------------
--  DDL for View ALL_XDS_ACL_REFSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XDS_ACL_REFSTAT" ("SCHEMA_NAME", "TABLE_NAME", "REFRESH_MODE", "REFRESH_ABILITY", "JOB_START_TIME", "JOB_END_TIME", "ROW_UPDATE_COUNT", "STATUS", "ERROR_MESSAGE") AS 
  select s.schema_name,
          s.table_name,
          s.refresh_mode,
          s.refresh_ability,
          s.job_start_time,
          s.job_end_time,
          s.row_update_count,
          s.status,
          s.error_message
from dba_xds_acl_refstat s, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and s.table_name = o.name
  and u.name       = s.schema_name
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
;
--------------------------------------------------------
--  DDL for View ALL_XDS_LATEST_ACL_REFSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XDS_LATEST_ACL_REFSTAT" ("SCHEMA_NAME", "TABLE_NAME", "REFRESH_MODE", "REFRESH_ABILITY", "JOB_START_TIME", "JOB_END_TIME", "ROW_UPDATE_COUNT", "STATUS", "ERROR_MESSAGE") AS 
  select s.schema_name,
          s.table_name,
          s.refresh_mode,
          s.refresh_ability,
          s.job_start_time,
          s.job_end_time,
          s.row_update_count,
          s.status,
          s.error_message
from dba_xds_latest_acl_refstat s, sys.obj$ o, sys.user$ u
where o.owner#     = u.user#
  and s.table_name = o.name
  and u.name       = s.schema_name
  and o.type#      = 2                     /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      )
;
--------------------------------------------------------
--  DDL for View ALL_XML_INDEXES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_INDEXES" ("INDEX_OWNER", "INDEX_NAME", "TABLE_OWNER", "TABLE_NAME", "TYPE", "INDEX_TYPE", "PATH_TABLE_NAME", "PARAMETERS", "ASYNC", "STALE", "PEND_TABLE_NAME", "EX_OR_INCLUDE") AS 
  select
   u.name         INDEX_OWNER,
   oi.name        INDEX_NAME,
   bu.name        TABLE_OWNER,
   bo.name        TABLE_NAME,
   case when bitand(p.flags, 536870912)=536870912 then 'REPOSITORY'
        when bitand(p.flags, 4096)=4096 then 'BINARY'
        when bitand(p.flags, 8192)=8192 then 'CLOB in OR'
        when bitand(p.flags, 16384)=16384 then 'CLOB'
        else 'OR' end TYPE,
   case when bitand(p.flags , 268435456 ) != 268435456 then 'STRUCTURED'
        when bitand(p.flags, 268435456 ) = 268435456 and exists (select xt.idxobj# from xdb.xdb$xtab xt where xt.idxobj# = p.idxobj#) then 'STRUCTURED and UNSTRUCTURED'
        else 'UNSTRUCTURED' end INDEX_TYPE,
   case when bitand(p.flags,  268435456 ) != 268435456 then ''
        else     ot.name  end PATH_TABLE_NAME,
   p.parameters   PARAMETERS,
   case when bitand(p.flags, 65011712)=6291456 then 'ON-COMMIT'
        when bitand(p.flags, 65011712)=10485760 then 'MANUAL'
        when bitand(p.flags, 65011712)=18874368 then 'EVERY'
        else 'ALWAYS' end ASYNC,
   case when bitand(p.flags, 2097152)=2097152 then 'TRUE'
        else 'FALSE' end STALE,
   case when bitand(p.flags, 2097152)=2097152 then
        (select op.name from sys.obj$ op
         where  op.obj# = p.pendtabobj#)
        else '' end PEND_TABLE_NAME,
   case when bitand(p.flags, 32)=32 then 'INCLUDE'
        when bitand(p.flags, 128)=128 then 'EXCLUDE'
        else 'FULLY IX' end EX_or_INCLUDE
 from xdb.xdb$dxptab p, sys.obj$ ot, sys.obj$ oi, sys.user$ u,
      sys.user$ bu, sys.obj$ bo, sys.ind$ i
 where oi.owner# = u.user# and
       oi.obj# = p.idxobj# and p.pathtabobj# = ot.obj# and
       i.obj# = oi.obj# and i.bo# = bo.obj# and bo.owner# = bu.user# and
       (u.user# = userenv('SCHEMAID')
        or oi.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (oi.owner#, oi.type#) = 1);

   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."INDEX_OWNER" IS 'Username of the owner of the XML index';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."INDEX_NAME" IS 'Name of the XML index';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."TABLE_OWNER" IS 'Username of the owner of the indexed object';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."TABLE_NAME" IS 'Name of the indexed object';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."TYPE" IS 'Type of indexed column (CLOB, CSX, CLOB_IN_OR, REPOSITORY, OR)';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."INDEX_TYPE" IS 'Index Type (Structured, Unstructured or both)';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."PATH_TABLE_NAME" IS 'Name of the PATH TABLE';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."PARAMETERS" IS 'Structured index groups, path subsetting xpaths and scheduler job information';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."ASYNC" IS 'Asynchronous index type';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."STALE" IS 'Stale index type';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."PEND_TABLE_NAME" IS 'Name of the PENDING TABLE';
   COMMENT ON COLUMN "SYS"."ALL_XML_INDEXES"."EX_OR_INCLUDE" IS 'Path Subsetting (Include or Exclude)';
   COMMENT ON TABLE "SYS"."ALL_XML_INDEXES"  IS 'Description of the all XMLType indexes that the user has privileges on'
;
--------------------------------------------------------
--  DDL for View ALL_XML_NESTED_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_NESTED_TABLES" ("OWNER", "TABLE_NAME", "NESTED_TABLE_NAME", "PARENT_COLUMN_NAME") AS 
  select x.OWNER,
       x.TABLE_NAME,
       NESTED_TABLE_NAME,
       'OBJECT_VALUE' PARENT_COLUMN_NAME
  from ALL_XML_TABLES x,
       (
         select TABLE_NAME NESTED_TABLE_NAME,
                connect_by_root PARENT_TABLE_NAME PARENT_TABLE_NAME, OWNER
           from ALL_NESTED_TABLES nt
                connect by prior TABLE_NAME = PARENT_TABLE_NAME
                       and OWNER = OWNER
       ) nt
 where x.TABLE_NAME = nt.PARENT_TABLE_NAME
   and x.OWNER = nt.OWNER
UNION ALL
select x.OWNER,
       x.TABLE_NAME,
       NESTED_TABLE_NAME,
       x.COLUMN_NAME PARENT_COLUMN_NAME
 from ALL_XML_TAB_COLS x,
(
select TABLE_NAME NESTED_TABLE_NAME,
                connect_by_root PARENT_TABLE_NAME PARENT_TABLE_NAME, OWNER
           from ALL_NESTED_TABLES nt
                connect by prior TABLE_NAME = PARENT_TABLE_NAME
                       and OWNER = OWNER
       ) nt
where x.TABLE_NAME = nt.PARENT_TABLE_NAME and
x.owner = nt.OWNER
;
--------------------------------------------------------
--  DDL for View ALL_XML_OUT_OF_LINE_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_OUT_OF_LINE_TABLES" ("SCHEMA_URL", "SCHEMA_OWNER", "TABLE_NAME", "TABLE_OWNER") AS 
  select d.xmlschema as SCHEMA_URL, --schema URL
       d.schema_owner as SCHEMA_OWNER,  --schema owner
       d.table_name as TABLE_NAME, --out of line table name
       d.owner as TABLE_OWNER --out of line table owner
from   ALL_XML_TABLES d, sys.obj$ o, sys.opqtype$ op, sys.user$ u
where
o.owner# = u.user# and
d.table_name = o.name and
d.owner = u.name and
o.obj# = op.obj# and
bitand(op.flags,32) = 32
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMA_ATTRIBUTES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMA_ATTRIBUTES" ("OWNER", "SCHEMA_URL", "TARGET_NAMESPACE", "ATTRIBUTE_NAME", "IS_REF", "TYPE_NAME", "GLOBAL", "ATTRIBUTE", "ELEMENT_ID", "SQL_TYPE", "SQL_NAME") AS 
  select s.xmldata.schema_owner OWNER,
       s.xmldata.schema_url SCHEMA_URL,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       (case
          when a.xmldata.name IS NULL
          then
             a.xmldata.propref_name.name
          else
             a.xmldata.name
          end
       )AS ATTRIBUTE_NAME,
       (case
          when a.xmldata.name IS NULL
          then
             1
          else
             0
          end
       )AS IS_REF,
       (case
          when a.xmldata.typename.name IS NULL
          then
              (select a1.xmldata.typename.name from xdb.xdb$attribute a1 where ref(a1)=a.xmldata.propref_ref)
          else
             a.xmldata.typename.name
          end
       )AS TYPE_NAME,
       a.xmldata.global GLOBAL,
       value(a) ATTRIBUTE,
       hextoraw(e.xmldata.property.prop_number) AS ELEMENT_ID,
       a.xmldata.sqltype AS SQL_TYPE,
       a.xmldata.sqlname AS SQL_NAME
  from xdb.xdb$schema s, xdb.xdb$attribute a,  all_xml_schemas al,
       xdb.xdb$element e, xdb.xdb$complex_type ct,
       table(ct.xmldata.attributes) att
 where  sys_op_r2o(a.xmldata.parent_schema) = s.sys_nc_oid$ and
       s.xmldata.schema_owner = al.owner and
       s.xmldata.schema_url = al.schema_url and
       ref(ct) = e.xmldata.property.type_ref and
       att.column_value = ref(a)
UNION ALL
select s.xmldata.schema_owner OWNER,
       s.xmldata.schema_url SCHEMA_URL,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       (case
          when a.xmldata.name IS NULL
          then
             a.xmldata.propref_name.name
          else
             a.xmldata.name
          end
       )AS ATTRIBUTE_NAME,
       (case
          when a.xmldata.name IS NULL
          then
             1
          else
             0
          end
       )AS IS_REF,
       (case
          when a.xmldata.typename.name IS NULL
          then
              (select a1.xmldata.typename.name from xdb.xdb$attribute a1 where ref(a1)=a.xmldata.propref_ref)
          else
             a.xmldata.typename.name
          end
       )AS TYPE_NAME,
       a.xmldata.global GLOBAL,
       value(a) ATTRIBUTE,
       hextoraw(e.xmldata.property.prop_number) AS ELEMENT_ID,
       a.xmldata.sqltype AS SQL_TYPE,
       a.xmldata.sqlname AS SQL_NAME
  from xdb.xdb$schema s, xdb.xdb$attribute a,  all_xml_schemas al,
       xdb.xdb$element e, xdb.xdb$complex_type ct,
       table(ct.xmldata.simplecont.restriction.attributes) att
 where  sys_op_r2o(a.xmldata.parent_schema) = s.sys_nc_oid$ and
       s.xmldata.schema_owner = al.owner and
       s.xmldata.schema_url = al.schema_url and
       ref(ct) = e.xmldata.property.type_ref and
       att.column_value = ref(a)
UNION ALL
select s.xmldata.schema_owner OWNER,
       s.xmldata.schema_url SCHEMA_URL,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       (case
          when a.xmldata.name IS NULL
          then
             a.xmldata.propref_name.name
          else
             a.xmldata.name
          end
       )AS ATTRIBUTE_NAME,
       (case
          when a.xmldata.name IS NULL
          then
             1
          else
             0
          end
       )AS IS_REF,
       (case
          when a.xmldata.typename.name IS NULL
          then
              (select a1.xmldata.typename.name from xdb.xdb$attribute a1 where ref(a1)=a.xmldata.propref_ref)
          else
             a.xmldata.typename.name
          end
       )AS TYPE_NAME,
       a.xmldata.global GLOBAL,
       value(a) ATTRIBUTE,
       hextoraw(e.xmldata.property.prop_number) AS ELEMENT_ID,
       a.xmldata.sqltype AS SQL_TYPE,
       a.xmldata.sqlname AS SQL_NAME
  from xdb.xdb$schema s, xdb.xdb$attribute a,  all_xml_schemas al,
       xdb.xdb$element e, xdb.xdb$complex_type ct,
       table(ct.xmldata.simplecont.extension.attributes) att
 where  sys_op_r2o(a.xmldata.parent_schema) = s.sys_nc_oid$ and
       s.xmldata.schema_owner = al.owner and
       s.xmldata.schema_url = al.schema_url and
       ref(ct) = e.xmldata.property.type_ref and
       att.column_value = ref(a)
UNION ALL
select s.xmldata.schema_owner OWNER,
       s.xmldata.schema_url SCHEMA_URL,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       (case
          when a.xmldata.name IS NULL
          then
             a.xmldata.propref_name.name
          else
             a.xmldata.name
          end
       )AS ATTRIBUTE_NAME,
       (case
          when a.xmldata.name IS NULL
          then
             1
          else
             0
          end
       )AS IS_REF,
       (case
          when a.xmldata.typename.name IS NULL
          then
              (select a1.xmldata.typename.name from xdb.xdb$attribute a1 where ref(a1)=a.xmldata.propref_ref)
          else
             a.xmldata.typename.name
          end
       )AS TYPE_NAME,
       a.xmldata.global GLOBAL,
       value(a) ATTRIBUTE,
       NULL AS ELEMENT_ID,
       a.xmldata.sqltype AS SQL_TYPE,
       a.xmldata.sqlname AS SQL_NAME
   from xdb.xdb$schema s, xdb.xdb$attribute a,  all_xml_schemas al
 where  sys_op_r2o(a.xmldata.parent_schema) = s.sys_nc_oid$ and
       s.xmldata.schema_owner = al.owner and
       s.xmldata.schema_url = al.schema_url and
       (
         (
	   ref(a) NOT IN (select t.column_value from xdb.xdb$complex_type ct,table(ct.xmldata.attributes)t)
           AND
           ref(a) NOT IN (select t.column_value from xdb.xdb$complex_type ct,table(ct.xmldata.simplecont.extension.attributes)t)
           AND
           ref(a) NOT IN (select t.column_value from xdb.xdb$complex_type ct,table(ct.xmldata.simplecont.restriction.attributes)t)
	 )
         OR
         (
           (
             ref(a)  IN (select t.column_value from xdb.xdb$complex_type ct,table(ct.xmldata.attributes)t)
             OR
             ref(a) IN (select t.column_value from xdb.xdb$complex_type ct,table(ct.xmldata.simplecont.extension.attributes)t)
             OR
             ref(a) IN (select t.column_value from xdb.xdb$complex_type ct,table(ct.xmldata.simplecont.restriction.attributes)t)
           )
           and (select ref(ct) from xdb.xdb$complex_type ct,table(ct.xmldata.attributes)t,table(ct.xmldata.simplecont.extension.attributes)t1,table(ct.xmldata.simplecont.restriction.attributes)t2 where
	     ref(a)  = t.column_value
             OR
             ref(a) = t1.column_value
             OR
             ref(a) = t2.column_value
	   ) NOT IN ( select e.xmldata.property.type_ref from xdb.xdb$element e)
         )
       )
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMA_COMPLEX_TYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMA_COMPLEX_TYPES" ("OWNER", "SCHEMA_URL", "TARGET_NAMESPACE", "COMPLEX_TYPE_NAME", "COMPLEX_TYPE", "BASE_NAME", "BASE_SCHEMA_URL", "BASE_TARGET_NAMESPACE", "MAINTAIN_DOM", "SQL_TYPE", "SQL_SCHEMA") AS 
  select s.xmldata.schema_owner OWNER,
       s.xmldata.schema_url SCHEMA_URL,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       ct.xmldata.name COMPLEX_TYPE_NAME,
       value(ct) COMPLEX_TYPE,
        (case
        when
                ct.xmldata.BASE_TYPE IS NULL then NULL
        when
                ( select count(1)
                  from xdb.xdb$simple_type st
                  where ct.xmldata.BASE_TYPE = ref(st) ) != 0
        then
                ( select st.xmldata.name
                  from  xdb.xdb$simple_type st
                  where ct.xmldata.BASE_TYPE = ref(st)  )
        else
                ( select ctb.xmldata.name
                  from xdb.xdb$complex_type ctm,
                       xdb.xdb$complex_type ctb
                  where ref(ct)  = ref(ctm)
                        and ctm.xmldata.BASE_TYPE = ref(ctb)  )
        end ) BASE_NAME,
        (case
        when
                ct.xmldata.BASE_TYPE IS NULL then NULL
        when
                ( select count(1)
                  from xdb.xdb$simple_type st
                  where ct.xmldata.BASE_TYPE = ref(st) ) != 0
        then
                ( select s.xmldata.schema_url
                  from  xdb.xdb$simple_type st, xdb.xdb$schema s
                  where ct.xmldata.BASE_TYPE = ref(st)
                  and sys_op_r2o(st.xmldata.parent_schema)  = s.sys_nc_oid$)
        else
                ( select s.xmldata.schema_url
                  from xdb.xdb$complex_type ctm,
                       xdb.xdb$complex_type ctb,
                       xdb.xdb$schema s
                  where ref(ct)  = ref(ctm)
                        and ctm.xmldata.BASE_TYPE = ref(ctb) and
                        sys_op_r2o(ctb.xmldata.parent_schema)  = s.sys_nc_oid$ )
        end ) BASE_SCHEMA_URL,
        (case
        when
                ct.xmldata.BASE_TYPE IS NULL then NULL
        when
                ( select count(1)
                  from xdb.xdb$simple_type st
                  where ct.xmldata.BASE_TYPE = ref(st) ) != 0
        then
                ( select s.xmldata.target_namespace
                  from  xdb.xdb$simple_type st, xdb.xdb$schema s
                  where ct.xmldata.BASE_TYPE = ref(st)
                  and sys_op_r2o(st.xmldata.parent_schema)  = s.sys_nc_oid$)
        else
                ( select s.xmldata.target_namespace
                  from xdb.xdb$complex_type ctm,
                       xdb.xdb$complex_type ctb,
                       xdb.xdb$schema s
                  where ref(ct)  = ref(ctm)
                        and ctm.xmldata.BASE_TYPE = ref(ctb) and
                        sys_op_r2o(ctb.xmldata.parent_schema)  = s.sys_nc_oid$ )
        end ) BASE_TARGET_NAMESPACE,
       ct.xmldata.maintain_dom MAINTAIN_DOM,
       ct.xmldata.sqltype SQL_TYPE,
       ct.xmldata.SQLSCHEMA SQL_SCHEMA
  from xdb.xdb$schema s, xdb.xdb$complex_type ct,all_xml_schemas a
 where sys_op_r2o(ct.xmldata.parent_schema)  = s.sys_nc_oid$ and
       s.xmldata.schema_owner = a.owner and
       s.xmldata.schema_url = a.schema_url
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMA_ELEMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMA_ELEMENTS" ("OWNER", "SCHEMA_URL", "TARGET_NAMESPACE", "ELEMENT_NAME", "IS_REF", "TYPE_NAME", "GLOBAL", "ELEMENT", "SQL_INLINE", "SQL_TYPE", "SQL_SCHEMA", "DEFAULT_TABLE", "SQL_NAME", "SQL_COL_TYPE", "MAINTAIN_DOM", "MAINTAIN_ORDER", "ELEMENT_ID", "PARENT_ELEMENT_ID") AS 
  (select s.xmldata.schema_owner AS OWNER,
       s.xmldata.schema_url AS SCHEMA_URL,
       s.xmldata.target_namespace AS TARGET_NAMESPACE,
       (case
          when e.xmldata.property.name IS NULL
          then
             e.xmldata.property.propref_name.name
          else
             e.xmldata.property.name
          end
       )AS ELEMENT_NAME,
       (case
          when e.xmldata.property.name IS NULL
          then
              1
          else
             0
          end
       )AS IS_REF,
       e.xmldata.property.typename.name AS TYPE_NAME,
       e.xmldata.property.global AS GLOBAL,
       value(e) AS ELEMENT,
       e.xmldata.sql_inline AS SQL_INLINE,
       e.xmldata.property.sqltype AS SQL_TYPE,
       e.xmldata.property.sqlschema AS SQL_SCHEMA,
       e.xmldata.default_table AS DEFAULT_TABLE,
       e.xmldata.property.sqlname AS SQL_NAME,
       e.xmldata.property.sqlcolltype AS SQL_COL_TYPE,
       e.xmldata.maintain_dom AS MAINTAIN_DOM,
       e.xmldata.maintain_order AS MAINTAIN_ORDER,
       hextoraw(e.xmldata.property.prop_number) AS ELEMENT_ID,
       t.column_value AS PARENT_ELEMENT_ID
  from xdb.xdb$schema s, xdb.xdb$element e, all_xml_schemas a,
       table( PrvtParentChild.getParentID(e.xmldata.property.prop_number)) t
 where sys_op_r2o(e.xmldata.property.parent_schema) = s.sys_nc_oid$ and
       s.xmldata.schema_owner = a.owner and
       s.xmldata.schema_url = a.schema_url and
       PrvtParentChild.sizeArray(e.xmldata.property.prop_number) <> 0
UNION ALL
select s.xmldata.schema_owner AS OWNER,
       s.xmldata.schema_url AS SCHEMA_URL,
       s.xmldata.target_namespace AS TARGET_NAMESPACE,
       (case
          when e.xmldata.property.name IS NULL
          then
             e.xmldata.property.propref_name.name
          else
             e.xmldata.property.name
          end
       )AS ELEMENT_NAME,
       (case
          when e.xmldata.property.name IS NULL
          then
              1
          else
             0
          end
       )AS IS_REF,
       e.xmldata.property.typename.name AS TYPE_NAME,
       e.xmldata.property.global AS GLOBAL,
       value(e) AS ELEMENT,
       e.xmldata.sql_inline AS SQL_INLINE,
       e.xmldata.property.sqltype AS SQL_TYPE,
       e.xmldata.property.sqlschema AS SQL_SCHEMA,
       e.xmldata.default_table AS DEFAULT_TABLE,
       e.xmldata.property.sqlname AS SQL_NAME,
       e.xmldata.property.sqlcolltype AS SQL_COL_TYPE,
       e.xmldata.maintain_dom AS MAINTAIN_DOM,
       e.xmldata.maintain_order AS MAINTAIN_ORDER,
       hextoraw(e.xmldata.property.prop_number) AS ELEMENT_ID,
       NULL AS PARENT_ELEMENT_ID
  from xdb.xdb$schema s, xdb.xdb$element e, all_xml_schemas a
 where sys_op_r2o(e.xmldata.property.parent_schema) = s.sys_nc_oid$ and
       s.xmldata.schema_owner = a.owner and
       s.xmldata.schema_url = a.schema_url and
       PrvtParentChild.sizeArray(e.xmldata.property.prop_number) = 0
)
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMA_NAMESPACES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMA_NAMESPACES" ("OWNER", "TARGET_NAMESPACE", "SCHEMA_URL") AS 
  select s.xmldata.schema_owner OWNER,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       s.xmldata.schema_url SCHEMA_URL
  from xdb.xdb$schema s, all_xml_schemas a
  where s.xmldata.schema_owner = a.owner
  and s.xmldata.schema_url = a.schema_url
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMAS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMAS" ("OWNER", "SCHEMA_URL", "LOCAL", "SCHEMA", "INT_OBJNAME", "QUAL_SCHEMA_URL", "HIER_TYPE", "BINARY", "SCHEMA_ID", "HIDDEN") AS 
  select u.name, s.xmldata.schema_url,
          case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16) = 16
               then 'NO' else 'YES' end,
	  case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16384) = 16384
               then xdb.dbms_csx_int.GetCSXSchema(xmltype(value(s).getclobval())) else value(s) end,
          xdb.dbms_xmlschema_int.xdb$Oid2IntName(s.object_id),
          case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16) = 16
               then s.xmldata.schema_url
               else 'http://xmlns.oracle.com/xdb/schemas/' ||
                    s.xmldata.schema_owner || '/' ||
                    case when substrb(s.xmldata.schema_url, 1, 7) = 'http://'
                         then substrb(s.xmldata.schema_url, 8)
                         else s.xmldata.schema_url
                    end
          end,
          case when bitand(to_number(s.xmldata.flags, 'xxxxxxxx'), 128) = 128
               then 'NONE'
               else case when
                    bitand(to_number(s.xmldata.flags, 'xxxxxxxx'), 64) = 64
                    then  'RESMETADATA'
                    else  'CONTENTS'
                    end
          end,
          case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16384) = 16384
              then 'YES' else 'NO' end,
          s.sys_nc_oid$,
          case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 32768) = 32768
              then 'YES' else 'NO' end
    from user$ u, xdb.xdb$schema s
    where u.user# = userenv('SCHEMAID')
    and   u.name  = s.xmldata.schema_owner
    union all
    select s.xmldata.schema_owner, s.xmldata.schema_url, 'NO', value(s),
          xdb.dbms_xmlschema_int.xdb$Oid2IntName(s.object_id),
          s.xmldata.schema_url,
          case when bitand(to_number(s.xmldata.flags, 'xxxxxxxx'), 128) = 128
               then 'NONE'
               else case when
                    bitand(to_number(s.xmldata.flags, 'xxxxxxxx'), 64) = 64
                    then  'RESMETADATA'
                    else  'CONTENTS'
                    end
          end,
          case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16384) = 16384
              then 'YES' else 'NO' end,
          s.sys_nc_oid$,
          case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 32768) = 32768
              then 'YES' else 'NO' end
    from xdb.xdb$schema s
    where bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16) = 16
    and s.xmldata.schema_url
       not in (select s2.xmldata.schema_url
               from xdb.xdb$schema s2, user$ u2
               where u2.user# = userenv('SCHEMAID')
               and   u2.name  = s.xmldata.schema_owner);

   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."OWNER" IS 'Owner of the XML Schema';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."SCHEMA_URL" IS 'Schema URL of the XML Schema';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."LOCAL" IS 'Is this XML Schema local or global';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."SCHEMA" IS 'The XML Schema document';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."INT_OBJNAME" IS 'The internal database object name for the schema';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."QUAL_SCHEMA_URL" IS 'The fully qualified schema URL';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."HIER_TYPE" IS 'The type of hierarchy for which the schema is enabled';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."BINARY" IS 'Is this XML Schema registered for binary encoding usage?';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."SCHEMA_ID" IS '16 byte opaque schema identifier';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS"."HIDDEN" IS 'Has this XML Schema been deleted in hidden mode?';
   COMMENT ON TABLE "SYS"."ALL_XML_SCHEMAS"  IS 'Description of all XML Schemas that user has privilege to reference'
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMA_SIMPLE_TYPES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMA_SIMPLE_TYPES" ("OWNER", "SCHEMA_URL", "TARGET_NAMESPACE", "SIMPLE_TYPE_NAME", "SIMPLE_TYPE") AS 
  select s.xmldata.schema_owner OWNER,
       s.xmldata.schema_url SCHEMA_URL,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       st.xmldata.name SIMPLE_TYPE_NAME,
       value(st) SIMPLE_TYPE
    from xdb.xdb$schema s, xdb.xdb$simple_type st, all_xml_schemas a
   where sys_op_r2o(st.xmldata.parent_schema)  = s.sys_nc_oid$ and
       s.xmldata.schema_owner = a.owner and
       s.xmldata.schema_url = a.schema_url
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMA_SUBSTGRP_HEAD
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMA_SUBSTGRP_HEAD" ("OWNER", "SCHEMA_URL", "TARGET_NAMESPACE", "ELEMENT_NAME", "ELEMENT") AS 
  select s.xmldata.schema_owner OWNER,
       s.xmldata.schema_url SCHEMA_URL,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       e.xmldata.property.name ELEMENT_NAME,
       value(e) ELEMENT
  from xdb.xdb$schema s, xdb.xdb$element e, all_xml_schemas a
 where sys_op_r2o(e.xmldata.property.parent_schema) = s.sys_nc_oid$
   and s.xmldata.schema_owner = a.owner
   and s.xmldata.schema_url = a.schema_url
   and e.xmldata.property.global = hexToRaw('01')
   and e.sys_nc_oid$ in ( select distinct sys_op_r2o
                         (se.xmldata.HEAD_ELEM_REF)
                          from xdb.xdb$element se
                          where  se.xmldata.HEAD_ELEM_REF is not null)
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMA_SUBSTGRP_MBRS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMA_SUBSTGRP_MBRS" ("OWNER", "SCHEMA_URL", "TARGET_NAMESPACE", "ELEMENT_NAME", "ELEMENT", "HEAD_OWNER", "HEAD_SCHEMA_URL", "HEAD_TARGET_NAMESPACE", "HEAD_ELEMENT_NAME", "HEAD_ELEMENT") AS 
  select s.xmldata.schema_owner OWNER,
       s.xmldata.schema_url SCHEMA_URL,
       s.xmldata.target_namespace TARGET_NAMESPACE,
       e.xmldata.property.name ELEMENT_NAME,
       value(e) ELEMENT,
       hs.xmldata.schema_owner HEAD_OWNER,
       hs.xmldata.schema_url HEAD_SCHEMA_URL,
       hs.xmldata.target_namespace HEAD_TARGET_NAMESPACE,
       he.xmldata.property.name HEAD_ELEMENT_NAME,
       value(he) HEAD_ELEMENT
  from xdb.xdb$schema s, xdb.xdb$schema hs, xdb.xdb$element e,
       xdb.xdb$element he,
all_xml_schemas a
 where sys_op_r2o(e.xmldata.property.parent_schema) = s.sys_nc_oid$
   and s.xmldata.schema_owner = a.owner
   and s.xmldata.schema_url = a.schema_url
   and e.xmldata.property.global = hexToRaw('01')
   and he.sys_nc_oid$ = sys_op_r2o(e.xmldata.HEAD_ELEM_REF)
   and sys_op_r2o(he.xmldata.property.parent_schema) = hs.sys_nc_oid$
;
--------------------------------------------------------
--  DDL for View ALL_XML_SCHEMAS2
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_SCHEMAS2" ("OWNER", "SCHEMA_URL", "LOCAL", "INT_OBJNAME", "QUAL_SCHEMA_URL") AS 
  select u.name, s.xmldata.schema_url,
          case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16) = 16
               then 'NO' else 'YES' end,
          xdb.dbms_xmlschema_int.xdb$Oid2IntName(s.object_id),
          case when bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16) = 16
               then s.xmldata.schema_url
               else 'http://xmlns.oracle.com/xdb/schemas/' ||
                    s.xmldata.schema_owner || '/' ||
                    case when substrb(s.xmldata.schema_url, 1, 7) = 'http://'
                         then substrb(s.xmldata.schema_url, 8)
                         else s.xmldata.schema_url
                    end
          end
    from user$ u, xdb.xdb$schema s
    where u.user# = userenv('SCHEMAID')
    and   u.name  = s.xmldata.schema_owner
    union all
    select s.xmldata.schema_owner, s.xmldata.schema_url, 'NO',
          xdb.dbms_xmlschema_int.xdb$Oid2IntName(s.object_id),
          s.xmldata.schema_url
    from xdb.xdb$schema s
    where bitand(to_number(s.xmldata.flags,'xxxxxxxx'), 16) = 16
    and s.xmldata.schema_url
       not in (select s2.xmldata.schema_url
               from xdb.xdb$schema s2, user$ u2
               where u2.user# = userenv('SCHEMAID')
               and   u2.name  = s.xmldata.schema_owner);

   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS2"."OWNER" IS 'Owner of the XML Schema';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS2"."SCHEMA_URL" IS 'Schema URL of the XML Schema';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS2"."LOCAL" IS 'Is this XML Schema local or global';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS2"."INT_OBJNAME" IS 'The internal database object name for the schema';
   COMMENT ON COLUMN "SYS"."ALL_XML_SCHEMAS2"."QUAL_SCHEMA_URL" IS 'The fully qualified schema URL';
   COMMENT ON TABLE "SYS"."ALL_XML_SCHEMAS2"  IS 'Dummy version of ALL_XML_SCHEMAS that does not have an XMLTYPE column'
;
--------------------------------------------------------
--  DDL for View ALL_XML_TAB_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_TAB_COLS" ("OWNER", "TABLE_NAME", "COLUMN_NAME", "XMLSCHEMA", "SCHEMA_OWNER", "ELEMENT_NAME", "STORAGE_TYPE", "ANYSCHEMA", "NONSCHEMA", "TOKENSETS") AS 
  select u.name, o.name,
   decode(bitand(tc.property, 1), 1, attr.name, tc.name),null,null,null,
   case when bitand(opq.flags,69) = 1 then 'OBJECT-RELATIONAL'
        when bitand(opq.flags,69) = 68 then 'BINARY'
   else 'CLOB' end,
   case when bitand(opq.flags,69) = 68 then
       case when bitand(opq.flags,128) = 128 then 'YES' else 'NO' end
   else NULL end,
   case when bitand(opq.flags,69) = 68  then
       case when bitand(opq.flags,256) = 256 then 'NO' else 'YES' end
   else NULL end, null
from  sys.opqtype$ opq,
      sys.tab$ t, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc,
      sys.attrcol$ attr
where o.owner# = u.user#
  and o.obj# = t.obj#
  and t.obj# = tc.obj#
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# = opq.intcol#
  and tc.obj# =  opq.obj#
  and tc.obj#    = attr.obj#(+)
  and tc.intcol# = attr.intcol#(+)
  and bitand(opq.flags,2) = 0
  and bitand(tc.property, 512) = 0
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
  and (bitand(t.property, power(2,64)) = 0
       or bitand(opq.flags,69) != 68)
  union all
 select u.name, o.name,
  decode(bitand(tc.property, 1), 1, attr.name, tc.name),
  schm.xmldata.schema_url, schm.xmldata.schema_owner,
decode(xel.xmldata.property.name, null,
        xel.xmldata.property.propref_name.name, xel.xmldata.property.name),
    case when bitand(opq.flags,69) = 1 then 'OBJECT-RELATIONAL'
         when bitand(opq.flags,69) = 68 then 'BINARY'
    else 'CLOB' end,
    case when bitand(opq.flags,69) = 68 then
        case when bitand(opq.flags,128) = 128 then 'YES' else 'NO' end
    else NULL end,
    case when bitand(opq.flags,69) = 68  then
        case when bitand(opq.flags,256) = 256 then 'NO' else 'YES' end
    else NULL end, null
 from xdb.xdb$element xel, xdb.xdb$schema schm, sys.opqtype$ opq,
      sys.tab$ t, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc,
      sys.attrcol$ attr
 where o.owner# = u.user#
  and o.obj# = t.obj#
  and t.obj# = tc.obj#
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# = opq.intcol#
  and tc.obj# =  opq.obj#
  and tc.obj#    = attr.obj#(+)
  and tc.intcol# = attr.intcol#(+)
  and bitand(tc.property, 512) = 0
  and opq.schemaoid =  schm.sys_nc_oid$
  and opq.elemnum =  xel.xmldata.property.prop_number
  and bitand(opq.flags,2) = 2
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
  and (bitand(t.property, power(2,64)) = 0
       or bitand(opq.flags,69) != 68)
  union all
 select u.name, o.name,
   decode(bitand(tc.property, 1), 1, attr.name, tc.name),null,null,null,
   case when bitand(opq.flags,69) = 1 then 'OBJECT-RELATIONAL'
        when bitand(opq.flags,69) = 68 then 'BINARY'
   else 'CLOB' end,
   case when bitand(opq.flags,69) = 68 then
       case when bitand(opq.flags,128) = 128 then 'YES' else 'NO' end
   else NULL end,
   case when bitand(opq.flags,69) = 68  then
       case when bitand(opq.flags,256) = 256 then 'NO' else 'YES' end
   else NULL end, tm.tokensets
from  sys.opqtype$ opq,
      sys.tab$ t, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc,
      sys.attrcol$ attr, (select tmap.guid as guid,
              LISTAGG(ob.name, ',') within group (order by ob.name)
                as tokensets
        from sys.obj$ ob, xdb.xdb$tsetmap tmap
        where tmap.obj#=ob.obj#
        group by tmap.guid) tm, xdb.xdb$ttset ts
where o.owner# = u.user#
  and o.obj# = t.obj#
  and t.obj# = tc.obj#
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# = opq.intcol#
  and tc.obj# =  opq.obj#
  and tc.obj#    = attr.obj#(+)
  and tc.intcol# = attr.intcol#(+)
  and bitand(opq.flags,2) = 0
  and bitand(tc.property, 512) = 0
  and ts.guid=tm.guid
  and ts.obj#=o.obj#
  and bitand(t.property, power(2,64)) = power(2,64)
  and bitand(opq.flags,69) = 68
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
  union all
 select u.name, o.name,
  decode(bitand(tc.property, 1), 1, attr.name, tc.name),
  schm.xmldata.schema_url, schm.xmldata.schema_owner,
decode(xel.xmldata.property.name, null,
        xel.xmldata.property.propref_name.name, xel.xmldata.property.name),
    case when bitand(opq.flags,69) = 1 then 'OBJECT-RELATIONAL'
         when bitand(opq.flags,69) = 68 then 'BINARY'
    else 'CLOB' end,
    case when bitand(opq.flags,69) = 68 then
        case when bitand(opq.flags,128) = 128 then 'YES' else 'NO' end
    else NULL end,
    case when bitand(opq.flags,69) = 68  then
        case when bitand(opq.flags,256) = 256 then 'NO' else 'YES' end
    else NULL end, tm.tokensets
 from xdb.xdb$element xel, xdb.xdb$schema schm, sys.opqtype$ opq,
      sys.tab$ t, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc,
      sys.attrcol$ attr, (select tmap.guid as guid,
              LISTAGG(ob.name, ',') within group (order by ob.name)
                as tokensets
        from sys.obj$ ob, xdb.xdb$tsetmap tmap
        where tmap.obj#=ob.obj#
        group by tmap.guid) tm, xdb.xdb$ttset ts
 where o.owner# = u.user#
  and o.obj# = t.obj#
  and t.obj# = tc.obj#
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# = opq.intcol#
  and tc.obj# =  opq.obj#
  and tc.obj#    = attr.obj#(+)
  and tc.intcol# = attr.intcol#(+)
  and bitand(tc.property, 512) = 0
  and opq.schemaoid =  schm.sys_nc_oid$
  and opq.elemnum =  xel.xmldata.property.prop_number
  and bitand(opq.flags,2) = 2
  and ts.guid=tm.guid
  and ts.obj#=o.obj#
  and bitand(t.property, power(2,64)) = power(2,64)
  and bitand(opq.flags,69) = 68
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_XML_TAB_COLS"."OWNER" IS 'Owner of the table ';
   COMMENT ON COLUMN "SYS"."ALL_XML_TAB_COLS"."TABLE_NAME" IS 'Name of the table ';
   COMMENT ON COLUMN "SYS"."ALL_XML_TAB_COLS"."XMLSCHEMA" IS 'Name of the XMLSchema that is used for the table definition';
   COMMENT ON COLUMN "SYS"."ALL_XML_TAB_COLS"."SCHEMA_OWNER" IS 'Name of the owner of the XMLSchema used for table definition';
   COMMENT ON COLUMN "SYS"."ALL_XML_TAB_COLS"."ELEMENT_NAME" IS 'Name XMLSChema element that is used for the table';
   COMMENT ON COLUMN "SYS"."ALL_XML_TAB_COLS"."STORAGE_TYPE" IS 'Type of storage option for the XMLtype data';
   COMMENT ON COLUMN "SYS"."ALL_XML_TAB_COLS"."ANYSCHEMA" IS 'If storage is BINARY, does this column allow ANYSCHEMA?';
   COMMENT ON COLUMN "SYS"."ALL_XML_TAB_COLS"."NONSCHEMA" IS 'If storage is BINARY, does this column allow NONSCHEMA?';
   COMMENT ON TABLE "SYS"."ALL_XML_TAB_COLS"  IS 'Description of the all XMLType tables that the user has privileges on'
;
--------------------------------------------------------
--  DDL for View ALL_XML_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_TABLES" ("OWNER", "TABLE_NAME", "XMLSCHEMA", "SCHEMA_OWNER", "ELEMENT_NAME", "STORAGE_TYPE", "ANYSCHEMA", "NONSCHEMA", "TOKENSETS") AS 
  select u.name, o.name, null, null, null,
    case when bitand(opq.flags,69) = 1 then 'OBJECT-RELATIONAL'
         when bitand(opq.flags,69) = 68 then 'BINARY'
    else 'CLOB' end,
    case when bitand(opq.flags,69) = 68 then
        case when bitand(opq.flags,128) = 128 then 'YES' else 'NO' end
    else NULL end,
    case when bitand(opq.flags,69) = 68  then
        case when bitand(opq.flags,256) = 256 then 'NO' else 'YES' end
    else NULL end, null
 from sys.opqtype$ opq, sys.tab$ t, sys.user$ u, sys.obj$ o,
      sys.coltype$ ac, sys.col$ tc
 where o.owner# = u.user#
  and o.obj# = t.obj#
  and bitand(t.property, 1) = 1
  and t.obj# = tc.obj#
  and tc.name = 'SYS_NC_ROWINFO$'
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# =  opq.intcol#
  and tc.obj# =  opq.obj#
  and bitand(opq.flags,2) = 0
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
  and bitand(t.property, power(2,64)) = 0
 union all
 select u.name, o.name, schm.xmldata.schema_url, schm.xmldata.schema_owner,
 decode(xel.xmldata.property.name, null,
        xel.xmldata.property.propref_name.name, xel.xmldata.property.name),
  case when bitand(opq.flags,69) = 1 then 'OBJECT-RELATIONAL'
       when bitand(opq.flags,69) = 68 then 'BINARY'
  else 'CLOB' end,
  case when bitand(opq.flags,69) = 68 then
      case when bitand(opq.flags,128) = 128 then 'YES' else 'NO' end
  else NULL end,
  case when bitand(opq.flags,69) = 68  then
      case when bitand(opq.flags,256) = 256 then 'NO' else 'YES' end
  else NULL end, null
from xdb.xdb$element xel, xdb.xdb$schema schm, sys.opqtype$ opq,
      sys.tab$ t, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc
where o.owner# = u.user#
  and o.obj# = t.obj#
  and bitand(t.property, 1) = 1
  and t.obj# = tc.obj#
  and tc.name = 'SYS_NC_ROWINFO$'
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# =  opq.intcol#
  and tc.obj# =  opq.obj#
  and opq.schemaoid =  schm.sys_nc_oid$
  and bitand(opq.flags,2) = 2
  and opq.elemnum =  xel.xmldata.property.prop_number
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
  and bitand(t.property, power(2,64)) = 0
 union all
 select u.name, o.name, null, null, null,
    case when bitand(opq.flags,69) = 1 then 'OBJECT-RELATIONAL'
         when bitand(opq.flags,69) = 68 then 'BINARY'
    else 'CLOB' end,
    case when bitand(opq.flags,69) = 68 then
        case when bitand(opq.flags,128) = 128 then 'YES' else 'NO' end
    else NULL end,
    case when bitand(opq.flags,69) = 68  then
        case when bitand(opq.flags,256) = 256 then 'NO' else 'YES' end
    else NULL end, tm.tokensets
 from sys.opqtype$ opq, sys.tab$ t, sys.user$ u, sys.obj$ o,
      sys.coltype$ ac, sys.col$ tc,
      (select tmap.guid as guid,
              LISTAGG(ob.name, ',') within group (order by ob.name)
                as tokensets
        from sys.obj$ ob, xdb.xdb$tsetmap tmap
        where tmap.obj#=ob.obj#
        group by tmap.guid) tm, xdb.xdb$ttset ts
 where o.owner# = u.user#
  and o.obj# = t.obj#
  and bitand(t.property, 1) = 1
  and t.obj# = tc.obj#
  and tc.name = 'SYS_NC_ROWINFO$'
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# =  opq.intcol#
  and tc.obj# =  opq.obj#
  and bitand(opq.flags,2) = 0
  and ts.guid=tm.guid
  and ts.obj#=o.obj#
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
  and bitand(t.property, power(2,64)) = power(2,64)
 union all
 select u.name, o.name, schm.xmldata.schema_url, schm.xmldata.schema_owner,
 decode(xel.xmldata.property.name, null,
        xel.xmldata.property.propref_name.name, xel.xmldata.property.name),
  case when bitand(opq.flags,69) = 1 then 'OBJECT-RELATIONAL'
       when bitand(opq.flags,69) = 68 then 'BINARY'
  else 'CLOB' end,
  case when bitand(opq.flags,69) = 68 then
      case when bitand(opq.flags,128) = 128 then 'YES' else 'NO' end
  else NULL end,
  case when bitand(opq.flags,69) = 68  then
      case when bitand(opq.flags,256) = 256 then 'NO' else 'YES' end
  else NULL end, tm.tokensets
from xdb.xdb$element xel, xdb.xdb$schema schm, sys.opqtype$ opq,
      sys.tab$ t, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc,
      (select tmap.guid as guid,
              LISTAGG(ob.name, ',') within group (order by ob.name)
                as tokensets
        from sys.obj$ ob, xdb.xdb$tsetmap tmap
        where tmap.obj#=ob.obj#
        group by tmap.guid) tm, xdb.xdb$ttset ts
where o.owner# = u.user#
  and o.obj# = t.obj#
  and bitand(t.property, 1) = 1
  and t.obj# = tc.obj#
  and tc.name = 'SYS_NC_ROWINFO$'
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# =  opq.intcol#
  and tc.obj# =  opq.obj#
  and opq.schemaoid =  schm.sys_nc_oid$
  and bitand(opq.flags,2) = 2
  and ts.guid=tm.guid
  and ts.obj#=o.obj#
  and opq.elemnum =  xel.xmldata.property.prop_number
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
  and bitand(t.property, power(2,64)) = power(2,64);

   COMMENT ON COLUMN "SYS"."ALL_XML_TABLES"."OWNER" IS 'Owner of the table ';
   COMMENT ON COLUMN "SYS"."ALL_XML_TABLES"."TABLE_NAME" IS 'Name of the table ';
   COMMENT ON COLUMN "SYS"."ALL_XML_TABLES"."XMLSCHEMA" IS 'Name of the XMLSchema that is used for the table definition';
   COMMENT ON COLUMN "SYS"."ALL_XML_TABLES"."SCHEMA_OWNER" IS 'Name of the owner of the XMLSchema used for table definition';
   COMMENT ON COLUMN "SYS"."ALL_XML_TABLES"."ELEMENT_NAME" IS 'Name XMLSChema element that is used for the table';
   COMMENT ON COLUMN "SYS"."ALL_XML_TABLES"."STORAGE_TYPE" IS 'Type of storage option for the XMLtype data';
   COMMENT ON COLUMN "SYS"."ALL_XML_TABLES"."ANYSCHEMA" IS 'If storage is BINARY, does this column allow ANYSCHEMA?';
   COMMENT ON COLUMN "SYS"."ALL_XML_TABLES"."NONSCHEMA" IS 'If storage is BINARY, does this column allow NONSCHEMA?';
   COMMENT ON TABLE "SYS"."ALL_XML_TABLES"  IS 'Description of the all XMLType tables that the user has privileges on'
;
--------------------------------------------------------
--  DDL for View ALL_XMLTYPE_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XMLTYPE_COLS" ("SCHEMA_ID", "SCHEMA_URL", "COL_NAME", "QUALIFIED_COL_NAME", "TABLE_NAME", "TABLE_OWNER") AS 
  ((select s.sys_nc_oid$ as SCHEMA_ID,
       s.xmldata.schema_url as SCHEMA_URL, --schema URL for the column
       c.name as COL_NAME,  --name of the relational column
       (select c1.name from sys.col$ c1 where c1.intcol# = op.objcol and
        c1.obj# = op.obj#) QUALIFIED_COL_NAME,
       o.name as TABLE_NAME, --name of the parent table
       u.name as TABLE_OWNER --parent table owner
from xdb.xdb$schema s, sys.opqtype$ op, sys.col$ c, sys.obj$ o, sys.user$ u,
     all_tables a
where o.type# = 2 and
o.obj# = op.obj# and
o.obj# = c.obj# and
op.schemaoid = s.sys_nc_oid$ and
o.owner# = u.user# and
c.intcol# = op.intcol# and
o.name = a.table_name and
u.name = a.owner)
UNION
(select NULL as SCHEMA_ID,
       NULL as SCHEMA_URL, --schema URL for the column
       c.name as COL_NAME,  --name of the relational column
       (select c1.name from sys.col$ c1 where c1.intcol# = op.objcol and
        c1.obj# = op.obj#) QUALIFIED_COL_NAME,
       o.name as TABLE_NAME, --name of the parent table
       u.name as TABLE_OWNER --parent table owner
from sys.opqtype$ op, sys.col$ c, sys.obj$ o, sys.user$ u,
     all_tables a
where o.type# = 2 and
o.obj# = op.obj# and
o.obj# = c.obj# and
o.owner# = u.user# and
c.intcol# = op.intcol# and
o.name = a.table_name and
u.name = a.owner and op.schemaoid IS NULL))
;
--------------------------------------------------------
--  DDL for View ALL_XML_VIEW_COLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_VIEW_COLS" ("OWNER", "VIEW_NAME", "COLUMN_NAME", "XMLSCHEMA", "SCHEMA_OWNER", "ELEMENT_NAME") AS 
  select u.name, o.name,
  decode(bitand(tc.property, 1), 1, attr.name, tc.name),
  null, null, null
from sys.opqtype$ opq,
      sys.view$ v, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc,
      sys.attrcol$ attr
where o.owner# = u.user#
  and o.obj# = v.obj#
  and bitand(v.property, 1) = 1
  and v.obj# = tc.obj#
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# = opq.intcol#
  and tc.obj# =  opq.obj#
  and tc.obj#    = attr.obj#(+)
  and tc.intcol# = attr.intcol#(+)
  and bitand(opq.flags,2) = 0
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
union all
select u.name, o.name,
  decode(bitand(tc.property, 1), 1, attr.name, tc.name),
  schm.xmldata.schema_url, schm.xmldata.schema_owner,
decode(xel.xmldata.property.name, null,
        xel.xmldata.property.propref_name.name, xel.xmldata.property.name)
from xdb.xdb$element xel, xdb.xdb$schema schm, sys.opqtype$ opq,
      sys.view$ v, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc,
      sys.attrcol$ attr
where o.owner# = u.user#
  and o.obj# = v.obj#
  and bitand(v.property, 1) = 1
  and v.obj# = tc.obj#
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# = opq.intcol#
  and tc.obj# =  opq.obj#
  and tc.obj#    = attr.obj#(+)
  and tc.intcol# = attr.intcol#(+)
  and opq.schemaoid =  schm.sys_nc_oid$
  and opq.elemnum =  xel.xmldata.property.prop_number
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_XML_VIEW_COLS"."OWNER" IS 'Owner of the view ';
   COMMENT ON COLUMN "SYS"."ALL_XML_VIEW_COLS"."VIEW_NAME" IS 'Name of the view ';
   COMMENT ON COLUMN "SYS"."ALL_XML_VIEW_COLS"."XMLSCHEMA" IS 'Name of the XMLSchema that is used for the view definition';
   COMMENT ON COLUMN "SYS"."ALL_XML_VIEW_COLS"."SCHEMA_OWNER" IS 'Name of the owner of the XMLSchema used for table definition';
   COMMENT ON COLUMN "SYS"."ALL_XML_VIEW_COLS"."ELEMENT_NAME" IS 'Name XMLSChema element that is used for the view';
   COMMENT ON TABLE "SYS"."ALL_XML_VIEW_COLS"  IS 'Description of the all XMLType views that the user has privileges on'
;
--------------------------------------------------------
--  DDL for View ALL_XML_VIEWS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XML_VIEWS" ("OWNER", "VIEW_NAME", "XMLSCHEMA", "SCHEMA_OWNER", "ELEMENT_NAME") AS 
  select u.name, o.name, null, null, null
 from sys.opqtype$ opq,
      sys.view$ v, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc
 where o.owner# = u.user#
  and o.obj# = v.obj#
  and bitand(v.property, 1) = 1
  and v.obj# = tc.obj#
  and tc.name = 'SYS_NC_ROWINFO$'
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# =  opq.intcol#
  and tc.obj# =  opq.obj#
  and bitand(opq.flags,2) = 0
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      )
 union all
 select u.name, o.name, schm.xmldata.schema_url, schm.xmldata.schema_owner,
   decode(xel.xmldata.property.name, null,
        xel.xmldata.property.propref_name.name, xel.xmldata.property.name)
 from xdb.xdb$element xel, xdb.xdb$schema schm, sys.opqtype$ opq,
      sys.view$ v, sys.user$ u, sys.obj$ o, sys.coltype$ ac, sys.col$ tc
 where o.owner# = u.user#
  and o.obj# = v.obj#
  and bitand(v.property, 1) = 1
  and v.obj# = tc.obj#
  and tc.name = 'SYS_NC_ROWINFO$'
  and tc.obj# = ac.obj#
  and tc.intcol# = ac.intcol#
  and ac.toid = '00000000000000000000000000020100'
  and tc.intcol# =  opq.intcol#
  and tc.obj# =  opq.obj#
  and opq.schemaoid =  schm.sys_nc_oid$
  and opq.elemnum =  xel.xmldata.property.prop_number
  and (o.owner# = userenv('SCHEMAID')
       or o.obj# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
       or /* user has system privileges */
         ora_check_SYS_privilege (o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_XML_VIEWS"."OWNER" IS 'Owner of the view ';
   COMMENT ON COLUMN "SYS"."ALL_XML_VIEWS"."VIEW_NAME" IS 'Name of the view ';
   COMMENT ON COLUMN "SYS"."ALL_XML_VIEWS"."XMLSCHEMA" IS 'Name of the XMLSchema that is used for the view definition';
   COMMENT ON COLUMN "SYS"."ALL_XML_VIEWS"."SCHEMA_OWNER" IS 'Name of the owner of the XMLSchema used for table definition';
   COMMENT ON COLUMN "SYS"."ALL_XML_VIEWS"."ELEMENT_NAME" IS 'Name XMLSChema element that is used for the view';
   COMMENT ON TABLE "SYS"."ALL_XML_VIEWS"  IS 'Description of the all XMLType views that the user has privileges on'
;
--------------------------------------------------------
--  DDL for View ALL_XS_ACES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_ACES" ("ACL", "OWNER", "ACE_ORDER", "START_DATE", "END_DATE", "GRANT_TYPE", "INVERTED_PRINCIPAL", "PRINCIPAL", "PRINCIPAL_TYPE", "PRIVILEGE", "SECURITY_CLASS", "SECURITY_CLASS_OWNER") AS 
  select DISTINCT o1.name, o1.owner, ace.order#, ace.start_date, ace.end_date,
       decode (ace.ace_type, 1, 'GRANT', 0, 'DENY'),
       decode (ace.prin_invert, 1, 'YES', 0, 'NO'),
       case ace.prin_type
            when 2 then (select u.name from sys.user$ u
                          where u.user# = ace.prin#)
            else        (select o.name from sys.xs$obj o where o.id = ace.prin#)
       end,
       decode (ace.prin_type, 1, 'APPLICATION',
                              2, 'DATABASE',
                              4, 'EXTERNAL'),
       o2.name, o3.name, o3.owner
  from sys.xs$acl acl, sys.xs$ace ace, sys.xs$ace_priv ace_priv,
       sys.xs$obj o1, sys.xs$obj o2, sys.xs$obj o3, sys.xs$obj o4
 where acl.acl# = ace.acl# and
       ace.acl# = ace_priv.acl# and ace.order# = ace_priv.ace_order# and
       o1.id = ace.acl# and o2.id = ace_priv.priv# and o3.id(+) = acl.sc# and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o1.owner != 'SYS') or
        o1.owner = sys_context('USERENV','CURRENT_USER') or
        (o1.owner=o4.owner and o4.name='XS$SCHEMA_ACL' and o4.type=3 and
        ORA_CHECK_ACL(TO_ACLID(o4.owner||'.XS$SCHEMA_ACL'),
                      'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."ACL" IS 'Name of the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."OWNER" IS 'Owner of the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."ACE_ORDER" IS 'Order number of the ACE in the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."START_DATE" IS 'Effective start date of the ACE';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."END_DATE" IS 'Effective end date of the ACE';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."GRANT_TYPE" IS 'Indicates whether the ACE GRANT or DENY the privileges';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."INVERTED_PRINCIPAL" IS 'Indicates whether the principal is inverted (YES) or not (NO)';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."PRINCIPAL_TYPE" IS 'Type of the principal';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."PRIVILEGE" IS 'Name of the privilege';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."SECURITY_CLASS" IS 'Name of the security class that scopes the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACES"."SECURITY_CLASS_OWNER" IS 'Owner of the security class that scopes the ACL';
   COMMENT ON TABLE "SYS"."ALL_XS_ACES"  IS 'All the Real Application Security ACES of the ACLs accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_ACL_PARAMETERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_ACL_PARAMETERS" ("POLICY", "POLICY_OWNER", "ACL", "ACL_OWNER", "PARAMETER", "DATATYPE", "VALUE", "REALM_ORDER", "REALM") AS 
  select DISTINCT o1.name, o1.owner,
       o2.name, o2.owner,
       ap.pname,
       decode(pp.type, 1, 'NUMBER', 2, 'VARCHAR', 3, 'DATE', 4, 'TIMESTAMP'),
       decode(pp.type, 1, to_char(ap.pvalue1), ap.pvalue2),
       apir.order#, apir.rule
  from sys.xs$acl_param ap, sys.xs$policy_param pp,
       sys.xs$obj o1, sys.xs$obj o2, sys.xs$obj o3,
       (select ap.xdsid#, ap.acl#, ap.pname, ir.order#, ir.rule
          from sys.xs$acl_param ap, sys.xs$instset_rule ir
         where ap.xdsid# = ir.xdsid# and bitand(ir.flags, 1) = 1 and
               ap.pname in
               (select * from table(sys.get_realm_parameters(ir.rule)))) apir
 where o1.id = ap.xdsid# and o2.id = ap.acl# and
       ap.xdsid# = apir.xdsid#(+) and
       ap.acl# = apir.acl#(+) and
       ap.pname = apir.pname(+) and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o1.owner != 'SYS') or
        o1.owner  = sys_context('USERENV','CURRENT_USER') or
        (o1.owner=o3.owner and o3.name='XS$SCHEMA_ACL' and o3.type=3 and
         ORA_CHECK_ACL(TO_ACLID(o3.owner||'.XS$SCHEMA_ACL'),
                       'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."POLICY" IS 'Name of the data security policy where the ACL parameter is defined';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."POLICY_OWNER" IS 'Owner of the data security policy where the ACL parameter is defined';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."ACL" IS 'Name of the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."ACL_OWNER" IS 'Owner of the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."PARAMETER" IS 'Name of the ACL parameter';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."DATATYPE" IS 'Datatype of the ACL parameter';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."VALUE" IS 'Value of the ACL parameter';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."REALM_ORDER" IS 'The order of the realm within the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACL_PARAMETERS"."REALM" IS 'The realm that contains the ACL parameter';
   COMMENT ON TABLE "SYS"."ALL_XS_ACL_PARAMETERS"  IS 'All the Real Application Security ACL parameters defined in the data security policies accessbile to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_ACLS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_ACLS" ("NAME", "OWNER", "SECURITY_CLASS", "SECURITY_CLASS_OWNER", "PARENT_ACL", "PARENT_ACL_OWNER", "INHERITANCE_TYPE", "DESCRIPTION") AS 
  select DISTINCT o1.name, o1.owner, o2.name, o2.owner, o3.name, o3.owner,
       decode(a.acl_flag,1,'EXTENDED',2,'CONSTRAINED','NONE'), a.description
  from sys.xs$obj o1, sys.xs$obj o2, sys.xs$obj o3, sys.xs$obj o4, sys.xs$acl a
 where o1.id = a.acl# and o2.id(+) = a.sc# and o3.id(+) = a.parent_acl# and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o1.owner != 'SYS') or
        o1.owner = sys_context('USERENV','CURRENT_USER') or
        (o1.owner=o4.owner and o4.name='XS$SCHEMA_ACL' and o4.type=3 and
         ORA_CHECK_ACL(TO_ACLID(o4.owner||'.XS$SCHEMA_ACL'),
                       'ADMIN_SEC_POLICY')=1)) and
        o1.name != 'XS$SCHEMA_ACL';

   COMMENT ON COLUMN "SYS"."ALL_XS_ACLS"."NAME" IS 'Name of the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACLS"."OWNER" IS 'Owner of the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACLS"."SECURITY_CLASS" IS 'Name of the security class associated with ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACLS"."SECURITY_CLASS_OWNER" IS 'Owner of the security class associated with ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACLS"."PARENT_ACL" IS 'Name of the parent ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACLS"."PARENT_ACL_OWNER" IS 'Owner of the parent ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACLS"."INHERITANCE_TYPE" IS 'Inheritance type of the ACL';
   COMMENT ON COLUMN "SYS"."ALL_XS_ACLS"."DESCRIPTION" IS 'Description of the ACL';
   COMMENT ON TABLE "SYS"."ALL_XS_ACLS"  IS 'All the Real Application Security ACLs accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_APPLICABLE_OBJECTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_APPLICABLE_OBJECTS" ("OWNER", "OBJECT_NAME", "TYPE") AS 
  select OWNER, TABLE_NAME, 'TABLE'
  from sys.DBA_TABLES
 where /* User has ADMIN_ANY_SEC_POLICY or APPLY_SEC_POLICY on itself */
       ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 or
       ORA_CHECK_PRIVILEGE('APPLY_SEC_POLICY')=1
union
select t.OWNER, TABLE_NAME, 'TABLE'
  from sys.DBA_TABLES t, sys.xs$obj o
 where /* User has APPLY_SEC_POLICY on table schema */
       t.owner=o.owner and o.name='XS$SCHEMA_ACL' and o.type=3 and
       ORA_CHECK_ACL(TO_ACLID(o.owner||'.XS$SCHEMA_ACL'),'APPLY_SEC_POLICY')=1
union
select OWNER, VIEW_NAME, 'VIEW'
  from sys.DBA_VIEWS
 where ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1
union
select v.OWNER, VIEW_NAME, 'VIEW'
  from sys.DBA_VIEWS v, sys.xs$obj o
 where v.owner=o.owner and o.name='XS$SCHEMA_ACL' and o.type=3 and
       ORA_CHECK_ACL(TO_ACLID(o.owner||'.XS$SCHEMA_ACL'),'APPLY_SEC_POLICY')=1;

   COMMENT ON COLUMN "SYS"."ALL_XS_APPLICABLE_OBJECTS"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLICABLE_OBJECTS"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLICABLE_OBJECTS"."TYPE" IS 'Type of the object';
   COMMENT ON TABLE "SYS"."ALL_XS_APPLICABLE_OBJECTS"  IS 'All the tables or views to which the current user can apply data security policies'
;
--------------------------------------------------------
--  DDL for View ALL_XS_APPLIED_POLICIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_APPLIED_POLICIES" ("SCHEMA", "OBJECT", "POLICY", "POLICY_OWNER", "SEL", "INS", "UPD", "DEL", "IDX", "ROW_ACL", "OWNER_BYPASS", "STATUS") AS 
  select DISTINCT u.name, o.name, r.pname, r.pfschma,
       decode(bitand(r.stmt_type,1), 0, 'NO', 'YES'),
       decode(bitand(r.stmt_type,2), 0, 'NO', 'YES'),
       decode(bitand(r.stmt_type,4), 0, 'NO', 'YES'),
       decode(bitand(r.stmt_type,8), 0, 'NO', 'YES'),
       decode(bitand(r.stmt_type,2048), 0, 'NO', 'YES'),
       decode(bitand(r.stmt_type,16384), 0, 'NO', 'YES'),
       decode(bitand(r.stmt_type,2097152), 0, 'NO', 'YES'),
       decode(r.enable_flag, 0, 'DISABLED', 'ENABLED')
  from sys.user$ u, sys.obj$ o, sys.xs$obj o2, sys.rls$ r
 where u.user# = o.owner# and r.obj# = o.obj# and
       r.gname = 'SYS_XDS$POLICY_GROUP' and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and r.pfschma != 'SYS')
        or
        r.pfschma = sys_context('USERENV','CURRENT_USER') or
        (r.pfschma=o2.owner and o2.name='XS$SCHEMA_ACL' and o2.type=3 and
         ORA_CHECK_ACL(TO_ACLID(o2.owner||'.XS$SCHEMA_ACL'),
                       'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."SCHEMA" IS 'Schema of the object';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."OBJECT" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."POLICY" IS 'Name of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."POLICY_OWNER" IS 'Owner of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."SEL" IS 'Policy enabled for SELECT statements';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."INS" IS 'Policy enabled for INSERT statements';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."UPD" IS 'Policy enabled for UPDATE statements';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."DEL" IS 'Policy enabled for DELETE statements';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."IDX" IS 'Policy enabled for INDEX statements';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."ROW_ACL" IS 'Object has row ACL column';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."OWNER_BYPASS" IS 'Policy bypassed by object owner';
   COMMENT ON COLUMN "SYS"."ALL_XS_APPLIED_POLICIES"."STATUS" IS 'Indicates whether the data security policy is enabled or disabled';
   COMMENT ON TABLE "SYS"."ALL_XS_APPLIED_POLICIES"  IS 'All the database objects on which Real Application Security data security policies accessible to the current user are enabled'
;
--------------------------------------------------------
--  DDL for View ALL_XS_COLUMN_CONSTRAINTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_COLUMN_CONSTRAINTS" ("POLICY", "OWNER", "COLUMN_NAME", "PRIVILEGE") AS 
  select DISTINCT o1.name, o1.owner, c.attr_name, o2.name
  from sys.xs$obj o1, sys.xs$obj o2, sys.xs$obj o3, sys.xs$attr_sec c
 where o1.id = c.xdsid# and o2.id = c.priv# and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o1.owner != 'SYS') or
        o1.owner  = sys_context('USERENV','CURRENT_USER') or
        (o1.owner=o3.owner and o3.name='XS$SCHEMA_ACL' and o3.type=3 and
         ORA_CHECK_ACL(TO_ACLID(o3.owner||'.XS$SCHEMA_ACL'),
                       'ADMIN_SEC_POLICY')=1))
 order by o1.name, c.attr_name;

   COMMENT ON COLUMN "SYS"."ALL_XS_COLUMN_CONSTRAINTS"."POLICY" IS 'Name of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_COLUMN_CONSTRAINTS"."OWNER" IS 'Owner of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_COLUMN_CONSTRAINTS"."COLUMN_NAME" IS 'Name of the column that the column constraint is enforced';
   COMMENT ON COLUMN "SYS"."ALL_XS_COLUMN_CONSTRAINTS"."PRIVILEGE" IS 'Name of the privilege required to access the column';
   COMMENT ON TABLE "SYS"."ALL_XS_COLUMN_CONSTRAINTS"  IS 'All the Real Application Security column constraints accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_IMPLIED_PRIVILEGES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_IMPLIED_PRIVILEGES" ("PRIVILEGE", "IMPLIED_PRIVILEGE", "SECURITY_CLASS", "SECURITY_CLASS_OWNER") AS 
  select DISTINCT o1.name, o2.name, o3.name, o3.owner
  from sys.xs$obj o1, sys.xs$obj o2, sys.xs$obj o3, sys.xs$obj o4,
       sys.xs$aggr_priv agp
 where o1.id = agp.aggr_priv# and o2.id = agp.implied_priv# and
       o3.id = agp.sc# and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o3.owner != 'SYS')
        or
        o3.owner = sys_context('USERENV','CURRENT_USER') or
        (o3.owner=o4.owner and o4.name='XS$SCHEMA_ACL' and o4.type=3 and
         ORA_CHECK_ACL(TO_ACLID(o4.owner||'.XS$SCHEMA_ACL'),
                       'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_IMPLIED_PRIVILEGES"."PRIVILEGE" IS 'Name of the privilege that has implied privileges';
   COMMENT ON COLUMN "SYS"."ALL_XS_IMPLIED_PRIVILEGES"."IMPLIED_PRIVILEGE" IS 'Name of the implied privilege';
   COMMENT ON COLUMN "SYS"."ALL_XS_IMPLIED_PRIVILEGES"."SECURITY_CLASS" IS 'Name of the security class that scopes the privilege and the implied privilege';
   COMMENT ON COLUMN "SYS"."ALL_XS_IMPLIED_PRIVILEGES"."SECURITY_CLASS_OWNER" IS 'Owner of the security class that scopes the privilege and the implied privilege';
   COMMENT ON TABLE "SYS"."ALL_XS_IMPLIED_PRIVILEGES"  IS 'All the Real Application Security implied privileges scoped by the security classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_INHERITED_REALMS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_INHERITED_REALMS" ("POLICY", "POLICY_OWNER", "REALM_ORDER", "PARENT_OBJECT", "PARENT_SCHEMA", "PRIMARY_KEY", "FOREIGN_KEY", "FOREIGN_KEY_TYPE") AS 
  select DISTINCT o.name, o.owner, ih.order#, ih.parent_object, ih.parent_schema,
       ihk.pkey, ihk.fkey,
       decode(ihk.fkey_type, 1, 'NAME', 2, 'VALUE')
  from sys.xs$instset_inh  ih,
       sys.xs$instset_inh_key ihk,
       sys.xs$obj o, sys.xs$obj o2
 where ih.xdsid# = ihk.xdsid#(+) and
       ih.order# = ihk.order#(+) and
       ih.xdsid# = o.id          and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o.owner != 'SYS') or
        o.owner  = sys_context('USERENV','CURRENT_USER') or
        (o.owner=o2.owner and o2.name='XS$SCHEMA_ACL' and o2.type=3 and
         ORA_CHECK_ACL(TO_ACLID(o2.owner||'.XS$SCHEMA_ACL'),
                       'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_INHERITED_REALMS"."POLICY" IS 'Name of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_INHERITED_REALMS"."POLICY_OWNER" IS 'Owner of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_INHERITED_REALMS"."REALM_ORDER" IS 'The order of the realm within the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_INHERITED_REALMS"."PARENT_OBJECT" IS 'Name of the parent object';
   COMMENT ON COLUMN "SYS"."ALL_XS_INHERITED_REALMS"."PARENT_SCHEMA" IS 'Schema of the parent object';
   COMMENT ON COLUMN "SYS"."ALL_XS_INHERITED_REALMS"."PRIMARY_KEY" IS 'The column name in the master table';
   COMMENT ON COLUMN "SYS"."ALL_XS_INHERITED_REALMS"."FOREIGN_KEY" IS 'The column name or column value in the detail table';
   COMMENT ON COLUMN "SYS"."ALL_XS_INHERITED_REALMS"."FOREIGN_KEY_TYPE" IS 'Type of the foreign key. Possible values are NAME and VALUE';
   COMMENT ON TABLE "SYS"."ALL_XS_INHERITED_REALMS"  IS 'All the Real Application Security inherited realms accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_POLICIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_POLICIES" ("NAME", "OWNER", "CREATE_TIME", "MODIFY_TIME", "DESCRIPTION") AS 
  select DISTINCT o.name, o.owner, d.ctime, d.mtime, d.description
  from sys.xs$dsec d, sys.xs$obj o, sys.xs$obj o2
 where o.id = d.xdsid# and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o.owner != 'SYS') or
        o.owner = sys_context('USERENV','CURRENT_USER') or
        (o.owner=o2.owner and o2.name='XS$SCHEMA_ACL' and o2.type=3 and
         ORA_CHECK_ACL(TO_ACLID(o2.owner||'.XS$SCHEMA_ACL'),
                       'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_POLICIES"."NAME" IS 'Name of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_POLICIES"."OWNER" IS 'owner of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_POLICIES"."CREATE_TIME" IS 'Creation time of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_POLICIES"."MODIFY_TIME" IS 'Modification time of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_POLICIES"."DESCRIPTION" IS 'Description of the data security policy';
   COMMENT ON TABLE "SYS"."ALL_XS_POLICIES"  IS 'All the Real Application Security data security policies accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_PRIVILEGES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_PRIVILEGES" ("NAME", "SECURITY_CLASS", "SECURITY_CLASS_OWNER", "DESCRIPTION") AS 
  select DISTINCT o1.name, o2.name, o2.owner, p.description
from sys.xs$obj o1, sys.xs$obj o2, sys.xs$obj o3, sys.xs$priv p
where o1.id = p.priv# and o2.id = p.sc# and
      ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o2.owner != 'SYS') or
       o2.owner = sys_context('USERENV','CURRENT_USER') or
       (o2.owner=o3.owner and o3.name='XS$SCHEMA_ACL' and o3.type=3 and
        ORA_CHECK_ACL(TO_ACLID(o3.owner||'.XS$SCHEMA_ACL'),
                      'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_PRIVILEGES"."NAME" IS 'Name of the privilege';
   COMMENT ON COLUMN "SYS"."ALL_XS_PRIVILEGES"."SECURITY_CLASS" IS 'Name of the security class that scopes the privilege';
   COMMENT ON COLUMN "SYS"."ALL_XS_PRIVILEGES"."SECURITY_CLASS_OWNER" IS 'Owner of the security class that scopes the privilege';
   COMMENT ON COLUMN "SYS"."ALL_XS_PRIVILEGES"."DESCRIPTION" IS 'Description of the privilege';
   COMMENT ON TABLE "SYS"."ALL_XS_PRIVILEGES"  IS 'All the Real Application Security privileges scoped by the security classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_REALM_CONSTRAINTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_REALM_CONSTRAINTS" ("POLICY", "POLICY_OWNER", "REALM_ORDER", "REALM_TYPE", "STATIC", "REALM", "REALM_DESCRIPTION", "ACL", "ACL_OWNER", "PARENT_OBJECT", "PARENT_SCHEMA") AS 
  select DISTINCT o1.name, o1.owner, il.order#,
       decode(il.type,
              1, decode(bitand(ir.flags, 1), 0, 'REGULAR', 'PARAMETERIZED'),
              'INHERITED'),
       decode(ir.static, 1, 'STATIC ', 'DYNAMIC'),
       decode(il.type, 1, ir.rule, null),
       ir.description,
       acl.name, acl.owner, ih.parent_object, ih.parent_schema
  from sys.xs$instset_list il,
       sys.xs$instset_rule ir,
       sys.xs$instset_inh  ih,
       (select ia.xdsid#, ia.order#, o2.name, o2.owner
          from sys.xs$instset_acl  ia, sys.xs$obj o2
         where ia.acl# = o2.id) acl,
       sys.xs$obj o1, sys.xs$obj o3
 where il.xdsid# = ir.xdsid#(+)  and
       il.order# = ir.order#(+)  and
       il.xdsid# = acl.xdsid#(+) and
       il.order# = acl.order#(+) and
       il.xdsid# = ih.xdsid#(+)  and
       il.order# = ih.order#(+)  and
       il.xdsid# = o1.id         and
       ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o1.owner != 'SYS') or
        o1.owner  = sys_context('USERENV','CURRENT_USER') or
        (o1.owner=o3.owner and o3.name='XS$SCHEMA_ACL' and o3.type=3 AND
         ORA_CHECK_ACL(TO_ACLID(o3.owner||'.XS$SCHEMA_ACL'),
                       'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."POLICY" IS 'Name of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."POLICY_OWNER" IS 'Owner of the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."REALM_ORDER" IS 'The order of the realm within the data security policy';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."REALM_TYPE" IS 'The type of the realm. Possible values are REGULAR, PARAMETERIZED, and INHERITED';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."STATIC" IS 'Indicates whether the realm is static (YES) or not (NO)';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."REALM" IS 'The realm';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."REALM_DESCRIPTION" IS 'The realm description';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."ACL" IS 'Name of the associated ACL for REGULAR realm';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."ACL_OWNER" IS 'Owner of the associated ACL for REGULAR realm';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."PARENT_OBJECT" IS 'Name of the parent object if the type of the realm is INHERITED';
   COMMENT ON COLUMN "SYS"."ALL_XS_REALM_CONSTRAINTS"."PARENT_SCHEMA" IS 'Schema of the parent object if the type of the realm is INHERITED';
   COMMENT ON TABLE "SYS"."ALL_XS_REALM_CONSTRAINTS"  IS 'All the Real Application Security realms accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_SECURITY_CLASS_DEP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_SECURITY_CLASS_DEP" ("SECURITY_CLASS", "OWNER", "PARENT", "PARENT_OWNER") AS 
  select DISTINCT o1.name, o1.owner, o2.name, o2.owner
from sys.xs$obj o1, sys.xs$obj o2, sys.xs$obj o3, sys.xs$seccls_h sh
where o1.id = sh.sc# and o2.id = sh.parent_sc# and
      ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o1.owner != 'SYS') or
       o1.owner = sys_context('USERENV','CURRENT_USER') or
       (o1.owner=o3.owner and o3.name='XS$SCHEMA_ACL' and o3.type=3 and
        ORA_CHECK_ACL(TO_ACLID(o3.owner||'.XS$SCHEMA_ACL'),
                      'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_SECURITY_CLASS_DEP"."SECURITY_CLASS" IS 'Name of the security class';
   COMMENT ON COLUMN "SYS"."ALL_XS_SECURITY_CLASS_DEP"."OWNER" IS 'Owner of the security class';
   COMMENT ON COLUMN "SYS"."ALL_XS_SECURITY_CLASS_DEP"."PARENT" IS 'Name of the parent security class';
   COMMENT ON COLUMN "SYS"."ALL_XS_SECURITY_CLASS_DEP"."PARENT_OWNER" IS 'Owner of the parent security class';
   COMMENT ON TABLE "SYS"."ALL_XS_SECURITY_CLASS_DEP"  IS 'All the Real Application Security class dependencies of the security classes
that are accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XS_SECURITY_CLASSES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XS_SECURITY_CLASSES" ("NAME", "OWNER", "DESCRIPTION") AS 
  select DISTINCT o.name, o.owner, s.description
from sys.xs$obj o, sys.xs$seccls s, sys.xs$obj o2
where o.id = s.sc# and
      ((ORA_CHECK_PRIVILEGE('ADMIN_ANY_SEC_POLICY')=1 and o.owner != 'SYS') or
       o.owner = sys_context('USERENV','CURRENT_USER') or
       (o.owner=o2.owner and o2.name='XS$SCHEMA_ACL' and o2.type=3 and
        ORA_CHECK_ACL(TO_ACLID(o2.owner||'.XS$SCHEMA_ACL'), 'ADMIN_SEC_POLICY')=1));

   COMMENT ON COLUMN "SYS"."ALL_XS_SECURITY_CLASSES"."NAME" IS 'Name of the security class';
   COMMENT ON COLUMN "SYS"."ALL_XS_SECURITY_CLASSES"."OWNER" IS 'Owner of the security class';
   COMMENT ON COLUMN "SYS"."ALL_XS_SECURITY_CLASSES"."DESCRIPTION" IS 'Description of the security class';
   COMMENT ON TABLE "SYS"."ALL_XS_SECURITY_CLASSES"  IS 'All the Real Application Security security classes accessible to the current user'
;
--------------------------------------------------------
--  DDL for View ALL_XSTREAM_ADMINISTRATOR
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XSTREAM_ADMINISTRATOR" ("USERNAME", "PRIVILEGE_TYPE", "GRANT_SELECT_PRIVILEGES", "CREATE_TIME") AS 
  (select xp.username,
       decode(xp.privilege_type, 1, 'CAPTURE',
                              2, 'APPLY',
                              3, '*'),
       decode(xp.privilege_level, 0, 'NO',
                               1, 'YES'),
       xp.create_time
  from sys.xstream$_privileges xp, sys.user$ u, dba_role_privs rp
  where ((xp.username = u.name) and  (u.user# = userenv('SCHEMAID')))
union
select xp.username,
       decode(xp.privilege_type, 1, 'CAPTURE',
                              2, 'APPLY',
                              3, '*'),
       decode(xp.privilege_level, 0, 'NO',
                               1, 'YES'),
       xp.create_time
  from sys.xstream$_privileges xp, sys.user$ u, dba_role_privs rp
  where (u.name = rp.grantee
        and rp.granted_role = 'SELECT_CATALOG_ROLE'
        and (u.user# = userenv('SCHEMAID'))));

   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_ADMINISTRATOR"."USERNAME" IS 'Name of the user who has been granted privileges to be XStream administrator';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_ADMINISTRATOR"."PRIVILEGE_TYPE" IS 'Type of privilege granted';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_ADMINISTRATOR"."GRANT_SELECT_PRIVILEGES" IS 'Whether to grant select privileges';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_ADMINISTRATOR"."CREATE_TIME" IS 'Timestamp for the granted privilege';
   COMMENT ON TABLE "SYS"."ALL_XSTREAM_ADMINISTRATOR"  IS 'Users granted the privileges to be a XStream administrator for the user'
;
--------------------------------------------------------
--  DDL for View ALL_XSTREAM_INBOUND
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XSTREAM_INBOUND" ("SERVER_NAME", "QUEUE_OWNER", "QUEUE_NAME", "APPLY_USER", "USER_COMMENT", "CREATE_DATE", "STATUS", "COMMITTED_DATA_ONLY") AS 
  select ib."SERVER_NAME",ib."QUEUE_OWNER",ib."QUEUE_NAME",ib."APPLY_USER",ib."USER_COMMENT",ib."CREATE_DATE",ib."STATUS",ib."COMMITTED_DATA_ONLY"
from dba_xstream_inbound ib, all_apply a
   where a.apply_name = ib.server_name;

   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND"."SERVER_NAME" IS 'Name of the inbound server';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND"."QUEUE_OWNER" IS 'Owner of the queue associated with the inbound server';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND"."QUEUE_NAME" IS 'Name of the queue associated with the inbound server';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND"."APPLY_USER" IS 'Name of the user who is applying the messages';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND"."USER_COMMENT" IS 'User comment';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND"."CREATE_DATE" IS 'Date when inbound server was created';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND"."STATUS" IS 'Status of the apply process: DISABLED, ABORTED, ATTACHED, DETACHED';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND"."COMMITTED_DATA_ONLY" IS 'Is inbound server receiving committed data only?';
   COMMENT ON TABLE "SYS"."ALL_XSTREAM_INBOUND"  IS 'Details about the XStream inbound server visible to user'
;
--------------------------------------------------------
--  DDL for View ALL_XSTREAM_INBOUND_PROGRESS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XSTREAM_INBOUND_PROGRESS" ("SERVER_NAME", "PROCESSED_LOW_POSITION", "APPLIED_LOW_POSITION", "APPLIED_HIGH_POSITION", "SPILL_POSITION", "OLDEST_POSITION", "OLDEST_MESSAGE_NUMBER", "APPLIED_MESSAGE_NUMBER", "APPLIED_TIME", "APPLIED_MESSAGE_CREATE_TIME", "SPILL_MESSAGE_NUMBER", "SOURCE_DATABASE", "SOURCE_ROOT_NAME") AS 
  select xp."SERVER_NAME",xp."PROCESSED_LOW_POSITION",xp."APPLIED_LOW_POSITION",xp."APPLIED_HIGH_POSITION",xp."SPILL_POSITION",xp."OLDEST_POSITION",xp."OLDEST_MESSAGE_NUMBER",xp."APPLIED_MESSAGE_NUMBER",xp."APPLIED_TIME",xp."APPLIED_MESSAGE_CREATE_TIME",xp."SPILL_MESSAGE_NUMBER",xp."SOURCE_DATABASE",xp."SOURCE_ROOT_NAME"
  from dba_xstream_inbound_progress xp, all_apply ap
    where ap.apply_name = xp.server_name;

   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."SERVER_NAME" IS 'Name of the outbound server';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."PROCESSED_LOW_POSITION" IS 'Position of processed low transaction';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."APPLIED_LOW_POSITION" IS 'All messages with commit position less than this value have been applied';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."APPLIED_HIGH_POSITION" IS 'Highest commit position of a transaction that has been applied';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."SPILL_POSITION" IS 'Position of the spill low watermark';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."OLDEST_POSITION" IS 'Earliest position of the transactions currently being applied';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."OLDEST_MESSAGE_NUMBER" IS 'Earliest message number of the transactions currently being applied';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."APPLIED_MESSAGE_NUMBER" IS 'All messages below this number have been successfully applied';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."APPLIED_TIME" IS 'Time at which the APPLIED_MESSAGE_NUMBER message was applied';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."APPLIED_MESSAGE_CREATE_TIME" IS 'Time at which the APPLIED_MESSAGE_NUMBER message was created';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."SPILL_MESSAGE_NUMBER" IS 'Spill low water mark SCN';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."SOURCE_DATABASE" IS 'Database where the transaction originated';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_INBOUND_PROGRESS"."SOURCE_ROOT_NAME" IS 'Root database where all transactions originated'
;
--------------------------------------------------------
--  DDL for View ALL_XSTREAM_OUTBOUND
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XSTREAM_OUTBOUND" ("SERVER_NAME", "CONNECT_USER", "CAPTURE_NAME", "SOURCE_DATABASE", "CAPTURE_USER", "QUEUE_OWNER", "QUEUE_NAME", "USER_COMMENT", "CREATE_DATE", "STATUS", "COMMITTED_DATA_ONLY", "START_SCN", "START_TIME", "SOURCE_ROOT_NAME", "LCRID_VERSION") AS 
  select ob."SERVER_NAME",ob."CONNECT_USER",ob."CAPTURE_NAME",ob."SOURCE_DATABASE",ob."CAPTURE_USER",ob."QUEUE_OWNER",ob."QUEUE_NAME",ob."USER_COMMENT",ob."CREATE_DATE",ob."STATUS",ob."COMMITTED_DATA_ONLY",ob."START_SCN",ob."START_TIME",ob."SOURCE_ROOT_NAME",ob."LCRID_VERSION"
   from dba_xstream_outbound ob, all_apply app
   where app.apply_name = ob.server_name;

   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."SERVER_NAME" IS 'Name of the outbound server';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."CONNECT_USER" IS 'Name of the user who can process the outbound LCR stream';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."CAPTURE_NAME" IS 'Name of the XStream capture process';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."SOURCE_DATABASE" IS 'Database where the transaction originated';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."CAPTURE_USER" IS 'Current user who is enqueuing captured messages';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."QUEUE_OWNER" IS 'Owner of the queue associated with the outbound server';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."QUEUE_NAME" IS 'Name of the queue associated with the outbound server';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."USER_COMMENT" IS 'User comment';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."CREATE_DATE" IS 'Date when outbound server was created';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."STATUS" IS 'Status of the apply process: DISABLED, ABORTED, DETACHED, ATTACHED';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."COMMITTED_DATA_ONLY" IS 'Is outbound server sending committed data only?';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."START_SCN" IS 'Start SCN of the associated co-located capture process';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."START_TIME" IS 'Start time of the associated co-located capture process';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND"."SOURCE_ROOT_NAME" IS 'Root database where all transactions originated';
   COMMENT ON TABLE "SYS"."ALL_XSTREAM_OUTBOUND"  IS 'Details about the XStream outbound server visible to user'
;
--------------------------------------------------------
--  DDL for View ALL_XSTREAM_OUTBOUND_PROGRESS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS" ("SERVER_NAME", "SOURCE_DATABASE", "PROCESSED_LOW_POSITION", "PROCESSED_LOW_TIME", "OLDEST_POSITION", "SOURCE_ROOT_NAME", "PROCESSED_LOW_SCN", "OLDEST_SCN") AS 
  select xp."SERVER_NAME",xp."SOURCE_DATABASE",xp."PROCESSED_LOW_POSITION",xp."PROCESSED_LOW_TIME",xp."OLDEST_POSITION",xp."SOURCE_ROOT_NAME",xp."PROCESSED_LOW_SCN",xp."OLDEST_SCN"
from dba_xstream_outbound_progress xp, all_apply a
 where a.apply_name = xp.server_name;

   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS"."SERVER_NAME" IS 'Name of the outbound server';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS"."SOURCE_DATABASE" IS 'Database where the transaction originated';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS"."PROCESSED_LOW_POSITION" IS 'Position of low watermark transaction processed by client';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS"."PROCESSED_LOW_TIME" IS 'Time which the processed low position was last updated';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS"."OLDEST_POSITION" IS 'Earliest position of the transactions currently being applied';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS"."SOURCE_ROOT_NAME" IS 'Root database where all transactions originated';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS"."PROCESSED_LOW_SCN" IS 'SCN of low watermark transaction processed';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUTBOUND_PROGRESS"."OLDEST_SCN" IS 'Oldest SCN of the transactions currently being applied'
;
--------------------------------------------------------
--  DDL for View ALL_XSTREAM_OUT_SUPPORT_MODE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XSTREAM_OUT_SUPPORT_MODE" ("OWNER", "OBJECT_NAME", "SUPPORT_MODE") AS 
  select xosm."OWNER",xosm."OBJECT_NAME",xosm."SUPPORT_MODE"
  from DBA_XSTREAM_OUT_SUPPORT_MODE xosm, ALL_APPLY aa
  where aa.apply_user = xosm.owner;

   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUT_SUPPORT_MODE"."OWNER" IS 'Owner of the object';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUT_SUPPORT_MODE"."OBJECT_NAME" IS 'Name of the object';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_OUT_SUPPORT_MODE"."SUPPORT_MODE" IS 'Either FULL, ID KEY, or NONE';
   COMMENT ON TABLE "SYS"."ALL_XSTREAM_OUT_SUPPORT_MODE"  IS 'List of support mode for objects by XStream Out'
;
--------------------------------------------------------
--  DDL for View ALL_XSTREAM_RULES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XSTREAM_RULES" ("STREAMS_NAME", "STREAMS_TYPE", "STREAMS_RULE_TYPE", "RULE_SET_OWNER", "RULE_SET_NAME", "RULE_SET_TYPE", "RULE_OWNER", "RULE_NAME", "RULE_TYPE", "RULE_CONDITION", "SCHEMA_NAME", "OBJECT_NAME", "INCLUDE_TAGGED_LCR", "SUBSETTING_OPERATION", "DML_CONDITION", "SOURCE_DATABASE", "ORIGINAL_RULE_CONDITION", "SAME_RULE_CONDITION", "SOURCE_ROOT_NAME", "SOURCE_CONTAINER_NAME") AS 
  select r."STREAMS_NAME",r."STREAMS_TYPE",r."STREAMS_RULE_TYPE",r."RULE_SET_OWNER",r."RULE_SET_NAME",r."RULE_SET_TYPE",r."RULE_OWNER",r."RULE_NAME",r."RULE_TYPE",r."RULE_CONDITION",r."SCHEMA_NAME",r."OBJECT_NAME",r."INCLUDE_TAGGED_LCR",r."SUBSETTING_OPERATION",r."DML_CONDITION",r."SOURCE_DATABASE",r."ORIGINAL_RULE_CONDITION",r."SAME_RULE_CONDITION",r."SOURCE_ROOT_NAME",r."SOURCE_CONTAINER_NAME"
  from dba_xstream_rules r, "_ALL_STREAMS_PROCESSES" p
where r.streams_type = p.streams_type
  and r.streams_name = p.streams_name;

   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."STREAMS_NAME" IS 'Name of the Streams process';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."STREAMS_TYPE" IS 'Type of the Streams process: CAPTURE or APPLY';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."STREAMS_RULE_TYPE" IS 'For global, schema or table rules, type of rule: TABLE, SCHEMA or GLOBAL';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."RULE_SET_OWNER" IS 'Owner of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."RULE_SET_NAME" IS 'Name of the rule set';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."RULE_SET_TYPE" IS 'Type of the rule set: POSITIVE or NEGATIVE';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."RULE_OWNER" IS 'Owner of the rule';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."RULE_NAME" IS 'Name of the rule';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."RULE_TYPE" IS 'For global, schema or table rules, type of rule: DML, DDL or PROCEDURE';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."RULE_CONDITION" IS 'Current rule condition';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."SCHEMA_NAME" IS 'For table and schema rules, the schema name';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."OBJECT_NAME" IS 'For table rules, the table name';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."INCLUDE_TAGGED_LCR" IS 'For global, schema or table rules, whether or not to include tagged LCRs';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."SUBSETTING_OPERATION" IS 'For subset rules, the type of operation: INSERT, UPDATE, or DELETE';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."DML_CONDITION" IS 'For subset rules, the row subsetting condition';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."SOURCE_DATABASE" IS 'For global, schema or table rules, the name of the database where the LCRs originated';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."ORIGINAL_RULE_CONDITION" IS 'For rules created by Streams administrative APIs, the original rule condition when the rule was created';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."SAME_RULE_CONDITION" IS 'For rules created by Streams administrative APIs, whether or not the current rule condition is the same as the original rule condition';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_RULES"."SOURCE_ROOT_NAME" IS 'Root Database where the transactions originated';
   COMMENT ON TABLE "SYS"."ALL_XSTREAM_RULES"  IS 'Details about the XStream server rules visible to user'
;
--------------------------------------------------------
--  DDL for View ALL_XSTREAM_TRANSFORMATIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XSTREAM_TRANSFORMATIONS" ("RULE_OWNER", "RULE_NAME", "TRANSFORM_TYPE", "FROM_SCHEMA_NAME", "TO_SCHEMA_NAME", "FROM_TABLE_NAME", "TO_TABLE_NAME", "SCHEMA_NAME", "TABLE_NAME", "FROM_COLUMN_NAME", "TO_COLUMN_NAME", "COLUMN_NAME", "COLUMN_VALUE", "COLUMN_TYPE", "COLUMN_FUNCTION", "VALUE_TYPE", "USER_FUNCTION_NAME", "SUBSETTING_OPERATION", "DML_CONDITION", "DECLARATIVE_TYPE", "PRECEDENCE", "STEP_NUMBER") AS 
  select st."RULE_OWNER",st."RULE_NAME",st."TRANSFORM_TYPE",st."FROM_SCHEMA_NAME",st."TO_SCHEMA_NAME",st."FROM_TABLE_NAME",st."TO_TABLE_NAME",st."SCHEMA_NAME",st."TABLE_NAME",st."FROM_COLUMN_NAME",st."TO_COLUMN_NAME",st."COLUMN_NAME",st."COLUMN_VALUE",st."COLUMN_TYPE",st."COLUMN_FUNCTION",st."VALUE_TYPE",st."USER_FUNCTION_NAME",st."SUBSETTING_OPERATION",st."DML_CONDITION",st."DECLARATIVE_TYPE",st."PRECEDENCE",st."STEP_NUMBER"
from  DBA_XSTREAM_TRANSFORMATIONS st, ALL_APPLY aa, ALL_CAPTURE ca
  where (aa.apply_user = st.rule_owner) or (ca.capture_user = st.rule_owner);

   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."RULE_OWNER" IS 'Owner of the rule which has an associated transformation';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."RULE_NAME" IS 'Name of the rule which has an associated transformation';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."TRANSFORM_TYPE" IS 'The type of transformation';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."FROM_SCHEMA_NAME" IS 'The schema to be renamed';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."TO_SCHEMA_NAME" IS 'The new schema name';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."FROM_TABLE_NAME" IS 'The table to be renamed';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."TO_TABLE_NAME" IS 'The new table name';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."SCHEMA_NAME" IS 'The schema of the column to be modified';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."TABLE_NAME" IS 'The table of the column to be modified';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."FROM_COLUMN_NAME" IS 'The column to rename';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."TO_COLUMN_NAME" IS 'The new column name';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."COLUMN_NAME" IS 'The column to add or delete';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."COLUMN_VALUE" IS 'The value of the column to add';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."COLUMN_TYPE" IS 'The type of the new column';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."COLUMN_FUNCTION" IS 'The name of the default function used to add a column';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."USER_FUNCTION_NAME" IS 'The name of the user-defined transformation function to run ';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."SUBSETTING_OPERATION" IS 'DML operation for row subsetting';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."DML_CONDITION" IS 'Row subsetting condition';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."DECLARATIVE_TYPE" IS 'The type of declarative transformation to run';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."PRECEDENCE" IS 'Execution order relative to other declarative transformations on the same step_number';
   COMMENT ON COLUMN "SYS"."ALL_XSTREAM_TRANSFORMATIONS"."STEP_NUMBER" IS 'The order that this transformation should be executed';
   COMMENT ON TABLE "SYS"."ALL_XSTREAM_TRANSFORMATIONS"  IS 'Transformations defined on rules for the user'
;
--------------------------------------------------------
--  DDL for View ALL_XTERNAL_LOC_PARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XTERNAL_LOC_PARTITIONS" ("OWNER", "TABLE_NAME", "PARTITION_NAME", "LOCATION", "DIRECTORY_OWNER", "DIRECTORY_NAME") AS 
  select u.name, o.name, o.subname, xl.name, 'SYS', nvl(xl.dir, xt.default_dir)
from sys.external_location$ xl, sys.external_tab$ xt, sys.obj$ o, sys.tabpart$ tp,
     sys.user$ u, sys.tab$ t
where o.obj# = xl.obj# and
      o.obj# = xt.obj# and
      o.obj# = tp.obj# and
      u.user# = o.owner# and
      tp.bo# = t.obj# and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID')
       or tp.bo# in
           (select oa.obj#
            from sys.objauth$ oa
            where grantee# in ( select kzsrorol
                                from x$kzsro
                              )
           )
       or /* user has system privileges */
        exists (select null from v$enabledprivs
                where priv_number in (-45 /* LOCK ANY TABLE */,
                                      -47 /* SELECT ANY TABLE */,
                                      -397/* READ ANY TABLE */)
               )
      )
union all -- COMPOSITE PARTITIONS
select u.name, o.name, o.subname, xl.name, 'SYS', nvl(xl.dir, xt.default_dir)
from   sys.external_location$ xl, sys.external_tab$ xt, sys.obj$ o, sys.tabcompart$ tcp,
       sys.user$ u, sys.tab$ t
where o.obj# = xl.obj# and
      o.obj# = xt.obj# and
      o.obj# = tcp.obj# and
      u.user# = o.owner# and
      tcp.bo# = t.obj# and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
      (o.owner# = userenv('SCHEMAID')
       or tcp.bo# in
           (select oa.obj#
            from sys.objauth$ oa
            where grantee# in ( select kzsrorol
                                from x$kzsro
                              )
           )
       or /* user has system privileges */
        exists (select null from v$enabledprivs
                where priv_number in (-45 /* LOCK ANY TABLE */,
                                      -47 /* SELECT ANY TABLE */,
                                      -397/* READ ANY TABLE */)
               )
     )
;
--------------------------------------------------------
--  DDL for View ALL_XTERNAL_LOC_SUBPARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XTERNAL_LOC_SUBPARTITIONS" ("TABLE_OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "LOCATION", "DIRECTORY_OWNER", "DIRECTORY_NAME") AS 
  select u.name, po.name, po.subname, so.subname, xl.name, 'SYS',
       nvl(xl.dir, xt.default_dir)
from sys.external_location$ xl, sys.external_tab$ xt, obj$ po, obj$ so,
     tabcompart$ tcp, tabsubpart$ tsp, tab$ t, user$ u
where so.obj# = xl.obj# and
      so.obj# = xt.obj# and
      so.obj# = tsp.obj# and
      po.obj# = tcp.obj# and
      tcp.obj# = tsp.pobj# and
      tcp.bo# = t.obj# and
      u.user# = po.owner# and
      po.namespace = 1 and
      po.remoteowner IS NULL and
      po.linkname IS NULL and
      so.namespace = 1 and
      so.remoteowner IS NULL and
      so.linkname IS NULL and
      ((po.owner# = userenv('SCHEMAID') and so.owner# = userenv('SCHEMAID'))
        or tcp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */)
                )
      )
;
--------------------------------------------------------
--  DDL for View ALL_XTERNAL_PART_TABLES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XTERNAL_PART_TABLES" ("OWNER", "TABLE_NAME", "TYPE_OWNER", "TYPE_NAME", "DEFAULT_DIRECTORY_OWNER", "DEFAULT_DIRECTORY_NAME", "REJECT_LIMIT", "ACCESS_TYPE", "ACCESS_PARAMETERS", "PROPERTY") AS 
  select u.name, o.name, 'SYS', xt.type$, 'SYS', xt.default_dir,
       decode(xt.reject_limit, 2147483647, 'UNLIMITED', xt.reject_limit),
       decode(xt.par_type, 1, 'BLOB', 2, 'CLOB',       'UNKNOWN'),
       case when xt.par_type = 2 then xt.param_clob else NULL end,
       decode(bitand(xt.property, 3), 2, 'REFERENCED', 1, 'ALL',     'UNKNOWN')
from sys.external_tab$ xt, sys.obj$ o, sys.partobj$ po, sys.user$ u
where o.obj# = po.obj# and
      o.obj#   = xt.obj# and
      o.owner# = u.user# and
      o.subname IS NULL and
      o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
     ( o.owner# = userenv('SCHEMAID')
        or o.obj# in
            ( select oa.obj# from sys.objauth$ oa
              where grantee# in (select kzsrorol from x$kzsro)
            )
        or    /* user has system privileges */
          exists ( select null from v$enabledprivs
                   where priv_number in (-45 /* LOCK ANY TABLE */,
                                         -47 /* SELECT ANY TABLE */,
                                         -397/* READ ANY TABLE */)
                 )
      )
;
--------------------------------------------------------
--  DDL for View ALL_XTERNAL_TAB_PARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XTERNAL_TAB_PARTITIONS" ("TABLE_OWNER", "TABLE_NAME", "PARTITION_NAME", "DEFAULT_DIRECTORY_OWNER", "DEFAULT_DIRECTORY_NAME", "ACCESS_TYPE", "ACCESS_PARAMETERS") AS 
  select u.name, o.name, o.subname, 'SYS', xt.default_dir,
       decode(xt.par_type, 1, 'BLOB', 2, 'CLOB',       'UNKNOWN'),
       case when xt.par_type = 2 then xt.param_clob else NULL end
from   sys.external_tab$ xt, sys.obj$ o, sys.tabpart$ tp, sys.user$ u,
       sys.tab$ t
where  o.obj# = xt.obj# and
       o.obj# = tp.obj# and
       u.user# = o.owner# and
       tp.bo# = t.obj# and
       o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
       (o.owner# = userenv('SCHEMAID')
        or tp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */)
                 )
      )
union all -- COMPOSITE PARTITIONS
select u.name, o.name, o.subname, 'SYS', xt.default_dir,
       decode(xt.par_type, 1, 'BLOB', 2, 'CLOB',       'UNKNOWN'),
       case when xt.par_type = 2 then xt.param_clob else NULL end
from   sys.external_tab$ xt, sys.obj$ o, sys.tabcompart$ tcp, sys.user$ u,
       sys.tab$ t
where  o.obj# = xt.obj# and
       o.obj# = tcp.obj# and
       u.user# = o.owner# and
       tcp.bo# = t.obj# and
       o.namespace = 1 and o.remoteowner IS NULL and o.linkname IS NULL and
       (o.owner# = userenv('SCHEMAID')
        or tcp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */)
                )
      )
;
--------------------------------------------------------
--  DDL for View ALL_XTERNAL_TAB_SUBPARTITIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_XTERNAL_TAB_SUBPARTITIONS" ("TABLE_OWNER", "TABLE_NAME", "PARTITION_NAME", "SUBPARTITION_NAME", "DEFAULT_DIRECTORY_OWNER", "DEFAULT_DIRECTORY_NAME", "ACCESS_TYPE", "ACCESS_PARAMETERS") AS 
  select u.name, po.name, po.subname, so.subname, 'SYS', xt.default_dir,
       decode(xt.par_type, 1, 'BLOB', 2, 'CLOB',       'UNKNOWN'),
       case when xt.par_type = 2 then xt.param_clob else NULL end
from   sys.external_tab$ xt, obj$ po, obj$ so, tabcompart$ tcp, tabsubpart$ tsp,
       tab$ t, user$ u
where so.obj# = xt.obj# and
      so.obj# = tsp.obj# and
      po.obj# = tcp.obj# and
      tcp.obj# = tsp.pobj# and
      tcp.bo# = t.obj# and
      u.user# = po.owner# and
      po.namespace = 1 and
      po.remoteowner IS NULL and
      po.linkname IS NULL and
      so.namespace = 1 and so.remoteowner IS NULL and so.linkname IS NULL and
      ((po.owner# = userenv('SCHEMAID') and so.owner# = userenv('SCHEMAID'))
        or tcp.bo# in
            (select oa.obj#
             from sys.objauth$ oa
             where grantee# in ( select kzsrorol
                                 from x$kzsro
                               )
            )
        or /* user has system privileges */
         exists (select null from v$enabledprivs
                 where priv_number in (-45 /* LOCK ANY TABLE */,
                                       -47 /* SELECT ANY TABLE */,
                                       -397/* READ ANY TABLE */)
                )
      )
;
--------------------------------------------------------
--  DDL for View ALL_ZONEMAP_MEASURES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ZONEMAP_MEASURES" ("OWNER", "ZONEMAP_NAME", "MEASURE", "POSITION_IN_SELECT", "AGG_FUNCTION", "AGG_COLUMN_NAME") AS 
  select z."OWNER",z."ZONEMAP_NAME",z."MEASURE",z."POSITION_IN_SELECT",z."AGG_FUNCTION",z."AGG_COLUMN_NAME" from dba_zonemap_measures z, sys.obj$ o, sys.user$ u
where o.owner#        = u.user#
  and z.zonemap_name  = o.name
  and u.name          = z.owner
  and o.type#         = 2                                    /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_ZONEMAP_MEASURES"."OWNER" IS 'Zonemap owner name';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAP_MEASURES"."ZONEMAP_NAME" IS 'Zonemap name';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAP_MEASURES"."MEASURE" IS 'Column whose MIN/MAX materialized';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAP_MEASURES"."POSITION_IN_SELECT" IS 'Ordinal position of measure aggregate';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAP_MEASURES"."AGG_FUNCTION" IS 'Type of aggregate function: MIN/MAX';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAP_MEASURES"."AGG_COLUMN_NAME" IS 'Aggregate column name in zonemap table';
   COMMENT ON TABLE "SYS"."ALL_ZONEMAP_MEASURES"  IS 'Zonemap measures accessible to the user'
;
--------------------------------------------------------
--  DDL for View ALL_ZONEMAPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."ALL_ZONEMAPS" ("OWNER", "ZONEMAP_NAME", "FACT_OWNER", "FACT_TABLE", "SCALE", "HIERARCHICAL", "WITH_CLUSTERING", "QUERY", "QUERY_LEN", "PRUNING", "REFRESH_MODE", "REFRESH_METHOD", "LAST_REFRESH_METHOD", "LAST_REFRESH_TIME", "INVALID", "STALE", "UNUSABLE", "COMPILE_STATE") AS 
  select z."OWNER",z."ZONEMAP_NAME",z."FACT_OWNER",z."FACT_TABLE",z."SCALE",z."HIERARCHICAL",z."WITH_CLUSTERING",z."QUERY",z."QUERY_LEN",z."PRUNING",z."REFRESH_MODE",z."REFRESH_METHOD",z."LAST_REFRESH_METHOD",z."LAST_REFRESH_TIME",z."INVALID",z."STALE",z."UNUSABLE",z."COMPILE_STATE" from dba_zonemaps z, sys.obj$ o, sys.user$ u
where o.owner#        = u.user#
  and z.zonemap_name  = o.name
  and u.name          = z.owner
  and o.type#         = 2                            /* table */
  and ( u.user# in (userenv('SCHEMAID'), 1)
        or
        o.obj# in ( select obj#
                    from sys.objauth$
                    where grantee# in ( select kzsrorol
                                        from x$kzsro
                                      )
                  )
       or /* user has system privileges */
         ora_check_sys_privilege(o.owner#, o.type#) = 1
      );

   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."OWNER" IS 'Zonemap owner name';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."ZONEMAP_NAME" IS 'Zonemap name';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."FACT_OWNER" IS 'Fact table owner name';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."FACT_TABLE" IS 'Fact table name';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."SCALE" IS 'Zonemap scale factor';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."HIERARCHICAL" IS 'Zonemap is hierarchical or not';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."WITH_CLUSTERING" IS 'Is zonemap created with clustering clause';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."QUERY" IS 'Zonemap defining query';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."QUERY_LEN" IS 'Zonemap defining query length';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."PRUNING" IS 'Zonemap enabled for pruning or not';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."REFRESH_MODE" IS 'Refresh on: commit/demand/load/datamovement';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."REFRESH_METHOD" IS 'Refresh method: force/complete/fast';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."LAST_REFRESH_METHOD" IS 'Refresh method used last time';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."LAST_REFRESH_TIME" IS 'Time last refresh occurred';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."INVALID" IS 'Zonemap invalid (due to some DDL) or not';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."STALE" IS 'Zonemap fully stale or not';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."UNUSABLE" IS 'Zonemap marked unusable (by user) or not';
   COMMENT ON COLUMN "SYS"."ALL_ZONEMAPS"."COMPILE_STATE" IS 'Zonemap compile state';
   COMMENT ON TABLE "SYS"."ALL_ZONEMAPS"  IS 'Zonemaps accessible to the user'
;
--------------------------------------------------------
--  DDL for View AQ$ALERT_QT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$ALERT_QT" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "ALERT_QT" qt, "AQ$_ALERT_QT_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 19613 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_ALERT_QT_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_ALERT_QT_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_ALERT_QT_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_ALERT_QT_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "ALERT_QT" qt, "AQ$_ALERT_QT_I" iot, SYS.USER_AQ_AGENT_PRIVS up, SYS.ALL_INT_DEQUEUE_QUEUES qo  WHERE qt.msgid=iot.msgid  and (iot.name = up.agent_name or  iot.subscriber# = (select s.subscriber_id from "AQ$_ALERT_QT_S" s  where s.name = up.agent_name and  bitand(s.subscriber_type, 9) = 1)) and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$ALERT_QT_R
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$ALERT_QT_R" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "RULE", "RULE_SET", "TRANSFORMATION") AS 
  SELECT queue_name QUEUE, s.name NAME , address ADDRESS , protocol PROTOCOL, rule_condition RULE, ruleset_name RULE_SET, trans_name TRANSFORMATION  FROM "AQ$_ALERT_QT_S" s , sys.all_rules r WHERE (bitand(s.subscriber_type, 1) = 1) AND s.rule_name = r.rule_name and r.rule_owner = 'SYS'  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$ALERT_QT_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$ALERT_QT_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_ALERT_QT_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$AQ_EVENT_TABLE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$AQ_EVENT_TABLE" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON") AS 
  SELECT q_name QUEUE, msgid MSG_ID, corrid CORR_ID, priority MSG_PRIORITY, decode(state, 0,   'READY',
                                1,   'WAIT',
                                2,   'PROCESSED',
                                3,   'EXPIRED',
                                10,  'BUFFERED_EXPIRED') MSG_STATE, cast(FROM_TZ(delay, '00:00')
                  at time zone sessiontimezone as date) DELAY, cast(FROM_TZ(delay, '00:00')
               at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration, cast(FROM_TZ(enq_time, '00:00')
                  at time zone sessiontimezone as date) ENQ_TIME, cast(FROM_TZ(enq_time, '00:00')
                  at time zone sessiontimezone as timestamp) 
                  ENQ_TIMESTAMP, enq_uid ENQ_USER_ID, enq_tid ENQ_TXN_ID, cast(FROM_TZ(deq_time, '00:00')
                  at time zone sessiontimezone as date) DEQ_TIME, cast(FROM_TZ(deq_time, '00:00')
                  at time zone sessiontimezone as timestamp) 
                  DEQ_TIMESTAMP, deq_uid DEQ_USER_ID, deq_tid DEQ_TXN_ID, retry_count,  decode (state, 0, exception_qschema, 
                                  1, exception_qschema, 
                                  2, exception_qschema,  
                                  NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                  1, exception_queue, 
                                  2, exception_queue,  
                                  NULL) EXCEPTION_QUEUE,  user_data,  decode (state, 3, 
                     decode (deq_tid, 'INVALID_TRANSACTION', NULL, 
                             exception_queue), NULL)
                                ORIGINAL_QUEUE_NAME,  decode (state, 3, 
                     decode (deq_tid, 'INVALID_TRANSACTION', NULL, 
                             exception_qschema), NULL)
                                ORIGINAL_QUEUE_OWNER,  decode(state, 3, 
                     decode(deq_time, NULL, 
                       decode(deq_tid, NULL,
                       decode (expiration , NULL , 'MAX_RETRY_EXCEEDED',
                            'TIME_EXPIRATION'),
                              'INVALID_TRANSACTION', NULL,
                              'MAX_RETRY_EXCEEDED'), NULL), NULL) 
                             EXPIRATION_REASON  FROM "AQ_EVENT_TABLE" WHERE state != 7 AND   state != 9 WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_AQ_EVENT_TABLE_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_AQ_EVENT_TABLE_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "QUEUE_ID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(qt) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA , qo.qid QUEUE_ID  FROM "AQ_EVENT_TABLE" qt, SYS.ALL_INT_DEQUEUE_QUEUES  qo  WHERE qt.q_name = qo.name AND qo.owner = 'SYS' WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$AQ$_MEM_MC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$AQ$_MEM_MC" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "AQ$_MEM_MC" qt, "AQ$_AQ$_MEM_MC_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 20088 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_AQ$_MEM_MC_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_AQ$_MEM_MC_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_AQ$_MEM_MC_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_AQ$_MEM_MC_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "AQ$_MEM_MC" qt, "AQ$_AQ$_MEM_MC_I" iot, SYS.ALL_INT_DEQUEUE_QUEUES qo WHERE qt.msgid=iot.msgid  and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$AQ$_MEM_MC_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$AQ$_MEM_MC_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_AQ$_MEM_MC_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$AQ_PROP_TABLE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$AQ_PROP_TABLE" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "AQ_PROP_TABLE" qt, "AQ$_AQ_PROP_TABLE_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 20126 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_AQ_PROP_TABLE_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_AQ_PROP_TABLE_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_AQ_PROP_TABLE_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_AQ_PROP_TABLE_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "AQ_PROP_TABLE" qt, "AQ$_AQ_PROP_TABLE_I" iot, SYS.ALL_INT_DEQUEUE_QUEUES qo WHERE qt.msgid=iot.msgid  and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$AQ_PROP_TABLE_R
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$AQ_PROP_TABLE_R" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "RULE", "RULE_SET", "TRANSFORMATION") AS 
  SELECT queue_name QUEUE, s.name NAME , address ADDRESS , protocol PROTOCOL, rule_condition RULE, ruleset_name RULE_SET, trans_name TRANSFORMATION  FROM "AQ$_AQ_PROP_TABLE_S" s , sys.all_rules r WHERE (bitand(s.subscriber_type, 1) = 1) AND s.rule_name = r.rule_name and r.rule_owner = 'SYS'  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$AQ_PROP_TABLE_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$AQ_PROP_TABLE_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_AQ_PROP_TABLE_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$INTERNET_USERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$INTERNET_USERS" ("AGENT_NAME", "DB_USERNAME", "HTTP_ENABLED", "SMTP_ENABLED", "FTP_ENABLED") AS 
  (SELECT t.agent_name, t.db_username, decode(bitand(u.protocol, 1), 0, 'NO  ', 1, 'YES ') http_enabled, decode(bitand(u.protocol, 2), 0, 'NO  ', 2, 'YES ') smtp_enabled, decode(bitand(u.protocol, 4), 0, 'NO  ', 4, 'YES ') ftp_enabled FROM SYSTEM.AQ$_Internet_Agent_Privs t, SYSTEM.AQ$_Internet_Agents u WHERE t.agent_name = u.agent_name UNION (SELECT x.agent_name, NULL, decode(bitand(x.protocol, 1), 0, 'NO  ', 1, 'YES ') http_enabled, decode(bitand(x.protocol, 2), 0, 'NO  ', 2, 'YES ') smtp_enabled, decode(bitand(x.protocol, 4), 0, 'NO  ', 4, 'YES ') ftp_enabled FROM SYSTEM.AQ$_Internet_Agents x WHERE (x.agent_name NOT IN (SELECT y.agent_name FROM SYSTEM.AQ$_Internet_Agent_Privs y))))
;
--------------------------------------------------------
--  DDL for View AQ$ORA$PREPLUGIN_BACKUP_QTB
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$ORA$PREPLUGIN_BACKUP_QTB" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "ORA$PREPLUGIN_BACKUP_QTB" qt, "AQ$_ORA$PREPLUGIN_BACKUP_QTB_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 19871 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_ORA$PREPLUGIN_BACKUP_QTB_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_ORA$PREPLUGIN_BACKUP_QTB_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_ORA$PREPLUGIN_BACKUP_QTB_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_ORA$PREPLUGIN_BACKUP_QTB_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "ORA$PREPLUGIN_BACKUP_QTB" qt, "AQ$_ORA$PREPLUGIN_BACKUP_QTB_I" iot, SYS.ALL_INT_DEQUEUE_QUEUES qo WHERE qt.msgid=iot.msgid  and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$ORA$PREPLUGIN_BACKUP_QTB_R
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$ORA$PREPLUGIN_BACKUP_QTB_R" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "RULE", "RULE_SET", "TRANSFORMATION") AS 
  SELECT queue_name QUEUE, s.name NAME , address ADDRESS , protocol PROTOCOL, rule_condition RULE, ruleset_name RULE_SET, trans_name TRANSFORMATION  FROM "AQ$_ORA$PREPLUGIN_BACKUP_QTB_S" s , sys.all_rules r WHERE (bitand(s.subscriber_type, 1) = 1) AND s.rule_name = r.rule_name and r.rule_owner = 'SYS'  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$ORA$PREPLUGIN_BACKUP_QTB_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$ORA$PREPLUGIN_BACKUP_QTB_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_ORA$PREPLUGIN_BACKUP_QTB_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$PDB_MON_EVENT_QTABLE$
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$PDB_MON_EVENT_QTABLE$" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "PDB_MON_EVENT_QTABLE$" qt, "AQ$_PDB_MON_EVENT_QTABLE$_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 20610 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_PDB_MON_EVENT_QTABLE$_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_PDB_MON_EVENT_QTABLE$_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_PDB_MON_EVENT_QTABLE$_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_PDB_MON_EVENT_QTABLE$_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "PDB_MON_EVENT_QTABLE$" qt, "AQ$_PDB_MON_EVENT_QTABLE$_I" iot, SYS.ALL_INT_DEQUEUE_QUEUES qo WHERE qt.msgid=iot.msgid  and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$PDB_MON_EVENT_QTABLE$_R
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$PDB_MON_EVENT_QTABLE$_R" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "RULE", "RULE_SET", "TRANSFORMATION") AS 
  SELECT queue_name QUEUE, s.name NAME , address ADDRESS , protocol PROTOCOL, rule_condition RULE, ruleset_name RULE_SET, trans_name TRANSFORMATION  FROM "AQ$_PDB_MON_EVENT_QTABLE$_S" s , sys.all_rules r WHERE (bitand(s.subscriber_type, 1) = 1) AND s.rule_name = r.rule_name and r.rule_owner = 'SYS'  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$PDB_MON_EVENT_QTABLE$_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$PDB_MON_EVENT_QTABLE$_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_PDB_MON_EVENT_QTABLE$_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER$_EVENT_QTAB
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER$_EVENT_QTAB" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "SCHEDULER$_EVENT_QTAB" qt, "AQ$_SCHEDULER$_EVENT_QTAB_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 19494 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_SCHEDULER$_EVENT_QTAB_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_SCHEDULER$_EVENT_QTAB_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_SCHEDULER$_EVENT_QTAB_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_SCHEDULER$_EVENT_QTAB_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "SCHEDULER$_EVENT_QTAB" qt, "AQ$_SCHEDULER$_EVENT_QTAB_I" iot, SYS.USER_AQ_AGENT_PRIVS up, SYS.ALL_INT_DEQUEUE_QUEUES qo  WHERE qt.msgid=iot.msgid  and (iot.name = up.agent_name or  iot.subscriber# = (select s.subscriber_id from "AQ$_SCHEDULER$_EVENT_QTAB_S" s  where s.name = up.agent_name and  bitand(s.subscriber_type, 9) = 1)) and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER$_EVENT_QTAB_R
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER$_EVENT_QTAB_R" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "RULE", "RULE_SET", "TRANSFORMATION") AS 
  SELECT queue_name QUEUE, s.name NAME , address ADDRESS , protocol PROTOCOL, rule_condition RULE, ruleset_name RULE_SET, trans_name TRANSFORMATION  FROM "AQ$_SCHEDULER$_EVENT_QTAB_S" s , sys.all_rules r WHERE (bitand(s.subscriber_type, 1) = 1) AND s.rule_name = r.rule_name and r.rule_owner = 'SYS'  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER$_EVENT_QTAB_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER$_EVENT_QTAB_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_SCHEDULER$_EVENT_QTAB_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER_FILEWATCHER_QT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER_FILEWATCHER_QT" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "SCHEDULER_FILEWATCHER_QT" qt, "AQ$_SCHEDULER_FILEWATCHER_QT_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 19555 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_SCHEDULER_FILEWATCHER_QT_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_SCHEDULER_FILEWATCHER_QT_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_SCHEDULER_FILEWATCHER_QT_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_SCHEDULER_FILEWATCHER_QT_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "SCHEDULER_FILEWATCHER_QT" qt, "AQ$_SCHEDULER_FILEWATCHER_QT_I" iot, SYS.USER_AQ_AGENT_PRIVS up, SYS.ALL_INT_DEQUEUE_QUEUES qo  WHERE qt.msgid=iot.msgid  and (iot.name = up.agent_name or  iot.subscriber# = (select s.subscriber_id from "AQ$_SCHEDULER_FILEWATCHER_QT_S" s  where s.name = up.agent_name and  bitand(s.subscriber_type, 9) = 1)) and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER_FILEWATCHER_QT_R
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER_FILEWATCHER_QT_R" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "RULE", "RULE_SET", "TRANSFORMATION") AS 
  SELECT queue_name QUEUE, s.name NAME , address ADDRESS , protocol PROTOCOL, rule_condition RULE, ruleset_name RULE_SET, trans_name TRANSFORMATION  FROM "AQ$_SCHEDULER_FILEWATCHER_QT_S" s , sys.all_rules r WHERE (bitand(s.subscriber_type, 1) = 1) AND s.rule_name = r.rule_name and r.rule_owner = 'SYS'  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER_FILEWATCHER_QT_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER_FILEWATCHER_QT_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_SCHEDULER_FILEWATCHER_QT_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER$_REMDB_JOBQTAB
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER$_REMDB_JOBQTAB" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "SCHEDULER$_REMDB_JOBQTAB" qt, "AQ$_SCHEDULER$_REMDB_JOBQTAB_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 19521 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_SCHEDULER$_REMDB_JOBQTAB_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_SCHEDULER$_REMDB_JOBQTAB_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_SCHEDULER$_REMDB_JOBQTAB_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_SCHEDULER$_REMDB_JOBQTAB_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "SCHEDULER$_REMDB_JOBQTAB" qt, "AQ$_SCHEDULER$_REMDB_JOBQTAB_I" iot, SYS.ALL_INT_DEQUEUE_QUEUES qo WHERE qt.msgid=iot.msgid  and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER$_REMDB_JOBQTAB_R
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER$_REMDB_JOBQTAB_R" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "RULE", "RULE_SET", "TRANSFORMATION") AS 
  SELECT queue_name QUEUE, s.name NAME , address ADDRESS , protocol PROTOCOL, rule_condition RULE, ruleset_name RULE_SET, trans_name TRANSFORMATION  FROM "AQ$_SCHEDULER$_REMDB_JOBQTAB_S" s , sys.all_rules r WHERE (bitand(s.subscriber_type, 1) = 1) AND s.rule_name = r.rule_name and r.rule_owner = 'SYS'  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SCHEDULER$_REMDB_JOBQTAB_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SCHEDULER$_REMDB_JOBQTAB_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_SCHEDULER$_REMDB_JOBQTAB_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SYS$SERVICE_METRICS_TAB
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SYS$SERVICE_METRICS_TAB" ("QUEUE", "MSG_ID", "CORR_ID", "MSG_PRIORITY", "MSG_STATE", "DELAY", "DELAY_TIMESTAMP", "EXPIRATION", "ENQ_TIME", "ENQ_TIMESTAMP", "ENQ_USER_ID", "ENQ_TXN_ID", "DEQ_TIME", "DEQ_TIMESTAMP", "DEQ_USER_ID", "DEQ_TXN_ID", "RETRY_COUNT", "EXCEPTION_QUEUE_OWNER", "EXCEPTION_QUEUE", "USER_DATA", "PROPAGATED_MSGID", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "ORIGINAL_MSGID", "ORIGINAL_QUEUE_NAME", "ORIGINAL_QUEUE_OWNER", "EXPIRATION_REASON", "CONSUMER_NAME", "ADDRESS", "PROTOCOL") AS 
  SELECT  q_name QUEUE, qt.msgid MSG_ID, corrid CORR_ID,  priority MSG_PRIORITY,  decode(bitand(s.subscriber_type,2) , 2,'UNDELIVERABLE',
                                             decode(h.dequeue_time, NULL,decode(l.dequeue_time, NULL, decode(state, 0,   'READY',	     
                              		                                          1,   'WAIT',	     
                                                                                  2,   'PROCESSED',	     
                                                                                  3,   'EXPIRED',
                                                                                  8,   'DEFERRED',
                                                                                 10,  'BUFFERED_EXPIRED'),(decode(l.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED'))), (decode(h.transaction_id, NULL, 'UNDELIVERABLE', 'PROCESSED')))
                          )                         MSG_STATE,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as date) delay,  cast(FROM_TZ(qt.delay, '00:00')
                 at time zone sessiontimezone as timestamp) DELAY_TIMESTAMP, expiration,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as date) enq_time,  cast(FROM_TZ(qt.enq_time, '00:00')
                 at time zone sessiontimezone as timestamp)
                 enq_timestamp,   enq_uid ENQ_USER_ID,  qt.enq_tid ENQ_TXN_ID,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_DATE(NULL),cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as date)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as date)) DEQ_TIME,  decode(h.transaction_id, NULL, 
                 decode(l.transaction_id, NULL, 
                 decode(qt.deq_tid, NULL, TO_TIMESTAMP(NULL), cast(FROM_TZ(qt.deq_time, '00:00')
                 at time zone sessiontimezone as timestamp)), l.dequeue_time),
                        cast(FROM_TZ(h.dequeue_time, '00:00')
                 at time zone sessiontimezone as timestamp))
                 DEQ_TIMESTAMP,  decode(h.dequeue_user, NULL, l.dequeue_user, h.dequeue_user) 
	         DEQ_USER_ID,  decode(h.transaction_id, NULL, l.transaction_id, 
                 h.transaction_id) DEQ_TXN_ID,  h.retry_count retry_count,  decode (state, 0, exception_qschema, 
                                1, exception_qschema, 
                                2, exception_qschema,  
                                NULL) EXCEPTION_QUEUE_OWNER,  decode (state, 0, exception_queue, 
                                1, exception_queue, 
                                2, exception_queue,  
                                NULL) EXCEPTION_QUEUE,  user_data,  h.propagated_msgid PROPAGATED_MSGID,  sender_name  SENDER_NAME, sender_address  SENDER_ADDRESS, sender_protocol  SENDER_PROTOCOL, dequeue_msgid ORIGINAL_MSGID,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_queue, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_queue)),
                   decode (h.transaction_id, NULL, NULL, exception_queue)) 
                                ORIGINAL_QUEUE_NAME,  decode (h.dequeue_time, NULL, decode (l.dequeue_time, NULL,
                   decode (state, 3, exception_qschema, NULL), 
                   decode (l.transaction_id, NULL, NULL, exception_qschema)),
                   decode (h.transaction_id, NULL, NULL, exception_qschema)) 
                                ORIGINAL_QUEUE_OWNER,  decode(bitand(s.subscriber_type, 2), 2,
                                         'Messages to be cleaned up later',
                        decode(h.dequeue_time, NULL, 
                               decode(state, 3, 
                                           decode(h.transaction_id, NULL, 
                                           decode (expiration , NULL , 
                                                   'MAX_RETRY_EXCEEDED',
                                                   'TIME_EXPIRATION'),
                                                   'INVALID_TRANSACTION', NULL,
                                                   'MAX_RETRY_EXCEEDED'), NULL),
                                           decode(h.transaction_id, NULL, 
                                                 'PROPAGATION_FAILURE', NULL)))
                 EXPIRATION_REASON,  decode(h.subscriber#, 0, decode(h.name, '0', NULL,
							        h.name),
					  s.name) CONSUMER_NAME,  s.address ADDRESS,  s.protocol PROTOCOL  FROM "SYS$SERVICE_METRICS_TAB" qt, "AQ$_SYS$SERVICE_METRICS_TAB_H" h LEFT OUTER JOIN  (SELECT fv.MSGID MSGID, fv.SUBSCRIBER# SUBSCRIBER#, fv.NAME NAME, 0 ADDRESS#, fv.DEQUEUE_TIME DEQUEUE_TIME,fv.TRANSACTION_ID TRANSACTION_ID, fv.DEQUEUE_USER DEQUEUE_USER, fv.FLAGS FLAGS FROM AQ$_UNFLUSHED_DEQUEUES fv WHERE fv.QTOBJNO = 20447 union select dl.MSGID MSGID, dl.SUBSCRIBER# SUBSCRIBER#, dl.NAME NAME, dl.ADDRESS# ADDRESS#, dl.DEQUEUE_TIME DEQUEUE_TIME, dl.TRANSACTION_ID TRANSACTION_ID, dl.DEQUEUE_USER DEQUEUE_USER, dl.FLAGS FLAGS from "SYS"."AQ$_SYS$SERVICE_METRICS_TAB_L" dl )  l  ON h.msgid = l.msgid AND h.subscriber# = l.subscriber# AND h.name = l.name AND h.address# = l.address#, "AQ$_SYS$SERVICE_METRICS_TAB_S" s  WHERE  qt.msgid = h.msgid AND  ((h.subscriber# != 0 AND h.subscriber# = s.subscriber_id)  OR (h.subscriber# = 0 AND h.address# = s.subscriber_id)) AND (qt.state != 7 OR   qt.state != 9 )     WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_SYS$SERVICE_METRICS_TAB_F
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_SYS$SERVICE_METRICS_TAB_F" ("Q_NAME", "ROW_ID", "MSGID", "CORRID", "PRIORITY", "STATE", "DELAY", "EXPIRATION", "ENQ_TIME", "ENQ_UID", "ENQ_TID", "DEQ_TIME", "DEQ_UID", "DEQ_TID", "RETRY_COUNT", "EXCEPTION_QSCHEMA", "EXCEPTION_QUEUE", "CSCN", "DSCN", "CHAIN_NO", "LOCAL_ORDER_NO", "TIME_MANAGER_INFO", "STEP_NO", "USER_DATA", "SENDER_NAME", "SENDER_ADDRESS", "SENDER_PROTOCOL", "DEQUEUE_MSGID", "DELIVERY_MODE", "SEQUENCE_NUM", "MSG_NUM", "QUEUE_ID", "USER_PROP", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "QUEUE_EVTID") AS 
  SELECT  /*+ NO_MERGE (qo) USE_NL(iot) */ qt.q_name Q_NAME, qt.rowid ROW_ID, qt.msgid MSGID, qt.corrid CORRID, qt.priority PRIORITY, qt.state STATE, cast(FROM_TZ(qt.delay, '00:00') at time zone sessiontimezone as timestamp) DELAY, qt.expiration EXPIRATION, cast(FROM_TZ(qt.enq_time, '00:00') at time zone sessiontimezone as timestamp) ENQ_TIME, qt.enq_uid ENQ_UID, qt.enq_tid ENQ_TID, cast(FROM_TZ(qt.deq_time, '00:00') at time zone sessiontimezone as timestamp) DEQ_TIME, qt.deq_uid DEQ_UID, qt.deq_tid DEQ_TID, qt.retry_count RETRY_COUNT, qt.exception_qschema EXCEPTION_QSCHEMA, qt.exception_queue EXCEPTION_QUEUE, qt.cscn CSCN, qt.dscn DSCN, qt.chain_no CHAIN_NO, qt.local_order_no LOCAL_ORDER_NO, cast(FROM_TZ(qt.time_manager_info, '00:00') at time zone sessiontimezone as timestamp)   TIME_MANAGER_INFO, qt.step_no STEP_NO, qt.user_data USER_DATA, qt.sender_name SENDER_NAME, qt.sender_address SENDER_ADDRESS, qt.sender_protocol SENDER_PROTOCOL, qt.dequeue_msgid DEQUEUE_MSGID, 'PERSISTENT' DELIVERY_MODE, 0 SEQUENCE_NUM, 0 MSG_NUM, qo.qid QUEUE_ID, qt.user_prop USER_PROP, iot.subscriber# SUBSCRIBER_ID, iot.name SUBSCRIBER_NAME, iot.queue# QUEUE_EVTID FROM "SYS$SERVICE_METRICS_TAB" qt, "AQ$_SYS$SERVICE_METRICS_TAB_I" iot, SYS.ALL_INT_DEQUEUE_QUEUES qo WHERE qt.msgid=iot.msgid  and qt.q_name = qo.name  AND qo.owner = 'SYS' AND iot.msg_enq_time = qt.enq_time AND  iot.msg_step_no = qt.step_no AND iot.msg_local_order_no = qt.local_order_no AND   iot.msg_chain_no = qt.chain_no  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SYS$SERVICE_METRICS_TAB_R
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SYS$SERVICE_METRICS_TAB_R" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "RULE", "RULE_SET", "TRANSFORMATION") AS 
  SELECT queue_name QUEUE, s.name NAME , address ADDRESS , protocol PROTOCOL, rule_condition RULE, ruleset_name RULE_SET, trans_name TRANSFORMATION  FROM "AQ$_SYS$SERVICE_METRICS_TAB_S" s , sys.all_rules r WHERE (bitand(s.subscriber_type, 1) = 1) AND s.rule_name = r.rule_name and r.rule_owner = 'SYS'  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$SYS$SERVICE_METRICS_TAB_S
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$SYS$SERVICE_METRICS_TAB_S" ("QUEUE", "NAME", "ADDRESS", "PROTOCOL", "TRANSFORMATION", "QUEUE_TO_QUEUE") AS 
  SELECT queue_name QUEUE, name NAME , address ADDRESS , protocol PROTOCOL, trans_name TRANSFORMATION, decode(bitand(SUBSCRIBER_TYPE, 512), 512, 'TRUE', 'FALSE') QUEUE_TO_QUEUE  FROM "AQ$_SYS$SERVICE_METRICS_TAB_S" s  WHERE (bitand(s.subscriber_type, 1) = 1)  WITH READ ONLY
;
--------------------------------------------------------
--  DDL for View AQ$_UNFLUSHED_DEQUEUES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AQ$_UNFLUSHED_DEQUEUES" ("ADDR", "INDX", "QTOBJNO", "MSGID", "SUBSCRIBER#", "NAME", "DEQUEUE_TIME", "TRANSACTION_ID", "DEQUEUE_USER", "FLAGS") AS 
  select ADDR, INDX, QTOBJNO, MSGID, SUBSCRIBER#, NAME, DEQUEUE_TIME,
TRANSACTION_ID, DEQUEUE_USER, FLAGS from x$unflushed_dequeues
;
--------------------------------------------------------
--  DDL for View AUDITABLE_OBJECT_ACTIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AUDITABLE_OBJECT_ACTIONS" ("ACTION", "NAME") AS 
  select INDX, ACTION_NAME from x$aud_obj_actions;

   COMMENT ON COLUMN "SYS"."AUDITABLE_OBJECT_ACTIONS"."ACTION" IS 'Numeric auditable action code for object specific actions';
   COMMENT ON COLUMN "SYS"."AUDITABLE_OBJECT_ACTIONS"."NAME" IS 'Name of auditable action';
   COMMENT ON TABLE "SYS"."AUDITABLE_OBJECT_ACTIONS"  IS 'Mapping table to map the Audit policy''s auditable object action number
 to action name'
;
--------------------------------------------------------
--  DDL for View AUDITABLE_SYSTEM_ACTIONS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AUDITABLE_SYSTEM_ACTIONS" ("TYPE", "COMPONENT", "ACTION", "NAME") AS 
  select audit_type, component, command_type, command_name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'Standard'),
  v$sqlcommand
  where command_type NOT IN (0,
                             17,  /* GRANT OBJECT */
                             18,  /* REVOKE OBJECT */
                             23,  /* VALIDATE INDEX */
                             27,  /* NO-OP */
                             30,  /* AUDIT OBJECT */
                             31,  /* NOAUDIT OBJECT */
                             34,  /* CREATE DATABASE */
                             46,  /* SAVEPOINT */
                             47,  /* PL/SQL EXECUTE */
                             50,  /* EXPLAIN */
                             57,  /* CREATE CONTROL FILE */
                             58,  /* ALTER TRACING */
                             87,  /* CREATE BITMAPFILE */
                             89,  /* DROP BITMAPFILE */
                             90,  /* SET CONSTRAINTS */
                             170, /* CALL METHOD */
                             171, /* CREATE SUMMARY */
                             172, /* ALTER SUMMARY */
                             173, /* DROP SUMMARY */
                             182, /* UPDATE INDEXES */
                             184, /* Do not use 184 */
                             185, /* Do not use 185 */
                             186, /* Do not use 186 */
                             189, /* UPSERT */
                             191, /* UPDATE JOIN INDEX */
                             198, /* PURGE DBA RECYCLEBIN */
                             202, /* UNDROP OBJECT */
                             203, /* DROP DATABASE */
                             204, /* FLASHBACK DATABASE */
                             209, /* DECLARE REWRITE EQUIVALENCE */
                             210, /* ALTER REWRITE EQUIVALENCE */
                             211, /* DROP REWRITE EQUIVALENCE */
                             213  /* ALTER EDITION */ )
UNION ALL
select audit_type, component, action, name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'Standard'),
  (select  17 action, 'GRANT'                name from dual UNION ALL
   select  18 action, 'REVOKE'               name from dual UNION ALL
   select  30 action, 'AUDIT'                name from dual UNION ALL
   select  31 action, 'NOAUDIT'              name from dual UNION ALL
   select 100 action, 'LOGON'                name from dual UNION ALL
   select 101 action, 'LOGOFF'               name from dual UNION ALL
   select  47 action, 'EXECUTE'              name from dual UNION ALL
   select  50 action, 'EXPLAIN PLAN'         name from dual UNION ALL
   select 170 action, 'CALL'                 name from dual UNION ALL
   select 198 action, 'PURGE DBA_RECYCLEBIN' name from dual UNION ALL
   select (select max(command_type) from v$sqlcommand)+1 action,
           'ALL' name from dual)
/* 2. Add OLS audit actions */
UNION ALL
select audit_type, component, indx, action_name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'Label Security'),
  (select indx, action_name from x$aud_ols_actions where indx <> 0)
/* 3. Add Triton audit actions */
UNION ALL
select audit_type, component, indx, action_name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'XS'),
  (select indx, action_name from x$aud_xs_actions where indx <> 0)
/* 5. Add Data Pump audit actions */
UNION ALL
select audit_type, component, indx, action_name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'Datapump'),
  (select indx, action_name from x$aud_dp_actions where indx <> 0)
/* 6. Add Database Vault audit actions */
UNION ALL
select audit_type, component, indx, action_name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'Database Vault'),
  (select indx, action_name from x$aud_dv_obj_events where indx <> 0)
/* 7. Add Direct path API audit actions */
UNION ALL
select audit_type, component, indx, action_name from
  (select distinct audit_type, component from v$unified_audit_record_format
                                         where component = 'Direct path API'),
  (select indx, action_name from x$aud_dpapi_actions where indx <> 0);

   COMMENT ON COLUMN "SYS"."AUDITABLE_SYSTEM_ACTIONS"."TYPE" IS 'Numeric component type for system wide actions';
   COMMENT ON COLUMN "SYS"."AUDITABLE_SYSTEM_ACTIONS"."COMPONENT" IS 'Name of component for system wide actions';
   COMMENT ON COLUMN "SYS"."AUDITABLE_SYSTEM_ACTIONS"."ACTION" IS 'Numeric auditable action code for system wide actions';
   COMMENT ON COLUMN "SYS"."AUDITABLE_SYSTEM_ACTIONS"."NAME" IS 'Name of auditable action';
   COMMENT ON TABLE "SYS"."AUDITABLE_SYSTEM_ACTIONS"  IS 'Mapping table to map the Audit policy''s auditable system action number
 to action name'
;
--------------------------------------------------------
--  DDL for View AUDIT_UNIFIED_CONTEXTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AUDIT_UNIFIED_CONTEXTS" ("NAMESPACE", "ATTRIBUTE", "USER_NAME") AS 
  select a.namespace,
       a.attribute,
       u.name
from sys.aud_context$ a, sys.user$ u
where a.user# = u.user#
UNION all
select a.namespace,
       a.attribute,
       'ALL USERS'
from sys.aud_context$ a
where a.user# = -1;

   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_CONTEXTS"."NAMESPACE" IS 'Name of Application context''s Namespace';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_CONTEXTS"."ATTRIBUTE" IS 'Name of Application context''s Attribute';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_CONTEXTS"."USER_NAME" IS 'Database username for whom the Application context''s attribute is congfigured
 to be captured in the audit trail';
   COMMENT ON TABLE "SYS"."AUDIT_UNIFIED_CONTEXTS"  IS 'Describes the application context''s attributes, which are configured to be
 captured in the audit trail'
;
--------------------------------------------------------
--  DDL for View AUDIT_UNIFIED_ENABLED_POLICIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES" ("USER_NAME", "POLICY_NAME", "ENABLED_OPT", "ENABLED_OPTION", "ENTITY_NAME", "ENTITY_TYPE", "SUCCESS", "FAILURE") AS 
  select USER_NAME, POLICY_NAME, ENABLED_OPT, ENABLED_OPTION, ENTITY_NAME,
       ENTITY_TYPE, SUCCESS, FAILURE
from INT$AUDIT_UNIFIED_ENABLED_POL;

   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"."USER_NAME" IS 'Deprecated - Use ENTITY_NAME column instead';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"."POLICY_NAME" IS 'Name of the Audit policy';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"."ENABLED_OPT" IS 'Deprecated - Use ENABLED_OPTION column instead';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"."ENABLED_OPTION" IS 'Enabled option of the Audit policy. The possible values are BY USER,
 EXCEPT USER, BY GRANTED ROLE, INVALID.';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"."ENTITY_NAME" IS 'Database entity on which the Audit policy is enabled';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"."ENTITY_TYPE" IS 'Database entity type - User or Role';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"."SUCCESS" IS 'Is the Audit policy enabled for auditing successful events';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"."FAILURE" IS 'Is the Audit policy enabled for auditing unsuccessful events';
   COMMENT ON TABLE "SYS"."AUDIT_UNIFIED_ENABLED_POLICIES"  IS 'Describes the Audit policy''s enablement to users'
;
--------------------------------------------------------
--  DDL for View AUDIT_UNIFIED_POLICIES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AUDIT_UNIFIED_POLICIES" ("POLICY_NAME", "AUDIT_CONDITION", "CONDITION_EVAL_OPT", "AUDIT_OPTION", "AUDIT_OPTION_TYPE", "OBJECT_SCHEMA", "OBJECT_NAME", "OBJECT_TYPE", "COMMON", "INHERITED") AS 
  select POLICY_NAME, AUDIT_CONDITION, CONDITION_EVAL_OPT, AUDIT_OPTION,
       AUDIT_OPTION_TYPE, OBJECT_SCHEMA, OBJECT_NAME, OBJECT_TYPE, COMMON,
       decode(COMMON,
              'YES', (decode(ORIGIN_CON_ID,
                             SYS_CONTEXT('USERENV', 'CON_ID'), 'NO', 'YES')),
              'NO', 'NO', NULL)
from INT$AUDIT_UNIFIED_POLICIES;

   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."POLICY_NAME" IS 'Name of the Audit policy';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."AUDIT_CONDITION" IS 'Condition associated with the Audit policy';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."CONDITION_EVAL_OPT" IS 'Evaluation option associated with the Audit policy''s Condition.
 The possible values are STATEMENT, SESSION, INSTANCE, NONE.';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."AUDIT_OPTION" IS 'Auditing option defined in the Audit policy';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."AUDIT_OPTION_TYPE" IS 'Type of the Auditing option. The possible values are SYSTEM PRIVILEGE,
 SYSTEM ACTION, OBJECT ACTION, INVALID';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."OBJECT_SCHEMA" IS 'Owner of the object, in case of Object-specific auditing option';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."OBJECT_NAME" IS 'Name of the object, in case of Object-specific auditing option';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."OBJECT_TYPE" IS 'Type of the object, in case of Object-specific auditing option';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."COMMON" IS 'Whether the audit policy is a Common Audit Policy or Local. It is NULL
in case of non-CDBs';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICIES"."INHERITED" IS 'Was audit policy inherited from another container. It is NULL in case of non-CDBs';
   COMMENT ON TABLE "SYS"."AUDIT_UNIFIED_POLICIES"  IS 'Describes the Audit policy''s definition of all policies created in database'
;
--------------------------------------------------------
--  DDL for View AUDIT_UNIFIED_POLICY_COMMENTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AUDIT_UNIFIED_POLICY_COMMENTS" ("POLICY_NAME", "COMMENTS") AS 
  ( select o.name, c.comment$ from sys.com$ c, obj$ o
  where c.obj# = o.obj# and o.type#=115 );

   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICY_COMMENTS"."POLICY_NAME" IS 'Unified Audit Policy Name';
   COMMENT ON COLUMN "SYS"."AUDIT_UNIFIED_POLICY_COMMENTS"."COMMENTS" IS 'Unified Audit Policy Description'
;
--------------------------------------------------------
--  DDL for View AUDTAB$TBS$FOR_EXPORT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AUDTAB$TBS$FOR_EXPORT" ("OWNER", "NAME", "TS_NAME") AS 
  select owner, table_name, tablespace_name from dba_tables
where owner = 'SYS' and (table_name = 'AUD$' or table_name = 'FGA_LOG$')
;
--------------------------------------------------------
--  DDL for View AWR_CDB_ACTIVE_SESS_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_ACTIVE_SESS_HISTORY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SAMPLE_ID", "SAMPLE_TIME", "SAMPLE_TIME_UTC", "USECS_PER_ROW", "SESSION_ID", "SESSION_SERIAL#", "SESSION_TYPE", "FLAGS", "USER_ID", "SQL_ID", "IS_SQLID_CURRENT", "SQL_CHILD_NUMBER", "SQL_OPCODE", "SQL_OPNAME", "FORCE_MATCHING_SIGNATURE", "TOP_LEVEL_SQL_ID", "TOP_LEVEL_SQL_OPCODE", "SQL_PLAN_HASH_VALUE", "SQL_FULL_PLAN_HASH_VALUE", "SQL_ADAPTIVE_PLAN_RESOLVED", "SQL_PLAN_LINE_ID", "SQL_PLAN_OPERATION", "SQL_PLAN_OPTIONS", "SQL_EXEC_ID", "SQL_EXEC_START", "PLSQL_ENTRY_OBJECT_ID", "PLSQL_ENTRY_SUBPROGRAM_ID", "PLSQL_OBJECT_ID", "PLSQL_SUBPROGRAM_ID", "QC_INSTANCE_ID", "QC_SESSION_ID", "QC_SESSION_SERIAL#", "PX_FLAGS", "EVENT", "EVENT_ID", "SEQ#", "P1TEXT", "P1", "P2TEXT", "P2", "P3TEXT", "P3", "WAIT_CLASS", "WAIT_CLASS_ID", "WAIT_TIME", "SESSION_STATE", "TIME_WAITED", "BLOCKING_SESSION_STATUS", "BLOCKING_SESSION", "BLOCKING_SESSION_SERIAL#", "BLOCKING_INST_ID", "BLOCKING_HANGCHAIN_INFO", "CURRENT_OBJ#", "CURRENT_FILE#", "CURRENT_BLOCK#", "CURRENT_ROW#", "TOP_LEVEL_CALL#", "TOP_LEVEL_CALL_NAME", "CONSUMER_GROUP_ID", "XID", "REMOTE_INSTANCE#", "TIME_MODEL", "IN_CONNECTION_MGMT", "IN_PARSE", "IN_HARD_PARSE", "IN_SQL_EXECUTION", "IN_PLSQL_EXECUTION", "IN_PLSQL_RPC", "IN_PLSQL_COMPILATION", "IN_JAVA_EXECUTION", "IN_BIND", "IN_CURSOR_CLOSE", "IN_SEQUENCE_LOAD", "IN_INMEMORY_QUERY", "IN_INMEMORY_POPULATE", "IN_INMEMORY_PREPOPULATE", "IN_INMEMORY_REPOPULATE", "IN_INMEMORY_TREPOPULATE", "IN_TABLESPACE_ENCRYPTION", "CAPTURE_OVERHEAD", "REPLAY_OVERHEAD", "IS_CAPTURED", "IS_REPLAYED", "IS_REPLAY_SYNC_TOKEN_HOLDER", "SERVICE_HASH", "PROGRAM", "MODULE", "ACTION", "CLIENT_ID", "MACHINE", "PORT", "ECID", "DBREPLAY_FILE_ID", "DBREPLAY_CALL_COUNTER", "TM_DELTA_TIME", "TM_DELTA_CPU_TIME", "TM_DELTA_DB_TIME", "DELTA_TIME", "DELTA_READ_IO_REQUESTS", "DELTA_WRITE_IO_REQUESTS", "DELTA_READ_IO_BYTES", "DELTA_WRITE_IO_BYTES", "DELTA_INTERCONNECT_IO_BYTES", "PGA_ALLOCATED", "TEMP_SPACE_ALLOCATED", "DBOP_NAME", "DBOP_EXEC_ID", "CON_DBID", "CON_ID") AS 
  select /* ASH/AWR meta attributes */
       ash.snap_id, ash.dbid, ash.instance_number,
       ash.sample_id, ash.sample_time, ash.sample_time_utc,
       ash.usecs_per_row,
       /* Session/User attributes */
       ash.session_id, ash.session_serial#,
       decode(ash.session_type, 1,'FOREGROUND', 'BACKGROUND'),
       ash.flags,
       ash.user_id,
       /* SQL attributes */
       ash.sql_id,
       decode(bitand(ash.flags, power(2, 4)), NULL, 'N', 0, 'N', 'Y'),
       ash.sql_child_number, ash.sql_opcode,
       (select command_name
          from WRH$_SQLCOMMAND_NAME s
         where s.command_type = ash.sql_opcode
           and s.dbid = ash.dbid
           and s.con_dbid = ash.dbid) as sql_opname,
       ash.force_matching_signature,
       decode(ash.top_level_sql_id, NULL, ash.sql_id, ash.top_level_sql_id),
       decode(ash.top_level_sql_id, NULL, ash.sql_opcode,
              ash.top_level_sql_opcode),
       /* SQL Plan/Execution attributes */
       ash.sql_plan_hash_value,
       ash.sql_full_plan_hash_value,
       ash.sql_adaptive_plan_resolved,
       decode(ash.sql_plan_line_id, 0, to_number(NULL), ash.sql_plan_line_id),
       (select operation_name
          from WRH$_PLAN_OPERATION_NAME pn
         where  pn.operation_id = ash.sql_plan_operation#
           and  pn.dbid = ash.dbid
           and  pn.con_dbid = ash.dbid) as sql_plan_operation,
       (select option_name
          from WRH$_PLAN_OPTION_NAME po
         where  po.option_id = ash.sql_plan_options#
           and  po.dbid = ash.dbid
           and  po.con_dbid = ash.dbid) as sql_plan_options,
       decode(ash.sql_exec_id, 0, to_number(NULL), ash.sql_exec_id),
       ash.sql_exec_start,
       /* PL/SQL attributes */
       decode(ash.plsql_entry_object_id,0,to_number(NULL),
              ash.plsql_entry_object_id),
       decode(ash.plsql_entry_object_id,0,to_number(NULL),
              ash.plsql_entry_subprogram_id),
       decode(ash.plsql_object_id,0,to_number(NULL),
              ash.plsql_object_id),
       decode(ash.plsql_object_id,0,to_number(NULL),
              ash.plsql_subprogram_id),
       /* PQ attributes */
       decode(ash.qc_session_id, 0, to_number(NULL), ash.qc_instance_id),
       decode(ash.qc_session_id, 0, to_number(NULL), ash.qc_session_id),
       decode(ash.qc_session_id, 0, to_number(NULL), ash.qc_session_serial#),
       decode(ash.px_flags,      0, to_number(NULL), ash.px_flags),
       /* Wait event attributes */
       decode(ash.wait_time, 0, evt.event_name, NULL),
       decode(ash.wait_time, 0, evt.event_id,   NULL),
       ash.seq#,
       evt.parameter1, ash.p1,
       evt.parameter2, ash.p2,
       evt.parameter3, ash.p3,
       decode(ash.wait_time, 0, evt.wait_class,    NULL),
       decode(ash.wait_time, 0, evt.wait_class_id, NULL),
       ash.wait_time,
       decode(ash.wait_time, 0, 'WAITING', 'ON CPU'),
       ash.time_waited,
       (case when ash.blocking_session = 4294967295
               then 'UNKNOWN'
             when ash.blocking_session = 4294967294
               then 'GLOBAL'
             when ash.blocking_session = 4294967293
               then 'UNKNOWN'
             when ash.blocking_session = 4294967292
               then 'NO HOLDER'
             when ash.blocking_session = 4294967291
               then 'NOT IN WAIT'
             else 'VALID'
        end),
       (case when ash.blocking_session between 4294967291 and 4294967295
               then to_number(NULL)
             else ash.blocking_session
        end),
       (case when ash.blocking_session between 4294967291 and 4294967295
               then to_number(NULL)
             else ash.blocking_session_serial#
        end),
       (case when ash.blocking_session between 4294967291 and 4294967295
               then to_number(NULL)
             else ash.blocking_inst_id
          end),
       (case when ash.blocking_session between 4294967291 and 4294967295
               then NULL
             else decode(bitand(ash.flags, power(2, 3)), NULL, 'N',
                         0, 'N', 'Y')
          end),
       /* Session's working context */
       ash.current_obj#, ash.current_file#, ash.current_block#,
       ash.current_row#, ash.top_level_call#,
       (select top_level_call_name
          from WRH$_TOPLEVELCALL_NAME t
         where top_level_call# = ash.top_level_call#
           and t.dbid = ash.dbid
           and t.con_dbid = ash.dbid) as top_level_call_name,
       decode(ash.consumer_group_id, 0, to_number(NULL),
              ash.consumer_group_id),
       ash.xid,
       decode(ash.remote_instance#, 0, to_number(NULL), ash.remote_instance#),
       ash.time_model,
       decode(bitand(ash.time_model,power(2, 3)),0,'N','Y')
                                                         as in_connection_mgmt,
       decode(bitand(ash.time_model,power(2, 4)),0,'N','Y')as in_parse,
       decode(bitand(ash.time_model,power(2, 7)),0,'N','Y')as in_hard_parse,
       decode(bitand(ash.time_model,power(2,10)),0,'N','Y')as in_sql_execution,
       decode(bitand(ash.time_model,power(2,11)),0,'N','Y')
                                                         as in_plsql_execution,
       decode(bitand(ash.time_model,power(2,12)),0,'N','Y')as in_plsql_rpc,
       decode(bitand(ash.time_model,power(2,13)),0,'N','Y')
                                                       as in_plsql_compilation,
       decode(bitand(ash.time_model,power(2,14)),0,'N','Y')
                                                       as in_java_execution,
       decode(bitand(ash.time_model,power(2,15)),0,'N','Y')as in_bind,
       decode(bitand(ash.time_model,power(2,16)),0,'N','Y')as in_cursor_close,
       decode(bitand(ash.time_model,power(2,17)),0,'N','Y')as in_sequence_load,
       decode(bitand(ash.time_model,power(2,18)),0,'N','Y')as in_inmemory_query,
       decode(bitand(ash.time_model,power(2,19)),0,'N','Y')
                                                        as in_inmemory_populate,
       decode(bitand(ash.time_model,power(2,20)),0,'N','Y')
                                                     as in_inmemory_prepopulate,
       decode(bitand(ash.time_model,power(2,21)),0,'N','Y')
                                                      as in_inmemory_repopulate,
       decode(bitand(ash.time_model,power(2,22)),0,'N','Y')
                                                     as in_inmemory_trepopulate,
       decode(bitand(ash.time_model,power(2,23)),0,'N','Y')
                                               as in_tablespace_encryption,
       decode(bitand(ash.flags,power(2,5)),NULL,'N',0,'N','Y')
                                                       as capture_overhead,
       decode(bitand(ash.flags,power(2,6)), NULL,'N',0,'N','Y' )
                                                           as replay_overhead,
       decode(bitand(ash.flags,power(2,0)),NULL,'N',0,'N','Y') as is_captured,
       decode(bitand(ash.flags,power(2,2)), NULL,'N',0,'N','Y' )as is_replayed,
       decode(bitand(ash.flags,power(2,8)), NULL,'N',0,'N','Y')
             as is_replay_sync_token_holder,
       /* Application attributes */
       ash.service_hash,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' then ash.program else null end program, -- Use macro to mask sensitive column
       substrb(ash.module,1,(select ksumodlen from x$modact_length)) module,
       substrb(ash.action,1,(select ksuactlen from x$modact_length)) action,
       ash.client_id,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' then ash.machine else null end machine, -- Use macro to mask sensitive column
       ash.port, ash.ecid,
       /* DB Replay info */
       ash.dbreplay_file_id, ash.dbreplay_call_counter,
       /* stash columns */
       ash.tm_delta_time,
       ash.tm_delta_cpu_time,
       ash.tm_delta_db_time,
       ash.delta_time,
       ash.delta_read_io_requests,
       ash.delta_write_io_requests,
       ash.delta_read_io_bytes,
       ash.delta_write_io_bytes,
       ash.delta_interconnect_io_bytes,
       ash.pga_allocated,
       ash.temp_space_allocated,
       ash.dbop_name,
       ash.dbop_exec_id,
       decode(ash.con_dbid, 0, ash.dbid, ash.con_dbid),
       decode(ash.per_pdb, 0, 0,
         con_dbid_to_id(decode(ash.con_dbid, 0, ash.dbid, ash.con_dbid))) con_id
from WRM$_SNAPSHOT sn, WRH$_ACTIVE_SESSION_HISTORY ash, WRH$_EVENT_NAME evt
where      ash.snap_id          = sn.snap_id(+)
      and  ash.dbid             = sn.dbid(+)
      and  ash.instance_number  = sn.instance_number(+)
      and  ash.dbid             = evt.dbid(+)
      and  ash.event_id         = evt.event_id(+);

   COMMENT ON TABLE "SYS"."AWR_CDB_ACTIVE_SESS_HISTORY"  IS 'Active Session Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_APPLY_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_APPLY_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "APPLY_NAME", "STARTUP_TIME", "READER_TOTAL_MESSAGES_DEQUEUED", "READER_LAG", "COORD_TOTAL_RECEIVED", "COORD_TOTAL_APPLIED", "COORD_TOTAL_ROLLBACKS", "COORD_TOTAL_WAIT_DEPS", "COORD_TOTAL_WAIT_CMTS", "COORD_LWM_LAG", "SERVER_TOTAL_MESSAGES_APPLIED", "SERVER_ELAPSED_DEQUEUE_TIME", "SERVER_ELAPSED_APPLY_TIME", "CON_DBID", "REPLICAT_NAME", "UNASSIGNED_COMPLETE_TXN", "TOTAL_LCRS_RETRIED", "TOTAL_TRANSACTIONS_RETRIED", "TOTAL_ERRORS", "SESSION_MODULE", "CON_ID") AS 
  select sas.snap_id, sas.dbid, sas.instance_number, sas.apply_name,
       sas.startup_time, sas.reader_total_messages_dequeued, sas.reader_lag,
       sas.coord_total_received, sas.coord_total_applied,
       sas.coord_total_rollbacks, sas.coord_total_wait_deps,
       sas.coord_total_wait_cmts, sas.coord_lwm_lag,
       sas.server_total_messages_applied, sas.server_elapsed_dequeue_time,
       sas.server_elapsed_apply_time,
       decode(sas.con_dbid, 0, sas.dbid, sas.con_dbid),
       sas.replicat_name, sas.unassigned_complete_txn,
       sas.total_lcrs_retried,
       sas.total_transactions_retried, sas.total_errors, sas.session_module,
       decode(sas.per_pdb, 0, 0,
         con_dbid_to_id(decode(sas.con_dbid, 0, sas.dbid, sas.con_dbid))) con_id
  from wrh$_streams_apply_sum sas, AWR_CDB_SNAPSHOT sn
  where sn.snap_id              = sas.snap_id
        and sn.dbid             = sas.dbid
        and sn.instance_number  = sas.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_APPLY_SUMMARY"  IS 'Streams/Goldengate/XStream Apply Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_ASH_SNAPSHOT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_ASH_SNAPSHOT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STARTUP_TIME", "BEGIN_INTERVAL_TIME", "END_INTERVAL_TIME", "FLUSH_ELAPSED", "SNAP_LEVEL", "STATUS", "ERROR_COUNT", "BL_MOVED", "SNAP_FLAG", "SNAP_TIMEZONE", "CON_ID") AS 
  select snap_id, dbid, instance_number, startup_time, begin_interval_time,
       end_interval_time, flush_elapsed, snap_level, status, error_count,
       bl_moved, snap_flag, snap_timezone,
       decode(con_dbid_to_id(s.dbid), 1, 0, con_dbid_to_id(s.dbid)) con_id
  from wrm$_snapshot s
 where s.status in (0,1)
   and s.flush_elapsed is not null
   and (s.snap_id,dbid,instance_number) not in
       (select e.snap_id,dbid,instance_number
          from WRM$_SNAP_ERROR e
         where e.table_name = 'WRH$_ACTIVE_SESSION_HISTORY')
;
--------------------------------------------------------
--  DDL for View AWR_CDB_ASM_BAD_DISK
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_ASM_BAD_DISK"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "GROUP_NUMBER", "NAME", "PATH", "STATUS", "CON_DBID", "CON_ID") AS 
  select tb.snap_id, tb.dbid,
       GROUP_NUMBER, NAME, PATH, STATUS,
       decode(con_dbid, 0, tb.dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, tb.dbid, con_dbid))) con_id
  from (select distinct snap_id, dbid
          from AWR_CDB_SNAPSHOT) sn,
       WRH$_ASM_BAD_DISK tb
  where sn.snap_id = tb.snap_id
    and sn.dbid    = tb.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_ASM_BAD_DISK"  IS 'Non-Online ASM Disks'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_ASM_DISKGROUP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_ASM_DISKGROUP"  CONTAINER_DATA 
 ("DBID", "CURRENT_SNAP_ID", "GROUP_NUMBER", "NAME", "TYPE", "CON_DBID", "CON_ID") AS 
  select dbid,
       CURRENT_SNAP_ID, GROUP_NUMBER, NAME, TYPE,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_ASM_DISKGROUP;

   COMMENT ON TABLE "SYS"."AWR_CDB_ASM_DISKGROUP"  IS 'ASM Diskgroups connected to this Database'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_ASM_DISKGROUP_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_ASM_DISKGROUP_STAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "GROUP_NUMBER", "TOTAL_MB", "FREE_MB", "NUM_DISK", "NUM_FAILGROUP", "STATE", "CON_DBID", "CON_ID") AS 
  select snap_id, dbid,
       GROUP_NUMBER, TOTAL_MB, FREE_MB, NUM_DISK, NUM_FAILGROUP, STATE,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_ASM_DISKGROUP_STAT;

   COMMENT ON TABLE "SYS"."AWR_CDB_ASM_DISKGROUP_STAT"  IS 'Statistics for ASM Diskgroup connected to this Database'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_ASM_DISK_STAT_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_ASM_DISK_STAT_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "GROUP_NUMBER", "READS", "WRITES", "READ_ERRS", "WRITE_ERRS", "READ_TIMEOUT", "WRITE_TIMEOUT", "READ_TIME", "WRITE_TIME", "BYTES_READ", "BYTES_WRITTEN", "CON_DBID", "CON_ID") AS 
  select snap_id, dbid, instance_number, GROUP_NUMBER,
       READS, WRITES, READ_ERRS, WRITE_ERRS, READ_TIMEOUT, WRITE_TIMEOUT,
       READ_TIME, WRITE_TIME, BYTES_READ, BYTES_WRITTEN,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_ASM_DISK_STAT_SUMMARY;

   COMMENT ON TABLE "SYS"."AWR_CDB_ASM_DISK_STAT_SUMMARY"  IS 'Statistics for ASM Disk summary statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_BASELINE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_BASELINE"  CONTAINER_DATA 
 ("DBID", "BASELINE_ID", "BASELINE_NAME", "BASELINE_TYPE", "START_SNAP_ID", "START_SNAP_TIME", "END_SNAP_ID", "END_SNAP_TIME", "MOVING_WINDOW_SIZE", "CREATION_TIME", "EXPIRATION", "TEMPLATE_NAME", "LAST_TIME_COMPUTED", "CON_ID") AS 
  select bl.dbid, bl.baseline_id,
       bl.baseline_name, max(bl.baseline_type),
       min(bst.start_snap_id), min(bst.start_snap_time),
       max(bst.end_snap_id),   max(bst.end_snap_time),
       max(bl.moving_window_size), max(bl.creation_time),
       max(bl.expiration), max(bl.template_name),
       max(bl.last_time_computed),
       decode(con_dbid_to_id(bl.dbid), 1, 0, con_dbid_to_id(bl.dbid)) con_id
from
  WRM$_BASELINE bl, WRM$_BASELINE_DETAILS bst
where
  bl.dbid = bst.dbid and
  bl.baseline_id != 0 and
  bl.baseline_id = bst.baseline_id
group by bl.dbid, bl.baseline_id, baseline_name
union all
select bl.dbid, bl.baseline_id,
       bl.baseline_name, max(bl.baseline_type),
       min(bst.start_snap_id), min(bst.start_snap_time),
       max(bst.end_snap_id),   max(bst.end_snap_time),
       max(bl.moving_window_size), max(bl.creation_time),
       max(bl.expiration), max(bl.template_name),
       max(bl.last_time_computed),
       decode(con_dbid_to_id(bl.dbid), 1, 0, con_dbid_to_id(bl.dbid)) con_id
from
  WRM$_BASELINE bl,  /* Note: moving window stats only for local dbid */
  table(dbms_workload_repository.select_baseline_details(bl.baseline_id)) bst
where
  bl.dbid = bst.dbid and
  bl.baseline_id = 0 and
  bl.baseline_id = bst.baseline_id
group by bl.dbid, bl.baseline_id, baseline_name;

   COMMENT ON TABLE "SYS"."AWR_CDB_BASELINE"  IS 'Baseline Metadata Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_BASELINE_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_BASELINE_DETAILS"  CONTAINER_DATA 
 ("DBID", "INSTANCE_NUMBER", "BASELINE_ID", "BASELINE_NAME", "BASELINE_TYPE", "START_SNAP_ID", "START_SNAP_TIME", "END_SNAP_ID", "END_SNAP_TIME", "SHUTDOWN", "ERROR_COUNT", "PCT_TOTAL_TIME", "LAST_TIME_COMPUTED", "MOVING_WINDOW_SIZE", "CREATION_TIME", "EXPIRATION", "TEMPLATE_NAME", "CON_ID") AS 
  select bl.dbid, bst.instance_number,
       bl.baseline_id, bl.baseline_name, bl.baseline_type,
       bst.start_snap_id, bst.start_snap_time,
       bst.end_snap_id,   bst.end_snap_time,
       bst.shutdown, bst.error_count, bst.pct_total_time,
       bl.last_time_computed,
       bl.moving_window_size, bl.creation_time,
       bl.expiration, bl.template_name,
       decode(con_dbid_to_id(bl.dbid), 1, 0, con_dbid_to_id(bl.dbid)) con_id
from
  WRM$_BASELINE bl, WRM$_BASELINE_DETAILS bst
where
  bl.dbid = bst.dbid and
  bl.baseline_id != 0 and
  bl.baseline_id = bst.baseline_id
union all
select bl.dbid, bst.instance_number,
       bl.baseline_id, bl.baseline_name, bl.baseline_type,
       bst.start_snap_id, bst.start_snap_time,
       bst.end_snap_id,   bst.end_snap_time,
       bst.shutdown, bst.error_count, bst.pct_total_time,
       bl.last_time_computed,
       bl.moving_window_size, bl.creation_time,
       bl.expiration, bl.template_name,
       decode(con_dbid_to_id(bl.dbid), 1, 0, con_dbid_to_id(bl.dbid)) con_id
from
  WRM$_BASELINE bl,  /* Note: moving window stats only for local dbid */
  table(dbms_workload_repository.select_baseline_details(bl.baseline_id)) bst
where
  bl.dbid = bst.dbid and
  bl.baseline_id = 0 and
  bl.baseline_id = bst.baseline_id;

   COMMENT ON TABLE "SYS"."AWR_CDB_BASELINE_DETAILS"  IS 'Baseline Stats on per Instance Level'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_BASELINE_METADATA
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_BASELINE_METADATA"  CONTAINER_DATA 
 ("DBID", "BASELINE_ID", "BASELINE_NAME", "BASELINE_TYPE", "START_SNAP_ID", "END_SNAP_ID", "MOVING_WINDOW_SIZE", "CREATION_TIME", "EXPIRATION", "TEMPLATE_NAME", "LAST_TIME_COMPUTED", "CON_ID") AS 
  select dbid, baseline_id,
       baseline_name, baseline_type,
       start_snap_id, end_snap_id,
       moving_window_size, creation_time,
       expiration, template_name, last_time_computed,
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from
  WRM$_BASELINE;

   COMMENT ON TABLE "SYS"."AWR_CDB_BASELINE_METADATA"  IS 'Baseline Metadata Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_BASELINE_TEMPLATE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_BASELINE_TEMPLATE"  CONTAINER_DATA 
 ("DBID", "TEMPLATE_ID", "TEMPLATE_NAME", "TEMPLATE_TYPE", "BASELINE_NAME_PREFIX", "START_TIME", "END_TIME", "DAY_OF_WEEK", "HOUR_IN_DAY", "DURATION", "EXPIRATION", "REPEAT_INTERVAL", "LAST_GENERATED", "CON_ID") AS 
  select dbid, template_id, template_name, template_type,
       baseline_name_prefix, start_time, end_time,
       day_of_week, hour_in_day, duration,
       expiration, repeat_interval, last_generated,
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from
  WRM$_BASELINE_TEMPLATE;

   COMMENT ON TABLE "SYS"."AWR_CDB_BASELINE_TEMPLATE"  IS 'Baseline Template Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_BG_EVENT_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_BG_EVENT_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EVENT_ID", "EVENT_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "TOTAL_WAITS", "TOTAL_TIMEOUTS", "TIME_WAITED_MICRO", "CON_DBID", "CON_ID") AS 
  select e.snap_id, e.dbid, e.instance_number,
       e.event_id, en.event_name, en.wait_class_id, en.wait_class,
       total_waits, total_timeouts, time_waited_micro,
       decode(e.con_dbid, 0, e.dbid, e.con_dbid),
       decode(e.per_pdb, 0, 0,
         con_dbid_to_id(decode(e.con_dbid, 0, e.dbid, e.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_BG_EVENT_SUMMARY e, WRH$_EVENT_NAME en
where     sn.snap_id         = e.snap_id
      and sn.dbid            = e.dbid
      and sn.instance_number = e.instance_number
      and e.event_id         = en.event_id
      and e.dbid             = en.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_BG_EVENT_SUMMARY"  IS 'Summary of Background Event Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_BUFFERED_QUEUES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_BUFFERED_QUEUES"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_SCHEMA", "QUEUE_NAME", "STARTUP_TIME", "QUEUE_ID", "NUM_MSGS", "SPILL_MSGS", "CNUM_MSGS", "CSPILL_MSGS", "EXPIRED_MSGS", "OLDEST_MSGID", "OLDEST_MSG_ENQTM", "QUEUE_STATE", "ELAPSED_ENQUEUE_TIME", "ELAPSED_DEQUEUE_TIME", "ELAPSED_TRANSFORMATION_TIME", "ELAPSED_RULE_EVALUATION_TIME", "ENQUEUE_CPU_TIME", "DEQUEUE_CPU_TIME", "LAST_ENQUEUE_TIME", "LAST_DEQUEUE_TIME", "CON_DBID", "CON_ID") AS 
  select qs.snap_id, qs.dbid, qs.instance_number, qs.queue_schema, qs.queue_name,
       qs.startup_time, qs.queue_id, qs.num_msgs, qs.spill_msgs, qs.cnum_msgs,
       qs.cspill_msgs, qs.expired_msgs, qs.oldest_msgid, qs.oldest_msg_enqtm,
       qs.queue_state, qs.elapsed_enqueue_time,
       qs.elapsed_dequeue_time, qs.elapsed_transformation_time,
       qs.elapsed_rule_evaluation_time, qs.enqueue_cpu_time,
       qs.dequeue_cpu_time, qs.last_enqueue_time, qs.last_dequeue_time,
       decode(qs.con_dbid, 0, qs.dbid, qs.con_dbid),
       decode(qs.per_pdb, 0, 0,
         con_dbid_to_id(decode(qs.con_dbid, 0, qs.dbid, qs.con_dbid))) con_id
  from wrh$_buffered_queues qs, AWR_CDB_SNAPSHOT sn
  where     sn.snap_id          = qs.snap_id
        and sn.dbid             = qs.dbid
        and sn.instance_number  = qs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_BUFFERED_QUEUES"  IS 'STREAMS Buffered Queues Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_BUFFERED_SUBSCRIBERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_BUFFERED_SUBSCRIBERS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_SCHEMA", "QUEUE_NAME", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "SUBSCRIBER_ADDRESS", "SUBSCRIBER_TYPE", "STARTUP_TIME", "LAST_BROWSED_SEQ", "LAST_BROWSED_NUM", "LAST_DEQUEUED_SEQ", "LAST_DEQUEUED_NUM", "CURRENT_ENQ_SEQ", "NUM_MSGS", "CNUM_MSGS", "TOTAL_DEQUEUED_MSG", "TOTAL_SPILLED_MSG", "EXPIRED_MSGS", "MESSAGE_LAG", "ELAPSED_DEQUEUE_TIME", "DEQUEUE_CPU_TIME", "LAST_DEQUEUE_TIME", "OLDEST_MSGID", "OLDEST_MSG_ENQTM", "CON_DBID", "CON_ID") AS 
  select ss.snap_id, ss.dbid, ss.instance_number, ss.queue_schema, ss.queue_name,
       ss.subscriber_id, ss.subscriber_name, ss.subscriber_address,
       ss.subscriber_type, ss.startup_time, ss.last_browsed_seq,
       ss.last_browsed_num, ss.last_dequeued_seq, ss.last_dequeued_num,
       ss.current_enq_seq, ss.num_msgs, ss.cnum_msgs,
       ss.total_dequeued_msg, ss.total_spilled_msg, ss.expired_msgs,
       ss.message_lag, ss.elapsed_dequeue_time, ss.dequeue_cpu_time,
       ss.last_dequeue_time, ss.oldest_msgid, ss.oldest_msg_enqtm,
       decode(ss.con_dbid, 0, ss.dbid, ss.con_dbid),
       decode(ss.per_pdb, 0, 0,
         con_dbid_to_id(decode(ss.con_dbid, 0, ss.dbid, ss.con_dbid))) con_id
  from wrh$_buffered_subscribers ss, AWR_CDB_SNAPSHOT sn
  where     sn.snap_id          = ss.snap_id
        and sn.dbid             = ss.dbid
        and sn.instance_number  = ss.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_BUFFERED_SUBSCRIBERS"  IS 'STREAMS Buffered Queue Subscribers Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_BUFFER_POOL_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_BUFFER_POOL_STAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "ID", "NAME", "BLOCK_SIZE", "SET_MSIZE", "CNUM_REPL", "CNUM_WRITE", "CNUM_SET", "BUF_GOT", "SUM_WRITE", "SUM_SCAN", "FREE_BUFFER_WAIT", "WRITE_COMPLETE_WAIT", "BUFFER_BUSY_WAIT", "FREE_BUFFER_INSPECTED", "DIRTY_BUFFERS_INSPECTED", "DB_BLOCK_CHANGE", "DB_BLOCK_GETS", "CONSISTENT_GETS", "PHYSICAL_READS", "PHYSICAL_WRITES", "CON_DBID", "CON_ID") AS 
  select bp.snap_id, bp.dbid, bp.instance_number,
       id, name, block_size, set_msize,
       cnum_repl, cnum_write, cnum_set, buf_got, sum_write, sum_scan,
       free_buffer_wait, write_complete_wait, buffer_busy_wait,
       free_buffer_inspected, dirty_buffers_inspected,
       db_block_change, db_block_gets, consistent_gets,
       physical_reads, physical_writes,
       decode(bp.con_dbid, 0, bp.dbid, bp.con_dbid),
       decode(bp.per_pdb, 0, 0,
         con_dbid_to_id(decode(bp.con_dbid, 0, bp.dbid, bp.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_BUFFER_POOL_STATISTICS bp
  where     sn.snap_id         = bp.snap_id
        and sn.dbid            = bp.dbid
        and sn.instance_number = bp.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_BUFFER_POOL_STAT"  IS 'Buffer Pool Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CAPTURE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CAPTURE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CAPTURE_NAME", "STARTUP_TIME", "LAG", "TOTAL_MESSAGES_CAPTURED", "TOTAL_MESSAGES_ENQUEUED", "ELAPSED_RULE_TIME", "ELAPSED_ENQUEUE_TIME", "ELAPSED_REDO_WAIT_TIME", "ELAPSED_PAUSE_TIME", "CON_DBID", "EXTRACT_NAME", "BYTES_REDO_MINED", "BYTES_SENT", "SESSION_MODULE", "CON_ID") AS 
  select cs.snap_id, cs.dbid, cs.instance_number, cs.capture_name,
       cs.startup_time, cs.lag,
       cs.total_messages_captured, cs.total_messages_enqueued,
       cs.elapsed_rule_time, cs.elapsed_enqueue_time,
       cs.elapsed_redo_wait_time, cs.elapsed_pause_time,
       decode(cs.con_dbid, 0, cs.dbid, cs.con_dbid),
       cs.extract_name,
       cs.bytes_redo_mined, cs.bytes_sent, cs.session_module,
       decode(cs.per_pdb, 0, 0,
         con_dbid_to_id(decode(cs.con_dbid, 0, cs.dbid, cs.con_dbid))) con_id
  from wrh$_streams_capture cs, AWR_CDB_SNAPSHOT sn
  where sn.snap_id              = cs.snap_id
        and sn.dbid             = cs.dbid
        and sn.instance_number  = cs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CAPTURE"  IS 'Streams/GoldenGate/XStream Capture Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_CONFIG
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_CONFIG"  CONTAINER_DATA 
 ("DBID", "CURRENT_SNAP_ID", "CELLNAME", "CELLHASH", "CONFTYPE", "CONFVAL_HASH", "CONFVAL", "CON_DBID", "CON_ID") AS 
  select dbid, CURRENT_SNAP_ID,
       CELLNAME, CELLHASH, CONFTYPE, CONFVAL_HASH, CONFVAL,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_CELL_CONFIG;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_CONFIG"  IS 'Exadata configuration information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_CONFIG_DETAIL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_CONFIG_DETAIL"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "CELLNAME", "CELLHASH", "CONFTYPE", "CONFVAL_HASH", "CONFVAL", "CON_DBID", "CON_ID") AS 
  select d.snap_id, d.dbid,
       c.CELLNAME, d.CELLHASH, d.CONFTYPE, d.CONFVAL_HASH, c.CONFVAL,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid),
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
  from WRH$_CELL_CONFIG c,
       WRH$_CELL_CONFIG_DETAIL d
 where c.dbid = d.dbid
   and c.cellhash = d.cellhash
   and c.conftype = d.conftype
   and c.confval_hash = d.confval_hash;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_CONFIG_DETAIL"  IS 'Exadata configuration information per snapshot'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_DB
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_DB"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "SRC_DBID", "SRC_DBNAME", "DISK_REQUESTS", "DISK_BYTES", "FLASH_REQUESTS", "FLASH_BYTES", "DISK_SMALL_IO_REQS", "DISK_LARGE_IO_REQS", "FLASH_SMALL_IO_REQS", "FLASH_LARGE_IO_REQS", "DISK_SMALL_IO_SERVICE_TIME", "DISK_SMALL_IO_QUEUE_TIME", "DISK_LARGE_IO_SERVICE_TIME", "DISK_LARGE_IO_QUEUE_TIME", "FLASH_SMALL_IO_SERVICE_TIME", "FLASH_SMALL_IO_QUEUE_TIME", "FLASH_LARGE_IO_SERVICE_TIME", "FLASH_LARGE_IO_QUEUE_TIME", "IS_CURRENT_SRC_DB", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.cell_hash, s.incarnation_num,
       s.src_dbid, s.src_dbname,
       s.disk_requests, s.disk_bytes, s.flash_requests, s.flash_bytes,
       s.disk_small_io_reqs, s.disk_large_io_reqs,
       s.flash_small_io_reqs, s.flash_large_io_reqs,
       s.disk_small_io_service_time, s. disk_small_io_queue_time,
       s.disk_large_io_service_time, s.disk_large_io_queue_time,
       s.flash_small_io_service_time, s. flash_small_io_queue_time,
       s.flash_large_io_service_time, s.flash_large_io_queue_time,
       s.is_current_src_db,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from WRH$_CELL_DB s,
    (select distinct snap_id, dbid
       from AWR_CDB_SNAPSHOT) sn
where  s.snap_id          = sn.snap_id
  and  s.dbid             = sn.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_DB"  IS 'Cell Database IO Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_DISK_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_DISK_NAME"  CONTAINER_DATA 
 ("DBID", "SNAP_ID", "CELL_HASH", "DISK_ID", "DISK_NAME", "DISK", "CON_DBID", "CON_ID") AS 
  select dbid,
       snap_id,
       cell_hash,
       to_number(substr(id,length(id)-8+1),'XXXXXXXX') disk_id,
       disk_name,
       disk,
       decode(con_dbid, 0, dbid, con_dbid) con_dbid,
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from (
    select d.dbid, d.con_dbid,
           d.snap_id, d.per_pdb,
           d.cellhash cell_hash,
           extractvalue(value(t),'/celldisk/id') id,
           extractvalue(value(t),'/celldisk/name') disk_name,
           extractvalue(value(t),'/celldisk/diskType') disk
      from wrh$_cell_config_detail d,
           wrh$_cell_config c,
           table(xmlsequence(extract(xmltype(c.confval),
                                    '/cli-output/celldisk'))) t
     where d.dbid = c.dbid
       and d.cellhash = c.cellhash
       and d.conftype = c.conftype
       and d.confval_hash = c.confval_hash
       and c.conftype = 'CELLDISK');

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_DISK_NAME"  IS 'Exadata Cell disk names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_DISK_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_DISK_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "DISK_ID", "NUM_SAMPLES", "DISK_UTILIZATION_SUM", "READS_SUM", "READ_MB_SUM", "WRITES_SUM", "WRITE_MB_SUM", "IO_REQUESTS_SUM", "IO_MB_SUM", "SERVICE_TIME_SUM", "WAIT_TIME_SUM", "SMALL_READS_SUM", "SMALL_WRITES_SUM", "LARGE_READS_SUM", "LARGE_WRITES_SUM", "SMALL_READ_BYTES_SUM", "SMALL_WRITE_BYTES_SUM", "LARGE_READ_BYTES_SUM", "LARGE_WRITE_BYTES_SUM", "SMALL_READ_LATENCY_SUM", "SMALL_WRITE_LATENCY_SUM", "LARGE_READ_LATENCY_SUM", "LARGE_WRITE_LATENCY_SUM", "APP_IO_REQUESTS_SUM", "APP_IO_BYTES_SUM", "APP_IO_LATENCY_SUM", "DISK_UTILIZATION_SUMX2", "READS_SUMX2", "READ_MB_SUMX2", "WRITES_SUMX2", "WRITE_MB_SUMX2", "IO_REQUESTS_SUMX2", "IO_MB_SUMX2", "SERVICE_TIME_SUMX2", "WAIT_TIME_SUMX2", "SMALL_READS_SUMX2", "SMALL_WRITES_SUMX2", "LARGE_READS_SUMX2", "LARGE_WRITES_SUMX2", "SMALL_READ_BYTES_SUMX2", "SMALL_WRITE_BYTES_SUMX2", "LARGE_READ_BYTES_SUMX2", "LARGE_WRITE_BYTES_SUMX2", "SMALL_READ_LATENCY_SUMX2", "SMALL_WRITE_LATENCY_SUMX2", "LARGE_READ_LATENCY_SUMX2", "LARGE_WRITE_LATENCY_SUMX2", "APP_IO_REQUESTS_SUMX2", "APP_IO_BYTES_SUMX2", "APP_IO_LATENCY_SUMX2", "DISK_UTILIZATION_AVG", "READS_AVG", "READ_MB_AVG", "WRITES_AVG", "WRITE_MB_AVG", "IO_REQUESTS_AVG", "IO_MB_AVG", "SERVICE_TIME_AVG", "SMALL_READS_AVG", "SMALL_WRITES_AVG", "LARGE_READS_AVG", "LARGE_WRITES_AVG", "SMALL_READ_BYTES_AVG", "SMALL_WRITE_BYTES_AVG", "LARGE_READ_BYTES_AVG", "LARGE_WRITE_BYTES_AVG", "SMALL_READ_LATENCY_AVG", "SMALL_WRITE_LATENCY_AVG", "LARGE_READ_LATENCY_AVG", "LARGE_WRITE_LATENCY_AVG", "APP_IO_REQUESTS_AVG", "APP_IO_BYTES_AVG", "APP_IO_LATENCY_AVG", "CON_DBID", "CON_ID") AS 
  select cd.snap_id, cd.dbid, cd.cell_hash, cd.incarnation_num,
       cd.disk_id disk_id,
       num_samples,
       disk_utilization_sum,
       reads_sum, read_mb_sum, writes_sum, write_mb_sum,
       io_requests_sum, io_mb_sum,
       service_time_sum,wait_time_sum,
       small_reads_sum,small_writes_sum,large_reads_sum,large_writes_sum,
       small_read_bytes_sum,small_write_bytes_sum,
       large_read_bytes_sum,large_write_bytes_sum,
       small_read_latency_sum, small_write_latency_sum,
       large_read_latency_sum, large_write_latency_sum,
       app_io_requests_sum, app_io_bytes_sum, app_io_latency_sum,
       disk_utilization_sumx2,
       reads_sumx2, read_mb_sumx2, writes_sumx2, write_mb_sumx2,
       io_requests_sumx2, io_mb_sumx2,
       service_time_sumx2,wait_time_sumx2,
       small_reads_sumx2,small_writes_sumx2,
       large_reads_sumx2,large_writes_sumx2,
       small_read_bytes_sumx2,small_write_bytes_sumx2,
       large_read_bytes_sumx2,large_write_bytes_sumx2,
       small_read_latency_sumx2, small_write_latency_sumx2,
       large_read_latency_sumx2, large_write_latency_sumx2,
       app_io_requests_sumx2, app_io_bytes_sumx2, app_io_latency_sumx2,
       disk_utilization_sum/num_samples disk_utilization_avg,
       reads_sum/num_samples      reads_avg,
       read_mb_sum/num_samples    read_mb_avg,
       writes_sum/num_samples     writes_avg,
       write_mb_sum/num_samples   write_mb_avg,
       io_requests_sum/num_samples         io_requests_avg,
       io_mb_sum/num_samples      io_mb_avg,
       service_time_sum/num_samples service_time_avg,
       small_reads_sum/num_samples      small_reads_avg,
       small_writes_sum/num_samples     small_writes_avg,
       large_reads_sum/num_samples      large_reads_avg,
       large_writes_sum/num_samples     large_writes_avg,
       small_read_bytes_sum/num_samples   small_read_bytes_avg,
       small_write_bytes_sum/num_samples  small_write_bytes_avg,
       large_read_bytes_sum/num_samples   large_read_bytes_avg,
       large_write_bytes_sum/num_samples  large_write_bytes_avg,
       small_read_latency_sum/num_samples small_read_latency_avg,
       small_write_latency_sum/num_samples small_write_latency_avg,
       large_read_latency_sum/num_samples  large_read_latency_avg,
       large_write_latency_sum/num_samples large_write_latency_avg,
       app_io_requests_sum/num_samples app_io_requests_avg,
       app_io_bytes_sum/num_samples   app_io_bytes_avg,
       app_io_latency_sum/num_samples app_io_latency_avg,
       decode(cd.con_dbid, 0, cd.dbid, cd.con_dbid),
       decode(cd.per_pdb, 0, 0,
         con_dbid_to_id(decode(cd.con_dbid, 0, cd.dbid, cd.con_dbid))) con_id
  from wrh$_cell_disk_summary cd,
      (select distinct snap_id, dbid
         from AWR_CDB_SNAPSHOT)  sn
  where     sn.snap_id          = cd.snap_id
        and sn.dbid             = cd.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_DISK_SUMMARY"  IS 'Cell Disk Summary Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_DISKTYPE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_DISKTYPE"  CONTAINER_DATA 
 ("DBID", "SNAP_ID", "CELL_HASH", "CELL_NAME", "HARD_DISK_TYPE", "FLASH_DISK_TYPE", "NUM_CELL_DISKS", "NUM_GRID_DISKS", "NUM_HARD_DISKS", "NUM_FLASH_DISKS", "MAX_DISK_IOPS", "MAX_FLASH_IOPS", "MAX_DISK_MBPS", "MAX_FLASH_MBPS", "MAX_CELL_DISK_IOPS", "MAX_CELL_FLASH_IOPS", "MAX_CELL_DISK_MBPS", "MAX_CELL_FLASH_MBPS", "CONFVAL", "CON_DBID", "CON_ID") AS 
  select d.dbid,
       d.snap_id,
       c.cellhash cell_hash,
       extractvalue(xmltype(c.confval),'/cli-output/context/@cell') cell_name,
       extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/hardDiskType') hard_disk_type,
       extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/flashDiskType') flash_disk_type,
       to_number(extractvalue(xmltype(c.confval),
                   '/cli-output/not-set/numCellDisks'))  num_cell_disks,
       to_number(extractvalue(xmltype(c.confval),
                   '/cli-output/not-set/numGridDisks'))  num_grid_disks,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numHardDisks'))  num_hard_disks,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numFlashDisks'))  num_flash_disks,
       to_number(
         extractvalue(xmltype(c.confval),'/cli-output/not-set/maxPDIOPS'))
                                                            max_disk_iops,
       to_number(
         extractvalue(xmltype(c.confval),'/cli-output/not-set/maxFDIOPS'))
                                                           max_flash_iops,
       to_number(
         extractvalue(xmltype(c.confval),'/cli-output/not-set/maxPDMBPS'))
                                                           max_disk_mbps,
       to_number(
         extractvalue(xmltype(c.confval),'/cli-output/not-set/maxFDMBPS'))
                                                         max_flash_mbps,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numHardDisks')) *
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/maxPDIOPS'))  max_cell_disk_iops,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numFlashDisks')) *
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/maxFDIOPS'))  max_cell_flash_iops,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numHardDisks')) *
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/maxPDMBPS'))  max_cell_disk_mbps,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numFlashDisks')) *
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/maxFDMBPS'))  max_cell_flash_mbps,
       c.confval,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid) con_dbid,
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
  from wrh$_cell_config_detail d,
       wrh$_cell_config c
 where d.dbid = c.dbid
   and d.cellhash = c.cellhash
   and d.conftype = c.conftype
   and d.confval_hash = c.confval_hash
   and c.conftype = 'AWRXML';

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_DISKTYPE"  IS 'Exadata Cell disk types'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_GLOBAL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_GLOBAL"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "METRIC_ID", "METRIC_NAME", "METRIC_VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.cell_hash, s.incarnation_num,
       s.metric_id, nm.metric_name, s.metric_value,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from WRH$_CELL_GLOBAL s,
     WRH$_CELL_METRIC_DESC nm,
    (select distinct snap_id, dbid
       from AWR_CDB_SNAPSHOT) sn
where      s.metric_id        = nm.metric_id
      and  s.dbid             = nm.dbid
      and  s.snap_id          = sn.snap_id
      and  s.dbid             = sn.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_GLOBAL"  IS 'Cell Global Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_GLOBAL_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_GLOBAL_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "NUM_SAMPLES", "CPU_USAGE_SUM", "SYS_USAGE_SUM", "USER_USAGE_SUM", "NETWORK_BYTES_RECD_SUM", "NETWORK_BYTES_SENT_SUM", "CPU_USAGE_SUMX2", "SYS_USAGE_SUMX2", "USER_USAGE_SUMX2", "NETWORK_BYTES_RECD_SUMX2", "NETWORK_BYTES_SENT_SUMX2", "CPU_USAGE_AVG", "SYS_USAGE_AVG", "USER_USAGE_AVG", "NETWORK_BYTES_RECD_AVG", "NETWORK_BYTES_SENT_AVG", "CON_DBID", "CON_ID") AS 
  select cg.snap_id, cg.dbid, cg.cell_hash, cg.incarnation_num,
       num_samples,
       cpu_usage_sum, sys_usage_sum, user_usage_sum,
       network_bytes_recd_sum, network_bytes_sent_sum,
       cpu_usage_sumx2, sys_usage_sumx2, user_usage_sumx2,
       network_bytes_recd_sumx2, network_bytes_sent_sumx2,
       cpu_usage_sum/num_samples cpu_usage_avg,
       sys_usage_sum/num_samples sys_usage_avg,
       user_usage_sum/num_samples user_usage_avg,
       network_bytes_recd_sum/num_samples network_bytes_recd_avg,
       network_bytes_sent_sum/num_samples network_bytes_sent_avg,
       decode(cg.con_dbid, 0, cg.dbid, cg.con_dbid),
       decode(cg.per_pdb, 0, 0,
         con_dbid_to_id(decode(cg.con_dbid, 0, cg.dbid, cg.con_dbid))) con_id
  from wrh$_cell_global_summary cg,
      (select distinct snap_id, dbid
         from AWR_CDB_SNAPSHOT)  sn
  where     sn.snap_id          = cg.snap_id
        and sn.dbid             = cg.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_GLOBAL_SUMMARY"  IS 'Cell Global Summary Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_IOREASON
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_IOREASON"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "REASON_ID", "REASON_NAME", "REQUESTS", "BYTES", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.cell_hash, s.incarnation_num,
       s.reason_id, nm.reason_name, s.requests, s.bytes,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from WRH$_CELL_IOREASON s,
     WRH$_CELL_IOREASON_NAME nm,
    (select distinct snap_id, dbid
       from AWR_CDB_SNAPSHOT) sn
where      s.reason_id        = nm.reason_id
      and  s.dbid             = nm.dbid
      and  s.snap_id          = sn.snap_id
      and  s.dbid             = sn.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_IOREASON"  IS 'Cell IO Reason Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_IOREASON_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_IOREASON_NAME"  CONTAINER_DATA 
 ("DBID", "REASON_ID", "REASON_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, reason_id, reason_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_CELL_IOREASON_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_IOREASON_NAME"  IS 'Cell IO Reason Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_METRIC_DESC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_METRIC_DESC"  CONTAINER_DATA 
 ("DBID", "METRIC_ID", "METRIC_NAME", "METRIC_TYPE", "CON_DBID", "CON_ID") AS 
  select dbid, metric_id, metric_name, metric_type,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_CELL_METRIC_DESC;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_METRIC_DESC"  IS 'Cell Metric Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_NAME"  CONTAINER_DATA 
 ("DBID", "SNAP_ID", "CELL_HASH", "CELL_NAME", "CON_DBID", "CON_ID") AS 
  select d.dbid,
       d.snap_id,
       c.cellhash cell_hash,
       extractvalue(xmltype(c.confval),'/cli-output/cell/name') cell_name,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid) con_dbid,
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
  from wrh$_cell_config_detail d,
       wrh$_cell_config c
 where d.dbid = c.dbid
   and d.cellhash = c.cellhash
   and d.conftype = c.conftype
   and d.confval_hash = c.confval_hash
   and c.conftype = 'CELL';

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_NAME"  IS 'Exadata Cell names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CELL_OPEN_ALERTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CELL_OPEN_ALERTS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "CELL_HASH", "BEGIN_TIME", "SEQ_NO", "MESSAGE", "STATEFUL", "SEVERITY", "CELL_ALERT_SUMMARY", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.cell_hash,
       s.begin_time, s.seq_no, s.message,
       decode(s.stateful,1,'Y','N') stateful,
       s.severity,
       s.cell_alert_summary,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from WRH$_CELL_OPEN_ALERTS s,
    (select distinct snap_id, dbid
       from AWR_CDB_SNAPSHOT) sn
where  s.snap_id          = sn.snap_id
  and  s.dbid             = sn.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_CELL_OPEN_ALERTS"  IS 'Cell Open Alerts Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CHANNEL_WAITS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CHANNEL_WAITS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CHANNEL", "MESSAGES_PUBLISHED", "WAIT_COUNT", "WAIT_TIME_USEC", "CON_DBID", "CON_ID") AS 
  select cw.snap_id, cw.dbid, cw.instance_number,
       channel, messages_published, wait_count, wait_time_usec,
       decode(cw.con_dbid, 0, cw.dbid, cw.con_dbid),
       decode(cw.per_pdb, 0, 0,
         con_dbid_to_id(decode(cw.con_dbid, 0, cw.dbid, cw.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_CHANNEL_WAITS cw
  where     sn.snap_id         = cw.snap_id
        and sn.dbid            = cw.dbid
        and sn.instance_number = cw.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CHANNEL_WAITS"  IS 'Channel Waits Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CLUSTER_INTERCON
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CLUSTER_INTERCON"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "IP_ADDRESS", "IS_PUBLIC", "SOURCE", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  ci.name,
  case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' then ci.ip_address else null end ip_address, -- Use macro to mask sensitive column
  ci.is_public, ci.source,
  decode(ci.con_dbid, 0, ci.dbid, ci.con_dbid),
  decode(ci.per_pdb, 0, 0,
    con_dbid_to_id(decode(ci.con_dbid, 0, ci.dbid, ci.con_dbid))) con_id
 from AWR_CDB_SNAPSHOT sn, WRH$_CLUSTER_INTERCON ci
 where     sn.snap_id         = ci.snap_id
       and sn.dbid            = ci.dbid
       and sn.instance_number = ci.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CLUSTER_INTERCON"  IS 'Cluster Interconnect Historical Stats'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_COLORED_SQL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_COLORED_SQL"  CONTAINER_DATA 
 ("DBID", "SQL_ID", "CREATE_TIME", "CON_ID") AS 
  select dbid, sql_id, create_time,
          decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from wrm$_colored_sql where owner = 1;

   COMMENT ON TABLE "SYS"."AWR_CDB_COLORED_SQL"  IS 'Marked SQLs for snapshots'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_COMP_IOSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_COMP_IOSTAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "COMPONENT", "FILE_TYPE", "IO_TYPE", "OPERATION", "BYTES", "IO_COUNT", "CON_DBID", "CON_ID") AS 
  select io.snap_id, io.dbid, io.instance_number, io.component,
       io.file_type, io.io_type, io.operation, io.bytes, io.io_count,
       decode(io.con_dbid, 0, io.dbid, io.con_dbid),
       decode(io.per_pdb, 0, 0,
         con_dbid_to_id(decode(io.con_dbid, 0, io.dbid, io.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_COMP_IOSTAT io
  where     sn.snap_id         = io.snap_id
        and sn.dbid            = io.dbid
        and sn.instance_number = io.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_COMP_IOSTAT"  IS 'I/O stats aggregated on component level'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CON_SYSMETRIC_HIST
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CON_SYSMETRIC_HIST"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "METRIC_ID", "METRIC_NAME", "VALUE", "METRIC_UNIT", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number,
       begin_time, end_time, intsize,
       m.group_id, m.metric_id, mn.metric_name, value, mn.metric_unit,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid)) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_CON_SYSMETRIC_HISTORY m, WRH$_METRIC_NAME mn
where       m.group_id       = mn.group_id
      and   m.metric_id      = mn.metric_id
      and   m.dbid           = mn.dbid
      and   sn.snap_id       = m.snap_id
      and sn.dbid            = m.dbid
      and sn.instance_number = m.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CON_SYSMETRIC_HIST"  IS 'PDB System Metrics History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CON_SYSMETRIC_SUMM
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CON_SYSMETRIC_SUMM"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "METRIC_ID", "METRIC_NAME", "METRIC_UNIT", "NUM_INTERVAL", "MINVAL", "MAXVAL", "AVERAGE", "STANDARD_DEVIATION", "SUM_SQUARES", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number,
       begin_time, end_time, intsize,
       m.group_id, m.metric_id, mn.metric_name, mn.metric_unit,
       num_interval, minval, maxval, average, standard_deviation, sum_squares,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid)) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_CON_SYSMETRIC_SUMMARY m, WRH$_METRIC_NAME mn
  where     m.group_id         = mn.group_id
        and m.metric_id        = mn.metric_id
        and m.dbid             = mn.dbid
        and sn.snap_id         = m.snap_id
        and sn.dbid            = m.dbid
        and sn.instance_number = m.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CON_SYSMETRIC_SUMM"  IS 'PDB System Metrics Summary'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CON_SYSSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CON_SYSSTAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select /*+ leading(sn s nm) use_hash(sn s) */
       s.snap_id, s.dbid, s.instance_number,
       s.stat_id, nm.stat_name, s.value, s.con_dbid,
       con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid)) con_id
from WRH$_CON_SYSSTAT s, WRH$_STAT_NAME nm
where      s.stat_id          = nm.stat_id
      and  s.dbid             = nm.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_CON_SYSSTAT"  IS 'System Historical Statistics Information Per PDB'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CON_SYSTEM_EVENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CON_SYSTEM_EVENT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EVENT_ID", "EVENT_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "TOTAL_WAITS", "TOTAL_TIMEOUTS", "TIME_WAITED_MICRO", "TOTAL_WAITS_FG", "TOTAL_TIMEOUTS_FG", "TIME_WAITED_MICRO_FG", "CON_DBID", "CON_ID") AS 
  select e.snap_id, e.dbid, e.instance_number,
       e.event_id, en.event_name, en.wait_class_id, en.wait_class,
       total_waits, total_timeouts, time_waited_micro,
       total_waits_fg, total_timeouts_fg, time_waited_micro_fg,
       e.con_dbid,
       con_dbid_to_id(decode(e.con_dbid, 0, e.dbid, e.con_dbid)) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_CON_SYSTEM_EVENT e, WRH$_EVENT_NAME en
where     e.event_id         = en.event_id
      and e.dbid             = en.dbid
      and e.snap_id          = sn.snap_id
      and e.dbid             = sn.dbid
      and e.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CON_SYSTEM_EVENT"  IS 'System Event Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CON_SYS_TIME_MODEL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CON_SYS_TIME_MODEL"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.instance_number, s.stat_id,
       nm.stat_name, value,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid)) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_CON_SYS_TIME_MODEL s, WRH$_STAT_NAME nm
where      s.stat_id          = nm.stat_id
      and  s.dbid             = nm.dbid
      and  s.snap_id          = sn.snap_id
      and  s.dbid             = sn.dbid
      and  s.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CON_SYS_TIME_MODEL"  IS 'PDB System Time Model Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CR_BLOCK_SERVER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CR_BLOCK_SERVER"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CR_REQUESTS", "CURRENT_REQUESTS", "DATA_REQUESTS", "UNDO_REQUESTS", "TX_REQUESTS", "CURRENT_RESULTS", "PRIVATE_RESULTS", "ZERO_RESULTS", "DISK_READ_RESULTS", "FAIL_RESULTS", "FAIRNESS_DOWN_CONVERTS", "FLUSHES", "BUILDS", "LIGHT_WORKS", "ERRORS", "CON_DBID", "CON_ID") AS 
  select crb.snap_id, crb.dbid, crb.instance_number,
       cr_requests, current_requests,
       data_requests, undo_requests, tx_requests,
       current_results, private_results, zero_results,
       disk_read_results, fail_results,
       fairness_down_converts, flushes, builds,
       light_works, errors,
       decode(crb.con_dbid, 0, crb.dbid, crb.con_dbid),
       decode(crb.per_pdb, 0, 0,
         con_dbid_to_id(decode(crb.con_dbid, 0, crb.dbid, crb.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_CR_BLOCK_SERVER crb
  where     sn.snap_id         = crb.snap_id
        and sn.dbid            = crb.dbid
        and sn.instance_number = crb.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CR_BLOCK_SERVER"  IS 'Consistent Read Block Server Historical Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_CURRENT_BLOCK_SERVER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_CURRENT_BLOCK_SERVER"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PIN0", "PIN1", "PIN10", "PIN100", "PIN1000", "PIN10000", "FLUSH0", "FLUSH1", "FLUSH10", "FLUSH100", "FLUSH1000", "FLUSH10000", "CON_DBID", "CON_ID") AS 
  select cub.snap_id, cub.dbid, cub.instance_number,
       pin0,   pin1,   pin10,   pin100,   pin1000,   pin10000,
       flush0, flush1, flush10, flush100, flush1000, flush10000,
       decode(cub.con_dbid, 0, cub.dbid, cub.con_dbid),
       decode(cub.per_pdb, 0, 0,
         con_dbid_to_id(decode(cub.con_dbid, 0, cub.dbid, cub.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_CURRENT_BLOCK_SERVER cub
  where     sn.snap_id         = cub.snap_id
        and sn.dbid            = cub.dbid
        and sn.instance_number = cub.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_CURRENT_BLOCK_SERVER"  IS 'Current Block Server Historical Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_DATABASE_INSTANCE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_DATABASE_INSTANCE"  CONTAINER_DATA 
 ("DBID", "INSTANCE_NUMBER", "STARTUP_TIME", "PARALLEL", "VERSION", "DB_NAME", "INSTANCE_NAME", "HOST_NAME", "LAST_ASH_SAMPLE_ID", "PLATFORM_NAME", "CDB", "EDITION", "DB_UNIQUE_NAME", "DATABASE_ROLE", "CDB_ROOT_DBID", "CON_ID", "STARTUP_TIME_TZ") AS 
  select dbid, instance_number, startup_time, parallel, version,
       db_name, instance_name,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' then host_name else null end host_name, -- Use macro to mask sensitive column
       last_ash_sample_id,
       platform_name, cdb, edition, db_unique_name,
       database_role, cdb_root_dbid,
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id,
       startup_time_tz
from WRM$_DATABASE_INSTANCE;

   COMMENT ON TABLE "SYS"."AWR_CDB_DATABASE_INSTANCE"  IS 'Database Instance Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_DATAFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_DATAFILE"  CONTAINER_DATA 
 ("DBID", "FILE#", "CREATION_CHANGE#", "FILENAME", "TS#", "TSNAME", "BLOCK_SIZE", "CON_DBID", "CON_ID") AS 
  select d.dbid, d.file#, d.creation_change#,
       d.filename, d.ts#, coalesce(t.tsname, d.tsname) tsname, d.block_size,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid),
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
from WRH$_DATAFILE d LEFT OUTER JOIN WRH$_TABLESPACE t
     on (d.dbid = t.dbid
         and d.ts# = t.ts#
         and d.con_dbid = t.con_dbid);

   COMMENT ON TABLE "SYS"."AWR_CDB_DATAFILE"  IS 'Names of Datafiles'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_DB_CACHE_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_DB_CACHE_ADVICE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BPID", "BUFFERS_FOR_ESTIMATE", "NAME", "BLOCK_SIZE", "ADVICE_STATUS", "SIZE_FOR_ESTIMATE", "SIZE_FACTOR", "PHYSICAL_READS", "BASE_PHYSICAL_READS", "ACTUAL_PHYSICAL_READS", "ESTD_PHYSICAL_READ_TIME", "CON_DBID", "CON_ID") AS 
  select db.snap_id, db.dbid, db.instance_number,
       bpid, buffers_for_estimate,
       name, block_size, advice_status, size_for_estimate,
       size_factor, physical_reads, base_physical_reads,
       actual_physical_reads, estd_physical_read_time,
       decode(db.con_dbid, 0, db.dbid, db.con_dbid),
       decode(db.per_pdb, 0, 0,
         con_dbid_to_id(decode(db.con_dbid, 0, db.dbid, db.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_DB_CACHE_ADVICE db
where      db.snap_id          = sn.snap_id
      and  db.dbid             = sn.dbid
      and  db.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_DB_CACHE_ADVICE"  IS 'DB Cache Advice History Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_DISPATCHER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_DISPATCHER"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "SERIAL#", "IDLE", "BUSY", "WAIT", "TOTALQ", "SAMPLED_TOTAL_CONN", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  d.name, d.serial#, d.idle, d.busy, d.wait, d.totalq, d.sampled_total_conn,
  decode(d.con_dbid, 0, d.dbid, d.con_dbid),
  decode(d.per_pdb, 0, 0,
    con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_DISPATCHER d
where     sn.snap_id         = d.snap_id
      and sn.dbid            = d.dbid
      and sn.instance_number = d.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_DISPATCHER"  IS 'Dispatcher statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_DLM_MISC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_DLM_MISC"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STATISTIC#", "NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select dlm.snap_id, dlm.dbid, dlm.instance_number,
       statistic#, name, value,
       decode(dlm.con_dbid, 0, dlm.dbid, dlm.con_dbid),
       decode(dlm.per_pdb, 0, 0,
         con_dbid_to_id(decode(dlm.con_dbid, 0, dlm.dbid, dlm.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_DLM_MISC dlm
  where     sn.snap_id         = dlm.snap_id
        and sn.dbid            = dlm.dbid
        and sn.instance_number = dlm.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_DLM_MISC"  IS 'Distributed Lock Manager Miscellaneous Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_DYN_REMASTER_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_DYN_REMASTER_STATS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "REMASTER_TYPE", "REMASTER_OPS", "REMASTER_TIME", "REMASTERED_OBJECTS", "QUIESCE_TIME", "FREEZE_TIME", "CLEANUP_TIME", "REPLAY_TIME", "FIXWRITE_TIME", "SYNC_TIME", "RESOURCES_CLEANED", "REPLAYED_LOCKS_SENT", "REPLAYED_LOCKS_RECEIVED", "CURRENT_OBJECTS", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
   s.remaster_type, s.remaster_ops, s.remaster_time, s.remastered_objects,
   s.quiesce_time, s.freeze_time, s.cleanup_time,
   s.replay_time, s.fixwrite_time, s.sync_time,
   s.resources_cleaned, s.replayed_locks_sent,
   s.replayed_locks_received, s.current_objects,
   decode(s.con_dbid, 0, s.dbid, s.con_dbid),
   decode(s.per_pdb, 0, 0,
     con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_DYN_REMASTER_STATS s
where     sn.snap_id         = s.snap_id
      and sn.dbid            = s.dbid
      and sn.instance_number = s.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_DYN_REMASTER_STATS"  IS 'Dynamic remastering statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_ENQUEUE_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_ENQUEUE_STAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EQ_TYPE", "REQ_REASON", "TOTAL_REQ#", "TOTAL_WAIT#", "SUCC_REQ#", "FAILED_REQ#", "CUM_WAIT_TIME", "EVENT#", "CON_DBID", "CON_ID") AS 
  select eq.snap_id, eq.dbid, eq.instance_number,
       eq_type, req_reason, total_req#,
       total_wait#, succ_req#, failed_req#, cum_wait_time, event#,
       decode(eq.con_dbid, 0, eq.dbid, eq.con_dbid),
       decode(eq.per_pdb, 0, 0,
         con_dbid_to_id(decode(eq.con_dbid, 0, eq.dbid, eq.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_ENQUEUE_STAT eq
  where     sn.snap_id         = eq.snap_id
        and sn.dbid            = eq.dbid
        and sn.instance_number = eq.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_ENQUEUE_STAT"  IS 'Enqueue Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_EVENT_HISTOGRAM
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_EVENT_HISTOGRAM"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EVENT_ID", "EVENT_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "WAIT_TIME_MILLI", "WAIT_COUNT", "CON_DBID", "CON_ID") AS 
  select e.snap_id, e.dbid, e.instance_number,
       e.event_id, en.event_name, en.wait_class_id, en.wait_class,
       e.wait_time_milli, e.wait_count,
       decode(e.con_dbid, 0, e.dbid, e.con_dbid),
       decode(e.per_pdb, 0, 0,
         con_dbid_to_id(decode(e.con_dbid, 0, e.dbid, e.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_EVENT_HISTOGRAM e, WRH$_EVENT_NAME en
where     e.event_id         = en.event_id
      and e.dbid             = en.dbid
      and e.snap_id          = sn.snap_id
      and e.dbid             = sn.dbid
      and e.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_EVENT_HISTOGRAM"  IS 'Event Histogram Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_EVENT_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_EVENT_NAME"  CONTAINER_DATA 
 ("DBID", "EVENT_ID", "EVENT_NAME", "PARAMETER1", "PARAMETER2", "PARAMETER3", "WAIT_CLASS_ID", "WAIT_CLASS", "CON_DBID", "CON_ID") AS 
  select dbid, event_id, event_name, parameter1, parameter2, parameter3,
       wait_class_id, wait_class,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_EVENT_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_EVENT_NAME"  IS 'Event Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_FILEMETRIC_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_FILEMETRIC_HISTORY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FILEID", "CREATIONTIME", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "AVGREADTIME", "AVGWRITETIME", "PHYSICALREAD", "PHYSICALWRITE", "PHYBLKREAD", "PHYBLKWRITE", "CON_DBID", "CON_ID") AS 
  select fm.snap_id, fm.dbid, fm.instance_number,
       fileid, creationtime, begin_time,
       end_time, intsize, group_id, avgreadtime, avgwritetime,
       physicalread, physicalwrite, phyblkread, phyblkwrite,
       decode(fm.con_dbid, 0, fm.dbid, fm.con_dbid),
       decode(fm.per_pdb, 0, 0,
         con_dbid_to_id(decode(fm.con_dbid, 0, fm.dbid, fm.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_FILEMETRIC_HISTORY fm
  where     sn.snap_id         = fm.snap_id
        and sn.dbid            = fm.dbid
        and sn.instance_number = fm.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_FILEMETRIC_HISTORY"  IS 'File Metrics History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_FILESTATXS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_FILESTATXS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FILE#", "CREATION_CHANGE#", "FILENAME", "TS#", "TSNAME", "BLOCK_SIZE", "PHYRDS", "PHYWRTS", "SINGLEBLKRDS", "READTIM", "WRITETIM", "SINGLEBLKRDTIM", "PHYBLKRD", "PHYBLKWRT", "WAIT_COUNT", "TIME", "OPTIMIZED_PHYBLKRD", "CON_DBID", "CON_ID") AS 
  select f.snap_id, f.dbid, f.instance_number,
       f.file#, f.creation_change#, d.filename,
       d.ts#, coalesce(t.tsname, d.tsname) tsname, d.block_size,
       phyrds, phywrts, singleblkrds, readtim, writetim,
       singleblkrdtim, phyblkrd, phyblkwrt, wait_count, time,
       optimized_phyblkrd, decode(f.con_dbid, 0, f.dbid, f.con_dbid),
       decode(f.per_pdb, 0, 0,
         con_dbid_to_id(decode(f.con_dbid, 0, f.dbid, f.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_FILESTATXS f, WRH$_DATAFILE d, WRH$_TABLESPACE t
where      f.dbid             = d.dbid
      and  f.file#            = d.file#
      and  f.creation_change# = d.creation_change#
      and  f.snap_id          = sn.snap_id
      and  f.dbid             = sn.dbid
      and  f.instance_number  = sn.instance_number
      and  f.con_dbid         = d.con_dbid
      and  d.dbid             = t.dbid(+)
      and  d.ts#              = t.ts#(+)
      and  d.con_dbid         = t.con_dbid(+);

   COMMENT ON TABLE "SYS"."AWR_CDB_FILESTATXS"  IS 'Datafile Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IC_CLIENT_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IC_CLIENT_STATS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "BYTES_SENT", "BYTES_RECEIVED", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  t.name, t.bytes_sent, t.bytes_received,
  decode(t.con_dbid, 0, t.dbid, t.con_dbid),
  decode(t.per_pdb, 0, 0,
    con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid))) con_id
 from AWR_CDB_SNAPSHOT sn, WRH$_IC_CLIENT_STATS t
 where     sn.snap_id         = t.snap_id
       and sn.dbid            = t.dbid
       and sn.instance_number = t.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_IC_CLIENT_STATS"  IS 'Historical interconnect client statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IC_DEVICE_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IC_DEVICE_STATS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "IF_NAME", "IP_ADDR", "NET_MASK", "FLAGS", "MTU", "BYTES_RECEIVED", "PACKETS_RECEIVED", "RECEIVE_ERRORS", "RECEIVE_DROPPED", "RECEIVE_BUF_OR", "RECEIVE_FRAME_ERR", "BYTES_SENT", "PACKETS_SENT", "SEND_ERRORS", "SENDS_DROPPED", "SEND_BUF_OR", "SEND_CARRIER_LOST", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  t.if_name ,t.ip_addr ,t.net_mask ,t.flags ,t.mtu ,t.bytes_received,
  t.packets_received, t.receive_errors ,t.receive_dropped,
  t.receive_buf_or ,t.receive_frame_err, t.bytes_sent ,t.packets_sent,
  t.send_errors ,t.sends_dropped ,t.send_buf_or, t.send_carrier_lost,
  decode(t.con_dbid, 0, t.dbid, t.con_dbid),
  decode(t.per_pdb, 0, 0,
    con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid))) con_id
 from AWR_CDB_SNAPSHOT sn, WRH$_IC_DEVICE_STATS t
 where     sn.snap_id         = t.snap_id
       and sn.dbid            = t.dbid
       and sn.instance_number = t.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_IC_DEVICE_STATS"  IS 'Historical interconnect device statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IM_SEG_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IM_SEG_STAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TS#", "OBJ#", "DATAOBJ#", "MEMBYTES", "SCANS", "SCANS_DELTA", "DB_BLOCK_CHANGES", "DB_BLOCK_CHANGES_DELTA", "POPULATE_CUS", "POPULATE_CUS_DELTA", "REPOPULATE_CUS", "REPOPULATE_CUS_DELTA", "CON_DBID", "CON_ID") AS 
  select seg.snap_id, seg.dbid, seg.instance_number, ts#,
obj#, dataobj#, 0,
im_scans_total as scans, im_scans_delta as scans_delta,
im_db_block_changes_total as db_block_changes,
im_db_block_changes_delta as db_block_changes_delta,
populate_cus_total as populate_cus, populate_cus_delta,
repopulate_cus_total as repopulate_cus, repopulate_cus_delta,
decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid),
decode(seg.per_pdb, 0, 0,
       con_dbid_to_id(decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_SEG_STAT seg
where
        seg.snap_id         = sn.snap_id
    and seg.dbid            = sn.dbid
    and seg.instance_number = sn.instance_number
    and ((seg.im_scans_total > 0) or (seg.populate_cus_total > 0) or
         (seg.repopulate_cus_total > 0) or (seg.im_db_block_changes_total > 0))
union
select seg.snap_id, seg.dbid, seg.instance_number, ts#,
obj#, dataobj#, membytes,
scans, scans_delta,
db_block_changes,  db_block_changes_delta,
populate_cus, populate_cus_delta,
repopulate_cus, repopulate_cus_delta,
decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid),
decode(seg.per_pdb, 0, 0,
       con_dbid_to_id(decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_IM_SEG_STAT seg
where
        seg.snap_id         = sn.snap_id
    and seg.dbid            = sn.dbid
    and seg.instance_number = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_IM_SEG_STAT"  IS ' Historical IM Segment Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IM_SEG_STAT_OBJ
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IM_SEG_STAT_OBJ"  CONTAINER_DATA 
 ("DBID", "TS#", "OBJ#", "DATAOBJ#", "OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "OBJECT_TYPE", "TABLESPACE_NAME", "CON_DBID", "CON_ID") AS 
  select so.dbid, so.ts#, so.obj#, so.dataobj#, so.owner, so.object_name,
       so.subobject_name, so.object_type,
       coalesce(ts.tsname, tablespace_name) tablespace_name,
       decode(so.con_dbid, 0, so.dbid, so.con_dbid),
       decode(so.per_pdb, 0, 0,
         con_dbid_to_id(decode(so.con_dbid, 0, so.dbid, so.con_dbid))) con_id
from WRH$_IM_SEG_STAT_OBJ so LEFT OUTER JOIN WRH$_TABLESPACE ts
     on (so.dbid = ts.dbid
         and so.ts# = ts.ts#
         and so.con_dbid = ts.con_dbid)
union
select so.dbid, so.ts#, so.obj#, so.dataobj#, so.owner, so.object_name,
       so.subobject_name, so.object_type,
       coalesce(ts.tsname, tablespace_name) tablespace_name,
       decode(so.con_dbid, 0, so.dbid, so.con_dbid),
       decode(so.per_pdb, 0, 0,
         con_dbid_to_id(decode(so.con_dbid, 0, so.dbid, so.con_dbid))) con_id
from WRH$_SEG_STAT_OBJ so LEFT OUTER JOIN WRH$_TABLESPACE ts
     on (so.dbid = ts.dbid
         and so.ts# = ts.ts#
         and so.con_dbid = ts.con_dbid);

   COMMENT ON TABLE "SYS"."AWR_CDB_IM_SEG_STAT_OBJ"  IS 'IM Segment Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_INSTANCE_RECOVERY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_INSTANCE_RECOVERY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "RECOVERY_ESTIMATED_IOS", "ACTUAL_REDO_BLKS", "TARGET_REDO_BLKS", "LOG_FILE_SIZE_REDO_BLKS", "LOG_CHKPT_TIMEOUT_REDO_BLKS", "LOG_CHKPT_INTERVAL_REDO_BLKS", "FAST_START_IO_TARGET_REDO_BLKS", "TARGET_MTTR", "ESTIMATED_MTTR", "CKPT_BLOCK_WRITES", "OPTIMAL_LOGFILE_SIZE", "ESTD_CLUSTER_AVAILABLE_TIME", "WRITES_MTTR", "WRITES_LOGFILE_SIZE", "WRITES_LOG_CHECKPOINT_SETTINGS", "WRITES_OTHER_SETTINGS", "WRITES_AUTOTUNE", "WRITES_FULL_THREAD_CKPT", "CON_DBID", "CON_ID") AS 
  select ir.snap_id, ir.dbid, ir.instance_number, recovery_estimated_ios,
       actual_redo_blks, target_redo_blks, log_file_size_redo_blks,
       log_chkpt_timeout_redo_blks, log_chkpt_interval_redo_blks,
       fast_start_io_target_redo_blks, target_mttr, estimated_mttr,
       ckpt_block_writes, optimal_logfile_size, estd_cluster_available_time,
       writes_mttr, writes_logfile_size, writes_log_checkpoint_settings,
       writes_other_settings, writes_autotune, writes_full_thread_ckpt,
       decode(ir.con_dbid, 0, ir.dbid, ir.con_dbid),
       decode(ir.per_pdb, 0, 0,
         con_dbid_to_id(decode(ir.con_dbid, 0, ir.dbid, ir.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_INSTANCE_RECOVERY ir
  where     sn.snap_id         = ir.snap_id
        and sn.dbid            = ir.dbid
        and sn.instance_number = ir.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_INSTANCE_RECOVERY"  IS 'Instance Recovery Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_INST_CACHE_TRANSFER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_INST_CACHE_TRANSFER"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "INSTANCE", "CLASS", "CR_BLOCK", "CR_BUSY", "CR_CONGESTED", "CURRENT_BLOCK", "CURRENT_BUSY", "CURRENT_CONGESTED", "LOST", "CR_2HOP", "CR_3HOP", "CURRENT_2HOP", "CURRENT_3HOP", "CR_BLOCK_TIME", "CR_BUSY_TIME", "CR_CONGESTED_TIME", "CURRENT_BLOCK_TIME", "CURRENT_BUSY_TIME", "CURRENT_CONGESTED_TIME", "LOST_TIME", "CR_2HOP_TIME", "CR_3HOP_TIME", "CURRENT_2HOP_TIME", "CURRENT_3HOP_TIME", "CON_DBID", "CON_ID") AS 
  select ict.snap_id, ict.dbid, ict.instance_number,
       instance, class, cr_block, cr_busy, cr_congested,
       current_block, current_busy, current_congested
      ,lost ,cr_2hop ,cr_3hop ,current_2hop ,current_3hop
      ,cr_block_time ,cr_busy_time ,cr_congested_time ,current_block_time
      ,current_busy_time ,current_congested_time ,lost_time ,cr_2hop_time
      ,cr_3hop_time ,current_2hop_time ,current_3hop_time,
       decode(ict.con_dbid, 0, ict.dbid, ict.con_dbid),
       decode(ict.per_pdb, 0, 0,
         con_dbid_to_id(decode(ict.con_dbid, 0, ict.dbid, ict.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_INST_CACHE_TRANSFER ict
  where     sn.snap_id         = ict.snap_id
        and sn.dbid            = ict.dbid
        and sn.instance_number = ict.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_INST_CACHE_TRANSFER"  IS 'Instance Cache Transfer Historical Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_INTERCONNECT_PINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_INTERCONNECT_PINGS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TARGET_INSTANCE", "CNT_500B", "WAIT_500B", "WAITSQ_500B", "CNT_8K", "WAIT_8K", "WAITSQ_8K", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  t.target_instance, t.cnt_500b, t.wait_500b, t.waitsq_500b,
  t.cnt_8k, t.wait_8k, t.waitsq_8k,
  decode(t.con_dbid, 0, t.dbid, t.con_dbid),
  decode(t.per_pdb, 0, 0,
    con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid))) con_id
 from AWR_CDB_SNAPSHOT sn, WRH$_INTERCONNECT_PINGS t
 where     sn.snap_id         = t.snap_id
       and sn.dbid            = t.dbid
       and sn.instance_number = t.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_INTERCONNECT_PINGS"  IS 'Instance to instance ping stats'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IOSTAT_DETAIL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IOSTAT_DETAIL"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FUNCTION_ID", "FUNCTION_NAME", "FILETYPE_ID", "FILETYPE_NAME", "SMALL_READ_MEGABYTES", "SMALL_WRITE_MEGABYTES", "LARGE_READ_MEGABYTES", "LARGE_WRITE_MEGABYTES", "SMALL_READ_REQS", "SMALL_WRITE_REQS", "LARGE_READ_REQS", "LARGE_WRITE_REQS", "NUMBER_OF_WAITS", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select io.snap_id, io.dbid, io.instance_number,
       io.function_id, nmfn.function_name,
       io.filetype_id, nmft.filetype_name,
       io.small_read_megabytes, io.small_write_megabytes,
       io.large_read_megabytes, io.large_write_megabytes,
       io.small_read_reqs, io.small_write_reqs,
       io.large_read_reqs, io.large_write_reqs,
       io.number_of_waits, io.wait_time,
       decode(io.con_dbid, 0, io.dbid, io.con_dbid),
       decode(io.per_pdb, 0, 0,
         con_dbid_to_id(decode(io.con_dbid, 0, io.dbid, io.con_dbid))) con_id
  from  AWR_CDB_SNAPSHOT sn, WRH$_IOSTAT_DETAIL io,
        WRH$_IOSTAT_FUNCTION_NAME nmfn, WRH$_IOSTAT_FILETYPE_NAME nmft
  where     sn.snap_id         = io.snap_id
        and sn.dbid            = io.dbid
        and sn.instance_number = io.instance_number
        and io.function_id     = nmfn.function_id
        and io.dbid            = nmfn.dbid
        and io.filetype_id     = nmft.filetype_id
        and io.dbid            = nmft.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_IOSTAT_DETAIL"  IS 'Historical I/O statistics by function and filetype'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IOSTAT_FILETYPE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IOSTAT_FILETYPE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FILETYPE_ID", "FILETYPE_NAME", "SMALL_READ_MEGABYTES", "SMALL_WRITE_MEGABYTES", "LARGE_READ_MEGABYTES", "LARGE_WRITE_MEGABYTES", "SMALL_READ_REQS", "SMALL_WRITE_REQS", "SMALL_SYNC_READ_REQS", "LARGE_READ_REQS", "LARGE_WRITE_REQS", "SMALL_READ_SERVICETIME", "SMALL_WRITE_SERVICETIME", "SMALL_SYNC_READ_LATENCY", "LARGE_READ_SERVICETIME", "LARGE_WRITE_SERVICETIME", "RETRIES_ON_ERROR", "CON_DBID", "CON_ID") AS 
  select io.snap_id, io.dbid, io.instance_number,
       nm.filetype_id, nm.filetype_name,
       io.small_read_megabytes, io.small_write_megabytes,
       io.large_read_megabytes, io.large_write_megabytes,
       io.small_read_reqs, io.small_write_reqs, io.small_sync_read_reqs,
       io.large_read_reqs, io.large_write_reqs,
       io.small_read_servicetime, io.small_write_servicetime,
       io.small_sync_read_latency,
       io.large_read_servicetime, io.large_write_servicetime,
       io.retries_on_error,
       decode(io.con_dbid, 0, io.dbid, io.con_dbid),
       decode(io.per_pdb, 0, 0,
         con_dbid_to_id(decode(io.con_dbid, 0, io.dbid, io.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_IOSTAT_FILETYPE io, WRH$_IOSTAT_FILETYPE_NAME nm
  where     sn.snap_id         = io.snap_id
        and sn.dbid            = io.dbid
        and sn.instance_number = io.instance_number
        and io.filetype_id     = nm.filetype_id
        and io.dbid            = nm.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_IOSTAT_FILETYPE"  IS 'Historical I/O statistics by file type'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IOSTAT_FILETYPE_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IOSTAT_FILETYPE_NAME"  CONTAINER_DATA 
 ("DBID", "FILETYPE_ID", "FILETYPE_NAME", "CON_DBID", "CON_ID") AS 
  select dbid,
       filetype_id,
       filetype_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_IOSTAT_FILETYPE_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_IOSTAT_FILETYPE_NAME"  IS 'File type names for historical I/O statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IOSTAT_FUNCTION
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IOSTAT_FUNCTION"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FUNCTION_ID", "FUNCTION_NAME", "SMALL_READ_MEGABYTES", "SMALL_WRITE_MEGABYTES", "LARGE_READ_MEGABYTES", "LARGE_WRITE_MEGABYTES", "SMALL_READ_REQS", "SMALL_WRITE_REQS", "LARGE_READ_REQS", "LARGE_WRITE_REQS", "NUMBER_OF_WAITS", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select io.snap_id, io.dbid, io.instance_number,
       nm.function_id, nm.function_name,
       io.small_read_megabytes, io.small_write_megabytes,
       io.large_read_megabytes, io.large_write_megabytes,
       io.small_read_reqs, io.small_write_reqs,
       io.large_read_reqs, io.large_write_reqs,
       io.number_of_waits, io.wait_time,
       decode(io.con_dbid, 0, io.dbid, io.con_dbid),
       decode(io.per_pdb, 0, 0,
         con_dbid_to_id(decode(io.con_dbid, 0, io.dbid, io.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_IOSTAT_FUNCTION io,
       WRH$_IOSTAT_FUNCTION_NAME nm
  where     sn.snap_id         = io.snap_id
        and sn.dbid            = io.dbid
        and sn.instance_number = io.instance_number
        and io.function_id     = nm.function_id
        and io.dbid            = nm.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_IOSTAT_FUNCTION"  IS 'Historical I/O statistics by function'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_IOSTAT_FUNCTION_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_IOSTAT_FUNCTION_NAME"  CONTAINER_DATA 
 ("DBID", "FUNCTION_ID", "FUNCTION_NAME", "CON_DBID", "CON_ID") AS 
  select dbid,
       function_id,
       function_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_IOSTAT_FUNCTION_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_IOSTAT_FUNCTION_NAME"  IS 'Function names for historical I/O statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_JAVA_POOL_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_JAVA_POOL_ADVICE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "JAVA_POOL_SIZE_FOR_ESTIMATE", "JAVA_POOL_SIZE_FACTOR", "ESTD_LC_SIZE", "ESTD_LC_MEMORY_OBJECTS", "ESTD_LC_TIME_SAVED", "ESTD_LC_TIME_SAVED_FACTOR", "ESTD_LC_LOAD_TIME", "ESTD_LC_LOAD_TIME_FACTOR", "ESTD_LC_MEMORY_OBJECT_HITS", "CON_DBID", "CON_ID") AS 
  select jp.snap_id, jp.dbid, jp.instance_number,
       java_pool_size_for_estimate, java_pool_size_factor,
       estd_lc_size, estd_lc_memory_objects,
       estd_lc_time_saved, estd_lc_time_saved_factor,
       estd_lc_load_time, estd_lc_load_time_factor,
       estd_lc_memory_object_hits,
       decode(jp.con_dbid, 0, jp.dbid, jp.con_dbid),
       decode(jp.per_pdb, 0, 0,
         con_dbid_to_id(decode(jp.con_dbid, 0, jp.dbid, jp.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_JAVA_POOL_ADVICE jp
  where     sn.snap_id         = jp.snap_id
        and sn.dbid            = jp.dbid
        and sn.instance_number = jp.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_JAVA_POOL_ADVICE"  IS 'Java Pool Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_LATCH
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_LATCH"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "LATCH_HASH", "LATCH_NAME", "LEVEL#", "GETS", "MISSES", "SLEEPS", "IMMEDIATE_GETS", "IMMEDIATE_MISSES", "SPIN_GETS", "SLEEP1", "SLEEP2", "SLEEP3", "SLEEP4", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select l.snap_id, l.dbid, l.instance_number,
       l.latch_hash, ln.latch_name, level#,
       gets, misses, sleeps, immediate_gets, immediate_misses, spin_gets,
       sleep1, sleep2, sleep3, sleep4, wait_time,
       decode(l.con_dbid, 0, l.dbid, l.con_dbid),
       decode(l.per_pdb, 0, 0,
         con_dbid_to_id(decode(l.con_dbid, 0, l.dbid, l.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_LATCH l, WRH$_LATCH_NAME ln
where      l.latch_hash       = ln.latch_hash
      and  l.dbid             = ln.dbid
      and  l.snap_id          = sn.snap_id
      and  l.dbid             = sn.dbid
      and  l.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_LATCH"  IS 'Latch Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_LATCH_CHILDREN
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_LATCH_CHILDREN"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "LATCH_HASH", "LATCH_NAME", "CHILD#", "GETS", "MISSES", "SLEEPS", "IMMEDIATE_GETS", "IMMEDIATE_MISSES", "SPIN_GETS", "SLEEP1", "SLEEP2", "SLEEP3", "SLEEP4", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select l.snap_id, l.dbid, l.instance_number,
       l.latch_hash, ln.latch_name, child#,
       gets, misses, sleeps, immediate_gets, immediate_misses, spin_gets,
       sleep1, sleep2, sleep3, sleep4, wait_time,
       decode(l.con_dbid, 0, l.dbid, l.con_dbid),
       decode(l.per_pdb, 0, 0,
         con_dbid_to_id(decode(l.con_dbid, 0, l.dbid, l.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_LATCH_CHILDREN l, WRH$_LATCH_NAME ln
where      l.latch_hash       = ln.latch_hash
      and  l.dbid             = ln.dbid
      and  l.snap_id          = sn.snap_id
      and  l.dbid             = sn.dbid
      and  l.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_LATCH_CHILDREN"  IS 'Latch Children Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_LATCH_MISSES_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_LATCH_MISSES_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PARENT_NAME", "WHERE_IN_CODE", "NWFAIL_COUNT", "SLEEP_COUNT", "WTR_SLP_COUNT", "CON_DBID", "CON_ID") AS 
  select l.snap_id, l.dbid, l.instance_number, parent_name, where_in_code,
       nwfail_count, sleep_count, wtr_slp_count,
       decode(l.con_dbid, 0, l.dbid, l.con_dbid),
       decode(l.per_pdb, 0, 0,
         con_dbid_to_id(decode(l.con_dbid, 0, l.dbid, l.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_LATCH_MISSES_SUMMARY l
where      l.snap_id          = sn.snap_id
      and  l.dbid             = sn.dbid
      and  l.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_LATCH_MISSES_SUMMARY"  IS 'Latch Misses Summary Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_LATCH_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_LATCH_NAME"  CONTAINER_DATA 
 ("DBID", "LATCH_HASH", "LATCH_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, latch_hash, latch_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_LATCH_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_LATCH_NAME"  IS 'Latch Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_LATCH_PARENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_LATCH_PARENT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "LATCH_HASH", "LATCH_NAME", "LEVEL#", "GETS", "MISSES", "SLEEPS", "IMMEDIATE_GETS", "IMMEDIATE_MISSES", "SPIN_GETS", "SLEEP1", "SLEEP2", "SLEEP3", "SLEEP4", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select l.snap_id, l.dbid, l.instance_number,
       l.latch_hash, ln.latch_name, level#,
       gets, misses, sleeps, immediate_gets, immediate_misses, spin_gets,
       sleep1, sleep2, sleep3, sleep4, wait_time,
       decode(l.con_dbid, 0, l.dbid, l.con_dbid),
       decode(l.per_pdb, 0, 0,
         con_dbid_to_id(decode(l.con_dbid, 0, l.dbid, l.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_LATCH_PARENT l, WRH$_LATCH_NAME ln
where      l.latch_hash       = ln.latch_hash
      and  l.dbid             = ln.dbid
      and  l.snap_id          = sn.snap_id
      and  l.dbid             = sn.dbid
      and  l.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_LATCH_PARENT"  IS 'Latch Parent Historical Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_LIBRARYCACHE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_LIBRARYCACHE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAMESPACE", "GETS", "GETHITS", "PINS", "PINHITS", "RELOADS", "INVALIDATIONS", "DLM_LOCK_REQUESTS", "DLM_PIN_REQUESTS", "DLM_PIN_RELEASES", "DLM_INVALIDATION_REQUESTS", "DLM_INVALIDATIONS", "CON_DBID", "CON_ID") AS 
  select lc.snap_id, lc.dbid, lc.instance_number, namespace, gets,
       gethits, pins, pinhits, reloads, invalidations,
       dlm_lock_requests, dlm_pin_requests, dlm_pin_releases,
       dlm_invalidation_requests, dlm_invalidations,
       decode(lc.con_dbid, 0, lc.dbid, lc.con_dbid),
       decode(lc.per_pdb, 0, 0,
         con_dbid_to_id(decode(lc.con_dbid, 0, lc.dbid, lc.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_LIBRARYCACHE lc
  where     sn.snap_id         = lc.snap_id
        and sn.dbid            = lc.dbid
        and sn.instance_number = lc.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_LIBRARYCACHE"  IS 'Library Cache Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_LMS_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_LMS_STATS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PID", "PRIORITY", "PRIORITY_CHANGES", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
   s.pid, s.priority, s.priority_changes,
   decode(s.con_dbid, 0, s.dbid, s.con_dbid),
   decode(s.per_pdb, 0, 0,
     con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_LMS_STATS s
where     sn.snap_id         = s.snap_id
      and sn.dbid            = s.dbid
      and sn.instance_number = s.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_LMS_STATS"  IS 'LMS statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_LOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_LOG"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "GROUP#", "THREAD#", "SEQUENCE#", "BYTES", "MEMBERS", "ARCHIVED", "STATUS", "FIRST_CHANGE#", "FIRST_TIME", "CON_DBID", "CON_ID") AS 
  select log.snap_id, log.dbid, log.instance_number,
       group#, thread#, sequence#, bytes, members,
       archived, log.status, first_change#, first_time,
       decode(log.con_dbid, 0, log.dbid, log.con_dbid),
       decode(log.per_pdb, 0, 0,
         con_dbid_to_id(decode(log.con_dbid, 0, log.dbid, log.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_LOG log
  where     sn.snap_id         = log.snap_id
        and sn.dbid            = log.dbid
        and sn.instance_number = log.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_LOG"  IS 'Log Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_MEM_DYNAMIC_COMP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_MEM_DYNAMIC_COMP"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "COMPONENT", "CURRENT_SIZE", "MIN_SIZE", "MAX_SIZE", "USER_SPECIFIED_SIZE", "OPER_COUNT", "LAST_OPER_TYPE", "LAST_OPER_MODE", "LAST_OPER_TIME", "GRANULE_SIZE", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  t.component ,t.current_size, t.min_size, t.max_size,
  t.user_specified_size, t.oper_count, t.last_oper_type,
  t.last_oper_mode, t.last_oper_time, t.granule_size,
  decode(t.con_dbid, 0, t.dbid, t.con_dbid),
  con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid)) con_id
 from AWR_CDB_SNAPSHOT sn, WRH$_MEM_DYNAMIC_COMP t
 where     sn.snap_id         = t.snap_id
       and sn.dbid            = t.dbid
       and sn.instance_number = t.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_MEM_DYNAMIC_COMP"  IS 'Historical memory component sizes'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_MEMORY_RESIZE_OPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_MEMORY_RESIZE_OPS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "COMPONENT", "OPER_TYPE", "START_TIME", "END_TIME", "TARGET_SIZE", "OPER_MODE", "PARAMETER", "INITIAL_SIZE", "FINAL_SIZE", "STATUS", "CON_DBID", "CON_ID") AS 
  select mro.snap_id, mro.dbid, mro.instance_number,
       component, oper_type, start_time, end_time,
       target_size, oper_mode, parameter, initial_size,
       final_size, mro.status,
       decode(mro.con_dbid, 0, mro.dbid, mro.con_dbid),
       decode(mro.per_pdb, 0, 0,
         con_dbid_to_id(decode(mro.con_dbid, 0, mro.dbid, mro.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_MEMORY_RESIZE_OPS mro
  where     sn.snap_id         = mro.snap_id
        and sn.dbid            = mro.dbid
        and sn.instance_number = mro.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_MEMORY_RESIZE_OPS"  IS 'Memory Resize Operations History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_MEMORY_TARGET_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_MEMORY_TARGET_ADVICE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "MEMORY_SIZE", "MEMORY_SIZE_FACTOR", "ESTD_DB_TIME", "ESTD_DB_TIME_FACTOR", "VERSION", "CON_DBID", "CON_ID") AS 
  select mem.snap_id, mem.dbid, mem.instance_number,
       memory_size, memory_size_factor,
       estd_db_time, estd_db_time_factor, version,
       decode(mem.con_dbid, 0, mem.dbid, mem.con_dbid),
       decode(mem.per_pdb, 0, 0,
         con_dbid_to_id(decode(mem.con_dbid, 0, mem.dbid, mem.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_MEMORY_TARGET_ADVICE mem
  where     sn.snap_id         = mem.snap_id
        and sn.dbid            = mem.dbid
        and sn.instance_number = mem.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_MEMORY_TARGET_ADVICE"  IS 'Memory Target Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_METRIC_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_METRIC_NAME"  CONTAINER_DATA 
 ("DBID", "GROUP_ID", "GROUP_NAME", "METRIC_ID", "METRIC_NAME", "METRIC_UNIT", "CON_DBID", "CON_ID") AS 
  select dbid, group_id, group_name, metric_id, metric_name, metric_unit,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_METRIC_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_METRIC_NAME"  IS 'Segment Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_MTTR_TARGET_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_MTTR_TARGET_ADVICE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "MTTR_TARGET_FOR_ESTIMATE", "ADVICE_STATUS", "DIRTY_LIMIT", "ESTD_CACHE_WRITES", "ESTD_CACHE_WRITE_FACTOR", "ESTD_TOTAL_WRITES", "ESTD_TOTAL_WRITE_FACTOR", "ESTD_TOTAL_IOS", "ESTD_TOTAL_IO_FACTOR", "CON_DBID", "CON_ID") AS 
  select mt.snap_id, mt.dbid, mt.instance_number, mttr_target_for_estimate,
       advice_status, dirty_limit,
       estd_cache_writes, estd_cache_write_factor,
       estd_total_writes, estd_total_write_factor,
       estd_total_ios, estd_total_io_factor,
       decode(mt.con_dbid, 0, mt.dbid, mt.con_dbid),
       decode(mt.per_pdb, 0, 0,
         con_dbid_to_id(decode(mt.con_dbid, 0, mt.dbid, mt.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_MTTR_TARGET_ADVICE mt
  where     sn.snap_id         = mt.snap_id
        and sn.dbid            = mt.dbid
        and sn.instance_number = mt.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_MTTR_TARGET_ADVICE"  IS 'Mean-Time-To-Recover Target Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_MUTEX_SLEEP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_MUTEX_SLEEP"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "MUTEX_TYPE", "LOCATION", "SLEEPS", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number,
       mutex_type, location, sleeps, wait_time,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       decode(m.per_pdb, 0, 0,
         con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_MUTEX_SLEEP m
where      m.snap_id          = sn.snap_id
      and  m.dbid             = sn.dbid
      and  m.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_MUTEX_SLEEP"  IS 'Mutex Sleep Summary Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_MVPARAMETER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_MVPARAMETER"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PARAMETER_HASH", "PARAMETER_NAME", "ORDINAL", "VALUE", "ISDEFAULT", "ISMODIFIED", "CON_DBID", "CON_ID") AS 
  select mp.snap_id, mp.dbid, mp.instance_number,
       mp.parameter_hash, pn.parameter_name,
       mp.ordinal,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' or mp.per_pdb<>0 then mp.value else null end value, -- Use macro to mask sensitive column
       mp.isdefault, mp.ismodified,
       decode(mp.con_dbid, 0, mp.dbid, mp.con_dbid),
       decode(mp.per_pdb, 0, 0,
         con_dbid_to_id(decode(mp.con_dbid, 0, mp.dbid, mp.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_MVPARAMETER mp, WRH$_PARAMETER_NAME pn
where     mp.parameter_hash   = pn.parameter_hash
      and mp.dbid             = pn.dbid
      and mp.snap_id          = sn.snap_id
      and mp.dbid             = sn.dbid
      and mp.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_MVPARAMETER"  IS 'Multi-valued Parameter Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_OPTIMIZER_ENV
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_OPTIMIZER_ENV"  CONTAINER_DATA 
 ("DBID", "OPTIMIZER_ENV_HASH_VALUE", "OPTIMIZER_ENV", "CON_DBID", "CON_ID") AS 
  select dbid, optimizer_env_hash_value, optimizer_env,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
from WRH$_OPTIMIZER_ENV;

   COMMENT ON TABLE "SYS"."AWR_CDB_OPTIMIZER_ENV"  IS 'Optimizer Environment Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_OSSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_OSSTAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.instance_number, s.stat_id,
       nm.stat_name,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' or s.per_pdb<>0 then s.value else null end value, -- Use macro to mask sensitive column
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_OSSTAT s, WRH$_OSSTAT_NAME nm
where     s.stat_id          = nm.stat_id
      and s.dbid             = nm.dbid
      and s.snap_id          = sn.snap_id
      and s.dbid             = sn.dbid
      and s.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_OSSTAT"  IS 'Operating System Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_OSSTAT_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_OSSTAT_NAME"  CONTAINER_DATA 
 ("DBID", "STAT_ID", "STAT_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, stat_id, stat_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_OSSTAT_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_OSSTAT_NAME"  IS 'Operating System Statistic Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PARAMETER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PARAMETER"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PARAMETER_HASH", "PARAMETER_NAME", "VALUE", "ISDEFAULT", "ISMODIFIED", "CON_DBID", "CON_ID") AS 
  select p.snap_id, p.dbid, p.instance_number,
       p.parameter_hash, pn.parameter_name,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' or p.per_pdb<>0 then p.value else null end value, -- Use macro to mask sensitive column
       isdefault, ismodified,
       decode(p.con_dbid, 0, p.dbid, p.con_dbid),
       decode(p.per_pdb, 0, 0,
         con_dbid_to_id(decode(p.con_dbid, 0, p.dbid, p.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_PARAMETER p, WRH$_PARAMETER_NAME pn
where     p.parameter_hash   = pn.parameter_hash
      and p.dbid             = pn.dbid
      and p.snap_id          = sn.snap_id
      and p.dbid             = sn.dbid
      and p.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_PARAMETER"  IS 'Parameter Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PARAMETER_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PARAMETER_NAME"  CONTAINER_DATA 
 ("DBID", "PARAMETER_HASH", "PARAMETER_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, parameter_hash, parameter_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_PARAMETER_NAME
where (translate(parameter_name,'_','#') not like '#%');

   COMMENT ON TABLE "SYS"."AWR_CDB_PARAMETER_NAME"  IS 'Parameter Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PDB_IN_SNAP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PDB_IN_SNAP"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CON_DBID", "FLAG", "CON_ID", "OPEN_TIME_TZ") AS 
  select snap_id, dbid, instance_number, decode(con_dbid, 0, dbid, con_dbid),
       flag, con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid)) con_id,
       open_time_tz
       from wrm$_pdb_in_snap;

   COMMENT ON TABLE "SYS"."AWR_CDB_PDB_IN_SNAP"  IS 'Pluggable Databases in a snapshot'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PDB_INSTANCE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PDB_INSTANCE"  CONTAINER_DATA 
 ("DBID", "INSTANCE_NUMBER", "STARTUP_TIME", "CON_DBID", "OPEN_TIME", "OPEN_MODE", "PDB_NAME", "CON_ID", "SNAP_ID", "STARTUP_TIME_TZ", "OPEN_TIME_TZ") AS 
  select dbid, instance_number, startup_time,
       CON_DBID, OPEN_TIME, OPEN_MODE, PDB_NAME,
       con_dbid_to_id(con_dbid) con_id, snap_id,
       startup_time_tz, open_time_tz
       from wrm$_pdb_instance;

   COMMENT ON TABLE "SYS"."AWR_CDB_PDB_INSTANCE"  IS 'Pluggable Database Instance Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PERSISTENT_QMN_CACHE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PERSISTENT_QMN_CACHE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_TABLE_ID", "TYPE", "STATUS", "NEXT_SERVICE_TIME", "WINDOW_END_TIME", "TOTAL_RUNS", "TOTAL_LATENCY", "TOTAL_ELAPSED_TIME", "TOTAL_CPU_TIME", "TMGR_ROWS_PROCESSED", "TMGR_ELAPSED_TIME", "TMGR_CPU_TIME", "LAST_TMGR_PROCESSING_TIME", "DEQLOG_ROWS_PROCESSED", "DEQLOG_PROCESSING_ELAPSED_TIME", "DEQLOG_PROCESSING_CPU_TIME", "LAST_DEQLOG_PROCESSING_TIME", "DEQUEUE_INDEX_BLOCKS_FREED", "HISTORY_INDEX_BLOCKS_FREED", "TIME_INDEX_BLOCKS_FREED", "INDEX_CLEANUP_COUNT", "INDEX_CLEANUP_ELAPSED_TIME", "INDEX_CLEANUP_CPU_TIME", "LAST_INDEX_CLEANUP_TIME", "CON_DBID", "CON_ID") AS 
  select pqc.snap_id, pqc.dbid, pqc.instance_number, pqc.queue_table_id,
       pqc.type, pqc.status, pqc.next_service_time, pqc.window_end_time,
       pqc.TOTAL_RUNS, pqc.TOTAL_LATENCY, pqc.TOTAL_ELAPSED_TIME,
       pqc.TOTAL_CPU_TIME, pqc.TMGR_ROWS_PROCESSED, pqc.TMGR_ELAPSED_TIME,
       pqc.TMGR_CPU_TIME, pqc.LAST_TMGR_PROCESSING_TIME,
       pqc.DEQLOG_ROWS_PROCESSED, pqc.DEQLOG_PROCESSING_ELAPSED_TIME,
       pqc.DEQLOG_PROCESSING_CPU_TIME, pqc.LAST_DEQLOG_PROCESSING_TIME,
       pqc.DEQUEUE_INDEX_BLOCKS_FREED, pqc.HISTORY_INDEX_BLOCKS_FREED,
       pqc.TIME_INDEX_BLOCKS_FREED, pqc.INDEX_CLEANUP_COUNT,
       pqc.INDEX_CLEANUP_ELAPSED_TIME, pqc.INDEX_CLEANUP_CPU_TIME,
       pqc.LAST_INDEX_CLEANUP_TIME,
       decode(pqc.con_dbid, 0, pqc.dbid, pqc.con_dbid),
       decode(pqc.per_pdb, 0, 0,
         con_dbid_to_id(decode(pqc.con_dbid, 0, pqc.dbid, pqc.con_dbid))) con_id
  from wrh$_persistent_qmn_cache pqc, AWR_CDB_SNAPSHOT sn
  where     sn.snap_id          = pqc.snap_id
        and sn.dbid             = pqc.dbid
        and sn.instance_number  = pqc.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_PERSISTENT_QMN_CACHE"  IS 'STREAMS AQ Persistent QMN Cache Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PERSISTENT_QUEUES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PERSISTENT_QUEUES"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_SCHEMA", "QUEUE_NAME", "QUEUE_ID", "FIRST_ACTIVITY_TIME", "ENQUEUED_MSGS", "DEQUEUED_MSGS", "BROWSED_MSGS", "ELAPSED_ENQUEUE_TIME", "ELAPSED_DEQUEUE_TIME", "ENQUEUE_CPU_TIME", "DEQUEUE_CPU_TIME", "AVG_MSG_AGE", "DEQUEUED_MSG_LATENCY", "ELAPSED_TRANSFORMATION_TIME", "ELAPSED_RULE_EVALUATION_TIME", "ENQUEUED_EXPIRY_MSGS", "ENQUEUED_DELAY_MSGS", "MSGS_MADE_EXPIRED", "MSGS_MADE_READY", "LAST_ENQUEUE_TIME", "LAST_DEQUEUE_TIME", "LAST_TM_EXPIRY_TIME", "LAST_TM_READY_TIME", "ENQUEUE_TRANSACTIONS", "DEQUEUE_TRANSACTIONS", "EXECUTION_COUNT", "CON_DBID", "CON_ID") AS 
  select pqs.snap_id, pqs.dbid, pqs.instance_number, pqs.queue_schema,
       pqs.queue_name,pqs.queue_id, pqs.first_activity_time, pqs.enqueued_msgs,
       pqs.dequeued_msgs, pqs.browsed_msgs, pqs.elapsed_enqueue_time,
       pqs.elapsed_dequeue_time, pqs.enqueue_cpu_time, pqs.dequeue_cpu_time,
       pqs.avg_msg_age, pqs.dequeued_msg_latency,
       pqs.elapsed_transformation_time, pqs.elapsed_rule_evaluation_time,
       pqs.enqueued_expiry_msgs, pqs.enqueued_delay_msgs,
       pqs.msgs_made_expired, pqs.msgs_made_ready, pqs.last_enqueue_time,
       pqs.last_dequeue_time, pqs.last_tm_expiry_time, pqs.last_tm_ready_time,
       pqs.enqueue_transactions, pqs.dequeue_transactions, pqs.execution_count,
       decode(pqs.con_dbid, 0, pqs.dbid, pqs.con_dbid),
       decode(pqs.per_pdb, 0, 0,
         con_dbid_to_id(decode(pqs.con_dbid, 0, pqs.dbid, pqs.con_dbid))) con_id
  from wrh$_persistent_queues pqs, AWR_CDB_SNAPSHOT sn
  where     sn.snap_id          = pqs.snap_id
        and sn.dbid             = pqs.dbid
        and sn.instance_number  = pqs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_PERSISTENT_QUEUES"  IS 'STREAMS AQ Persistent Queues Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PERSISTENT_SUBS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PERSISTENT_SUBS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_SCHEMA", "QUEUE_NAME", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "SUBSCRIBER_ADDRESS", "SUBSCRIBER_TYPE", "FIRST_ACTIVITY_TIME", "ENQUEUED_MSGS", "DEQUEUED_MSGS", "AVG_MSG_AGE", "BROWSED_MSGS", "EXPIRED_MSGS", "DEQUEUED_MSG_LATENCY", "LAST_ENQUEUE_TIME", "LAST_DEQUEUE_TIME", "ELAPSED_DEQUEUE_TIME", "DEQUEUE_CPU_TIME", "DEQUEUE_TRANSACTIONS", "EXECUTION_COUNT", "CON_DBID", "CON_ID") AS 
  select pss.snap_id, pss.dbid, pss.instance_number,
       pss.queue_schema, pss.queue_name, pss.subscriber_id,
       pss.subscriber_name, pss.subscriber_address, pss.subscriber_type,
       pss.first_activity_time, pss.enqueued_msgs, pss.dequeued_msgs,
       pss.avg_msg_age, pss.browsed_msgs,
       pss.expired_msgs, pss.dequeued_msg_latency, pss.last_enqueue_time,
       pss.last_dequeue_time, pss.elapsed_dequeue_time,pss.dequeue_cpu_time,
       pss.dequeue_transactions, pss.execution_count,
       decode(pss.con_dbid, 0, pss.dbid, pss.con_dbid),
       decode(pss.per_pdb, 0, 0,
         con_dbid_to_id(decode(pss.con_dbid, 0, pss.dbid, pss.con_dbid))) con_id
  from wrh$_persistent_subscribers pss, AWR_CDB_SNAPSHOT sn
  where     sn.snap_id          = pss.snap_id
        and sn.dbid             = pss.dbid
        and sn.instance_number  = pss.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_PERSISTENT_SUBS"  IS 'STREAMS AQ Persistent Queue Subscribers Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PGASTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PGASTAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select pga.snap_id, pga.dbid, pga.instance_number, name, value,
       decode(pga.con_dbid, 0, pga.dbid, pga.con_dbid),
       decode(pga.per_pdb, 0, 0,
         con_dbid_to_id(decode(pga.con_dbid, 0, pga.dbid, pga.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_PGASTAT pga
  where     sn.snap_id         = pga.snap_id
        and sn.dbid            = pga.dbid
        and sn.instance_number = pga.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_PGASTAT"  IS 'PGA Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PGA_TARGET_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PGA_TARGET_ADVICE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PGA_TARGET_FOR_ESTIMATE", "PGA_TARGET_FACTOR", "ADVICE_STATUS", "BYTES_PROCESSED", "ESTD_TIME", "ESTD_EXTRA_BYTES_RW", "ESTD_PGA_CACHE_HIT_PERCENTAGE", "ESTD_OVERALLOC_COUNT", "CON_DBID", "CON_ID") AS 
  select pga.snap_id, pga.dbid, pga.instance_number,
       pga_target_for_estimate,
       pga_target_factor, advice_status, bytes_processed,
       estd_time, estd_extra_bytes_rw,
       estd_pga_cache_hit_percentage, estd_overalloc_count,
       decode(pga.con_dbid, 0, pga.dbid, pga.con_dbid),
       decode(pga.per_pdb, 0, 0,
         con_dbid_to_id(decode(pga.con_dbid, 0, pga.dbid, pga.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_PGA_TARGET_ADVICE pga
  where     sn.snap_id         = pga.snap_id
        and sn.dbid            = pga.dbid
        and sn.instance_number = pga.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_PGA_TARGET_ADVICE"  IS 'PGA Target Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PLAN_OPERATION_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PLAN_OPERATION_NAME"  CONTAINER_DATA 
 ("DBID", "OPERATION_ID", "OPERATION_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, operation_id, operation_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_PLAN_OPERATION_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_PLAN_OPERATION_NAME"  IS 'Optimizer Explain Plan Operation Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PLAN_OPTION_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PLAN_OPTION_NAME"  CONTAINER_DATA 
 ("DBID", "OPTION_ID", "OPTION_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, option_id, option_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_PLAN_OPTION_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_PLAN_OPTION_NAME"  IS 'Optimizer Explain Plan Option Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PROCESS_MEM_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PROCESS_MEM_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CATEGORY", "IS_INSTANCE_WIDE", "NUM_PROCESSES", "NON_ZERO_ALLOCS", "USED_TOTAL", "ALLOCATED_TOTAL", "ALLOCATED_AVG", "ALLOCATED_STDDEV", "ALLOCATED_MAX", "MAX_ALLOCATED_MAX", "CON_DBID", "CON_ID") AS 
  select pmem.snap_id, pmem.dbid, pmem.instance_number,
       category, decode(pmem.per_pdb_nn, 0, 1, 0) is_instance_wide,
       num_processes, non_zero_allocs,
       used_total, allocated_total, allocated_total / num_processes,
       allocated_stddev, allocated_max, max_allocated_max,
       decode(pmem.con_dbid, 0, pmem.dbid, pmem.con_dbid),
       decode(pmem.per_pdb, 0, 0,
         con_dbid_to_id(
           decode(pmem.con_dbid, 0, pmem.dbid, pmem.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_PROCESS_MEMORY_SUMMARY pmem
  where     sn.snap_id         = pmem.snap_id
        and sn.dbid            = pmem.dbid
        and sn.instance_number = pmem.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_PROCESS_MEM_SUMMARY"  IS 'Process Memory Historical Summary Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_PROCESS_WAITTIME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_PROCESS_WAITTIME"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PROCESS_TYPE", "DESCRIPTION", "WAIT_CLASS_TYPE", "VALUE", "CON_DBID", "CON_ID") AS 
  select cw.snap_id, cw.dbid, cw.instance_number,
       process_type, description, wait_class_type, value,
       decode(cw.con_dbid, 0, cw.dbid, cw.con_dbid),
       decode(cw.per_pdb, 0, 0,
         con_dbid_to_id(decode(cw.con_dbid, 0, cw.dbid, cw.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_PROCESS_WAITTIME cw
where    sn.snap_id         = cw.snap_id
     and sn.dbid            = cw.dbid
     and sn.instance_number = cw.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_PROCESS_WAITTIME"  IS 'cpu and wait time by process types'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_RECOVERY_PROGRESS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_RECOVERY_PROGRESS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "START_TIME", "TYPE", "ITEM", "UNITS", "SOFAR", "TOTAL", "TIMESTAMP", "CON_DBID", "CON_ID") AS 
  select rp.snap_id, rp.dbid, rp.instance_number, start_time, type,
       item, units, sofar, total, timestamp,
       decode(rp.con_dbid, 0, rp.dbid, rp.con_dbid),
       decode(rp.per_pdb, 0, 0,
         con_dbid_to_id(decode(rp.con_dbid, 0, rp.dbid, rp.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_RECOVERY_PROGRESS rp
  where    sn.snap_id  = rp.snap_id
       and sn.dbid     = rp.dbid
       and sn.instance_number = rp.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_RECOVERY_PROGRESS"  IS 'Recovery Progress'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_REPLICATION_TBL_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_REPLICATION_TBL_STATS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "APPLY_NAME", "TABLE_NAME", "TABLE_OWNER", "SESSION_MODULE", "TOTAL_INSERTS", "TOTAL_UPDATES", "TOTAL_DELETES", "CDR_SUCCESSFUL", "CDR_FAILED", "REPERR_CNT", "HANDLE_COLLISIONS", "CON_DBID", "CON_ID") AS 
  select rt.snap_id, rt.dbid, rt.instance_number, rt.apply_name,
       rt.table_name, rt.table_owner, rt.session_module,
       rt.total_inserts, rt.total_updates,
       rt.total_deletes, rt.cdr_successful, rt.cdr_failed, rt.reperr_cnt,
       rt.handle_collisions,
       decode(rt.con_dbid, 0, rt.dbid, rt.con_dbid),
       decode(rt.per_pdb, 0, 0,
         con_dbid_to_id(decode(rt.con_dbid, 0, rt.dbid, rt.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_REPLICATION_TBL_STATS rt
  where    rt.snap_id           = sn.snap_id
      and  rt.dbid              = sn.dbid
      and  rt.instance_number   = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_REPLICATION_TBL_STATS"  IS 'Replication Table Stats For GoldenGate/XStream Sessions'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_REPLICATION_TXN_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_REPLICATION_TXN_STATS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "OBJECT_NAME", "SESSION_TYPE", "SESSION_MODULE", "SOURCE_DATABASE", "SOURCE_TXN_ID", "FIRST_LCR_TIME", "TOTAL_LCRS_COUNT", "CON_DBID", "CON_ID") AS 
  select rt.snap_id, rt.dbid, rt.instance_number,
       rt.object_name, rt.session_type, rt.session_module, rt.source_database,
       rt.source_txn_id, rt.first_lcr_time, rt.total_lcrs_count,
       decode(rt.con_dbid, 0, rt.dbid, rt.con_dbid),
       decode(rt.per_pdb, 0, 0,
         con_dbid_to_id(decode(rt.con_dbid, 0, rt.dbid, rt.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_REPLICATION_TXN_STATS rt
  where    rt.snap_id           = sn.snap_id
      and  rt.dbid              = sn.dbid
      and  rt.instance_number   = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_REPLICATION_TXN_STATS"  IS 'Replication Transaction Stats For GoldenGate/XStream Sessions'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_RESOURCE_LIMIT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_RESOURCE_LIMIT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "RESOURCE_NAME", "CURRENT_UTILIZATION", "MAX_UTILIZATION", "INITIAL_ALLOCATION", "LIMIT_VALUE", "CON_DBID", "CON_ID") AS 
  select rl.snap_id, rl.dbid, rl.instance_number, resource_name,
       current_utilization, max_utilization, initial_allocation,
       limit_value,
       decode(rl.con_dbid, 0, rl.dbid, rl.con_dbid),
       decode(rl.per_pdb, 0, 0,
         con_dbid_to_id(decode(rl.con_dbid, 0, rl.dbid, rl.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_RESOURCE_LIMIT rl
  where     sn.snap_id         = rl.snap_id
        and sn.dbid            = rl.dbid
        and sn.instance_number = rl.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_RESOURCE_LIMIT"  IS 'Resource Limit Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_ROWCACHE_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_ROWCACHE_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PARAMETER", "TOTAL_USAGE", "USAGE", "GETS", "GETMISSES", "SCANS", "SCANMISSES", "SCANCOMPLETES", "MODIFICATIONS", "FLUSHES", "DLM_REQUESTS", "DLM_CONFLICTS", "DLM_RELEASES", "CON_DBID", "CON_ID") AS 
  select rc.snap_id, rc.dbid, rc.instance_number,
       parameter, total_usage,
       usage, gets, getmisses, scans, scanmisses, scancompletes,
       modifications, flushes, dlm_requests, dlm_conflicts,
       dlm_releases,
       decode(rc.con_dbid, 0, rc.dbid, rc.con_dbid),
       decode(rc.per_pdb, 0, 0,
         con_dbid_to_id(decode(rc.con_dbid, 0, rc.dbid, rc.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_ROWCACHE_SUMMARY rc
  where     sn.snap_id         = rc.snap_id
        and sn.dbid            = rc.dbid
        and sn.instance_number = rc.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_ROWCACHE_SUMMARY"  IS 'Row Cache Historical Statistics Information Summary'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_RSRC_CONSUMER_GROUP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_RSRC_CONSUMER_GROUP"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SEQUENCE#", "CONSUMER_GROUP_ID", "CONSUMER_GROUP_NAME", "REQUESTS", "CPU_WAIT_TIME", "CPU_WAITS", "CONSUMED_CPU_TIME", "YIELDS", "ACTIVE_SESS_LIMIT_HIT", "UNDO_LIMIT_HIT", "SWITCHES_IN_CPU_TIME", "SWITCHES_OUT_CPU_TIME", "SWITCHES_IN_IO_MEGABYTES", "SWITCHES_OUT_IO_MEGABYTES", "SWITCHES_IN_IO_REQUESTS", "SWITCHES_OUT_IO_REQUESTS", "SWITCHES_IN_IO_LOGICAL", "SWITCHES_OUT_IO_LOGICAL", "SWITCHES_IN_ELAPSED_TIME", "SWITCHES_OUT_ELAPSED_TIME", "PGA_LIMIT_SESSIONS_KILLED", "SQL_CANCELED", "ACTIVE_SESS_KILLED", "IDLE_SESS_KILLED", "IDLE_BLKR_SESS_KILLED", "QUEUED_TIME", "QUEUE_TIME_OUTS", "IO_SERVICE_TIME", "IO_SERVICE_WAITS", "SMALL_READ_MEGABYTES", "SMALL_WRITE_MEGABYTES", "LARGE_READ_MEGABYTES", "LARGE_WRITE_MEGABYTES", "SMALL_READ_REQUESTS", "SMALL_WRITE_REQUESTS", "LARGE_READ_REQUESTS", "LARGE_WRITE_REQUESTS", "PQS_QUEUED", "PQ_QUEUED_TIME", "PQ_QUEUE_TIME_OUTS", "PQS_COMPLETED", "PQ_SERVERS_USED", "PQ_ACTIVE_TIME", "CON_DBID", "CON_ID") AS 
  select
  cg.snap_id,
  cg.dbid,
  cg.instance_number,
  cg.sequence#,
  cg.consumer_group_id,
  cg.consumer_group_name,
  cg.requests,
  cg.cpu_wait_time,
  cg.cpu_waits,
  cg.consumed_cpu_time,
  cg.yields,
  cg.active_sess_limit_hit,
  cg.undo_limit_hit,
  cg.switches_in_cpu_time,
  cg.switches_out_cpu_time,
  cg.switches_in_io_megabytes,
  cg.switches_out_io_megabytes,
  cg.switches_in_io_requests,
  cg.switches_out_io_requests,
  cg.switches_in_io_logical,
  cg.switches_out_io_logical,
  cg.switches_in_elapsed_time,
  cg.switches_out_elapsed_time,
  cg.pga_limit_sessions_killed,
  cg.sql_canceled,
  cg.active_sess_killed,
  cg.idle_sess_killed,
  cg.idle_blkr_sess_killed,
  cg.queued_time,
  cg.queue_time_outs,
  cg.io_service_time,
  cg.io_service_waits,
  cg.small_read_megabytes,
  cg.small_write_megabytes,
  cg.large_read_megabytes,
  cg.large_write_megabytes,
  cg.small_read_requests,
  cg.small_write_requests,
  cg.large_read_requests,
  cg.large_write_requests,
  nvl(cg.pqs_queued, 0),
  nvl(cg.pq_queued_time, 0),
  nvl(cg.pq_queue_time_outs, 0),
  nvl(cg.pqs_completed, 0),
  nvl(cg.pq_servers_used, 0),
  nvl(cg.pq_active_time, 0),
  decode(cg.con_dbid, 0, cg.dbid, cg.con_dbid),
  decode(cg.per_pdb, 0, 0,
    con_dbid_to_id(decode(cg.con_dbid, 0, cg.dbid, cg.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_RSRC_CONSUMER_GROUP cg
  where     sn.snap_id         = cg.snap_id
        and sn.dbid            = cg.dbid
        and sn.instance_number = cg.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_RSRC_CONSUMER_GROUP"  IS 'Historical resource consumer group statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_RSRC_METRIC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_RSRC_METRIC"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE_CSEC", "SEQUENCE#", "CONSUMER_GROUP_ID", "CPU_CONSUMED_TIME", "CPU_WAIT_TIME", "AVG_RUNNING_SESSIONS", "AVG_WAITING_SESSIONS", "AVG_CPU_UTILIZATION", "IO_REQUESTS", "IO_MEGABYTES", "IOPS", "IOMBPS", "AVG_ACTIVE_PARALLEL_STMTS", "AVG_QUEUED_PARALLEL_STMTS", "AVG_ACTIVE_PARALLEL_SERVERS", "AVG_QUEUED_PARALLEL_SERVERS", "CON_DBID", "CON_ID") AS 
  select
  rm.snap_id,
  rm.dbid,
  rm.instance_number,
  rm.begin_time,
  rm.end_time,
  rm.intsize_csec,                                           /* centiseconds */
  rm.sequence#,
  rm.consumer_group_id,
  rm.cpu_consumed_time,                                      /* milliseconds */
  rm.cpu_wait_time,                                          /* milliseconds */
  rm.cpu_consumed_time  / (10 * rm.intsize_csec),    /* avg running sessions */
  rm.cpu_wait_time      / (10 * rm.intsize_csec),    /* avg waiting sessions */
  decode(rm.os_num_cpus, 0, 0,
         (10 * rm.cpu_consumed_time / rm.intsize_csec / rm.os_num_cpus)),
  rm.io_requests,                                                /* requests */
  rm.io_megabytes,                                              /* megabytes */
  rm.io_requests  / (rm.intsize_csec / 100),      /* I/O requests per second */
  rm.io_megabytes / (rm.intsize_csec / 100),     /* I/O megabytes per second */
  rm.pq_active_time / (10 * rm.intsize_csec),   /* avg active parallel stmts */
  rm.pq_queued_time / (10 * rm.intsize_csec),   /* avg queued parallel stmts */
  rm.ps_active_time / (10 * rm.intsize_csec),/* avg running parallel servers */
  rm.ps_queued_time / (10 * rm.intsize_csec),/* avg parallel servers requested
                                              * by queued parallel servers   */
  decode(rm.con_dbid, 0, rm.dbid, rm.con_dbid),
  decode(rm.per_pdb, 0, 0,
    con_dbid_to_id(decode(rm.con_dbid, 0, rm.dbid, rm.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_RSRC_METRIC rm
  where     rm.dbid            = sn.dbid
        and rm.snap_id         = sn.snap_id
        and rm.instance_number = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_RSRC_METRIC"  IS 'Historical resource manager metrics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_RSRC_PDB_METRIC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_RSRC_PDB_METRIC"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE_CSEC", "SEQUENCE#", "CPU_CONSUMED_TIME", "CPU_WAIT_TIME", "AVG_RUNNING_SESSIONS", "AVG_WAITING_SESSIONS", "AVG_CPU_UTILIZATION", "IOPS", "IOMBPS", "IOPS_THROTTLE_EXEMPT", "IOMBPS_THROTTLE_EXEMPT", "AVG_IO_THROTTLE", "AVG_ACTIVE_PARALLEL_STMTS", "AVG_QUEUED_PARALLEL_STMTS", "AVG_ACTIVE_PARALLEL_SERVERS", "AVG_QUEUED_PARALLEL_SERVERS", "SGA_BYTES", "BUFFER_CACHE_BYTES", "SHARED_POOL_BYTES", "PGA_BYTES", "PLAN_ID", "CON_DBID", "CON_ID") AS 
  select
  rm.snap_id,
  rm.dbid,
  rm.instance_number,
  rm.begin_time,
  rm.end_time,
  rm.intsize_csec,                                           /* centiseconds */
  rm.sequence#,
  rm.cpu_consumed_time,                                      /* milliseconds */
  rm.cpu_wait_time,                                          /* milliseconds */
  rm.cpu_consumed_time  / (10 * rm.intsize_csec),    /* avg running sessions */
  rm.cpu_wait_time      / (10 * rm.intsize_csec),    /* avg waiting sessions */
  decode(rm.os_num_cpus, 0, 0,
         (10 * rm.cpu_consumed_time / rm.intsize_csec / rm.os_num_cpus)),
  rm.io_requests  / (rm.intsize_csec / 100),      /* I/O requests per second */
  rm.io_megabytes / (rm.intsize_csec / 100),     /* I/O megabytes per second */
  rm.io_requests_throttle_exempt  / (rm.intsize_csec / 100),
                           /* I/O requests per second exempt from throttling */
  rm.io_megabytes_throttle_exempt / (rm.intsize_csec / 100),
                          /* I/O megabytes per second exempt from throttling */
  decode(rm.io_requests, 0, 0,      /* avg I/O throttle time per I/O request */
         rm.io_throttle_time / rm.io_requests),
  rm.pq_active_time / (10 * rm.intsize_csec),   /* avg active parallel stmts */
  rm.pq_queued_time / (10 * rm.intsize_csec),   /* avg queued parallel stmts */
  rm.ps_active_time / (10 * rm.intsize_csec),/* avg running parallel servers */
  rm.ps_queued_time / (10 * rm.intsize_csec),/* avg parallel servers requested
                                              * by queued parallel servers   */
  rm.sga_bytes,                                                     /* bytes */
  rm.buffer_cache_bytes,                                            /* bytes */
  rm.shared_pool_bytes,                                             /* bytes */
  rm.pga_bytes,                                                     /* bytes */
  rm.plan_id,
  decode(rm.con_dbid, 0, rm.dbid, rm.con_dbid),
  decode(rm.per_pdb, 0, 0,
    con_dbid_to_id(decode(rm.con_dbid, 0, rm.dbid, rm.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_RSRC_PDB_METRIC rm
  where     rm.dbid            = sn.dbid
        and rm.snap_id         = sn.snap_id
        and rm.instance_number = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_RSRC_PDB_METRIC"  IS 'Historical resource manager metrics by PDB'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_RSRC_PLAN
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_RSRC_PLAN"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SEQUENCE#", "START_TIME", "END_TIME", "PLAN_ID", "PLAN_NAME", "CPU_MANAGED", "PARALLEL_EXECUTION_MANAGED", "INSTANCE_CAGING", "CON_DBID", "CON_ID") AS 
  select
  pl.snap_id,
  pl.dbid,
  pl.instance_number,
  pl.sequence#,
  pl.start_time,
  pl.end_time,
  pl.plan_id,
  pl.plan_name,
  pl.cpu_managed,
  nvl(pl.parallel_execution_managed, 'OFF'),
  pl.instance_caging,
  decode(pl.con_dbid, 0, pl.dbid, pl.con_dbid),
  decode(pl.per_pdb, 0, 0,
    con_dbid_to_id(decode(pl.con_dbid, 0, pl.dbid, pl.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_RSRC_PLAN pl
  where     sn.snap_id         = pl.snap_id
        and sn.dbid            = pl.dbid
        and sn.instance_number = pl.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_RSRC_PLAN"  IS 'Historical resource plan statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_RULE_SET
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_RULE_SET"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "OWNER", "NAME", "STARTUP_TIME", "CPU_TIME", "ELAPSED_TIME", "EVALUATIONS", "SQL_FREE_EVALUATIONS", "SQL_EXECUTIONS", "RELOADS", "CON_DBID", "CON_ID") AS 
  select rs.snap_id, rs.dbid, rs.instance_number,
       rs.owner, rs.name, rs.startup_time, rs.cpu_time, rs.elapsed_time,
       rs.evaluations, rs.sql_free_evaluations, rs.sql_executions, rs.reloads,
       decode(rs.con_dbid, 0, rs.dbid, rs.con_dbid),
       decode(rs.per_pdb, 0, 0,
         con_dbid_to_id(decode(rs.con_dbid, 0, rs.dbid, rs.con_dbid))) con_id
  from wrh$_rule_set rs, AWR_CDB_SNAPSHOT sn
  where     sn.snap_id          = rs.snap_id
        and sn.dbid             = rs.dbid
        and sn.instance_number  = rs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_RULE_SET"  IS 'Rule sets historical statistics information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SEG_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SEG_STAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TS#", "OBJ#", "DATAOBJ#", "LOGICAL_READS_TOTAL", "LOGICAL_READS_DELTA", "BUFFER_BUSY_WAITS_TOTAL", "BUFFER_BUSY_WAITS_DELTA", "DB_BLOCK_CHANGES_TOTAL", "DB_BLOCK_CHANGES_DELTA", "PHYSICAL_READS_TOTAL", "PHYSICAL_READS_DELTA", "PHYSICAL_WRITES_TOTAL", "PHYSICAL_WRITES_DELTA", "PHYSICAL_READS_DIRECT_TOTAL", "PHYSICAL_READS_DIRECT_DELTA", "PHYSICAL_WRITES_DIRECT_TOTAL", "PHYSICAL_WRITES_DIRECT_DELTA", "ITL_WAITS_TOTAL", "ITL_WAITS_DELTA", "ROW_LOCK_WAITS_TOTAL", "ROW_LOCK_WAITS_DELTA", "GC_CR_BLOCKS_SERVED_TOTAL", "GC_CR_BLOCKS_SERVED_DELTA", "GC_CU_BLOCKS_SERVED_TOTAL", "GC_CU_BLOCKS_SERVED_DELTA", "GC_BUFFER_BUSY_TOTAL", "GC_BUFFER_BUSY_DELTA", "GC_CR_BLOCKS_RECEIVED_TOTAL", "GC_CR_BLOCKS_RECEIVED_DELTA", "GC_CU_BLOCKS_RECEIVED_TOTAL", "GC_CU_BLOCKS_RECEIVED_DELTA", "GC_REMOTE_GRANTS_TOTAL", "GC_REMOTE_GRANTS_DELTA", "SPACE_USED_TOTAL", "SPACE_USED_DELTA", "SPACE_ALLOCATED_TOTAL", "SPACE_ALLOCATED_DELTA", "TABLE_SCANS_TOTAL", "TABLE_SCANS_DELTA", "CHAIN_ROW_EXCESS_TOTAL", "CHAIN_ROW_EXCESS_DELTA", "PHYSICAL_READ_REQUESTS_TOTAL", "PHYSICAL_READ_REQUESTS_DELTA", "PHYSICAL_WRITE_REQUESTS_TOTAL", "PHYSICAL_WRITE_REQUESTS_DELTA", "OPTIMIZED_PHYSICAL_READS_TOTAL", "OPTIMIZED_PHYSICAL_READS_DELTA", "IM_SCANS_TOTAL", "IM_SCANS_DELTA", "POPULATE_CUS_TOTAL", "POPULATE_CUS_DELTA", "REPOPULATE_CUS_TOTAL", "REPOPULATE_CUS_DELTA", "IM_DB_BLOCK_CHANGES_TOTAL", "IM_DB_BLOCK_CHANGES_DELTA", "CON_DBID", "CON_ID") AS 
  select seg.snap_id, seg.dbid, seg.instance_number, ts#, obj#, dataobj#,
       logical_reads_total, logical_reads_delta,
       buffer_busy_waits_total, buffer_busy_waits_delta,
       db_block_changes_total, db_block_changes_delta,
       physical_reads_total, physical_reads_delta,
       physical_writes_total, physical_writes_delta,
       physical_reads_direct_total, physical_reads_direct_delta,
       physical_writes_direct_total, physical_writes_direct_delta,
       itl_waits_total, itl_waits_delta,
       row_lock_waits_total, row_lock_waits_delta,
       gc_cr_blocks_received_total, gc_cr_blocks_received_delta,
       gc_cu_blocks_received_total, gc_cu_blocks_received_delta,
       gc_buffer_busy_total, gc_buffer_busy_delta,
       gc_cr_blocks_received_total, gc_cr_blocks_received_delta,
       gc_cu_blocks_received_total, gc_cu_blocks_received_delta,
       gc_remote_grants_total, gc_remote_grants_delta,
       space_used_total, space_used_delta,
       space_allocated_total, space_allocated_delta,
       table_scans_total, table_scans_delta,
       chain_row_excess_total, chain_row_excess_delta,
       physical_read_requests_total, physical_read_requests_delta,
       physical_write_requests_total, physical_write_requests_delta,
       optimized_physical_reads_total, optimized_physical_reads_delta,
       im_scans_total, im_scans_delta,
       populate_cus_total, populate_cus_delta,
       repopulate_cus_total, repopulate_cus_delta,
       im_db_block_changes_total, im_db_block_changes_delta,
       decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid),
       decode(seg.per_pdb, 0, 0,
         con_dbid_to_id(decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_SEG_STAT seg
where     seg.snap_id         = sn.snap_id
      and seg.dbid            = sn.dbid
      and seg.instance_number = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SEG_STAT"  IS ' Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SEG_STAT_OBJ
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SEG_STAT_OBJ"  CONTAINER_DATA 
 ("DBID", "TS#", "OBJ#", "DATAOBJ#", "OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "OBJECT_TYPE", "TABLESPACE_NAME", "PARTITION_TYPE", "CON_DBID", "CON_ID") AS 
  select so.dbid, so.ts#, so.obj#, so.dataobj#, so.owner, so.object_name,
       so.subobject_name, so.object_type,
       coalesce(ts.tsname, tablespace_name) tablespace_name,
       so.partition_type,
       decode(so.con_dbid, 0, so.dbid, so.con_dbid),
       decode(so.per_pdb, 0, 0,
         con_dbid_to_id(decode(so.con_dbid, 0, so.dbid, so.con_dbid))) con_id
from WRH$_SEG_STAT_OBJ so LEFT OUTER JOIN WRH$_TABLESPACE ts
     on (so.dbid = ts.dbid
         and so.ts# = ts.ts#
         and so.con_dbid = ts.con_dbid);

   COMMENT ON TABLE "SYS"."AWR_CDB_SEG_STAT_OBJ"  IS 'Segment Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SERVICE_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SERVICE_NAME"  CONTAINER_DATA 
 ("DBID", "SERVICE_NAME_HASH", "SERVICE_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, service_name_hash, service_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_SERVICE_NAME sn;

   COMMENT ON TABLE "SYS"."AWR_CDB_SERVICE_NAME"  IS 'Service Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SERVICE_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SERVICE_STAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SERVICE_NAME_HASH", "SERVICE_NAME", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select st.snap_id, st.dbid, st.instance_number,
       st.service_name_hash, sv.service_name,
       nm.stat_id, nm.stat_name, value,
       decode(st.con_dbid, 0, st.dbid, st.con_dbid),
       decode(st.per_pdb, 0, 0,
         con_dbid_to_id(decode(st.con_dbid, 0, st.dbid, st.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SERVICE_STAT st,
       WRH$_SERVICE_NAME sv, WRH$_STAT_NAME nm
  where    st.service_name_hash = sv.service_name_hash
      and  st.dbid              = sv.dbid
      and  st.stat_id           = nm.stat_id
      and  st.dbid              = nm.dbid
      and  st.snap_id           = sn.snap_id
      and  st.dbid              = sn.dbid
      and  st.instance_number   = sn.instance_number
      and  st.con_dbid          = sv.con_dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_SERVICE_STAT"  IS 'Historical Service Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SERVICE_WAIT_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SERVICE_WAIT_CLASS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SERVICE_NAME_HASH", "SERVICE_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "TOTAL_WAITS", "TIME_WAITED", "CON_DBID", "CON_ID") AS 
  select st.snap_id, st.dbid, st.instance_number,
       st.service_name_hash, nm.service_name,
       wait_class_id, wait_class, total_waits, time_waited,
       decode(st.con_dbid, 0, st.dbid, st.con_dbid),
       decode(st.per_pdb, 0, 0,
         con_dbid_to_id(decode(st.con_dbid, 0, st.dbid, st.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SERVICE_WAIT_CLASS st,
       WRH$_SERVICE_NAME nm
  where    st.service_name_hash = nm.service_name_hash
      and  st.dbid              = nm.dbid
      and  st.snap_id           = sn.snap_id
      and  st.dbid              = sn.dbid
      and  st.instance_number   = sn.instance_number
      and  st.con_dbid          = nm.con_dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_SERVICE_WAIT_CLASS"  IS 'Historical Service Wait Class Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SESSMETRIC_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SESSMETRIC_HISTORY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "SESSID", "SERIAL#", "INTSIZE", "GROUP_ID", "METRIC_ID", "METRIC_NAME", "VALUE", "METRIC_UNIT", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number, begin_time, end_time, sessid,
       serial#, intsize, m.group_id, m.metric_id, mn.metric_name,
       value, mn.metric_unit,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       decode(m.per_pdb, 0, 0,
         con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SESSMETRIC_HISTORY m, WRH$_METRIC_NAME mn
  where     m.group_id         = mn.group_id
        and m.metric_id        = mn.metric_id
        and m.dbid             = mn.dbid
        and sn.snap_id         = m.snap_id
        and sn.dbid            = m.dbid
        and sn.instance_number = m.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SESSMETRIC_HISTORY"  IS 'System Metrics History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SESS_SGA_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SESS_SGA_STATS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "OBJECT_NAME", "SESSION_TYPE", "SESSION_MODULE", "SGA_USED", "SGA_ALLOCATED", "CON_DBID", "CON_ID") AS 
  select st.snap_id, st.dbid, st.instance_number, st.object_name,
       st.session_type, st.session_module, st.sga_used, st.sga_allocated,
       decode(st.con_dbid, 0, st.dbid, st.con_dbid),
       decode(st.per_pdb, 0, 0,
         con_dbid_to_id(decode(st.con_dbid, 0, st.dbid, st.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SESS_SGA_STATS st
  where    st.snap_id           = sn.snap_id
      and  st.dbid              = sn.dbid
      and  st.instance_number   = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SESS_SGA_STATS"  IS 'SGA Usage Stats For High Utilization GoldenGate/XStream Sessions'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SESS_TIME_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SESS_TIME_STATS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SESSION_TYPE", "MIN_LOGON_TIME", "SUM_CPU_TIME", "SUM_SYS_IO_WAIT", "SUM_USER_IO_WAIT", "CON_DBID", "SESSION_MODULE", "CON_ID") AS 
  select st.snap_id, st.dbid, st.instance_number, st.session_type,
       st.min_logon_time, st.sum_cpu_time, st.sum_sys_io_wait,
       st.sum_user_io_wait,
       decode(st.con_dbid, 0, st.dbid, st.con_dbid),
       st.session_module,
       decode(st.per_pdb, 0, 0,
         con_dbid_to_id(decode(st.con_dbid, 0, st.dbid, st.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SESS_TIME_STATS st
  where    st.snap_id           = sn.snap_id
      and  st.dbid              = sn.dbid
      and  st.instance_number   = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SESS_TIME_STATS"  IS 'CPU And I/O Time For High Utilization Streams/GoldenGate/XStream sessions'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SGA
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SGA"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select sga.snap_id, sga.dbid, sga.instance_number, name, value,
       decode(sga.con_dbid, 0, sga.dbid, sga.con_dbid),
       decode(sga.per_pdb, 0, 0,
         con_dbid_to_id(decode(sga.con_dbid, 0, sga.dbid, sga.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SGA sga
  where     sn.snap_id         = sga.snap_id
        and sn.dbid            = sga.dbid
        and sn.instance_number = sga.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SGA"  IS 'SGA Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SGASTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SGASTAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "POOL", "BYTES", "CON_DBID", "CON_ID") AS 
  select sga.snap_id, sga.dbid, sga.instance_number, name, pool, bytes,
       decode(sga.con_dbid, 0, sga.dbid, sga.con_dbid),
       decode(sga.per_pdb, 0, 0,
         con_dbid_to_id(decode(sga.con_dbid, 0, sga.dbid, sga.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SGASTAT sga
  where     sn.snap_id         = sga.snap_id
        and sn.dbid            = sga.dbid
        and sn.instance_number = sga.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SGASTAT"  IS 'SGA Pool Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SGA_TARGET_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SGA_TARGET_ADVICE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SGA_SIZE", "SGA_SIZE_FACTOR", "ESTD_DB_TIME", "ESTD_PHYSICAL_READS", "CON_DBID", "CON_ID") AS 
  select sga.snap_id, sga.dbid, sga.instance_number,
       sga.sga_size, sga.sga_size_factor, sga.estd_db_time,
       sga.estd_physical_reads,
       decode(sga.con_dbid, 0, sga.dbid, sga.con_dbid),
       decode(sga.per_pdb, 0, 0,
         con_dbid_to_id(decode(sga.con_dbid, 0, sga.dbid, sga.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SGA_TARGET_ADVICE sga
  where     sn.snap_id         = sga.snap_id
        and sn.dbid            = sga.dbid
        and sn.instance_number = sga.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SGA_TARGET_ADVICE"  IS 'SGA Target Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SHARED_POOL_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SHARED_POOL_ADVICE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SHARED_POOL_SIZE_FOR_ESTIMATE", "SHARED_POOL_SIZE_FACTOR", "ESTD_LC_SIZE", "ESTD_LC_MEMORY_OBJECTS", "ESTD_LC_TIME_SAVED", "ESTD_LC_TIME_SAVED_FACTOR", "ESTD_LC_LOAD_TIME", "ESTD_LC_LOAD_TIME_FACTOR", "ESTD_LC_MEMORY_OBJECT_HITS", "CON_DBID", "CON_ID") AS 
  select sp.snap_id, sp.dbid, sp.instance_number,
       shared_pool_size_for_estimate,
       shared_pool_size_factor, estd_lc_size, estd_lc_memory_objects,
       estd_lc_time_saved, estd_lc_time_saved_factor,
       estd_lc_load_time, estd_lc_load_time_factor,
       estd_lc_memory_object_hits,
       decode(sp.con_dbid, 0, sp.dbid, sp.con_dbid),
       decode(sp.per_pdb, 0, 0,
         con_dbid_to_id(decode(sp.con_dbid, 0, sp.dbid, sp.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SHARED_POOL_ADVICE sp
  where     sn.snap_id         = sp.snap_id
        and sn.dbid            = sp.dbid
        and sn.instance_number = sp.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SHARED_POOL_ADVICE"  IS 'Shared Pool Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SHARED_SERVER_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SHARED_SERVER_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NUM_SAMPLES", "SAMPLE_TIME", "SAMPLED_TOTAL_CONN", "SAMPLED_ACTIVE_CONN", "SAMPLED_TOTAL_SRV", "SAMPLED_ACTIVE_SRV", "SAMPLED_TOTAL_DISP", "SAMPLED_ACTIVE_DISP", "SRV_BUSY", "SRV_IDLE", "SRV_IN_NET", "SRV_OUT_NET", "SRV_MESSAGES", "SRV_BYTES", "CQ_WAIT", "CQ_TOTALQ", "DQ_TOTALQ", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  s.num_samples, s.sample_time,
  s.sampled_total_conn, s.sampled_active_conn,
  s.sampled_total_srv, s.sampled_active_srv,
  s.sampled_total_disp, s.sampled_active_disp,
  s.srv_busy, s.srv_idle, s.srv_in_net, s.srv_out_net,
  s.srv_messages, s.srv_bytes,
  s.cq_wait, s.cq_totalq,
  s.dq_totalq,
  decode(s.con_dbid, 0, s.dbid, s.con_dbid),
  decode(s.per_pdb, 0, 0,
    con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_SHARED_SERVER_SUMMARY s
where     sn.snap_id         = s.snap_id
      and sn.dbid            = s.dbid
      and sn.instance_number = s.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SHARED_SERVER_SUMMARY"  IS 'Shared Server summary statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SNAP_ERROR
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SNAP_ERROR"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TABLE_NAME", "ERROR_NUMBER", "STEP_ID", "CON_ID") AS 
  select snap_id, dbid, instance_number, table_name, error_number, step_id,
          decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from wrm$_snap_error;

   COMMENT ON TABLE "SYS"."AWR_CDB_SNAP_ERROR"  IS 'Snapshot Error Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SNAPSHOT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SNAPSHOT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STARTUP_TIME", "BEGIN_INTERVAL_TIME", "END_INTERVAL_TIME", "FLUSH_ELAPSED", "SNAP_LEVEL", "ERROR_COUNT", "SNAP_FLAG", "SNAP_TIMEZONE", "BEGIN_INTERVAL_TIME_TZ", "END_INTERVAL_TIME_TZ", "CON_ID") AS 
  select snap_id, dbid, instance_number, startup_time,
       begin_interval_time, end_interval_time,
       flush_elapsed, snap_level, error_count, snap_flag, snap_timezone,
       begin_interval_time_tz, end_interval_time_tz,
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRM$_SNAPSHOT
where status = 0;

   COMMENT ON TABLE "SYS"."AWR_CDB_SNAPSHOT"  IS 'Snapshot Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SQLBIND
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SQLBIND" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SQL_ID", "NAME", "POSITION", "DUP_POSITION", "DATATYPE", "DATATYPE_STRING", "CHARACTER_SID", "PRECISION", "SCALE", "MAX_LENGTH", "WAS_CAPTURED", "LAST_CAPTURED", "VALUE_STRING", "VALUE_ANYDATA", "CON_DBID", "CON_ID") AS 
  select snap_id                                                 snap_id,
       dbid                                                    dbid,
       instance_number                                         instance_number,
       sql_id                                                  sql_id,
       name                                                    name,
       position                                                position,
       nvl2(cap_bv, v.cap_bv.dup_position, dup_position)       dup_position,
       nvl2(cap_bv, v.cap_bv.datatype, datatype)               datatype,
       nvl2(cap_bv, v.cap_bv.datatype_string, datatype_string) datatype_string,
       nvl2(cap_bv, v.cap_bv.character_sid, character_sid)     character_sid,
       nvl2(cap_bv, v.cap_bv.precision, precision)             precision,
       nvl2(cap_bv, v.cap_bv.scale, scale)                     scale,
       nvl2(cap_bv, v.cap_bv.max_length, max_length)           max_length,
       nvl2(cap_bv, 'YES', 'NO')                               was_captured,
       nvl2(cap_bv, v.cap_bv.last_captured, NULL)              last_captured,
       nvl2(cap_bv, v.cap_bv.value_string, NULL)               value_string,
       nvl2(cap_bv, v.cap_bv.value_anydata, NULL)              value_anydata,
       con_dbid                                                con_dbid,
       con_id                                                  con_id
from
(select sql.snap_id, sql.dbid, sql.instance_number, sbm.sql_id,
        dbms_sqltune.extract_bind(sql.bind_data, sbm.position) cap_bv,
        sbm.name,
        sbm.position,
        sbm.dup_position,
        sbm.datatype,
        sbm.datatype_string,
        sbm.character_sid,
        sbm.precision,
        sbm.scale,
        sbm.max_length,
        sbm.con_dbid,
        sbm.con_id
 from   AWR_CDB_SNAPSHOT sn, AWR_CDB_SQL_BIND_METADATA sbm,
        AWR_CDB_SQLSTAT sql
 where      sn.snap_id         = sql.snap_id
        and sn.dbid            = sql.dbid
        and sn.instance_number = sql.instance_number
        and sbm.dbid           = sql.dbid
        and sbm.sql_id         = sql.sql_id
        and sbm.con_dbid       = sql.con_dbid) v;

   COMMENT ON TABLE "SYS"."AWR_CDB_SQLBIND"  IS 'SQL Bind Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SQL_BIND_METADATA
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SQL_BIND_METADATA"  CONTAINER_DATA 
 ("DBID", "SQL_ID", "NAME", "POSITION", "DUP_POSITION", "DATATYPE", "DATATYPE_STRING", "CHARACTER_SID", "PRECISION", "SCALE", "MAX_LENGTH", "CON_DBID", "CON_ID") AS 
  select dbid, sql_id, name, position, dup_position,
       datatype, datatype_string,
       character_sid, precision, scale, max_length,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_SQL_BIND_METADATA;

   COMMENT ON TABLE "SYS"."AWR_CDB_SQL_BIND_METADATA"  IS 'SQL Bind Metadata Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SQLCOMMAND_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SQLCOMMAND_NAME"  CONTAINER_DATA 
 ("DBID", "COMMAND_TYPE", "COMMAND_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, command_type, command_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_SQLCOMMAND_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_SQLCOMMAND_NAME"  IS 'Sql command types'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SQL_PLAN
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SQL_PLAN"  CONTAINER_DATA 
 ("DBID", "SQL_ID", "PLAN_HASH_VALUE", "ID", "OPERATION", "OPTIONS", "OBJECT_NODE", "OBJECT#", "OBJECT_OWNER", "OBJECT_NAME", "OBJECT_ALIAS", "OBJECT_TYPE", "OPTIMIZER", "PARENT_ID", "DEPTH", "POSITION", "SEARCH_COLUMNS", "COST", "CARDINALITY", "BYTES", "OTHER_TAG", "PARTITION_START", "PARTITION_STOP", "PARTITION_ID", "OTHER", "DISTRIBUTION", "CPU_COST", "IO_COST", "TEMP_SPACE", "ACCESS_PREDICATES", "FILTER_PREDICATES", "PROJECTION", "TIME", "QBLOCK_NAME", "REMARKS", "TIMESTAMP", "OTHER_XML", "CON_DBID", "CON_ID") AS 
  select dbid, sql_id, plan_hash_value, id, operation, options,
       object_node, object#, object_owner, object_name,
       object_alias, object_type, optimizer,
       parent_id, depth, position, search_columns, cost, cardinality,
       bytes, other_tag, partition_start, partition_stop, partition_id,
       other, distribution, cpu_cost, io_cost, temp_space,
       access_predicates, filter_predicates,
       projection, time, qblock_name, remarks, timestamp, other_xml,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
from WRH$_SQL_PLAN;

   COMMENT ON TABLE "SYS"."AWR_CDB_SQL_PLAN"  IS 'SQL Plan Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SQLSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SQLSTAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SQL_ID", "PLAN_HASH_VALUE", "OPTIMIZER_COST", "OPTIMIZER_MODE", "OPTIMIZER_ENV_HASH_VALUE", "SHARABLE_MEM", "LOADED_VERSIONS", "VERSION_COUNT", "MODULE", "ACTION", "SQL_PROFILE", "FORCE_MATCHING_SIGNATURE", "PARSING_SCHEMA_ID", "PARSING_SCHEMA_NAME", "PARSING_USER_ID", "FETCHES_TOTAL", "FETCHES_DELTA", "END_OF_FETCH_COUNT_TOTAL", "END_OF_FETCH_COUNT_DELTA", "SORTS_TOTAL", "SORTS_DELTA", "EXECUTIONS_TOTAL", "EXECUTIONS_DELTA", "PX_SERVERS_EXECS_TOTAL", "PX_SERVERS_EXECS_DELTA", "LOADS_TOTAL", "LOADS_DELTA", "INVALIDATIONS_TOTAL", "INVALIDATIONS_DELTA", "PARSE_CALLS_TOTAL", "PARSE_CALLS_DELTA", "DISK_READS_TOTAL", "DISK_READS_DELTA", "BUFFER_GETS_TOTAL", "BUFFER_GETS_DELTA", "ROWS_PROCESSED_TOTAL", "ROWS_PROCESSED_DELTA", "CPU_TIME_TOTAL", "CPU_TIME_DELTA", "ELAPSED_TIME_TOTAL", "ELAPSED_TIME_DELTA", "IOWAIT_TOTAL", "IOWAIT_DELTA", "CLWAIT_TOTAL", "CLWAIT_DELTA", "APWAIT_TOTAL", "APWAIT_DELTA", "CCWAIT_TOTAL", "CCWAIT_DELTA", "DIRECT_WRITES_TOTAL", "DIRECT_WRITES_DELTA", "PLSEXEC_TIME_TOTAL", "PLSEXEC_TIME_DELTA", "JAVEXEC_TIME_TOTAL", "JAVEXEC_TIME_DELTA", "IO_OFFLOAD_ELIG_BYTES_TOTAL", "IO_OFFLOAD_ELIG_BYTES_DELTA", "IO_INTERCONNECT_BYTES_TOTAL", "IO_INTERCONNECT_BYTES_DELTA", "PHYSICAL_READ_REQUESTS_TOTAL", "PHYSICAL_READ_REQUESTS_DELTA", "PHYSICAL_READ_BYTES_TOTAL", "PHYSICAL_READ_BYTES_DELTA", "PHYSICAL_WRITE_REQUESTS_TOTAL", "PHYSICAL_WRITE_REQUESTS_DELTA", "PHYSICAL_WRITE_BYTES_TOTAL", "PHYSICAL_WRITE_BYTES_DELTA", "OPTIMIZED_PHYSICAL_READS_TOTAL", "OPTIMIZED_PHYSICAL_READS_DELTA", "CELL_UNCOMPRESSED_BYTES_TOTAL", "CELL_UNCOMPRESSED_BYTES_DELTA", "IO_OFFLOAD_RETURN_BYTES_TOTAL", "IO_OFFLOAD_RETURN_BYTES_DELTA", "BIND_DATA", "FLAG", "OBSOLETE_COUNT", "CON_DBID", "CON_ID") AS 
  select sql.snap_id, sql.dbid, sql.instance_number,
       sql_id, plan_hash_value,
       optimizer_cost, optimizer_mode, optimizer_env_hash_value,
       sharable_mem, loaded_versions, version_count,
       substrb(module,1,(select ksumodlen from x$modact_length)) module,
       substrb(action,1,(select ksuactlen from x$modact_length)) action,
       sql_profile, force_matching_signature,
       parsing_schema_id, parsing_schema_name, parsing_user_id,
       fetches_total, fetches_delta,
       end_of_fetch_count_total, end_of_fetch_count_delta,
       sorts_total, sorts_delta,
       executions_total, executions_delta,
       px_servers_execs_total, px_servers_execs_delta,
       loads_total, loads_delta,
       invalidations_total, invalidations_delta,
       parse_calls_total, parse_calls_delta, disk_reads_total,
       disk_reads_delta, buffer_gets_total, buffer_gets_delta,
       rows_processed_total, rows_processed_delta, cpu_time_total,
       cpu_time_delta, elapsed_time_total, elapsed_time_delta,
       iowait_total, iowait_delta, clwait_total, clwait_delta,
       apwait_total, apwait_delta, ccwait_total, ccwait_delta,
       direct_writes_total, direct_writes_delta, plsexec_time_total,
       plsexec_time_delta, javexec_time_total, javexec_time_delta,
       io_offload_elig_bytes_total, io_offload_elig_bytes_delta,
       io_interconnect_bytes_total, io_interconnect_bytes_delta,
       physical_read_requests_total, physical_read_requests_delta,
       physical_read_bytes_total, physical_read_bytes_delta,
       physical_write_requests_total, physical_write_requests_delta,
       physical_write_bytes_total, physical_write_bytes_delta,
       optimized_physical_reads_total, optimized_physical_reads_delta,
       cell_uncompressed_bytes_total, cell_uncompressed_bytes_delta,
       io_offload_return_bytes_total, io_offload_return_bytes_delta,
       bind_data, sql.flag, obsolete_count,
       decode(sql.con_dbid, 0, sql.dbid, sql.con_dbid),
       decode(sql.per_pdb, 0, 0,
         con_dbid_to_id(decode(sql.con_dbid, 0, sql.dbid, sql.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_SQLSTAT sql
  where     sn.snap_id         = sql.snap_id
        and sn.dbid            = sql.dbid
        and sn.instance_number = sql.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SQLSTAT"  IS 'SQL Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SQL_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SQL_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TOTAL_SQL", "TOTAL_SQL_MEM", "SINGLE_USE_SQL", "SINGLE_USE_SQL_MEM", "CON_DBID", "CON_ID") AS 
  select ss.snap_id, ss.dbid, ss.instance_number,
       total_sql, total_sql_mem,
       single_use_sql, single_use_sql_mem,
       decode(ss.con_dbid, 0, ss.dbid, ss.con_dbid),
       decode(ss.per_pdb, 0, 0,
         con_dbid_to_id(decode(ss.con_dbid, 0, ss.dbid, ss.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_SQL_SUMMARY ss
where     sn.snap_id         = ss.snap_id
      and sn.dbid            = ss.dbid
      and sn.instance_number = ss.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SQL_SUMMARY"  IS 'Summary of SQL Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SQLTEXT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SQLTEXT"  CONTAINER_DATA 
 ("DBID", "SQL_ID", "SQL_TEXT", "COMMAND_TYPE", "CON_DBID", "CON_ID") AS 
  select dbid, sql_id, sql_text, command_type,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
from WRH$_SQLTEXT;

   COMMENT ON TABLE "SYS"."AWR_CDB_SQLTEXT"  IS 'SQL Text'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SQL_WORKAREA_HSTGRM
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SQL_WORKAREA_HSTGRM"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "LOW_OPTIMAL_SIZE", "HIGH_OPTIMAL_SIZE", "OPTIMAL_EXECUTIONS", "ONEPASS_EXECUTIONS", "MULTIPASSES_EXECUTIONS", "TOTAL_EXECUTIONS", "CON_DBID", "CON_ID") AS 
  select swh.snap_id, swh.dbid, swh.instance_number, low_optimal_size,
       high_optimal_size, optimal_executions, onepass_executions,
       multipasses_executions, total_executions,
       decode(swh.con_dbid, 0, swh.dbid, swh.con_dbid),
       decode(swh.per_pdb, 0, 0,
         con_dbid_to_id(decode(swh.con_dbid, 0, swh.dbid, swh.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SQL_WORKAREA_HISTOGRAM swh
  where     sn.snap_id         = swh.snap_id
        and sn.dbid            = swh.dbid
        and sn.instance_number = swh.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SQL_WORKAREA_HSTGRM"  IS 'SQL Workarea Histogram History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_STAT_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_STAT_NAME"  CONTAINER_DATA 
 ("DBID", "STAT_ID", "STAT_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, stat_id, stat_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_STAT_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_STAT_NAME"  IS 'Statistic Names'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_STREAMS_APPLY_SUM
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_STREAMS_APPLY_SUM"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "APPLY_NAME", "STARTUP_TIME", "READER_TOTAL_MESSAGES_DEQUEUED", "READER_LAG", "COORD_TOTAL_RECEIVED", "COORD_TOTAL_APPLIED", "COORD_TOTAL_ROLLBACKS", "COORD_TOTAL_WAIT_DEPS", "COORD_TOTAL_WAIT_CMTS", "COORD_LWM_LAG", "SERVER_TOTAL_MESSAGES_APPLIED", "SERVER_ELAPSED_DEQUEUE_TIME", "SERVER_ELAPSED_APPLY_TIME", "CON_DBID", "CON_ID") AS 
  select sas.snap_id, sas.dbid, sas.instance_number, sas.apply_name,
       sas.startup_time, sas.reader_total_messages_dequeued, sas.reader_lag,
       sas.coord_total_received, sas.coord_total_applied,
       sas.coord_total_rollbacks, sas.coord_total_wait_deps,
       sas.coord_total_wait_cmts, sas.coord_lwm_lag,
       sas.server_total_messages_applied, sas.server_elapsed_dequeue_time,
       sas.server_elapsed_apply_time,
       decode(sas.con_dbid, 0, sas.dbid, sas.con_dbid),
       decode(sas.per_pdb, 0, 0,
         con_dbid_to_id(decode(sas.con_dbid, 0, sas.dbid, sas.con_dbid))) con_id
  from wrh$_streams_apply_sum sas, AWR_CDB_SNAPSHOT sn
  where     sas.session_module = 'Streams'
        and sn.snap_id          = sas.snap_id
        and sn.dbid             = sas.dbid
        and sn.instance_number  = sas.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_STREAMS_APPLY_SUM"  IS 'STREAMS Apply Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_STREAMS_CAPTURE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_STREAMS_CAPTURE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CAPTURE_NAME", "STARTUP_TIME", "LAG", "TOTAL_MESSAGES_CAPTURED", "TOTAL_MESSAGES_ENQUEUED", "ELAPSED_RULE_TIME", "ELAPSED_ENQUEUE_TIME", "ELAPSED_REDO_WAIT_TIME", "ELAPSED_PAUSE_TIME", "CON_DBID", "CON_ID") AS 
  select cs.snap_id, cs.dbid, cs.instance_number, cs.capture_name,
       cs.startup_time, cs.lag,
       cs.total_messages_captured, cs.total_messages_enqueued,
       cs.elapsed_rule_time, cs.elapsed_enqueue_time,
       cs.elapsed_redo_wait_time, cs.elapsed_pause_time,
       decode(cs.con_dbid, 0, cs.dbid, cs.con_dbid),
       decode(cs.per_pdb, 0, 0,
         con_dbid_to_id(decode(cs.con_dbid, 0, cs.dbid, cs.con_dbid))) con_id
  from wrh$_streams_capture cs, AWR_CDB_SNAPSHOT sn
  where     cs.session_module = 'Streams'
        and sn.snap_id          = cs.snap_id
        and sn.dbid             = cs.dbid
        and sn.instance_number  = cs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_STREAMS_CAPTURE"  IS 'STREAMS Capture Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_STREAMS_POOL_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_STREAMS_POOL_ADVICE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SIZE_FOR_ESTIMATE", "SIZE_FACTOR", "ESTD_SPILL_COUNT", "ESTD_SPILL_TIME", "ESTD_UNSPILL_COUNT", "ESTD_UNSPILL_TIME", "CON_DBID", "CON_ID") AS 
  select sp.snap_id, sp.dbid, sp.instance_number,
       size_for_estimate, size_factor,
       estd_spill_count, estd_spill_time,
       estd_unspill_count, estd_unspill_time,
       decode(sp.con_dbid, 0, sp.dbid, sp.con_dbid),
       decode(sp.per_pdb, 0, 0,
         con_dbid_to_id(decode(sp.con_dbid, 0, sp.dbid, sp.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_STREAMS_POOL_ADVICE sp
  where     sn.snap_id         = sp.snap_id
        and sn.dbid            = sp.dbid
        and sn.instance_number = sp.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_STREAMS_POOL_ADVICE"  IS 'Streams Pool Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SYSMETRIC_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SYSMETRIC_HISTORY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "METRIC_ID", "METRIC_NAME", "VALUE", "METRIC_UNIT", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number,
       begin_time, end_time, intsize,
       m.group_id, m.metric_id, mn.metric_name, value, mn.metric_unit,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid)) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_SYSMETRIC_HISTORY m, WRH$_METRIC_NAME mn
where       m.group_id       = mn.group_id
      and   m.metric_id      = mn.metric_id
      and   m.dbid           = mn.dbid
      and   sn.snap_id       = m.snap_id
      and sn.dbid            = m.dbid
      and sn.instance_number = m.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SYSMETRIC_HISTORY"  IS 'System Metrics History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SYSMETRIC_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SYSMETRIC_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "METRIC_ID", "METRIC_NAME", "METRIC_UNIT", "NUM_INTERVAL", "MINVAL", "MAXVAL", "AVERAGE", "STANDARD_DEVIATION", "SUM_SQUARES", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number,
       begin_time, end_time, intsize,
       m.group_id, m.metric_id, mn.metric_name, mn.metric_unit,
       num_interval, minval, maxval, average, standard_deviation, sum_squares,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid)) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_SYSMETRIC_SUMMARY m, WRH$_METRIC_NAME mn
  where     m.group_id         = mn.group_id
        and m.metric_id        = mn.metric_id
        and m.dbid             = mn.dbid
        and sn.snap_id         = m.snap_id
        and sn.dbid            = m.dbid
        and sn.instance_number = m.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SYSMETRIC_SUMMARY"  IS 'System Metrics History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SYSSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SYSSTAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select /*+ leading(sn s nm) use_hash(sn s) */
       s.snap_id, s.dbid, s.instance_number,
       s.stat_id, nm.stat_name, value,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid)) con_id
from WRM$_SNAPSHOT sn, WRH$_SYSSTAT s, WRH$_STAT_NAME nm
where      s.stat_id          = nm.stat_id
      and  s.dbid             = nm.dbid
      and  s.snap_id          = sn.snap_id
      and  s.dbid             = sn.dbid
      and  s.instance_number  = sn.instance_number
      and  sn.status = 0;

   COMMENT ON TABLE "SYS"."AWR_CDB_SYSSTAT"  IS 'System Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SYSSTAT_ID
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SYSSTAT_ID"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.instance_number,
       s.stat_id, s.value,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid)) con_id
from WRH$_SYSSTAT s;

   COMMENT ON TABLE "SYS"."AWR_CDB_SYSSTAT_ID"  IS 'System Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SYSTEM_EVENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SYSTEM_EVENT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EVENT_ID", "EVENT_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "TOTAL_WAITS", "TOTAL_TIMEOUTS", "TIME_WAITED_MICRO", "TOTAL_WAITS_FG", "TOTAL_TIMEOUTS_FG", "TIME_WAITED_MICRO_FG", "CON_DBID", "CON_ID") AS 
  select e.snap_id, e.dbid, e.instance_number,
       e.event_id, en.event_name, en.wait_class_id, en.wait_class,
       total_waits, total_timeouts, time_waited_micro,
       total_waits_fg, total_timeouts_fg, time_waited_micro_fg,
       decode(e.con_dbid, 0, e.dbid, e.con_dbid),
       con_dbid_to_id(decode(e.con_dbid, 0, e.dbid, e.con_dbid)) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_SYSTEM_EVENT e, WRH$_EVENT_NAME en
where     e.event_id         = en.event_id
      and e.dbid             = en.dbid
      and e.snap_id          = sn.snap_id
      and e.dbid             = sn.dbid
      and e.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SYSTEM_EVENT"  IS 'System Event Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_SYS_TIME_MODEL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_SYS_TIME_MODEL"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.instance_number, s.stat_id,
       nm.stat_name, value,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid)) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_SYS_TIME_MODEL s, WRH$_STAT_NAME nm
where      s.stat_id          = nm.stat_id
      and  s.dbid             = nm.dbid
      and  s.snap_id          = sn.snap_id
      and  s.dbid             = sn.dbid
      and  s.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_SYS_TIME_MODEL"  IS 'System Time Model Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_TABLESPACE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_TABLESPACE"  CONTAINER_DATA 
 ("DBID", "TS#", "TSNAME", "CONTENTS", "SEGMENT_SPACE_MANAGEMENT", "EXTENT_MANAGEMENT", "BLOCK_SIZE", "CON_DBID", "CON_ID") AS 
  select tbs.dbid, tbs.ts#, tbs.tsname, tbs.contents,
       tbs.segment_space_management, tbs.extent_management, tbs.block_size,
       decode(tbs.con_dbid, 0, tbs.dbid, tbs.con_dbid),
       decode(tbs.per_pdb, 0, 0,
         con_dbid_to_id(
           decode(tbs.con_dbid, 0, tbs.dbid, tbs.con_dbid))) con_id
  from WRH$_TABLESPACE tbs;

   COMMENT ON TABLE "SYS"."AWR_CDB_TABLESPACE"  IS 'Tablespace Static Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_TABLESPACE_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_TABLESPACE_STAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TS#", "TSNAME", "CONTENTS", "STATUS", "SEGMENT_SPACE_MANAGEMENT", "EXTENT_MANAGEMENT", "IS_BACKUP", "CON_DBID", "CON_ID") AS 
  select tbs.snap_id, tbs.dbid, tbs.instance_number, tbs.ts#, tsname, contents,
       tbs.status, segment_space_management, extent_management,
       is_backup,
       decode(tbs.con_dbid, 0, tbs.dbid, tbs.con_dbid),
       decode(tbs.per_pdb, 0, 0,
         con_dbid_to_id(decode(tbs.con_dbid, 0, tbs.dbid, tbs.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_TABLESPACE_STAT tbs
where      tbs.snap_id          = sn.snap_id
      and  tbs.dbid             = sn.dbid
      and  tbs.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_TABLESPACE_STAT"  IS 'Tablespace Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_TBSPC_SPACE_USAGE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_TBSPC_SPACE_USAGE"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "TABLESPACE_ID", "TABLESPACE_SIZE", "TABLESPACE_MAXSIZE", "TABLESPACE_USEDSIZE", "RTIME", "CON_DBID", "CON_ID") AS 
  select tb.snap_id, tb.dbid, tablespace_id, tablespace_size,
       tablespace_maxsize, tablespace_usedsize, rtime,
       decode(tb.con_dbid, 0, tb.dbid, tb.con_dbid),
       decode(tb.per_pdb, 0, 0,
         con_dbid_to_id(decode(tb.con_dbid, 0, tb.dbid, tb.con_dbid))) con_id
  from (select distinct snap_id, dbid
          from AWR_CDB_SNAPSHOT) sn,
       WRH$_TABLESPACE_SPACE_USAGE tb
  where     sn.snap_id         = tb.snap_id
        and sn.dbid            = tb.dbid;

   COMMENT ON TABLE "SYS"."AWR_CDB_TBSPC_SPACE_USAGE"  IS 'Tablespace Usage Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_TEMPFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_TEMPFILE"  CONTAINER_DATA 
 ("DBID", "FILE#", "CREATION_CHANGE#", "FILENAME", "TS#", "TSNAME", "BLOCK_SIZE", "CON_DBID", "CON_ID") AS 
  select d.dbid, d.file#, d.creation_change#,
       d.filename, d.ts#, coalesce(t.tsname, d.tsname) tsname, d.block_size,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid),
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
from WRH$_TEMPFILE d LEFT OUTER JOIN WRH$_TABLESPACE t
     on (d.dbid = t.dbid
         and d.ts# = t.ts#
         and d.con_dbid = t.con_dbid);

   COMMENT ON TABLE "SYS"."AWR_CDB_TEMPFILE"  IS 'Names of Temporary Datafiles'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_TEMPSTATXS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_TEMPSTATXS"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FILE#", "CREATION_CHANGE#", "FILENAME", "TS#", "TSNAME", "BLOCK_SIZE", "PHYRDS", "PHYWRTS", "SINGLEBLKRDS", "READTIM", "WRITETIM", "SINGLEBLKRDTIM", "PHYBLKRD", "PHYBLKWRT", "WAIT_COUNT", "TIME", "CON_DBID", "CON_ID") AS 
  select t.snap_id, t.dbid, t.instance_number,
       t.file#, t.creation_change#, d.filename,
       d.ts#, coalesce(z.tsname, d.tsname) tsname, d.block_size,
       phyrds, phywrts, singleblkrds, readtim, writetim,
       singleblkrdtim, phyblkrd, phyblkwrt, wait_count, time,
       decode(t.con_dbid, 0, t.dbid, t.con_dbid),
       decode(t.per_pdb, 0, 0,
         con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid))) con_id
from AWR_CDB_SNAPSHOT sn, WRH$_TEMPSTATXS t, WRH$_TEMPFILE d, WRH$_TABLESPACE z
where     t.dbid             = d.dbid
      and t.file#            = d.file#
      and t.creation_change# = d.creation_change#
      and t.con_dbid         = d.dbid
      and sn.snap_id         = t.snap_id
      and sn.dbid            = t.dbid
      and sn.instance_number = t.instance_number
      and d.dbid             = z.dbid(+)
      and d.ts#              = z.ts#(+)
      and d.con_dbid         = z.con_dbid(+);

   COMMENT ON TABLE "SYS"."AWR_CDB_TEMPSTATXS"  IS 'Temporary Datafile Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_THREAD
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_THREAD"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "THREAD#", "THREAD_INSTANCE_NUMBER", "STATUS", "OPEN_TIME", "CURRENT_GROUP#", "SEQUENCE#", "CON_DBID", "CON_ID") AS 
  select th.snap_id, th.dbid, th.instance_number,
       thread#, thread_instance_number, th.status,
       open_time, current_group#, sequence#,
       decode(th.con_dbid, 0, th.dbid, th.con_dbid),
       decode(th.per_pdb, 0, 0,
         con_dbid_to_id(decode(th.con_dbid, 0, th.dbid, th.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_THREAD th
  where     sn.snap_id         = th.snap_id
        and sn.dbid            = th.dbid
        and sn.instance_number = th.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_THREAD"  IS 'Thread Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_TOPLEVELCALL_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_TOPLEVELCALL_NAME"  CONTAINER_DATA 
 ("DBID", "TOP_LEVEL_CALL#", "TOP_LEVEL_CALL_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, top_level_call#, top_level_call_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_TOPLEVELCALL_NAME;

   COMMENT ON TABLE "SYS"."AWR_CDB_TOPLEVELCALL_NAME"  IS 'Oracle top level call type'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_UNDOSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_UNDOSTAT"  CONTAINER_DATA 
 ("BEGIN_TIME", "END_TIME", "DBID", "INSTANCE_NUMBER", "SNAP_ID", "UNDOTSN", "UNDOBLKS", "TXNCOUNT", "MAXQUERYLEN", "MAXQUERYSQLID", "MAXCONCURRENCY", "UNXPSTEALCNT", "UNXPBLKRELCNT", "UNXPBLKREUCNT", "EXPSTEALCNT", "EXPBLKRELCNT", "EXPBLKREUCNT", "SSOLDERRCNT", "NOSPACEERRCNT", "ACTIVEBLKS", "UNEXPIREDBLKS", "EXPIREDBLKS", "TUNED_UNDORETENTION", "CON_DBID", "CON_ID") AS 
  select begin_time, end_time, ud.dbid, ud.instance_number,
       ud.snap_id, undotsn,
       undoblks, txncount, maxquerylen, maxquerysqlid,
       maxconcurrency, unxpstealcnt, unxpblkrelcnt, unxpblkreucnt,
       expstealcnt, expblkrelcnt, expblkreucnt, ssolderrcnt,
       nospaceerrcnt, activeblks, unexpiredblks, expiredblks,
       tuned_undoretention,
       decode(ud.con_dbid, 0, ud.dbid, ud.con_dbid),
       decode(ud.per_pdb, 0, 0,
         con_dbid_to_id(decode(ud.con_dbid, 0, ud.dbid, ud.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_UNDOSTAT ud
  where     sn.snap_id         = ud.snap_id
        and sn.dbid            = ud.dbid
        and sn.instance_number = ud.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_UNDOSTAT"  IS 'Undo Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_WAITCLASSMET_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_WAITCLASSMET_HISTORY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "WAIT_CLASS_ID", "WAIT_CLASS", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "AVERAGE_WAITER_COUNT", "DBTIME_IN_WAIT", "TIME_WAITED", "WAIT_COUNT", "TIME_WAITED_FG", "WAIT_COUNT_FG", "CON_DBID", "CON_ID") AS 
  select em.snap_id, em.dbid, em.instance_number,
       em.wait_class_id, wn.wait_class, begin_time, end_time, intsize,
       group_id, average_waiter_count, dbtime_in_wait,
       time_waited, wait_count, time_waited_fg, wait_count_fg,
       decode(em.con_dbid, 0, em.dbid, em.con_dbid),
       decode(em.per_pdb, 0, 0,
         con_dbid_to_id(decode(em.con_dbid, 0, em.dbid, em.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_WAITCLASSMETRIC_HISTORY em,
       (select wait_class_id, wait_class from wrh$_event_name
        group by wait_class_id, wait_class) wn
  where     em.wait_class_id   = wn.wait_class_id
        and sn.snap_id         = em.snap_id
        and sn.dbid            = em.dbid
        and sn.instance_number = em.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_WAITCLASSMET_HISTORY"  IS 'Wait Class Metric History'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_WAITSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_WAITSTAT"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CLASS", "WAIT_COUNT", "TIME", "CON_DBID", "CON_ID") AS 
  select wt.snap_id, wt.dbid, wt.instance_number,
       class, wait_count, time,
       decode(wt.con_dbid, 0, wt.dbid, wt.con_dbid),
       decode(wt.per_pdb, 0, 0,
         con_dbid_to_id(decode(wt.con_dbid, 0, wt.dbid, wt.con_dbid))) con_id
  from AWR_CDB_SNAPSHOT sn, WRH$_WAITSTAT wt
  where     sn.snap_id         = wt.snap_id
        and sn.dbid            = wt.dbid
        and sn.instance_number = wt.instance_number;

   COMMENT ON TABLE "SYS"."AWR_CDB_WAITSTAT"  IS 'Wait Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_WR_CONTROL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_WR_CONTROL"  CONTAINER_DATA 
 ("DBID", "SNAP_INTERVAL", "RETENTION", "TOPNSQL", "CON_ID", "SRC_DBID", "SRC_DBNAME") AS 
  select dbid, snap_interval, retention,
       decode(topnsql, 2000000000, 'DEFAULT',
                       2000000001, 'MAXIMUM',
                       to_char(topnsql, '999999999')) topnsql,
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id,
       decode(src_dbid, 0, dbid, src_dbid) src_dbid,
       src_dbname
from WRM$_WR_CONTROL;

   COMMENT ON TABLE "SYS"."AWR_CDB_WR_CONTROL"  IS 'Workload Repository Control Information'
;
--------------------------------------------------------
--  DDL for View AWR_CDB_WR_SETTINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_CDB_WR_SETTINGS"  CONTAINER_DATA 
 ("LOCAL_AWRDBID", "VIEW_LOCATION", "CON_ID") AS 
  select se.local_awrdbid,
       decode(se.view_location,0,'AWR_ROOT',1,'AWR_PDB','INVALID'),
       decode(con_dbid_to_id(se.local_awrdbid), 1, 0,
              con_dbid_to_id(se.local_awrdbid)) con_id
from WRM$_WR_SETTINGS se;

   COMMENT ON TABLE "SYS"."AWR_CDB_WR_SETTINGS"  IS 'Workload Repository Settings'
;
--------------------------------------------------------
--  DDL for View AWRI$_CDB_TS$
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWRI$_CDB_TS$"  CONTAINER_DATA 
 ("TS#", "NAME", "OWNER#", "ONLINE$", "CONTENTS$", "UNDOFILE#", "UNDOBLOCK#", "BLOCKSIZE", "INC#", "SCNWRP", "SCNBAS", "DFLMINEXT", "DFLMAXEXT", "DFLINIT", "DFLINCR", "DFLMINLEN", "DFLEXTPCT", "DFLOGGING", "AFFSTRENGTH", "BITMAPPED", "PLUGGED", "DIRECTALLOWED", "FLAGS", "PITRSCNWRP", "PITRSCNBAS", "OWNERINSTANCE", "BACKUPOWNER", "GROUPNAME", "SPARE1", "SPARE2", "SPARE3", "SPARE4", "CON_ID", "CON$NAME", "CDB$NAME", "CON$ERRNUM", "CON$ERRMSG") AS 
  SELECT k."TS#",k."NAME",k."OWNER#",k."ONLINE$",k."CONTENTS$",k."UNDOFILE#",k."UNDOBLOCK#",k."BLOCKSIZE",k."INC#",k."SCNWRP",k."SCNBAS",k."DFLMINEXT",k."DFLMAXEXT",k."DFLINIT",k."DFLINCR",k."DFLMINLEN",k."DFLEXTPCT",k."DFLOGGING",k."AFFSTRENGTH",k."BITMAPPED",k."PLUGGED",k."DIRECTALLOWED",k."FLAGS",k."PITRSCNWRP",k."PITRSCNBAS",k."OWNERINSTANCE",k."BACKUPOWNER",k."GROUPNAME",k."SPARE1",k."SPARE2",k."SPARE3",k."SPARE4",k."CON_ID", k.CON$NAME, k.CDB$NAME, k.CON$ERRNUM, k.CON$ERRMSG FROM CONTAINERS("SYS"."TS$") k;

   COMMENT ON COLUMN "SYS"."AWRI$_CDB_TS$"."CON_ID" IS 'container id';
   COMMENT ON COLUMN "SYS"."AWRI$_CDB_TS$"."CON$NAME" IS 'Container Name';
   COMMENT ON COLUMN "SYS"."AWRI$_CDB_TS$"."CDB$NAME" IS 'Database Name';
   COMMENT ON COLUMN "SYS"."AWRI$_CDB_TS$"."CON$ERRNUM" IS 'Error Number';
   COMMENT ON COLUMN "SYS"."AWRI$_CDB_TS$"."CON$ERRMSG" IS 'Error Message';
   COMMENT ON TABLE "SYS"."AWRI$_CDB_TS$"  IS ' in all containers'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_ACTIVE_SESS_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_ACTIVE_SESS_HISTORY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SAMPLE_ID", "SAMPLE_TIME", "SAMPLE_TIME_UTC", "USECS_PER_ROW", "SESSION_ID", "SESSION_SERIAL#", "SESSION_TYPE", "FLAGS", "USER_ID", "SQL_ID", "IS_SQLID_CURRENT", "SQL_CHILD_NUMBER", "SQL_OPCODE", "SQL_OPNAME", "FORCE_MATCHING_SIGNATURE", "TOP_LEVEL_SQL_ID", "TOP_LEVEL_SQL_OPCODE", "SQL_PLAN_HASH_VALUE", "SQL_FULL_PLAN_HASH_VALUE", "SQL_ADAPTIVE_PLAN_RESOLVED", "SQL_PLAN_LINE_ID", "SQL_PLAN_OPERATION", "SQL_PLAN_OPTIONS", "SQL_EXEC_ID", "SQL_EXEC_START", "PLSQL_ENTRY_OBJECT_ID", "PLSQL_ENTRY_SUBPROGRAM_ID", "PLSQL_OBJECT_ID", "PLSQL_SUBPROGRAM_ID", "QC_INSTANCE_ID", "QC_SESSION_ID", "QC_SESSION_SERIAL#", "PX_FLAGS", "EVENT", "EVENT_ID", "SEQ#", "P1TEXT", "P1", "P2TEXT", "P2", "P3TEXT", "P3", "WAIT_CLASS", "WAIT_CLASS_ID", "WAIT_TIME", "SESSION_STATE", "TIME_WAITED", "BLOCKING_SESSION_STATUS", "BLOCKING_SESSION", "BLOCKING_SESSION_SERIAL#", "BLOCKING_INST_ID", "BLOCKING_HANGCHAIN_INFO", "CURRENT_OBJ#", "CURRENT_FILE#", "CURRENT_BLOCK#", "CURRENT_ROW#", "TOP_LEVEL_CALL#", "TOP_LEVEL_CALL_NAME", "CONSUMER_GROUP_ID", "XID", "REMOTE_INSTANCE#", "TIME_MODEL", "IN_CONNECTION_MGMT", "IN_PARSE", "IN_HARD_PARSE", "IN_SQL_EXECUTION", "IN_PLSQL_EXECUTION", "IN_PLSQL_RPC", "IN_PLSQL_COMPILATION", "IN_JAVA_EXECUTION", "IN_BIND", "IN_CURSOR_CLOSE", "IN_SEQUENCE_LOAD", "IN_INMEMORY_QUERY", "IN_INMEMORY_POPULATE", "IN_INMEMORY_PREPOPULATE", "IN_INMEMORY_REPOPULATE", "IN_INMEMORY_TREPOPULATE", "IN_TABLESPACE_ENCRYPTION", "CAPTURE_OVERHEAD", "REPLAY_OVERHEAD", "IS_CAPTURED", "IS_REPLAYED", "IS_REPLAY_SYNC_TOKEN_HOLDER", "SERVICE_HASH", "PROGRAM", "MODULE", "ACTION", "CLIENT_ID", "MACHINE", "PORT", "ECID", "DBREPLAY_FILE_ID", "DBREPLAY_CALL_COUNTER", "TM_DELTA_TIME", "TM_DELTA_CPU_TIME", "TM_DELTA_DB_TIME", "DELTA_TIME", "DELTA_READ_IO_REQUESTS", "DELTA_WRITE_IO_REQUESTS", "DELTA_READ_IO_BYTES", "DELTA_WRITE_IO_BYTES", "DELTA_INTERCONNECT_IO_BYTES", "PGA_ALLOCATED", "TEMP_SPACE_ALLOCATED", "DBOP_NAME", "DBOP_EXEC_ID", "CON_DBID", "CON_ID") AS 
  select /* ASH/AWR meta attributes */
       ash.snap_id, ash.dbid, ash.instance_number,
       ash.sample_id, ash.sample_time, ash.sample_time_utc,
       ash.usecs_per_row,
       /* Session/User attributes */
       ash.session_id, ash.session_serial#,
       decode(ash.session_type, 1,'FOREGROUND', 'BACKGROUND'),
       ash.flags,
       ash.user_id,
       /* SQL attributes */
       ash.sql_id,
       decode(bitand(ash.flags, power(2, 4)), NULL, 'N', 0, 'N', 'Y'),
       ash.sql_child_number, ash.sql_opcode,
       (select command_name
          from WRH$_SQLCOMMAND_NAME s
         where s.command_type = ash.sql_opcode
           and s.dbid = ash.dbid
           and s.con_dbid = ash.dbid) as sql_opname,
       ash.force_matching_signature,
       decode(ash.top_level_sql_id, NULL, ash.sql_id, ash.top_level_sql_id),
       decode(ash.top_level_sql_id, NULL, ash.sql_opcode,
              ash.top_level_sql_opcode),
       /* SQL Plan/Execution attributes */
       ash.sql_plan_hash_value,
       ash.sql_full_plan_hash_value,
       ash.sql_adaptive_plan_resolved,
       decode(ash.sql_plan_line_id, 0, to_number(NULL), ash.sql_plan_line_id),
       (select operation_name
          from WRH$_PLAN_OPERATION_NAME pn
         where  pn.operation_id = ash.sql_plan_operation#
           and  pn.dbid = ash.dbid
           and  pn.con_dbid = ash.dbid) as sql_plan_operation,
       (select option_name
          from WRH$_PLAN_OPTION_NAME po
         where  po.option_id = ash.sql_plan_options#
           and  po.dbid = ash.dbid
           and  po.con_dbid = ash.dbid) as sql_plan_options,
       decode(ash.sql_exec_id, 0, to_number(NULL), ash.sql_exec_id),
       ash.sql_exec_start,
       /* PL/SQL attributes */
       decode(ash.plsql_entry_object_id,0,to_number(NULL),
              ash.plsql_entry_object_id),
       decode(ash.plsql_entry_object_id,0,to_number(NULL),
              ash.plsql_entry_subprogram_id),
       decode(ash.plsql_object_id,0,to_number(NULL),
              ash.plsql_object_id),
       decode(ash.plsql_object_id,0,to_number(NULL),
              ash.plsql_subprogram_id),
       /* PQ attributes */
       decode(ash.qc_session_id, 0, to_number(NULL), ash.qc_instance_id),
       decode(ash.qc_session_id, 0, to_number(NULL), ash.qc_session_id),
       decode(ash.qc_session_id, 0, to_number(NULL), ash.qc_session_serial#),
       decode(ash.px_flags,      0, to_number(NULL), ash.px_flags),
       /* Wait event attributes */
       decode(ash.wait_time, 0, evt.event_name, NULL),
       decode(ash.wait_time, 0, evt.event_id,   NULL),
       ash.seq#,
       evt.parameter1, ash.p1,
       evt.parameter2, ash.p2,
       evt.parameter3, ash.p3,
       decode(ash.wait_time, 0, evt.wait_class,    NULL),
       decode(ash.wait_time, 0, evt.wait_class_id, NULL),
       ash.wait_time,
       decode(ash.wait_time, 0, 'WAITING', 'ON CPU'),
       ash.time_waited,
       (case when ash.blocking_session = 4294967295
               then 'UNKNOWN'
             when ash.blocking_session = 4294967294
               then 'GLOBAL'
             when ash.blocking_session = 4294967293
               then 'UNKNOWN'
             when ash.blocking_session = 4294967292
               then 'NO HOLDER'
             when ash.blocking_session = 4294967291
               then 'NOT IN WAIT'
             else 'VALID'
        end),
       (case when ash.blocking_session between 4294967291 and 4294967295
               then to_number(NULL)
             else ash.blocking_session
        end),
       (case when ash.blocking_session between 4294967291 and 4294967295
               then to_number(NULL)
             else ash.blocking_session_serial#
        end),
       (case when ash.blocking_session between 4294967291 and 4294967295
               then to_number(NULL)
             else ash.blocking_inst_id
          end),
       (case when ash.blocking_session between 4294967291 and 4294967295
               then NULL
             else decode(bitand(ash.flags, power(2, 3)), NULL, 'N',
                         0, 'N', 'Y')
          end),
       /* Session's working context */
       ash.current_obj#, ash.current_file#, ash.current_block#,
       ash.current_row#, ash.top_level_call#,
       (select top_level_call_name
          from WRH$_TOPLEVELCALL_NAME t
         where top_level_call# = ash.top_level_call#
           and t.dbid = ash.dbid
           and t.con_dbid = ash.dbid) as top_level_call_name,
       decode(ash.consumer_group_id, 0, to_number(NULL),
              ash.consumer_group_id),
       ash.xid,
       decode(ash.remote_instance#, 0, to_number(NULL), ash.remote_instance#),
       ash.time_model,
       decode(bitand(ash.time_model,power(2, 3)),0,'N','Y')
                                                         as in_connection_mgmt,
       decode(bitand(ash.time_model,power(2, 4)),0,'N','Y')as in_parse,
       decode(bitand(ash.time_model,power(2, 7)),0,'N','Y')as in_hard_parse,
       decode(bitand(ash.time_model,power(2,10)),0,'N','Y')as in_sql_execution,
       decode(bitand(ash.time_model,power(2,11)),0,'N','Y')
                                                         as in_plsql_execution,
       decode(bitand(ash.time_model,power(2,12)),0,'N','Y')as in_plsql_rpc,
       decode(bitand(ash.time_model,power(2,13)),0,'N','Y')
                                                       as in_plsql_compilation,
       decode(bitand(ash.time_model,power(2,14)),0,'N','Y')
                                                       as in_java_execution,
       decode(bitand(ash.time_model,power(2,15)),0,'N','Y')as in_bind,
       decode(bitand(ash.time_model,power(2,16)),0,'N','Y')as in_cursor_close,
       decode(bitand(ash.time_model,power(2,17)),0,'N','Y')as in_sequence_load,
       decode(bitand(ash.time_model,power(2,18)),0,'N','Y')as in_inmemory_query,
       decode(bitand(ash.time_model,power(2,19)),0,'N','Y')
                                                        as in_inmemory_populate,
       decode(bitand(ash.time_model,power(2,20)),0,'N','Y')
                                                     as in_inmemory_prepopulate,
       decode(bitand(ash.time_model,power(2,21)),0,'N','Y')
                                                      as in_inmemory_repopulate,
       decode(bitand(ash.time_model,power(2,22)),0,'N','Y')
                                                     as in_inmemory_trepopulate,
       decode(bitand(ash.time_model,power(2,23)),0,'N','Y')
                                               as in_tablespace_encryption,
       decode(bitand(ash.flags,power(2,5)),NULL,'N',0,'N','Y')
                                                       as capture_overhead,
       decode(bitand(ash.flags,power(2,6)), NULL,'N',0,'N','Y' )
                                                           as replay_overhead,
       decode(bitand(ash.flags,power(2,0)),NULL,'N',0,'N','Y') as is_captured,
       decode(bitand(ash.flags,power(2,2)), NULL,'N',0,'N','Y' )as is_replayed,
       decode(bitand(ash.flags,power(2,8)), NULL,'N',0,'N','Y')
             as is_replay_sync_token_holder,
       /* Application attributes */
       ash.service_hash,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' then ash.program else null end program, -- Use macro to mask sensitive column
       substrb(ash.module,1,(select ksumodlen from x$modact_length)) module,
       substrb(ash.action,1,(select ksuactlen from x$modact_length)) action,
       ash.client_id,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' then ash.machine else null end machine, -- Use macro to mask sensitive column
       ash.port, ash.ecid,
       /* DB Replay info */
       ash.dbreplay_file_id, ash.dbreplay_call_counter,
       /* stash columns */
       ash.tm_delta_time,
       ash.tm_delta_cpu_time,
       ash.tm_delta_db_time,
       ash.delta_time,
       ash.delta_read_io_requests,
       ash.delta_write_io_requests,
       ash.delta_read_io_bytes,
       ash.delta_write_io_bytes,
       ash.delta_interconnect_io_bytes,
       ash.pga_allocated,
       ash.temp_space_allocated,
       ash.dbop_name,
       ash.dbop_exec_id,
       decode(ash.con_dbid, 0, ash.dbid, ash.con_dbid),
       decode(ash.per_pdb, 0, 0,
         con_dbid_to_id(decode(ash.con_dbid, 0, ash.dbid, ash.con_dbid))) con_id
from WRM$_SNAPSHOT sn, WRH$_ACTIVE_SESSION_HISTORY ash, WRH$_EVENT_NAME evt
where      ash.snap_id          = sn.snap_id(+)
      and  ash.dbid             = sn.dbid(+)
      and  ash.instance_number  = sn.instance_number(+)
      and  ash.dbid             = evt.dbid(+)
      and  ash.event_id         = evt.event_id(+);

   COMMENT ON TABLE "SYS"."AWR_PDB_ACTIVE_SESS_HISTORY"  IS 'Active Session Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_APPLY_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_APPLY_SUMMARY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "APPLY_NAME", "STARTUP_TIME", "READER_TOTAL_MESSAGES_DEQUEUED", "READER_LAG", "COORD_TOTAL_RECEIVED", "COORD_TOTAL_APPLIED", "COORD_TOTAL_ROLLBACKS", "COORD_TOTAL_WAIT_DEPS", "COORD_TOTAL_WAIT_CMTS", "COORD_LWM_LAG", "SERVER_TOTAL_MESSAGES_APPLIED", "SERVER_ELAPSED_DEQUEUE_TIME", "SERVER_ELAPSED_APPLY_TIME", "CON_DBID", "REPLICAT_NAME", "UNASSIGNED_COMPLETE_TXN", "TOTAL_LCRS_RETRIED", "TOTAL_TRANSACTIONS_RETRIED", "TOTAL_ERRORS", "SESSION_MODULE", "CON_ID") AS 
  select sas.snap_id, sas.dbid, sas.instance_number, sas.apply_name,
       sas.startup_time, sas.reader_total_messages_dequeued, sas.reader_lag,
       sas.coord_total_received, sas.coord_total_applied,
       sas.coord_total_rollbacks, sas.coord_total_wait_deps,
       sas.coord_total_wait_cmts, sas.coord_lwm_lag,
       sas.server_total_messages_applied, sas.server_elapsed_dequeue_time,
       sas.server_elapsed_apply_time,
       decode(sas.con_dbid, 0, sas.dbid, sas.con_dbid),
       sas.replicat_name, sas.unassigned_complete_txn,
       sas.total_lcrs_retried,
       sas.total_transactions_retried, sas.total_errors, sas.session_module,
       decode(sas.per_pdb, 0, 0,
         con_dbid_to_id(decode(sas.con_dbid, 0, sas.dbid, sas.con_dbid))) con_id
  from wrh$_streams_apply_sum sas, AWR_PDB_SNAPSHOT sn
  where sn.snap_id              = sas.snap_id
        and sn.dbid             = sas.dbid
        and sn.instance_number  = sas.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_APPLY_SUMMARY"  IS 'Streams/Goldengate/XStream Apply Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_ASH_SNAPSHOT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_ASH_SNAPSHOT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STARTUP_TIME", "BEGIN_INTERVAL_TIME", "END_INTERVAL_TIME", "FLUSH_ELAPSED", "SNAP_LEVEL", "STATUS", "ERROR_COUNT", "BL_MOVED", "SNAP_FLAG", "SNAP_TIMEZONE", "CON_ID") AS 
  select snap_id, dbid, instance_number, startup_time, begin_interval_time,
       end_interval_time, flush_elapsed, snap_level, status, error_count,
       bl_moved, snap_flag, snap_timezone,
       decode(con_dbid_to_id(s.dbid), 1, 0, con_dbid_to_id(s.dbid)) con_id
  from wrm$_snapshot s
 where s.status in (0,1)
   and s.flush_elapsed is not null
   and (s.snap_id,dbid,instance_number) not in
       (select e.snap_id,dbid,instance_number
          from WRM$_SNAP_ERROR e
         where e.table_name = 'WRH$_ACTIVE_SESSION_HISTORY')
;
--------------------------------------------------------
--  DDL for View AWR_PDB_ASM_BAD_DISK
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_ASM_BAD_DISK" ("SNAP_ID", "DBID", "GROUP_NUMBER", "NAME", "PATH", "STATUS", "CON_DBID", "CON_ID") AS 
  select tb.snap_id, tb.dbid,
       GROUP_NUMBER, NAME, PATH, STATUS,
       decode(con_dbid, 0, tb.dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, tb.dbid, con_dbid))) con_id
  from (select distinct snap_id, dbid
          from AWR_PDB_SNAPSHOT) sn,
       WRH$_ASM_BAD_DISK tb
  where sn.snap_id = tb.snap_id
    and sn.dbid    = tb.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_ASM_BAD_DISK"  IS 'Non-Online ASM Disks'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_ASM_DISKGROUP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_ASM_DISKGROUP" ("DBID", "CURRENT_SNAP_ID", "GROUP_NUMBER", "NAME", "TYPE", "CON_DBID", "CON_ID") AS 
  select dbid,
       CURRENT_SNAP_ID, GROUP_NUMBER, NAME, TYPE,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_ASM_DISKGROUP;

   COMMENT ON TABLE "SYS"."AWR_PDB_ASM_DISKGROUP"  IS 'ASM Diskgroups connected to this Database'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_ASM_DISKGROUP_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_ASM_DISKGROUP_STAT" ("SNAP_ID", "DBID", "GROUP_NUMBER", "TOTAL_MB", "FREE_MB", "NUM_DISK", "NUM_FAILGROUP", "STATE", "CON_DBID", "CON_ID") AS 
  select snap_id, dbid,
       GROUP_NUMBER, TOTAL_MB, FREE_MB, NUM_DISK, NUM_FAILGROUP, STATE,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_ASM_DISKGROUP_STAT;

   COMMENT ON TABLE "SYS"."AWR_PDB_ASM_DISKGROUP_STAT"  IS 'Statistics for ASM Diskgroup connected to this Database'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_ASM_DISK_STAT_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_ASM_DISK_STAT_SUMMARY"  CONTAINER_DATA 
 ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "GROUP_NUMBER", "READS", "WRITES", "READ_ERRS", "WRITE_ERRS", "READ_TIMEOUT", "WRITE_TIMEOUT", "READ_TIME", "WRITE_TIME", "BYTES_READ", "BYTES_WRITTEN", "CON_DBID", "CON_ID") AS 
  select snap_id, dbid, instance_number, GROUP_NUMBER,
       READS, WRITES, READ_ERRS, WRITE_ERRS, READ_TIMEOUT, WRITE_TIMEOUT,
       READ_TIME, WRITE_TIME, BYTES_READ, BYTES_WRITTEN,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_ASM_DISK_STAT_SUMMARY;

   COMMENT ON TABLE "SYS"."AWR_PDB_ASM_DISK_STAT_SUMMARY"  IS 'Statistics for ASM Disk summary statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_BASELINE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_BASELINE" ("DBID", "BASELINE_ID", "BASELINE_NAME", "BASELINE_TYPE", "START_SNAP_ID", "START_SNAP_TIME", "END_SNAP_ID", "END_SNAP_TIME", "MOVING_WINDOW_SIZE", "CREATION_TIME", "EXPIRATION", "TEMPLATE_NAME", "LAST_TIME_COMPUTED", "CON_ID") AS 
  select bl.dbid, bl.baseline_id,
       bl.baseline_name, max(bl.baseline_type),
       min(bst.start_snap_id), min(bst.start_snap_time),
       max(bst.end_snap_id),   max(bst.end_snap_time),
       max(bl.moving_window_size), max(bl.creation_time),
       max(bl.expiration), max(bl.template_name),
       max(bl.last_time_computed),
       decode(con_dbid_to_id(bl.dbid), 1, 0, con_dbid_to_id(bl.dbid)) con_id
from
  WRM$_BASELINE bl, WRM$_BASELINE_DETAILS bst
where
  bl.dbid = bst.dbid and
  bl.baseline_id != 0 and
  bl.baseline_id = bst.baseline_id
group by bl.dbid, bl.baseline_id, baseline_name
union all
select bl.dbid, bl.baseline_id,
       bl.baseline_name, max(bl.baseline_type),
       min(bst.start_snap_id), min(bst.start_snap_time),
       max(bst.end_snap_id),   max(bst.end_snap_time),
       max(bl.moving_window_size), max(bl.creation_time),
       max(bl.expiration), max(bl.template_name),
       max(bl.last_time_computed),
       decode(con_dbid_to_id(bl.dbid), 1, 0, con_dbid_to_id(bl.dbid)) con_id
from
  WRM$_BASELINE bl,  /* Note: moving window stats only for local dbid */
  table(dbms_workload_repository.select_baseline_details(bl.baseline_id)) bst
where
  bl.dbid = bst.dbid and
  bl.baseline_id = 0 and
  bl.baseline_id = bst.baseline_id
group by bl.dbid, bl.baseline_id, baseline_name;

   COMMENT ON TABLE "SYS"."AWR_PDB_BASELINE"  IS 'Baseline Metadata Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_BASELINE_DETAILS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_BASELINE_DETAILS" ("DBID", "INSTANCE_NUMBER", "BASELINE_ID", "BASELINE_NAME", "BASELINE_TYPE", "START_SNAP_ID", "START_SNAP_TIME", "END_SNAP_ID", "END_SNAP_TIME", "SHUTDOWN", "ERROR_COUNT", "PCT_TOTAL_TIME", "LAST_TIME_COMPUTED", "MOVING_WINDOW_SIZE", "CREATION_TIME", "EXPIRATION", "TEMPLATE_NAME", "CON_ID") AS 
  select bl.dbid, bst.instance_number,
       bl.baseline_id, bl.baseline_name, bl.baseline_type,
       bst.start_snap_id, bst.start_snap_time,
       bst.end_snap_id,   bst.end_snap_time,
       bst.shutdown, bst.error_count, bst.pct_total_time,
       bl.last_time_computed,
       bl.moving_window_size, bl.creation_time,
       bl.expiration, bl.template_name,
       decode(con_dbid_to_id(bl.dbid), 1, 0, con_dbid_to_id(bl.dbid)) con_id
from
  WRM$_BASELINE bl, WRM$_BASELINE_DETAILS bst
where
  bl.dbid = bst.dbid and
  bl.baseline_id != 0 and
  bl.baseline_id = bst.baseline_id
union all
select bl.dbid, bst.instance_number,
       bl.baseline_id, bl.baseline_name, bl.baseline_type,
       bst.start_snap_id, bst.start_snap_time,
       bst.end_snap_id,   bst.end_snap_time,
       bst.shutdown, bst.error_count, bst.pct_total_time,
       bl.last_time_computed,
       bl.moving_window_size, bl.creation_time,
       bl.expiration, bl.template_name,
       decode(con_dbid_to_id(bl.dbid), 1, 0, con_dbid_to_id(bl.dbid)) con_id
from
  WRM$_BASELINE bl,  /* Note: moving window stats only for local dbid */
  table(dbms_workload_repository.select_baseline_details(bl.baseline_id)) bst
where
  bl.dbid = bst.dbid and
  bl.baseline_id = 0 and
  bl.baseline_id = bst.baseline_id;

   COMMENT ON TABLE "SYS"."AWR_PDB_BASELINE_DETAILS"  IS 'Baseline Stats on per Instance Level'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_BASELINE_METADATA
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_BASELINE_METADATA" ("DBID", "BASELINE_ID", "BASELINE_NAME", "BASELINE_TYPE", "START_SNAP_ID", "END_SNAP_ID", "MOVING_WINDOW_SIZE", "CREATION_TIME", "EXPIRATION", "TEMPLATE_NAME", "LAST_TIME_COMPUTED", "CON_ID") AS 
  select dbid, baseline_id,
       baseline_name, baseline_type,
       start_snap_id, end_snap_id,
       moving_window_size, creation_time,
       expiration, template_name, last_time_computed,
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from
  WRM$_BASELINE;

   COMMENT ON TABLE "SYS"."AWR_PDB_BASELINE_METADATA"  IS 'Baseline Metadata Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_BASELINE_TEMPLATE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_BASELINE_TEMPLATE" ("DBID", "TEMPLATE_ID", "TEMPLATE_NAME", "TEMPLATE_TYPE", "BASELINE_NAME_PREFIX", "START_TIME", "END_TIME", "DAY_OF_WEEK", "HOUR_IN_DAY", "DURATION", "EXPIRATION", "REPEAT_INTERVAL", "LAST_GENERATED", "CON_ID") AS 
  select dbid, template_id, template_name, template_type,
       baseline_name_prefix, start_time, end_time,
       day_of_week, hour_in_day, duration,
       expiration, repeat_interval, last_generated,
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from
  WRM$_BASELINE_TEMPLATE;

   COMMENT ON TABLE "SYS"."AWR_PDB_BASELINE_TEMPLATE"  IS 'Baseline Template Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_BG_EVENT_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_BG_EVENT_SUMMARY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EVENT_ID", "EVENT_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "TOTAL_WAITS", "TOTAL_TIMEOUTS", "TIME_WAITED_MICRO", "CON_DBID", "CON_ID") AS 
  select e.snap_id, e.dbid, e.instance_number,
       e.event_id, en.event_name, en.wait_class_id, en.wait_class,
       total_waits, total_timeouts, time_waited_micro,
       decode(e.con_dbid, 0, e.dbid, e.con_dbid),
       decode(e.per_pdb, 0, 0,
         con_dbid_to_id(decode(e.con_dbid, 0, e.dbid, e.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_BG_EVENT_SUMMARY e, WRH$_EVENT_NAME en
where     sn.snap_id         = e.snap_id
      and sn.dbid            = e.dbid
      and sn.instance_number = e.instance_number
      and e.event_id         = en.event_id
      and e.dbid             = en.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_BG_EVENT_SUMMARY"  IS 'Summary of Background Event Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_BUFFERED_QUEUES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_BUFFERED_QUEUES" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_SCHEMA", "QUEUE_NAME", "STARTUP_TIME", "QUEUE_ID", "NUM_MSGS", "SPILL_MSGS", "CNUM_MSGS", "CSPILL_MSGS", "EXPIRED_MSGS", "OLDEST_MSGID", "OLDEST_MSG_ENQTM", "QUEUE_STATE", "ELAPSED_ENQUEUE_TIME", "ELAPSED_DEQUEUE_TIME", "ELAPSED_TRANSFORMATION_TIME", "ELAPSED_RULE_EVALUATION_TIME", "ENQUEUE_CPU_TIME", "DEQUEUE_CPU_TIME", "LAST_ENQUEUE_TIME", "LAST_DEQUEUE_TIME", "CON_DBID", "CON_ID") AS 
  select qs.snap_id, qs.dbid, qs.instance_number, qs.queue_schema, qs.queue_name,
       qs.startup_time, qs.queue_id, qs.num_msgs, qs.spill_msgs, qs.cnum_msgs,
       qs.cspill_msgs, qs.expired_msgs, qs.oldest_msgid, qs.oldest_msg_enqtm,
       qs.queue_state, qs.elapsed_enqueue_time,
       qs.elapsed_dequeue_time, qs.elapsed_transformation_time,
       qs.elapsed_rule_evaluation_time, qs.enqueue_cpu_time,
       qs.dequeue_cpu_time, qs.last_enqueue_time, qs.last_dequeue_time,
       decode(qs.con_dbid, 0, qs.dbid, qs.con_dbid),
       decode(qs.per_pdb, 0, 0,
         con_dbid_to_id(decode(qs.con_dbid, 0, qs.dbid, qs.con_dbid))) con_id
  from wrh$_buffered_queues qs, AWR_PDB_SNAPSHOT sn
  where     sn.snap_id          = qs.snap_id
        and sn.dbid             = qs.dbid
        and sn.instance_number  = qs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_BUFFERED_QUEUES"  IS 'STREAMS Buffered Queues Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_BUFFERED_SUBSCRIBERS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_BUFFERED_SUBSCRIBERS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_SCHEMA", "QUEUE_NAME", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "SUBSCRIBER_ADDRESS", "SUBSCRIBER_TYPE", "STARTUP_TIME", "LAST_BROWSED_SEQ", "LAST_BROWSED_NUM", "LAST_DEQUEUED_SEQ", "LAST_DEQUEUED_NUM", "CURRENT_ENQ_SEQ", "NUM_MSGS", "CNUM_MSGS", "TOTAL_DEQUEUED_MSG", "TOTAL_SPILLED_MSG", "EXPIRED_MSGS", "MESSAGE_LAG", "ELAPSED_DEQUEUE_TIME", "DEQUEUE_CPU_TIME", "LAST_DEQUEUE_TIME", "OLDEST_MSGID", "OLDEST_MSG_ENQTM", "CON_DBID", "CON_ID") AS 
  select ss.snap_id, ss.dbid, ss.instance_number, ss.queue_schema, ss.queue_name,
       ss.subscriber_id, ss.subscriber_name, ss.subscriber_address,
       ss.subscriber_type, ss.startup_time, ss.last_browsed_seq,
       ss.last_browsed_num, ss.last_dequeued_seq, ss.last_dequeued_num,
       ss.current_enq_seq, ss.num_msgs, ss.cnum_msgs,
       ss.total_dequeued_msg, ss.total_spilled_msg, ss.expired_msgs,
       ss.message_lag, ss.elapsed_dequeue_time, ss.dequeue_cpu_time,
       ss.last_dequeue_time, ss.oldest_msgid, ss.oldest_msg_enqtm,
       decode(ss.con_dbid, 0, ss.dbid, ss.con_dbid),
       decode(ss.per_pdb, 0, 0,
         con_dbid_to_id(decode(ss.con_dbid, 0, ss.dbid, ss.con_dbid))) con_id
  from wrh$_buffered_subscribers ss, AWR_PDB_SNAPSHOT sn
  where     sn.snap_id          = ss.snap_id
        and sn.dbid             = ss.dbid
        and sn.instance_number  = ss.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_BUFFERED_SUBSCRIBERS"  IS 'STREAMS Buffered Queue Subscribers Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_BUFFER_POOL_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_BUFFER_POOL_STAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "ID", "NAME", "BLOCK_SIZE", "SET_MSIZE", "CNUM_REPL", "CNUM_WRITE", "CNUM_SET", "BUF_GOT", "SUM_WRITE", "SUM_SCAN", "FREE_BUFFER_WAIT", "WRITE_COMPLETE_WAIT", "BUFFER_BUSY_WAIT", "FREE_BUFFER_INSPECTED", "DIRTY_BUFFERS_INSPECTED", "DB_BLOCK_CHANGE", "DB_BLOCK_GETS", "CONSISTENT_GETS", "PHYSICAL_READS", "PHYSICAL_WRITES", "CON_DBID", "CON_ID") AS 
  select bp.snap_id, bp.dbid, bp.instance_number,
       id, name, block_size, set_msize,
       cnum_repl, cnum_write, cnum_set, buf_got, sum_write, sum_scan,
       free_buffer_wait, write_complete_wait, buffer_busy_wait,
       free_buffer_inspected, dirty_buffers_inspected,
       db_block_change, db_block_gets, consistent_gets,
       physical_reads, physical_writes,
       decode(bp.con_dbid, 0, bp.dbid, bp.con_dbid),
       decode(bp.per_pdb, 0, 0,
         con_dbid_to_id(decode(bp.con_dbid, 0, bp.dbid, bp.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_BUFFER_POOL_STATISTICS bp
  where     sn.snap_id         = bp.snap_id
        and sn.dbid            = bp.dbid
        and sn.instance_number = bp.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_BUFFER_POOL_STAT"  IS 'Buffer Pool Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CAPTURE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CAPTURE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CAPTURE_NAME", "STARTUP_TIME", "LAG", "TOTAL_MESSAGES_CAPTURED", "TOTAL_MESSAGES_ENQUEUED", "ELAPSED_RULE_TIME", "ELAPSED_ENQUEUE_TIME", "ELAPSED_REDO_WAIT_TIME", "ELAPSED_PAUSE_TIME", "CON_DBID", "EXTRACT_NAME", "BYTES_REDO_MINED", "BYTES_SENT", "SESSION_MODULE", "CON_ID") AS 
  select cs.snap_id, cs.dbid, cs.instance_number, cs.capture_name,
       cs.startup_time, cs.lag,
       cs.total_messages_captured, cs.total_messages_enqueued,
       cs.elapsed_rule_time, cs.elapsed_enqueue_time,
       cs.elapsed_redo_wait_time, cs.elapsed_pause_time,
       decode(cs.con_dbid, 0, cs.dbid, cs.con_dbid),
       cs.extract_name,
       cs.bytes_redo_mined, cs.bytes_sent, cs.session_module,
       decode(cs.per_pdb, 0, 0,
         con_dbid_to_id(decode(cs.con_dbid, 0, cs.dbid, cs.con_dbid))) con_id
  from wrh$_streams_capture cs, AWR_PDB_SNAPSHOT sn
  where sn.snap_id              = cs.snap_id
        and sn.dbid             = cs.dbid
        and sn.instance_number  = cs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CAPTURE"  IS 'Streams/GoldenGate/XStream Capture Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_CONFIG
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_CONFIG" ("DBID", "CURRENT_SNAP_ID", "CELLNAME", "CELLHASH", "CONFTYPE", "CONFVAL_HASH", "CONFVAL", "CON_DBID", "CON_ID") AS 
  select dbid, CURRENT_SNAP_ID,
       CELLNAME, CELLHASH, CONFTYPE, CONFVAL_HASH, CONFVAL,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_CELL_CONFIG;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_CONFIG"  IS 'Exadata configuration information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_CONFIG_DETAIL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_CONFIG_DETAIL" ("SNAP_ID", "DBID", "CELLNAME", "CELLHASH", "CONFTYPE", "CONFVAL_HASH", "CONFVAL", "CON_DBID", "CON_ID") AS 
  select d.snap_id, d.dbid,
       c.CELLNAME, d.CELLHASH, d.CONFTYPE, d.CONFVAL_HASH, c.CONFVAL,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid),
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
  from WRH$_CELL_CONFIG c,
       WRH$_CELL_CONFIG_DETAIL d
 where c.dbid = d.dbid
   and c.cellhash = d.cellhash
   and c.conftype = d.conftype
   and c.confval_hash = d.confval_hash;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_CONFIG_DETAIL"  IS 'Exadata configuration information per snapshot'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_DB
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_DB" ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "SRC_DBID", "SRC_DBNAME", "DISK_REQUESTS", "DISK_BYTES", "FLASH_REQUESTS", "FLASH_BYTES", "DISK_SMALL_IO_REQS", "DISK_LARGE_IO_REQS", "FLASH_SMALL_IO_REQS", "FLASH_LARGE_IO_REQS", "DISK_SMALL_IO_SERVICE_TIME", "DISK_SMALL_IO_QUEUE_TIME", "DISK_LARGE_IO_SERVICE_TIME", "DISK_LARGE_IO_QUEUE_TIME", "FLASH_SMALL_IO_SERVICE_TIME", "FLASH_SMALL_IO_QUEUE_TIME", "FLASH_LARGE_IO_SERVICE_TIME", "FLASH_LARGE_IO_QUEUE_TIME", "IS_CURRENT_SRC_DB", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.cell_hash, s.incarnation_num,
       s.src_dbid, s.src_dbname,
       s.disk_requests, s.disk_bytes, s.flash_requests, s.flash_bytes,
       s.disk_small_io_reqs, s.disk_large_io_reqs,
       s.flash_small_io_reqs, s.flash_large_io_reqs,
       s.disk_small_io_service_time, s. disk_small_io_queue_time,
       s.disk_large_io_service_time, s.disk_large_io_queue_time,
       s.flash_small_io_service_time, s. flash_small_io_queue_time,
       s.flash_large_io_service_time, s.flash_large_io_queue_time,
       s.is_current_src_db,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from WRH$_CELL_DB s,
    (select distinct snap_id, dbid
       from AWR_PDB_SNAPSHOT) sn
where  s.snap_id          = sn.snap_id
  and  s.dbid             = sn.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_DB"  IS 'Cell Database IO Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_DISK_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_DISK_NAME" ("DBID", "SNAP_ID", "CELL_HASH", "DISK_ID", "DISK_NAME", "DISK", "CON_DBID", "CON_ID") AS 
  select dbid,
       snap_id,
       cell_hash,
       to_number(substr(id,length(id)-8+1),'XXXXXXXX') disk_id,
       disk_name,
       disk,
       decode(con_dbid, 0, dbid, con_dbid) con_dbid,
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from (
    select d.dbid, d.con_dbid,
           d.snap_id, d.per_pdb,
           d.cellhash cell_hash,
           extractvalue(value(t),'/celldisk/id') id,
           extractvalue(value(t),'/celldisk/name') disk_name,
           extractvalue(value(t),'/celldisk/diskType') disk
      from wrh$_cell_config_detail d,
           wrh$_cell_config c,
           table(xmlsequence(extract(xmltype(c.confval),
                                    '/cli-output/celldisk'))) t
     where d.dbid = c.dbid
       and d.cellhash = c.cellhash
       and d.conftype = c.conftype
       and d.confval_hash = c.confval_hash
       and c.conftype = 'CELLDISK');

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_DISK_NAME"  IS 'Exadata Cell disk names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_DISK_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_DISK_SUMMARY" ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "DISK_ID", "NUM_SAMPLES", "DISK_UTILIZATION_SUM", "READS_SUM", "READ_MB_SUM", "WRITES_SUM", "WRITE_MB_SUM", "IO_REQUESTS_SUM", "IO_MB_SUM", "SERVICE_TIME_SUM", "WAIT_TIME_SUM", "SMALL_READS_SUM", "SMALL_WRITES_SUM", "LARGE_READS_SUM", "LARGE_WRITES_SUM", "SMALL_READ_BYTES_SUM", "SMALL_WRITE_BYTES_SUM", "LARGE_READ_BYTES_SUM", "LARGE_WRITE_BYTES_SUM", "SMALL_READ_LATENCY_SUM", "SMALL_WRITE_LATENCY_SUM", "LARGE_READ_LATENCY_SUM", "LARGE_WRITE_LATENCY_SUM", "APP_IO_REQUESTS_SUM", "APP_IO_BYTES_SUM", "APP_IO_LATENCY_SUM", "DISK_UTILIZATION_SUMX2", "READS_SUMX2", "READ_MB_SUMX2", "WRITES_SUMX2", "WRITE_MB_SUMX2", "IO_REQUESTS_SUMX2", "IO_MB_SUMX2", "SERVICE_TIME_SUMX2", "WAIT_TIME_SUMX2", "SMALL_READS_SUMX2", "SMALL_WRITES_SUMX2", "LARGE_READS_SUMX2", "LARGE_WRITES_SUMX2", "SMALL_READ_BYTES_SUMX2", "SMALL_WRITE_BYTES_SUMX2", "LARGE_READ_BYTES_SUMX2", "LARGE_WRITE_BYTES_SUMX2", "SMALL_READ_LATENCY_SUMX2", "SMALL_WRITE_LATENCY_SUMX2", "LARGE_READ_LATENCY_SUMX2", "LARGE_WRITE_LATENCY_SUMX2", "APP_IO_REQUESTS_SUMX2", "APP_IO_BYTES_SUMX2", "APP_IO_LATENCY_SUMX2", "DISK_UTILIZATION_AVG", "READS_AVG", "READ_MB_AVG", "WRITES_AVG", "WRITE_MB_AVG", "IO_REQUESTS_AVG", "IO_MB_AVG", "SERVICE_TIME_AVG", "SMALL_READS_AVG", "SMALL_WRITES_AVG", "LARGE_READS_AVG", "LARGE_WRITES_AVG", "SMALL_READ_BYTES_AVG", "SMALL_WRITE_BYTES_AVG", "LARGE_READ_BYTES_AVG", "LARGE_WRITE_BYTES_AVG", "SMALL_READ_LATENCY_AVG", "SMALL_WRITE_LATENCY_AVG", "LARGE_READ_LATENCY_AVG", "LARGE_WRITE_LATENCY_AVG", "APP_IO_REQUESTS_AVG", "APP_IO_BYTES_AVG", "APP_IO_LATENCY_AVG", "CON_DBID", "CON_ID") AS 
  select cd.snap_id, cd.dbid, cd.cell_hash, cd.incarnation_num,
       cd.disk_id disk_id,
       num_samples,
       disk_utilization_sum,
       reads_sum, read_mb_sum, writes_sum, write_mb_sum,
       io_requests_sum, io_mb_sum,
       service_time_sum,wait_time_sum,
       small_reads_sum,small_writes_sum,large_reads_sum,large_writes_sum,
       small_read_bytes_sum,small_write_bytes_sum,
       large_read_bytes_sum,large_write_bytes_sum,
       small_read_latency_sum, small_write_latency_sum,
       large_read_latency_sum, large_write_latency_sum,
       app_io_requests_sum, app_io_bytes_sum, app_io_latency_sum,
       disk_utilization_sumx2,
       reads_sumx2, read_mb_sumx2, writes_sumx2, write_mb_sumx2,
       io_requests_sumx2, io_mb_sumx2,
       service_time_sumx2,wait_time_sumx2,
       small_reads_sumx2,small_writes_sumx2,
       large_reads_sumx2,large_writes_sumx2,
       small_read_bytes_sumx2,small_write_bytes_sumx2,
       large_read_bytes_sumx2,large_write_bytes_sumx2,
       small_read_latency_sumx2, small_write_latency_sumx2,
       large_read_latency_sumx2, large_write_latency_sumx2,
       app_io_requests_sumx2, app_io_bytes_sumx2, app_io_latency_sumx2,
       disk_utilization_sum/num_samples disk_utilization_avg,
       reads_sum/num_samples      reads_avg,
       read_mb_sum/num_samples    read_mb_avg,
       writes_sum/num_samples     writes_avg,
       write_mb_sum/num_samples   write_mb_avg,
       io_requests_sum/num_samples         io_requests_avg,
       io_mb_sum/num_samples      io_mb_avg,
       service_time_sum/num_samples service_time_avg,
       small_reads_sum/num_samples      small_reads_avg,
       small_writes_sum/num_samples     small_writes_avg,
       large_reads_sum/num_samples      large_reads_avg,
       large_writes_sum/num_samples     large_writes_avg,
       small_read_bytes_sum/num_samples   small_read_bytes_avg,
       small_write_bytes_sum/num_samples  small_write_bytes_avg,
       large_read_bytes_sum/num_samples   large_read_bytes_avg,
       large_write_bytes_sum/num_samples  large_write_bytes_avg,
       small_read_latency_sum/num_samples small_read_latency_avg,
       small_write_latency_sum/num_samples small_write_latency_avg,
       large_read_latency_sum/num_samples  large_read_latency_avg,
       large_write_latency_sum/num_samples large_write_latency_avg,
       app_io_requests_sum/num_samples app_io_requests_avg,
       app_io_bytes_sum/num_samples   app_io_bytes_avg,
       app_io_latency_sum/num_samples app_io_latency_avg,
       decode(cd.con_dbid, 0, cd.dbid, cd.con_dbid),
       decode(cd.per_pdb, 0, 0,
         con_dbid_to_id(decode(cd.con_dbid, 0, cd.dbid, cd.con_dbid))) con_id
  from wrh$_cell_disk_summary cd,
      (select distinct snap_id, dbid
         from AWR_PDB_SNAPSHOT)  sn
  where     sn.snap_id          = cd.snap_id
        and sn.dbid             = cd.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_DISK_SUMMARY"  IS 'Cell Disk Summary Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_DISKTYPE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_DISKTYPE" ("DBID", "SNAP_ID", "CELL_HASH", "CELL_NAME", "HARD_DISK_TYPE", "FLASH_DISK_TYPE", "NUM_CELL_DISKS", "NUM_GRID_DISKS", "NUM_HARD_DISKS", "NUM_FLASH_DISKS", "MAX_DISK_IOPS", "MAX_FLASH_IOPS", "MAX_DISK_MBPS", "MAX_FLASH_MBPS", "MAX_CELL_DISK_IOPS", "MAX_CELL_FLASH_IOPS", "MAX_CELL_DISK_MBPS", "MAX_CELL_FLASH_MBPS", "CONFVAL", "CON_DBID", "CON_ID") AS 
  select d.dbid,
       d.snap_id,
       c.cellhash cell_hash,
       extractvalue(xmltype(c.confval),'/cli-output/context/@cell') cell_name,
       extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/hardDiskType') hard_disk_type,
       extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/flashDiskType') flash_disk_type,
       to_number(extractvalue(xmltype(c.confval),
                   '/cli-output/not-set/numCellDisks'))  num_cell_disks,
       to_number(extractvalue(xmltype(c.confval),
                   '/cli-output/not-set/numGridDisks'))  num_grid_disks,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numHardDisks'))  num_hard_disks,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numFlashDisks'))  num_flash_disks,
       to_number(
         extractvalue(xmltype(c.confval),'/cli-output/not-set/maxPDIOPS'))
                                                            max_disk_iops,
       to_number(
         extractvalue(xmltype(c.confval),'/cli-output/not-set/maxFDIOPS'))
                                                           max_flash_iops,
       to_number(
         extractvalue(xmltype(c.confval),'/cli-output/not-set/maxPDMBPS'))
                                                           max_disk_mbps,
       to_number(
         extractvalue(xmltype(c.confval),'/cli-output/not-set/maxFDMBPS'))
                                                         max_flash_mbps,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numHardDisks')) *
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/maxPDIOPS'))  max_cell_disk_iops,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numFlashDisks')) *
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/maxFDIOPS'))  max_cell_flash_iops,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numHardDisks')) *
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/maxPDMBPS'))  max_cell_disk_mbps,
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/numFlashDisks')) *
       to_number(extractvalue(xmltype(c.confval),
                    '/cli-output/not-set/maxFDMBPS'))  max_cell_flash_mbps,
       c.confval,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid) con_dbid,
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
  from wrh$_cell_config_detail d,
       wrh$_cell_config c
 where d.dbid = c.dbid
   and d.cellhash = c.cellhash
   and d.conftype = c.conftype
   and d.confval_hash = c.confval_hash
   and c.conftype = 'AWRXML';

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_DISKTYPE"  IS 'Exadata Cell disk types'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_GLOBAL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_GLOBAL" ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "METRIC_ID", "METRIC_NAME", "METRIC_VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.cell_hash, s.incarnation_num,
       s.metric_id, nm.metric_name, s.metric_value,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from WRH$_CELL_GLOBAL s,
     WRH$_CELL_METRIC_DESC nm,
    (select distinct snap_id, dbid
       from AWR_PDB_SNAPSHOT) sn
where      s.metric_id        = nm.metric_id
      and  s.dbid             = nm.dbid
      and  s.snap_id          = sn.snap_id
      and  s.dbid             = sn.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_GLOBAL"  IS 'Cell Global Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_GLOBAL_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_GLOBAL_SUMMARY" ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "NUM_SAMPLES", "CPU_USAGE_SUM", "SYS_USAGE_SUM", "USER_USAGE_SUM", "NETWORK_BYTES_RECD_SUM", "NETWORK_BYTES_SENT_SUM", "CPU_USAGE_SUMX2", "SYS_USAGE_SUMX2", "USER_USAGE_SUMX2", "NETWORK_BYTES_RECD_SUMX2", "NETWORK_BYTES_SENT_SUMX2", "CPU_USAGE_AVG", "SYS_USAGE_AVG", "USER_USAGE_AVG", "NETWORK_BYTES_RECD_AVG", "NETWORK_BYTES_SENT_AVG", "CON_DBID", "CON_ID") AS 
  select cg.snap_id, cg.dbid, cg.cell_hash, cg.incarnation_num,
       num_samples,
       cpu_usage_sum, sys_usage_sum, user_usage_sum,
       network_bytes_recd_sum, network_bytes_sent_sum,
       cpu_usage_sumx2, sys_usage_sumx2, user_usage_sumx2,
       network_bytes_recd_sumx2, network_bytes_sent_sumx2,
       cpu_usage_sum/num_samples cpu_usage_avg,
       sys_usage_sum/num_samples sys_usage_avg,
       user_usage_sum/num_samples user_usage_avg,
       network_bytes_recd_sum/num_samples network_bytes_recd_avg,
       network_bytes_sent_sum/num_samples network_bytes_sent_avg,
       decode(cg.con_dbid, 0, cg.dbid, cg.con_dbid),
       decode(cg.per_pdb, 0, 0,
         con_dbid_to_id(decode(cg.con_dbid, 0, cg.dbid, cg.con_dbid))) con_id
  from wrh$_cell_global_summary cg,
      (select distinct snap_id, dbid
         from AWR_PDB_SNAPSHOT)  sn
  where     sn.snap_id          = cg.snap_id
        and sn.dbid             = cg.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_GLOBAL_SUMMARY"  IS 'Cell Global Summary Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_IOREASON
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_IOREASON" ("SNAP_ID", "DBID", "CELL_HASH", "INCARNATION_NUM", "REASON_ID", "REASON_NAME", "REQUESTS", "BYTES", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.cell_hash, s.incarnation_num,
       s.reason_id, nm.reason_name, s.requests, s.bytes,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from WRH$_CELL_IOREASON s,
     WRH$_CELL_IOREASON_NAME nm,
    (select distinct snap_id, dbid
       from AWR_PDB_SNAPSHOT) sn
where      s.reason_id        = nm.reason_id
      and  s.dbid             = nm.dbid
      and  s.snap_id          = sn.snap_id
      and  s.dbid             = sn.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_IOREASON"  IS 'Cell IO Reason Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_IOREASON_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_IOREASON_NAME" ("DBID", "REASON_ID", "REASON_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, reason_id, reason_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_CELL_IOREASON_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_IOREASON_NAME"  IS 'Cell IO Reason Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_METRIC_DESC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_METRIC_DESC" ("DBID", "METRIC_ID", "METRIC_NAME", "METRIC_TYPE", "CON_DBID", "CON_ID") AS 
  select dbid, metric_id, metric_name, metric_type,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_CELL_METRIC_DESC;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_METRIC_DESC"  IS 'Cell Metric Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_NAME" ("DBID", "SNAP_ID", "CELL_HASH", "CELL_NAME", "CON_DBID", "CON_ID") AS 
  select d.dbid,
       d.snap_id,
       c.cellhash cell_hash,
       extractvalue(xmltype(c.confval),'/cli-output/cell/name') cell_name,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid) con_dbid,
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
  from wrh$_cell_config_detail d,
       wrh$_cell_config c
 where d.dbid = c.dbid
   and d.cellhash = c.cellhash
   and d.conftype = c.conftype
   and d.confval_hash = c.confval_hash
   and c.conftype = 'CELL';

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_NAME"  IS 'Exadata Cell names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CELL_OPEN_ALERTS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CELL_OPEN_ALERTS" ("SNAP_ID", "DBID", "CELL_HASH", "BEGIN_TIME", "SEQ_NO", "MESSAGE", "STATEFUL", "SEVERITY", "CELL_ALERT_SUMMARY", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.cell_hash,
       s.begin_time, s.seq_no, s.message,
       decode(s.stateful,1,'Y','N') stateful,
       s.severity,
       s.cell_alert_summary,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from WRH$_CELL_OPEN_ALERTS s,
    (select distinct snap_id, dbid
       from AWR_PDB_SNAPSHOT) sn
where  s.snap_id          = sn.snap_id
  and  s.dbid             = sn.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_CELL_OPEN_ALERTS"  IS 'Cell Open Alerts Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CHANNEL_WAITS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CHANNEL_WAITS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CHANNEL", "MESSAGES_PUBLISHED", "WAIT_COUNT", "WAIT_TIME_USEC", "CON_DBID", "CON_ID") AS 
  select cw.snap_id, cw.dbid, cw.instance_number,
       channel, messages_published, wait_count, wait_time_usec,
       decode(cw.con_dbid, 0, cw.dbid, cw.con_dbid),
       decode(cw.per_pdb, 0, 0,
         con_dbid_to_id(decode(cw.con_dbid, 0, cw.dbid, cw.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_CHANNEL_WAITS cw
  where     sn.snap_id         = cw.snap_id
        and sn.dbid            = cw.dbid
        and sn.instance_number = cw.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CHANNEL_WAITS"  IS 'Channel Waits Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CLUSTER_INTERCON
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CLUSTER_INTERCON" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "IP_ADDRESS", "IS_PUBLIC", "SOURCE", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  ci.name,
  case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' then ci.ip_address else null end ip_address, -- Use macro to mask sensitive column
  ci.is_public, ci.source,
  decode(ci.con_dbid, 0, ci.dbid, ci.con_dbid),
  decode(ci. per_pdb, 0, 0,
    con_dbid_to_id(decode(ci.con_dbid, 0, ci.dbid, ci.con_dbid))) con_id
 from AWR_PDB_SNAPSHOT sn, WRH$_CLUSTER_INTERCON ci
 where     sn.snap_id         = ci.snap_id
       and sn.dbid            = ci.dbid
       and sn.instance_number = ci.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CLUSTER_INTERCON"  IS 'Cluster Interconnect Historical Stats'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_COLORED_SQL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_COLORED_SQL" ("DBID", "SQL_ID", "CREATE_TIME", "CON_ID") AS 
  select dbid, sql_id, create_time,
          decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from wrm$_colored_sql where owner = 1;

   COMMENT ON TABLE "SYS"."AWR_PDB_COLORED_SQL"  IS 'Marked SQLs for snapshots'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_COMP_IOSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_COMP_IOSTAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "COMPONENT", "FILE_TYPE", "IO_TYPE", "OPERATION", "BYTES", "IO_COUNT", "CON_DBID", "CON_ID") AS 
  select io.snap_id, io.dbid, io.instance_number, io.component,
       io.file_type, io.io_type, io.operation, io.bytes, io.io_count,
       decode(io.con_dbid, 0, io.dbid, io.con_dbid),
       decode(io.per_pdb, 0, 0,
         con_dbid_to_id(decode(io.con_dbid, 0, io.dbid, io.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_COMP_IOSTAT io
  where     sn.snap_id         = io.snap_id
        and sn.dbid            = io.dbid
        and sn.instance_number = io.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_COMP_IOSTAT"  IS 'I/O stats aggregated on component level'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CON_SYSMETRIC_HIST
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CON_SYSMETRIC_HIST" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "METRIC_ID", "METRIC_NAME", "VALUE", "METRIC_UNIT", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number,
       begin_time, end_time, intsize,
       m.group_id, m.metric_id, mn.metric_name, value, mn.metric_unit,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid)) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_CON_SYSMETRIC_HISTORY m, WRH$_METRIC_NAME mn
where       m.group_id       = mn.group_id
      and   m.metric_id      = mn.metric_id
      and   m.dbid           = mn.dbid
      and   sn.snap_id       = m.snap_id
      and sn.dbid            = m.dbid
      and sn.instance_number = m.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CON_SYSMETRIC_HIST"  IS 'PDB System Metrics History'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CON_SYSMETRIC_SUMM
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CON_SYSMETRIC_SUMM" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "METRIC_ID", "METRIC_NAME", "METRIC_UNIT", "NUM_INTERVAL", "MINVAL", "MAXVAL", "AVERAGE", "STANDARD_DEVIATION", "SUM_SQUARES", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number,
       begin_time, end_time, intsize,
       m.group_id, m.metric_id, mn.metric_name, mn.metric_unit,
       num_interval, minval, maxval, average, standard_deviation, sum_squares,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid)) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_CON_SYSMETRIC_SUMMARY m, WRH$_METRIC_NAME mn
  where     m.group_id         = mn.group_id
        and m.metric_id        = mn.metric_id
        and m.dbid             = mn.dbid
        and sn.snap_id         = m.snap_id
        and sn.dbid            = m.dbid
        and sn.instance_number = m.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CON_SYSMETRIC_SUMM"  IS 'PDB System Metrics Summary'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CON_SYSSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CON_SYSSTAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.instance_number,
       s.stat_id, nm.stat_name, s.value, s.con_dbid,
       con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid)) con_id
from  WRH$_CON_SYSSTAT s, WRH$_STAT_NAME nm
where      s.stat_id          = nm.stat_id
      and  s.dbid             = nm.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_CON_SYSSTAT"  IS 'System Historical Statistics Information Per PDB'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CON_SYSTEM_EVENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CON_SYSTEM_EVENT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EVENT_ID", "EVENT_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "TOTAL_WAITS", "TOTAL_TIMEOUTS", "TIME_WAITED_MICRO", "TOTAL_WAITS_FG", "TOTAL_TIMEOUTS_FG", "TIME_WAITED_MICRO_FG", "CON_DBID", "CON_ID") AS 
  select e.snap_id, e.dbid, e.instance_number,
       e.event_id, en.event_name, en.wait_class_id, en.wait_class,
       total_waits, total_timeouts, time_waited_micro,
       total_waits_fg, total_timeouts_fg, time_waited_micro_fg,
       e.con_dbid,
       con_dbid_to_id(decode(e.con_dbid, 0, e.dbid, e.con_dbid)) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_CON_SYSTEM_EVENT e, WRH$_EVENT_NAME en
where     e.event_id         = en.event_id
      and e.dbid             = en.dbid
      and e.snap_id          = sn.snap_id
      and e.dbid             = sn.dbid
      and e.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CON_SYSTEM_EVENT"  IS 'System Event Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CON_SYS_TIME_MODEL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CON_SYS_TIME_MODEL" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.instance_number, s.stat_id,
       nm.stat_name, value,
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid)) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_CON_SYS_TIME_MODEL s, WRH$_STAT_NAME nm
where      s.stat_id          = nm.stat_id
      and  s.dbid             = nm.dbid
      and  s.snap_id          = sn.snap_id
      and  s.dbid             = sn.dbid
      and  s.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CON_SYS_TIME_MODEL"  IS 'PDB System Time Model Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CR_BLOCK_SERVER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CR_BLOCK_SERVER" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CR_REQUESTS", "CURRENT_REQUESTS", "DATA_REQUESTS", "UNDO_REQUESTS", "TX_REQUESTS", "CURRENT_RESULTS", "PRIVATE_RESULTS", "ZERO_RESULTS", "DISK_READ_RESULTS", "FAIL_RESULTS", "FAIRNESS_DOWN_CONVERTS", "FLUSHES", "BUILDS", "LIGHT_WORKS", "ERRORS", "CON_DBID", "CON_ID") AS 
  select crb.snap_id, crb.dbid, crb.instance_number,
       cr_requests, current_requests,
       data_requests, undo_requests, tx_requests,
       current_results, private_results, zero_results,
       disk_read_results, fail_results,
       fairness_down_converts, flushes, builds,
       light_works, errors,
       decode(crb.con_dbid, 0, crb.dbid, crb.con_dbid),
       decode(crb.per_pdb, 0, 0,
         con_dbid_to_id(decode(crb.con_dbid, 0, crb.dbid, crb.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_CR_BLOCK_SERVER crb
  where     sn.snap_id         = crb.snap_id
        and sn.dbid            = crb.dbid
        and sn.instance_number = crb.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CR_BLOCK_SERVER"  IS 'Consistent Read Block Server Historical Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_CURRENT_BLOCK_SERVER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_CURRENT_BLOCK_SERVER" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PIN0", "PIN1", "PIN10", "PIN100", "PIN1000", "PIN10000", "FLUSH0", "FLUSH1", "FLUSH10", "FLUSH100", "FLUSH1000", "FLUSH10000", "CON_DBID", "CON_ID") AS 
  select cub.snap_id, cub.dbid, cub.instance_number,
       pin0,   pin1,   pin10,   pin100,   pin1000,   pin10000,
       flush0, flush1, flush10, flush100, flush1000, flush10000,
       decode(cub.con_dbid, 0, cub.dbid, cub.con_dbid),
       decode(cub.per_pdb, 0, 0,
         con_dbid_to_id(decode(cub.con_dbid, 0, cub.dbid, cub.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_CURRENT_BLOCK_SERVER cub
  where     sn.snap_id         = cub.snap_id
        and sn.dbid            = cub.dbid
        and sn.instance_number = cub.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_CURRENT_BLOCK_SERVER"  IS 'Current Block Server Historical Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_DATABASE_INSTANCE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_DATABASE_INSTANCE" ("DBID", "INSTANCE_NUMBER", "STARTUP_TIME", "PARALLEL", "VERSION", "DB_NAME", "INSTANCE_NAME", "HOST_NAME", "LAST_ASH_SAMPLE_ID", "PLATFORM_NAME", "CDB", "EDITION", "DB_UNIQUE_NAME", "DATABASE_ROLE", "CDB_ROOT_DBID", "CON_ID", "STARTUP_TIME_TZ") AS 
  select dbid, instance_number, startup_time, parallel, version,
       db_name, instance_name,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' then host_name else null end host_name, -- Use macro to mask sensitive column
       last_ash_sample_id,
       platform_name, cdb, edition, db_unique_name,
       database_role, cdb_root_dbid,
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id,
       startup_time_tz
from WRM$_DATABASE_INSTANCE;

   COMMENT ON TABLE "SYS"."AWR_PDB_DATABASE_INSTANCE"  IS 'Database Instance Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_DATAFILE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_DATAFILE" ("DBID", "FILE#", "CREATION_CHANGE#", "FILENAME", "TS#", "TSNAME", "BLOCK_SIZE", "CON_DBID", "CON_ID") AS 
  select d.dbid, d.file#, d.creation_change#,
       d.filename, d.ts#, coalesce(t.tsname, d.tsname) tsname, d.block_size,
       decode(d.con_dbid, 0, d.dbid, d.con_dbid),
       decode(d.per_pdb, 0, 0,
         con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
from WRH$_DATAFILE d LEFT OUTER JOIN WRH$_TABLESPACE t
     on (d.dbid = t.dbid
         and d.ts# = t.ts#
         and d.con_dbid = t.con_dbid);

   COMMENT ON TABLE "SYS"."AWR_PDB_DATAFILE"  IS 'Names of Datafiles'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_DB_CACHE_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_DB_CACHE_ADVICE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BPID", "BUFFERS_FOR_ESTIMATE", "NAME", "BLOCK_SIZE", "ADVICE_STATUS", "SIZE_FOR_ESTIMATE", "SIZE_FACTOR", "PHYSICAL_READS", "BASE_PHYSICAL_READS", "ACTUAL_PHYSICAL_READS", "ESTD_PHYSICAL_READ_TIME", "CON_DBID", "CON_ID") AS 
  select db.snap_id, db.dbid, db.instance_number,
       bpid, buffers_for_estimate,
       name, block_size, advice_status, size_for_estimate,
       size_factor, physical_reads, base_physical_reads,
       actual_physical_reads, estd_physical_read_time,
       decode(db.con_dbid, 0, db.dbid, db.con_dbid),
       decode(db.per_pdb, 0, 0,
         con_dbid_to_id(decode(db.con_dbid, 0, db.dbid, db.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_DB_CACHE_ADVICE db
where      db.snap_id          = sn.snap_id
      and  db.dbid             = sn.dbid
      and  db.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_DB_CACHE_ADVICE"  IS 'DB Cache Advice History Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_DISPATCHER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_DISPATCHER" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "SERIAL#", "IDLE", "BUSY", "WAIT", "TOTALQ", "SAMPLED_TOTAL_CONN", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  d.name, d.serial#, d.idle, d.busy, d.wait, d.totalq, d.sampled_total_conn,
  decode(d.con_dbid, 0, d.dbid, d.con_dbid),
  decode(d.per_pdb, 0, 0,
    con_dbid_to_id(decode(d.con_dbid, 0, d.dbid, d.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_DISPATCHER d
where     sn.snap_id         = d.snap_id
      and sn.dbid            = d.dbid
      and sn.instance_number = d.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_DISPATCHER"  IS 'Dispatcher statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_DLM_MISC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_DLM_MISC" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STATISTIC#", "NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select dlm.snap_id, dlm.dbid, dlm.instance_number,
       statistic#, name, value,
       decode(dlm.con_dbid, 0, dlm.dbid, dlm.con_dbid),
       decode(dlm.per_pdb, 0, 0,
         con_dbid_to_id(decode(dlm.con_dbid, 0, dlm.dbid, dlm.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_DLM_MISC dlm
  where     sn.snap_id         = dlm.snap_id
        and sn.dbid            = dlm.dbid
        and sn.instance_number = dlm.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_DLM_MISC"  IS 'Distributed Lock Manager Miscellaneous Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_DYN_REMASTER_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_DYN_REMASTER_STATS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "REMASTER_TYPE", "REMASTER_OPS", "REMASTER_TIME", "REMASTERED_OBJECTS", "QUIESCE_TIME", "FREEZE_TIME", "CLEANUP_TIME", "REPLAY_TIME", "FIXWRITE_TIME", "SYNC_TIME", "RESOURCES_CLEANED", "REPLAYED_LOCKS_SENT", "REPLAYED_LOCKS_RECEIVED", "CURRENT_OBJECTS", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
   s.remaster_type, s.remaster_ops, s.remaster_time, s.remastered_objects,
   s.quiesce_time, s.freeze_time, s.cleanup_time,
   s.replay_time, s.fixwrite_time, s.sync_time,
   s.resources_cleaned, s.replayed_locks_sent,
   s.replayed_locks_received, s.current_objects,
   decode(s.con_dbid, 0, s.dbid, s.con_dbid),
   decode(s.per_pdb, 0, 0,
     con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_DYN_REMASTER_STATS s
where     sn.snap_id         = s.snap_id
      and sn.dbid            = s.dbid
      and sn.instance_number = s.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_DYN_REMASTER_STATS"  IS 'Dynamic remastering statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_ENQUEUE_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_ENQUEUE_STAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EQ_TYPE", "REQ_REASON", "TOTAL_REQ#", "TOTAL_WAIT#", "SUCC_REQ#", "FAILED_REQ#", "CUM_WAIT_TIME", "EVENT#", "CON_DBID", "CON_ID") AS 
  select eq.snap_id, eq.dbid, eq.instance_number,
       eq_type, req_reason, total_req#,
       total_wait#, succ_req#, failed_req#, cum_wait_time, event#,
       decode(eq.con_dbid, 0, eq.dbid, eq.con_dbid),
       decode(eq.per_pdb, 0, 0,
         con_dbid_to_id(decode(eq.con_dbid, 0, eq.dbid, eq.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_ENQUEUE_STAT eq
  where     sn.snap_id         = eq.snap_id
        and sn.dbid            = eq.dbid
        and sn.instance_number = eq.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_ENQUEUE_STAT"  IS 'Enqueue Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_EVENT_HISTOGRAM
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_EVENT_HISTOGRAM" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "EVENT_ID", "EVENT_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "WAIT_TIME_MILLI", "WAIT_COUNT", "CON_DBID", "CON_ID") AS 
  select e.snap_id, e.dbid, e.instance_number,
       e.event_id, en.event_name, en.wait_class_id, en.wait_class,
       e.wait_time_milli, e.wait_count,
       decode(e.con_dbid, 0, e.dbid, e.con_dbid),
       decode(e.per_pdb, 0, 0,
         con_dbid_to_id(decode(e.con_dbid, 0, e.dbid, e.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_EVENT_HISTOGRAM e, WRH$_EVENT_NAME en
where     e.event_id         = en.event_id
      and e.dbid             = en.dbid
      and e.snap_id          = sn.snap_id
      and e.dbid             = sn.dbid
      and e.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_EVENT_HISTOGRAM"  IS 'Event Histogram Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_EVENT_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_EVENT_NAME" ("DBID", "EVENT_ID", "EVENT_NAME", "PARAMETER1", "PARAMETER2", "PARAMETER3", "WAIT_CLASS_ID", "WAIT_CLASS", "CON_DBID", "CON_ID") AS 
  select dbid, event_id, event_name, parameter1, parameter2, parameter3,
       wait_class_id, wait_class,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_EVENT_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_EVENT_NAME"  IS 'Event Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_FILEMETRIC_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_FILEMETRIC_HISTORY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FILEID", "CREATIONTIME", "BEGIN_TIME", "END_TIME", "INTSIZE", "GROUP_ID", "AVGREADTIME", "AVGWRITETIME", "PHYSICALREAD", "PHYSICALWRITE", "PHYBLKREAD", "PHYBLKWRITE", "CON_DBID", "CON_ID") AS 
  select fm.snap_id, fm.dbid, fm.instance_number,
       fileid, creationtime, begin_time,
       end_time, intsize, group_id, avgreadtime, avgwritetime,
       physicalread, physicalwrite, phyblkread, phyblkwrite,
       decode(fm.con_dbid, 0, fm.dbid, fm.con_dbid),
       decode(fm.per_pdb, 0, 0,
         con_dbid_to_id(decode(fm.con_dbid, 0, fm.dbid, fm.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_FILEMETRIC_HISTORY fm
  where     sn.snap_id         = fm.snap_id
        and sn.dbid            = fm.dbid
        and sn.instance_number = fm.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_FILEMETRIC_HISTORY"  IS 'File Metrics History'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_FILESTATXS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_FILESTATXS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FILE#", "CREATION_CHANGE#", "FILENAME", "TS#", "TSNAME", "BLOCK_SIZE", "PHYRDS", "PHYWRTS", "SINGLEBLKRDS", "READTIM", "WRITETIM", "SINGLEBLKRDTIM", "PHYBLKRD", "PHYBLKWRT", "WAIT_COUNT", "TIME", "OPTIMIZED_PHYBLKRD", "CON_DBID", "CON_ID") AS 
  select f.snap_id, f.dbid, f.instance_number,
       f.file#, f.creation_change#, d.filename,
       d.ts#, coalesce(t.tsname, d.tsname) tsname, d.block_size,
       phyrds, phywrts, singleblkrds, readtim, writetim,
       singleblkrdtim, phyblkrd, phyblkwrt, wait_count, time,
       optimized_phyblkrd, decode(f.con_dbid, 0, f.dbid, f.con_dbid),
       decode(f.per_pdb, 0, 0,
         con_dbid_to_id(decode(f.con_dbid, 0, f.dbid, f.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_FILESTATXS f, WRH$_DATAFILE d, WRH$_TABLESPACE t
where      f.dbid             = d.dbid
      and  f.file#            = d.file#
      and  f.creation_change# = d.creation_change#
      and  f.snap_id          = sn.snap_id
      and  f.dbid             = sn.dbid
      and  f.instance_number  = sn.instance_number
      and  f.con_dbid         = d.con_dbid
      and  d.dbid             = t.dbid(+)
      and  d.ts#              = t.ts#(+)
      and  d.con_dbid         = t.con_dbid(+);

   COMMENT ON TABLE "SYS"."AWR_PDB_FILESTATXS"  IS 'Datafile Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IC_CLIENT_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IC_CLIENT_STATS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "BYTES_SENT", "BYTES_RECEIVED", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  t.name, t.bytes_sent, t.bytes_received,
  decode(t.con_dbid, 0, t.dbid, t.con_dbid),
  decode(t.per_pdb, 0, 0,
    con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid))) con_id
 from AWR_PDB_SNAPSHOT sn, WRH$_IC_CLIENT_STATS t
 where     sn.snap_id         = t.snap_id
       and sn.dbid            = t.dbid
       and sn.instance_number = t.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_IC_CLIENT_STATS"  IS 'Historical interconnect client statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IC_DEVICE_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IC_DEVICE_STATS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "IF_NAME", "IP_ADDR", "NET_MASK", "FLAGS", "MTU", "BYTES_RECEIVED", "PACKETS_RECEIVED", "RECEIVE_ERRORS", "RECEIVE_DROPPED", "RECEIVE_BUF_OR", "RECEIVE_FRAME_ERR", "BYTES_SENT", "PACKETS_SENT", "SEND_ERRORS", "SENDS_DROPPED", "SEND_BUF_OR", "SEND_CARRIER_LOST", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  t.if_name ,t.ip_addr ,t.net_mask ,t.flags ,t.mtu ,t.bytes_received,
  t.packets_received, t.receive_errors ,t.receive_dropped,
  t.receive_buf_or ,t.receive_frame_err, t.bytes_sent ,t.packets_sent,
  t.send_errors ,t.sends_dropped ,t.send_buf_or, t.send_carrier_lost,
  decode(t.con_dbid, 0, t.dbid, t.con_dbid),
  decode(t.per_pdb, 0, 0,
    con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid))) con_id
 from AWR_PDB_SNAPSHOT sn, WRH$_IC_DEVICE_STATS t
 where     sn.snap_id         = t.snap_id
       and sn.dbid            = t.dbid
       and sn.instance_number = t.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_IC_DEVICE_STATS"  IS 'Historical interconnect device statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IM_SEG_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IM_SEG_STAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TS#", "OBJ#", "DATAOBJ#", "MEMBYTES", "SCANS", "SCANS_DELTA", "DB_BLOCK_CHANGES", "DB_BLOCK_CHANGES_DELTA", "POPULATE_CUS", "POPULATE_CUS_DELTA", "REPOPULATE_CUS", "REPOPULATE_CUS_DELTA", "CON_DBID", "CON_ID") AS 
  select seg.snap_id, seg.dbid, seg.instance_number, ts#,
obj#, dataobj#, 0,
im_scans_total as scans, im_scans_delta as scans_delta,
im_db_block_changes_total as db_block_changes,
im_db_block_changes_delta as db_block_changes_delta,
populate_cus_total as populate_cus, populate_cus_delta,
repopulate_cus_total as repopulate_cus, repopulate_cus_delta,
decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid),
decode(seg.per_pdb, 0, 0,
       con_dbid_to_id(decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_SEG_STAT seg
where
        seg.snap_id         = sn.snap_id
    and seg.dbid            = sn.dbid
    and seg.instance_number = sn.instance_number
    and ((seg.im_scans_total > 0) or (seg.populate_cus_total > 0) or
         (seg.repopulate_cus_total > 0) or (seg.im_db_block_changes_total > 0))
union
select seg.snap_id, seg.dbid, seg.instance_number, ts#,
obj#, dataobj#, membytes,
scans, scans_delta,
db_block_changes,  db_block_changes_delta,
populate_cus, populate_cus_delta,
repopulate_cus, repopulate_cus_delta,
decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid),
decode(seg.per_pdb, 0, 0,
       con_dbid_to_id(decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_IM_SEG_STAT seg
where
        seg.snap_id         = sn.snap_id
    and seg.dbid            = sn.dbid
    and seg.instance_number = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_IM_SEG_STAT"  IS ' Historical IM Segment Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IM_SEG_STAT_OBJ
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IM_SEG_STAT_OBJ" ("DBID", "TS#", "OBJ#", "DATAOBJ#", "OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "OBJECT_TYPE", "TABLESPACE_NAME", "CON_DBID", "CON_ID") AS 
  select so.dbid, so.ts#, so.obj#, so.dataobj#, so.owner, so.object_name,
       so.subobject_name, so.object_type,
       coalesce(ts.tsname, tablespace_name) tablespace_name,
       decode(so.con_dbid, 0, so.dbid, so.con_dbid),
       decode(so.per_pdb, 0, 0,
         con_dbid_to_id(decode(so.con_dbid, 0, so.dbid, so.con_dbid))) con_id
from WRH$_IM_SEG_STAT_OBJ so LEFT OUTER JOIN WRH$_TABLESPACE ts
     on (so.dbid = ts.dbid
         and so.ts# = ts.ts#
         and so.con_dbid = ts.con_dbid)
union
select so.dbid, so.ts#, so.obj#, so.dataobj#, so.owner, so.object_name,
       so.subobject_name, so.object_type,
       coalesce(ts.tsname, tablespace_name) tablespace_name,
       decode(so.con_dbid, 0, so.dbid, so.con_dbid),
       decode(so.per_pdb, 0, 0,
         con_dbid_to_id(decode(so.con_dbid, 0, so.dbid, so.con_dbid))) con_id
from WRH$_SEG_STAT_OBJ so LEFT OUTER JOIN WRH$_TABLESPACE ts
     on (so.dbid = ts.dbid
         and so.ts# = ts.ts#
         and so.con_dbid = ts.con_dbid);

   COMMENT ON TABLE "SYS"."AWR_PDB_IM_SEG_STAT_OBJ"  IS 'IM Segment Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_INSTANCE_RECOVERY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_INSTANCE_RECOVERY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "RECOVERY_ESTIMATED_IOS", "ACTUAL_REDO_BLKS", "TARGET_REDO_BLKS", "LOG_FILE_SIZE_REDO_BLKS", "LOG_CHKPT_TIMEOUT_REDO_BLKS", "LOG_CHKPT_INTERVAL_REDO_BLKS", "FAST_START_IO_TARGET_REDO_BLKS", "TARGET_MTTR", "ESTIMATED_MTTR", "CKPT_BLOCK_WRITES", "OPTIMAL_LOGFILE_SIZE", "ESTD_CLUSTER_AVAILABLE_TIME", "WRITES_MTTR", "WRITES_LOGFILE_SIZE", "WRITES_LOG_CHECKPOINT_SETTINGS", "WRITES_OTHER_SETTINGS", "WRITES_AUTOTUNE", "WRITES_FULL_THREAD_CKPT", "CON_DBID", "CON_ID") AS 
  select ir.snap_id, ir.dbid, ir.instance_number, recovery_estimated_ios,
       actual_redo_blks, target_redo_blks, log_file_size_redo_blks,
       log_chkpt_timeout_redo_blks, log_chkpt_interval_redo_blks,
       fast_start_io_target_redo_blks, target_mttr, estimated_mttr,
       ckpt_block_writes, optimal_logfile_size, estd_cluster_available_time,
       writes_mttr, writes_logfile_size, writes_log_checkpoint_settings,
       writes_other_settings, writes_autotune, writes_full_thread_ckpt,
       decode(ir.con_dbid, 0, ir.dbid, ir.con_dbid),
       decode(ir.per_pdb, 0, 0,
         con_dbid_to_id(decode(ir.con_dbid, 0, ir.dbid, ir.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_INSTANCE_RECOVERY ir
  where     sn.snap_id         = ir.snap_id
        and sn.dbid            = ir.dbid
        and sn.instance_number = ir.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_INSTANCE_RECOVERY"  IS 'Instance Recovery Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_INST_CACHE_TRANSFER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_INST_CACHE_TRANSFER" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "INSTANCE", "CLASS", "CR_BLOCK", "CR_BUSY", "CR_CONGESTED", "CURRENT_BLOCK", "CURRENT_BUSY", "CURRENT_CONGESTED", "LOST", "CR_2HOP", "CR_3HOP", "CURRENT_2HOP", "CURRENT_3HOP", "CR_BLOCK_TIME", "CR_BUSY_TIME", "CR_CONGESTED_TIME", "CURRENT_BLOCK_TIME", "CURRENT_BUSY_TIME", "CURRENT_CONGESTED_TIME", "LOST_TIME", "CR_2HOP_TIME", "CR_3HOP_TIME", "CURRENT_2HOP_TIME", "CURRENT_3HOP_TIME", "CON_DBID", "CON_ID") AS 
  select ict.snap_id, ict.dbid, ict.instance_number,
       instance, class, cr_block, cr_busy, cr_congested,
       current_block, current_busy, current_congested
      ,lost ,cr_2hop ,cr_3hop ,current_2hop ,current_3hop
      ,cr_block_time ,cr_busy_time ,cr_congested_time ,current_block_time
      ,current_busy_time ,current_congested_time ,lost_time ,cr_2hop_time
      ,cr_3hop_time ,current_2hop_time ,current_3hop_time,
       decode(ict.con_dbid, 0, ict.dbid, ict.con_dbid),
       decode(ict.per_pdb, 0, 0,
         con_dbid_to_id(decode(ict.con_dbid, 0, ict.dbid, ict.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_INST_CACHE_TRANSFER ict
  where     sn.snap_id         = ict.snap_id
        and sn.dbid            = ict.dbid
        and sn.instance_number = ict.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_INST_CACHE_TRANSFER"  IS 'Instance Cache Transfer Historical Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_INTERCONNECT_PINGS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_INTERCONNECT_PINGS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TARGET_INSTANCE", "CNT_500B", "WAIT_500B", "WAITSQ_500B", "CNT_8K", "WAIT_8K", "WAITSQ_8K", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  t.target_instance, t.cnt_500b, t.wait_500b, t.waitsq_500b,
  t.cnt_8k, t.wait_8k, t.waitsq_8k,
  decode(t.con_dbid, 0, t.dbid, t.con_dbid),
  decode(t.per_pdb, 0, 0,
    con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid))) con_id
 from AWR_PDB_SNAPSHOT sn, WRH$_INTERCONNECT_PINGS t
 where     sn.snap_id         = t.snap_id
       and sn.dbid            = t.dbid
       and sn.instance_number = t.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_INTERCONNECT_PINGS"  IS 'Instance to instance ping stats'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IOSTAT_DETAIL
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IOSTAT_DETAIL" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FUNCTION_ID", "FUNCTION_NAME", "FILETYPE_ID", "FILETYPE_NAME", "SMALL_READ_MEGABYTES", "SMALL_WRITE_MEGABYTES", "LARGE_READ_MEGABYTES", "LARGE_WRITE_MEGABYTES", "SMALL_READ_REQS", "SMALL_WRITE_REQS", "LARGE_READ_REQS", "LARGE_WRITE_REQS", "NUMBER_OF_WAITS", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select io.snap_id, io.dbid, io.instance_number,
       io.function_id, nmfn.function_name,
       io.filetype_id, nmft.filetype_name,
       io.small_read_megabytes, io.small_write_megabytes,
       io.large_read_megabytes, io.large_write_megabytes,
       io.small_read_reqs, io.small_write_reqs,
       io.large_read_reqs, io.large_write_reqs,
       io.number_of_waits, io.wait_time,
       decode(io.con_dbid, 0, io.dbid, io.con_dbid),
       decode(io.per_pdb, 0, 0,
         con_dbid_to_id(decode(io.con_dbid, 0, io.dbid, io.con_dbid))) con_id
  from  AWR_PDB_SNAPSHOT sn, WRH$_IOSTAT_DETAIL io,
        WRH$_IOSTAT_FUNCTION_NAME nmfn, WRH$_IOSTAT_FILETYPE_NAME nmft
  where     sn.snap_id         = io.snap_id
        and sn.dbid            = io.dbid
        and sn.instance_number = io.instance_number
        and io.function_id     = nmfn.function_id
        and io.dbid            = nmfn.dbid
        and io.filetype_id     = nmft.filetype_id
        and io.dbid            = nmft.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_IOSTAT_DETAIL"  IS 'Historical I/O statistics by function and filetype'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IOSTAT_FILETYPE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IOSTAT_FILETYPE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FILETYPE_ID", "FILETYPE_NAME", "SMALL_READ_MEGABYTES", "SMALL_WRITE_MEGABYTES", "LARGE_READ_MEGABYTES", "LARGE_WRITE_MEGABYTES", "SMALL_READ_REQS", "SMALL_WRITE_REQS", "SMALL_SYNC_READ_REQS", "LARGE_READ_REQS", "LARGE_WRITE_REQS", "SMALL_READ_SERVICETIME", "SMALL_WRITE_SERVICETIME", "SMALL_SYNC_READ_LATENCY", "LARGE_READ_SERVICETIME", "LARGE_WRITE_SERVICETIME", "RETRIES_ON_ERROR", "CON_DBID", "CON_ID") AS 
  select io.snap_id, io.dbid, io.instance_number,
       nm.filetype_id, nm.filetype_name,
       io.small_read_megabytes, io.small_write_megabytes,
       io.large_read_megabytes, io.large_write_megabytes,
       io.small_read_reqs, io.small_write_reqs, io.small_sync_read_reqs,
       io.large_read_reqs, io.large_write_reqs,
       io.small_read_servicetime, io.small_write_servicetime,
       io.small_sync_read_latency,
       io.large_read_servicetime, io.large_write_servicetime,
       io.retries_on_error,
       decode(io.con_dbid, 0, io.dbid, io.con_dbid),
       decode(io.per_pdb, 0, 0,
         con_dbid_to_id(decode(io.con_dbid, 0, io.dbid, io.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_IOSTAT_FILETYPE io, WRH$_IOSTAT_FILETYPE_NAME nm
  where     sn.snap_id         = io.snap_id
        and sn.dbid            = io.dbid
        and sn.instance_number = io.instance_number
        and io.filetype_id     = nm.filetype_id
        and io.dbid            = nm.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_IOSTAT_FILETYPE"  IS 'Historical I/O statistics by file type'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IOSTAT_FILETYPE_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IOSTAT_FILETYPE_NAME" ("DBID", "FILETYPE_ID", "FILETYPE_NAME", "CON_DBID", "CON_ID") AS 
  select dbid,
       filetype_id,
       filetype_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_IOSTAT_FILETYPE_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_IOSTAT_FILETYPE_NAME"  IS 'File type names for historical I/O statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IOSTAT_FUNCTION
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IOSTAT_FUNCTION" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "FUNCTION_ID", "FUNCTION_NAME", "SMALL_READ_MEGABYTES", "SMALL_WRITE_MEGABYTES", "LARGE_READ_MEGABYTES", "LARGE_WRITE_MEGABYTES", "SMALL_READ_REQS", "SMALL_WRITE_REQS", "LARGE_READ_REQS", "LARGE_WRITE_REQS", "NUMBER_OF_WAITS", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select io.snap_id, io.dbid, io.instance_number,
       nm.function_id, nm.function_name,
       io.small_read_megabytes, io.small_write_megabytes,
       io.large_read_megabytes, io.large_write_megabytes,
       io.small_read_reqs, io.small_write_reqs,
       io.large_read_reqs, io.large_write_reqs,
       io.number_of_waits, io.wait_time,
       decode(io.con_dbid, 0, io.dbid, io.con_dbid),
       decode(io.per_pdb, 0, 0,
         con_dbid_to_id(decode(io.con_dbid, 0, io.dbid, io.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_IOSTAT_FUNCTION io,
       WRH$_IOSTAT_FUNCTION_NAME nm
  where     sn.snap_id         = io.snap_id
        and sn.dbid            = io.dbid
        and sn.instance_number = io.instance_number
        and io.function_id     = nm.function_id
        and io.dbid            = nm.dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_IOSTAT_FUNCTION"  IS 'Historical I/O statistics by function'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_IOSTAT_FUNCTION_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_IOSTAT_FUNCTION_NAME" ("DBID", "FUNCTION_ID", "FUNCTION_NAME", "CON_DBID", "CON_ID") AS 
  select dbid,
       function_id,
       function_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
  from WRH$_IOSTAT_FUNCTION_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_IOSTAT_FUNCTION_NAME"  IS 'Function names for historical I/O statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_JAVA_POOL_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_JAVA_POOL_ADVICE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "JAVA_POOL_SIZE_FOR_ESTIMATE", "JAVA_POOL_SIZE_FACTOR", "ESTD_LC_SIZE", "ESTD_LC_MEMORY_OBJECTS", "ESTD_LC_TIME_SAVED", "ESTD_LC_TIME_SAVED_FACTOR", "ESTD_LC_LOAD_TIME", "ESTD_LC_LOAD_TIME_FACTOR", "ESTD_LC_MEMORY_OBJECT_HITS", "CON_DBID", "CON_ID") AS 
  select jp.snap_id, jp.dbid, jp.instance_number,
       java_pool_size_for_estimate, java_pool_size_factor,
       estd_lc_size, estd_lc_memory_objects,
       estd_lc_time_saved, estd_lc_time_saved_factor,
       estd_lc_load_time, estd_lc_load_time_factor,
       estd_lc_memory_object_hits,
       decode(jp.con_dbid, 0, jp.dbid, jp.con_dbid),
       decode(jp.per_pdb, 0, 0,
         con_dbid_to_id(decode(jp.con_dbid, 0, jp.dbid, jp.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_JAVA_POOL_ADVICE jp
  where     sn.snap_id         = jp.snap_id
        and sn.dbid            = jp.dbid
        and sn.instance_number = jp.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_JAVA_POOL_ADVICE"  IS 'Java Pool Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_LATCH
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_LATCH" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "LATCH_HASH", "LATCH_NAME", "LEVEL#", "GETS", "MISSES", "SLEEPS", "IMMEDIATE_GETS", "IMMEDIATE_MISSES", "SPIN_GETS", "SLEEP1", "SLEEP2", "SLEEP3", "SLEEP4", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select l.snap_id, l.dbid, l.instance_number,
       l.latch_hash, ln.latch_name, level#,
       gets, misses, sleeps, immediate_gets, immediate_misses, spin_gets,
       sleep1, sleep2, sleep3, sleep4, wait_time,
       decode(l.con_dbid, 0, l.dbid, l.con_dbid),
       decode(l.per_pdb, 0, 0,
         con_dbid_to_id(decode(l.con_dbid, 0, l.dbid, l.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_LATCH l, WRH$_LATCH_NAME ln
where      l.latch_hash       = ln.latch_hash
      and  l.dbid             = ln.dbid
      and  l.snap_id          = sn.snap_id
      and  l.dbid             = sn.dbid
      and  l.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_LATCH"  IS 'Latch Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_LATCH_CHILDREN
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_LATCH_CHILDREN" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "LATCH_HASH", "LATCH_NAME", "CHILD#", "GETS", "MISSES", "SLEEPS", "IMMEDIATE_GETS", "IMMEDIATE_MISSES", "SPIN_GETS", "SLEEP1", "SLEEP2", "SLEEP3", "SLEEP4", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select l.snap_id, l.dbid, l.instance_number,
       l.latch_hash, ln.latch_name, child#,
       gets, misses, sleeps, immediate_gets, immediate_misses, spin_gets,
       sleep1, sleep2, sleep3, sleep4, wait_time,
       decode(l.con_dbid, 0, l.dbid, l.con_dbid),
       decode(l.per_pdb, 0, 0,
         con_dbid_to_id(decode(l.con_dbid, 0, l.dbid, l.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_LATCH_CHILDREN l, WRH$_LATCH_NAME ln
where      l.latch_hash       = ln.latch_hash
      and  l.dbid             = ln.dbid
      and  l.snap_id          = sn.snap_id
      and  l.dbid             = sn.dbid
      and  l.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_LATCH_CHILDREN"  IS 'Latch Children Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_LATCH_MISSES_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_LATCH_MISSES_SUMMARY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PARENT_NAME", "WHERE_IN_CODE", "NWFAIL_COUNT", "SLEEP_COUNT", "WTR_SLP_COUNT", "CON_DBID", "CON_ID") AS 
  select l.snap_id, l.dbid, l.instance_number, parent_name, where_in_code,
       nwfail_count, sleep_count, wtr_slp_count,
       decode(l.con_dbid, 0, l.dbid, l.con_dbid),
       decode(l.per_pdb, 0, 0,
         con_dbid_to_id(decode(l.con_dbid, 0, l.dbid, l.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_LATCH_MISSES_SUMMARY l
where      l.snap_id          = sn.snap_id
      and  l.dbid             = sn.dbid
      and  l.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_LATCH_MISSES_SUMMARY"  IS 'Latch Misses Summary Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_LATCH_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_LATCH_NAME" ("DBID", "LATCH_HASH", "LATCH_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, latch_hash, latch_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_LATCH_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_LATCH_NAME"  IS 'Latch Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_LATCH_PARENT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_LATCH_PARENT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "LATCH_HASH", "LATCH_NAME", "LEVEL#", "GETS", "MISSES", "SLEEPS", "IMMEDIATE_GETS", "IMMEDIATE_MISSES", "SPIN_GETS", "SLEEP1", "SLEEP2", "SLEEP3", "SLEEP4", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select l.snap_id, l.dbid, l.instance_number,
       l.latch_hash, ln.latch_name, level#,
       gets, misses, sleeps, immediate_gets, immediate_misses, spin_gets,
       sleep1, sleep2, sleep3, sleep4, wait_time,
       decode(l.con_dbid, 0, l.dbid, l.con_dbid),
       decode(l.per_pdb, 0, 0,
         con_dbid_to_id(decode(l.con_dbid, 0, l.dbid, l.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_LATCH_PARENT l, WRH$_LATCH_NAME ln
where      l.latch_hash       = ln.latch_hash
      and  l.dbid             = ln.dbid
      and  l.snap_id          = sn.snap_id
      and  l.dbid             = sn.dbid
      and  l.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_LATCH_PARENT"  IS 'Latch Parent Historical Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_LIBRARYCACHE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_LIBRARYCACHE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAMESPACE", "GETS", "GETHITS", "PINS", "PINHITS", "RELOADS", "INVALIDATIONS", "DLM_LOCK_REQUESTS", "DLM_PIN_REQUESTS", "DLM_PIN_RELEASES", "DLM_INVALIDATION_REQUESTS", "DLM_INVALIDATIONS", "CON_DBID", "CON_ID") AS 
  select lc.snap_id, lc.dbid, lc.instance_number, namespace, gets,
       gethits, pins, pinhits, reloads, invalidations,
       dlm_lock_requests, dlm_pin_requests, dlm_pin_releases,
       dlm_invalidation_requests, dlm_invalidations,
       decode(lc.con_dbid, 0, lc.dbid, lc.con_dbid),
       decode(lc.per_pdb, 0, 0,
         con_dbid_to_id(decode(lc.con_dbid, 0, lc.dbid, lc.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_LIBRARYCACHE lc
  where     sn.snap_id         = lc.snap_id
        and sn.dbid            = lc.dbid
        and sn.instance_number = lc.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_LIBRARYCACHE"  IS 'Library Cache Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_LMS_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_LMS_STATS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PID", "PRIORITY", "PRIORITY_CHANGES", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
   s.pid, s.priority, s.priority_changes,
   decode(s.con_dbid, 0, s.dbid, s.con_dbid),
   decode(s.per_pdb, 0, 0,
     con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_LMS_STATS s
where     sn.snap_id         = s.snap_id
      and sn.dbid            = s.dbid
      and sn.instance_number = s.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_LMS_STATS"  IS 'LMS statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_LOG
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_LOG" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "GROUP#", "THREAD#", "SEQUENCE#", "BYTES", "MEMBERS", "ARCHIVED", "STATUS", "FIRST_CHANGE#", "FIRST_TIME", "CON_DBID", "CON_ID") AS 
  select log.snap_id, log.dbid, log.instance_number,
       group#, thread#, sequence#, bytes, members,
       archived, log.status, first_change#, first_time,
       decode(log.con_dbid, 0, log.dbid, log.con_dbid),
       decode(log.per_pdb, 0, 0,
         con_dbid_to_id(decode(log.con_dbid, 0, log.dbid, log.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_LOG log
  where     sn.snap_id         = log.snap_id
        and sn.dbid            = log.dbid
        and sn.instance_number = log.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_LOG"  IS 'Log Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_MEM_DYNAMIC_COMP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_MEM_DYNAMIC_COMP" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "COMPONENT", "CURRENT_SIZE", "MIN_SIZE", "MAX_SIZE", "USER_SPECIFIED_SIZE", "OPER_COUNT", "LAST_OPER_TYPE", "LAST_OPER_MODE", "LAST_OPER_TIME", "GRANULE_SIZE", "CON_DBID", "CON_ID") AS 
  select
  sn.snap_id, sn.dbid, sn.instance_number,
  t.component ,t.current_size, t.min_size, t.max_size,
  t.user_specified_size, t.oper_count, t.last_oper_type,
  t.last_oper_mode, t.last_oper_time, t.granule_size,
  decode(t.con_dbid, 0, t.dbid, t.con_dbid),
  con_dbid_to_id(decode(t.con_dbid, 0, t.dbid, t.con_dbid)) con_id
 from AWR_PDB_SNAPSHOT sn, WRH$_MEM_DYNAMIC_COMP t
 where     sn.snap_id         = t.snap_id
       and sn.dbid            = t.dbid
       and sn.instance_number = t.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_MEM_DYNAMIC_COMP"  IS 'Historical memory component sizes'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_MEMORY_RESIZE_OPS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_MEMORY_RESIZE_OPS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "COMPONENT", "OPER_TYPE", "START_TIME", "END_TIME", "TARGET_SIZE", "OPER_MODE", "PARAMETER", "INITIAL_SIZE", "FINAL_SIZE", "STATUS", "CON_DBID", "CON_ID") AS 
  select mro.snap_id, mro.dbid, mro.instance_number,
       component, oper_type, start_time, end_time,
       target_size, oper_mode, parameter, initial_size,
       final_size, mro.status,
       decode(mro.con_dbid, 0, mro.dbid, mro.con_dbid),
       decode(mro.per_pdb, 0, 0,
         con_dbid_to_id(decode(mro.con_dbid, 0, mro.dbid, mro.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_MEMORY_RESIZE_OPS mro
  where     sn.snap_id         = mro.snap_id
        and sn.dbid            = mro.dbid
        and sn.instance_number = mro.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_MEMORY_RESIZE_OPS"  IS 'Memory Resize Operations History'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_MEMORY_TARGET_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_MEMORY_TARGET_ADVICE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "MEMORY_SIZE", "MEMORY_SIZE_FACTOR", "ESTD_DB_TIME", "ESTD_DB_TIME_FACTOR", "VERSION", "CON_DBID", "CON_ID") AS 
  select mem.snap_id, mem.dbid, mem.instance_number,
       memory_size, memory_size_factor,
       estd_db_time, estd_db_time_factor, version,
       decode(mem.con_dbid, 0, mem.dbid, mem.con_dbid),
       decode(mem.per_pdb, 0, 0,
         con_dbid_to_id(decode(mem.con_dbid, 0, mem.dbid, mem.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_MEMORY_TARGET_ADVICE mem
  where     sn.snap_id         = mem.snap_id
        and sn.dbid            = mem.dbid
        and sn.instance_number = mem.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_MEMORY_TARGET_ADVICE"  IS 'Memory Target Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_METRIC_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_METRIC_NAME" ("DBID", "GROUP_ID", "GROUP_NAME", "METRIC_ID", "METRIC_NAME", "METRIC_UNIT", "CON_DBID", "CON_ID") AS 
  select dbid, group_id, group_name, metric_id, metric_name, metric_unit,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_METRIC_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_METRIC_NAME"  IS 'Segment Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_MTTR_TARGET_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_MTTR_TARGET_ADVICE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "MTTR_TARGET_FOR_ESTIMATE", "ADVICE_STATUS", "DIRTY_LIMIT", "ESTD_CACHE_WRITES", "ESTD_CACHE_WRITE_FACTOR", "ESTD_TOTAL_WRITES", "ESTD_TOTAL_WRITE_FACTOR", "ESTD_TOTAL_IOS", "ESTD_TOTAL_IO_FACTOR", "CON_DBID", "CON_ID") AS 
  select mt.snap_id, mt.dbid, mt.instance_number, mttr_target_for_estimate,
       advice_status, dirty_limit,
       estd_cache_writes, estd_cache_write_factor,
       estd_total_writes, estd_total_write_factor,
       estd_total_ios, estd_total_io_factor,
       decode(mt.con_dbid, 0, mt.dbid, mt.con_dbid),
       decode(mt.per_pdb, 0, 0,
         con_dbid_to_id(decode(mt.con_dbid, 0, mt.dbid, mt.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_MTTR_TARGET_ADVICE mt
  where     sn.snap_id         = mt.snap_id
        and sn.dbid            = mt.dbid
        and sn.instance_number = mt.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_MTTR_TARGET_ADVICE"  IS 'Mean-Time-To-Recover Target Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_MUTEX_SLEEP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_MUTEX_SLEEP" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "MUTEX_TYPE", "LOCATION", "SLEEPS", "WAIT_TIME", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number,
       mutex_type, location, sleeps, wait_time,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       decode(m.per_pdb, 0, 0,
         con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_MUTEX_SLEEP m
where      m.snap_id          = sn.snap_id
      and  m.dbid             = sn.dbid
      and  m.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_MUTEX_SLEEP"  IS 'Mutex Sleep Summary Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_MVPARAMETER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_MVPARAMETER" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PARAMETER_HASH", "PARAMETER_NAME", "ORDINAL", "VALUE", "ISDEFAULT", "ISMODIFIED", "CON_DBID", "CON_ID") AS 
  select mp.snap_id, mp.dbid, mp.instance_number,
       mp.parameter_hash, pn.parameter_name,
       mp.ordinal,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' or mp.per_pdb<>0 then mp.value else null end value, -- Use macro to mask sensitive column
       mp.isdefault, mp.ismodified,
       decode(mp.con_dbid, 0, mp.dbid, mp.con_dbid),
       decode(mp.per_pdb, 0, 0,
         con_dbid_to_id(decode(mp.con_dbid, 0, mp.dbid, mp.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_MVPARAMETER mp, WRH$_PARAMETER_NAME pn
where     mp.parameter_hash   = pn.parameter_hash
      and mp.dbid             = pn.dbid
      and mp.snap_id          = sn.snap_id
      and mp.dbid             = sn.dbid
      and mp.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_MVPARAMETER"  IS 'Multi-valued Parameter Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_OPTIMIZER_ENV
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_OPTIMIZER_ENV" ("DBID", "OPTIMIZER_ENV_HASH_VALUE", "OPTIMIZER_ENV", "CON_DBID", "CON_ID") AS 
  select dbid, optimizer_env_hash_value, optimizer_env,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
from WRH$_OPTIMIZER_ENV;

   COMMENT ON TABLE "SYS"."AWR_PDB_OPTIMIZER_ENV"  IS 'Optimizer Environment Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_OSSTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_OSSTAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select s.snap_id, s.dbid, s.instance_number, s.stat_id,
       nm.stat_name,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' or s.per_pdb<>0 then s.value else null end value, -- Use macro to mask sensitive column
       decode(s.con_dbid, 0, s.dbid, s.con_dbid),
       decode(s.per_pdb, 0, 0,
         con_dbid_to_id(decode(s.con_dbid, 0, s.dbid, s.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_OSSTAT s, WRH$_OSSTAT_NAME nm
where     s.stat_id          = nm.stat_id
      and s.dbid             = nm.dbid
      and s.snap_id          = sn.snap_id
      and s.dbid             = sn.dbid
      and s.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_OSSTAT"  IS 'Operating System Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_OSSTAT_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_OSSTAT_NAME" ("DBID", "STAT_ID", "STAT_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, stat_id, stat_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_OSSTAT_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_OSSTAT_NAME"  IS 'Operating System Statistic Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PARAMETER
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PARAMETER" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PARAMETER_HASH", "PARAMETER_NAME", "VALUE", "ISDEFAULT", "ISMODIFIED", "CON_DBID", "CON_ID") AS 
  select p.snap_id, p.dbid, p.instance_number,
       p.parameter_hash, pn.parameter_name,
       case when SYS_CONTEXT('USERENV','SYSTEM_DATA_VISIBLE')='YES' or p.per_pdb<>0 then p.value else null end value, -- Use macro to mask sensitive column
       isdefault, ismodified,
       decode(p.con_dbid, 0, p.dbid, p.con_dbid),
       decode(p.per_pdb, 0, 0,
         con_dbid_to_id(decode(p.con_dbid, 0, p.dbid, p.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_PARAMETER p, WRH$_PARAMETER_NAME pn
where     p.parameter_hash   = pn.parameter_hash
      and p.dbid             = pn.dbid
      and p.snap_id          = sn.snap_id
      and p.dbid             = sn.dbid
      and p.instance_number  = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_PARAMETER"  IS 'Parameter Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PARAMETER_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PARAMETER_NAME" ("DBID", "PARAMETER_HASH", "PARAMETER_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, parameter_hash, parameter_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_PARAMETER_NAME
where (translate(parameter_name,'_','#') not like '#%');

   COMMENT ON TABLE "SYS"."AWR_PDB_PARAMETER_NAME"  IS 'Parameter Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PDB_IN_SNAP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PDB_IN_SNAP" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CON_DBID", "FLAG", "CON_ID", "OPEN_TIME_TZ") AS 
  select snap_id, dbid, instance_number, decode(con_dbid, 0, dbid, con_dbid),
       flag, con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid)) con_id,
       open_time_tz
       from wrm$_pdb_in_snap;

   COMMENT ON TABLE "SYS"."AWR_PDB_PDB_IN_SNAP"  IS 'Pluggable Databases in a snapshot'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PDB_INSTANCE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PDB_INSTANCE" ("DBID", "INSTANCE_NUMBER", "STARTUP_TIME", "CON_DBID", "OPEN_TIME", "OPEN_MODE", "PDB_NAME", "CON_ID", "SNAP_ID", "STARTUP_TIME_TZ", "OPEN_TIME_TZ") AS 
  select dbid, instance_number, startup_time,
       CON_DBID, OPEN_TIME, OPEN_MODE, PDB_NAME,
       con_dbid_to_id(con_dbid) con_id, snap_id,
       startup_time_tz, open_time_tz
       from wrm$_pdb_instance;

   COMMENT ON TABLE "SYS"."AWR_PDB_PDB_INSTANCE"  IS 'Pluggable Database Instance Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PERSISTENT_QMN_CACHE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PERSISTENT_QMN_CACHE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_TABLE_ID", "TYPE", "STATUS", "NEXT_SERVICE_TIME", "WINDOW_END_TIME", "TOTAL_RUNS", "TOTAL_LATENCY", "TOTAL_ELAPSED_TIME", "TOTAL_CPU_TIME", "TMGR_ROWS_PROCESSED", "TMGR_ELAPSED_TIME", "TMGR_CPU_TIME", "LAST_TMGR_PROCESSING_TIME", "DEQLOG_ROWS_PROCESSED", "DEQLOG_PROCESSING_ELAPSED_TIME", "DEQLOG_PROCESSING_CPU_TIME", "LAST_DEQLOG_PROCESSING_TIME", "DEQUEUE_INDEX_BLOCKS_FREED", "HISTORY_INDEX_BLOCKS_FREED", "TIME_INDEX_BLOCKS_FREED", "INDEX_CLEANUP_COUNT", "INDEX_CLEANUP_ELAPSED_TIME", "INDEX_CLEANUP_CPU_TIME", "LAST_INDEX_CLEANUP_TIME", "CON_DBID", "CON_ID") AS 
  select pqc.snap_id, pqc.dbid, pqc.instance_number, pqc.queue_table_id,
       pqc.type, pqc.status, pqc.next_service_time, pqc.window_end_time,
       pqc.TOTAL_RUNS, pqc.TOTAL_LATENCY, pqc.TOTAL_ELAPSED_TIME,
       pqc.TOTAL_CPU_TIME, pqc.TMGR_ROWS_PROCESSED, pqc.TMGR_ELAPSED_TIME,
       pqc.TMGR_CPU_TIME, pqc.LAST_TMGR_PROCESSING_TIME,
       pqc.DEQLOG_ROWS_PROCESSED, pqc.DEQLOG_PROCESSING_ELAPSED_TIME,
       pqc.DEQLOG_PROCESSING_CPU_TIME, pqc.LAST_DEQLOG_PROCESSING_TIME,
       pqc.DEQUEUE_INDEX_BLOCKS_FREED, pqc.HISTORY_INDEX_BLOCKS_FREED,
       pqc.TIME_INDEX_BLOCKS_FREED, pqc.INDEX_CLEANUP_COUNT,
       pqc.INDEX_CLEANUP_ELAPSED_TIME, pqc.INDEX_CLEANUP_CPU_TIME,
       pqc.LAST_INDEX_CLEANUP_TIME,
       decode(pqc.con_dbid, 0, pqc.dbid, pqc.con_dbid),
       decode(pqc.per_pdb, 0, 0,
         con_dbid_to_id(decode(pqc.con_dbid, 0, pqc.dbid, pqc.con_dbid))) con_id
  from wrh$_persistent_qmn_cache pqc, AWR_PDB_SNAPSHOT sn
  where     sn.snap_id          = pqc.snap_id
        and sn.dbid             = pqc.dbid
        and sn.instance_number  = pqc.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_PERSISTENT_QMN_CACHE"  IS 'STREAMS AQ Persistent QMN Cache Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PERSISTENT_QUEUES
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PERSISTENT_QUEUES" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_SCHEMA", "QUEUE_NAME", "QUEUE_ID", "FIRST_ACTIVITY_TIME", "ENQUEUED_MSGS", "DEQUEUED_MSGS", "BROWSED_MSGS", "ELAPSED_ENQUEUE_TIME", "ELAPSED_DEQUEUE_TIME", "ENQUEUE_CPU_TIME", "DEQUEUE_CPU_TIME", "AVG_MSG_AGE", "DEQUEUED_MSG_LATENCY", "ELAPSED_TRANSFORMATION_TIME", "ELAPSED_RULE_EVALUATION_TIME", "ENQUEUED_EXPIRY_MSGS", "ENQUEUED_DELAY_MSGS", "MSGS_MADE_EXPIRED", "MSGS_MADE_READY", "LAST_ENQUEUE_TIME", "LAST_DEQUEUE_TIME", "LAST_TM_EXPIRY_TIME", "LAST_TM_READY_TIME", "ENQUEUE_TRANSACTIONS", "DEQUEUE_TRANSACTIONS", "EXECUTION_COUNT", "CON_DBID", "CON_ID") AS 
  select pqs.snap_id, pqs.dbid, pqs.instance_number, pqs.queue_schema,
       pqs.queue_name,pqs.queue_id, pqs.first_activity_time, pqs.enqueued_msgs,
       pqs.dequeued_msgs, pqs.browsed_msgs, pqs.elapsed_enqueue_time,
       pqs.elapsed_dequeue_time, pqs.enqueue_cpu_time, pqs.dequeue_cpu_time,
       pqs.avg_msg_age, pqs.dequeued_msg_latency,
       pqs.elapsed_transformation_time, pqs.elapsed_rule_evaluation_time,
       pqs.enqueued_expiry_msgs, pqs.enqueued_delay_msgs,
       pqs.msgs_made_expired, pqs.msgs_made_ready, pqs.last_enqueue_time,
       pqs.last_dequeue_time, pqs.last_tm_expiry_time, pqs.last_tm_ready_time,
       pqs.enqueue_transactions, pqs.dequeue_transactions, pqs.execution_count,
       decode(pqs.con_dbid, 0, pqs.dbid, pqs.con_dbid),
       decode(pqs.per_pdb, 0, 0,
         con_dbid_to_id(decode(pqs.con_dbid, 0, pqs.dbid, pqs.con_dbid))) con_id
  from wrh$_persistent_queues pqs, AWR_PDB_SNAPSHOT sn
  where     sn.snap_id          = pqs.snap_id
        and sn.dbid             = pqs.dbid
        and sn.instance_number  = pqs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_PERSISTENT_QUEUES"  IS 'STREAMS AQ Persistent Queues Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PERSISTENT_SUBS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PERSISTENT_SUBS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "QUEUE_SCHEMA", "QUEUE_NAME", "SUBSCRIBER_ID", "SUBSCRIBER_NAME", "SUBSCRIBER_ADDRESS", "SUBSCRIBER_TYPE", "FIRST_ACTIVITY_TIME", "ENQUEUED_MSGS", "DEQUEUED_MSGS", "AVG_MSG_AGE", "BROWSED_MSGS", "EXPIRED_MSGS", "DEQUEUED_MSG_LATENCY", "LAST_ENQUEUE_TIME", "LAST_DEQUEUE_TIME", "ELAPSED_DEQUEUE_TIME", "DEQUEUE_CPU_TIME", "DEQUEUE_TRANSACTIONS", "EXECUTION_COUNT", "CON_DBID", "CON_ID") AS 
  select pss.snap_id, pss.dbid, pss.instance_number,
       pss.queue_schema, pss.queue_name, pss.subscriber_id,
       pss.subscriber_name, pss.subscriber_address, pss.subscriber_type,
       pss.first_activity_time, pss.enqueued_msgs, pss.dequeued_msgs,
       pss.avg_msg_age, pss.browsed_msgs,
       pss.expired_msgs, pss.dequeued_msg_latency, pss.last_enqueue_time,
       pss.last_dequeue_time, pss.elapsed_dequeue_time,pss.dequeue_cpu_time,
       pss.dequeue_transactions, pss.execution_count,
       decode(pss.con_dbid, 0, pss.dbid, pss.con_dbid),
       decode(pss.per_pdb, 0, 0,
         con_dbid_to_id(decode(pss.con_dbid, 0, pss.dbid, pss.con_dbid))) con_id
  from wrh$_persistent_subscribers pss, AWR_PDB_SNAPSHOT sn
  where     sn.snap_id          = pss.snap_id
        and sn.dbid             = pss.dbid
        and sn.instance_number  = pss.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_PERSISTENT_SUBS"  IS 'STREAMS AQ Persistent Queue Subscribers Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PGASTAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PGASTAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select pga.snap_id, pga.dbid, pga.instance_number, name, value,
       decode(pga.con_dbid, 0, pga.dbid, pga.con_dbid),
       decode(pga.per_pdb, 0, 0,
         con_dbid_to_id(decode(pga.con_dbid, 0, pga.dbid, pga.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_PGASTAT pga
  where     sn.snap_id         = pga.snap_id
        and sn.dbid            = pga.dbid
        and sn.instance_number = pga.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_PGASTAT"  IS 'PGA Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PGA_TARGET_ADVICE
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PGA_TARGET_ADVICE" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PGA_TARGET_FOR_ESTIMATE", "PGA_TARGET_FACTOR", "ADVICE_STATUS", "BYTES_PROCESSED", "ESTD_TIME", "ESTD_EXTRA_BYTES_RW", "ESTD_PGA_CACHE_HIT_PERCENTAGE", "ESTD_OVERALLOC_COUNT", "CON_DBID", "CON_ID") AS 
  select pga.snap_id, pga.dbid, pga.instance_number,
       pga_target_for_estimate,
       pga_target_factor, advice_status, bytes_processed,
       estd_time, estd_extra_bytes_rw,
       estd_pga_cache_hit_percentage, estd_overalloc_count,
       decode(pga.con_dbid, 0, pga.dbid, pga.con_dbid),
       decode(pga.per_pdb, 0, 0,
         con_dbid_to_id(decode(pga.con_dbid, 0, pga.dbid, pga.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_PGA_TARGET_ADVICE pga
  where     sn.snap_id         = pga.snap_id
        and sn.dbid            = pga.dbid
        and sn.instance_number = pga.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_PGA_TARGET_ADVICE"  IS 'PGA Target Advice History'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PLAN_OPERATION_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PLAN_OPERATION_NAME" ("DBID", "OPERATION_ID", "OPERATION_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, operation_id, operation_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_PLAN_OPERATION_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_PLAN_OPERATION_NAME"  IS 'Optimizer Explain Plan Operation Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PLAN_OPTION_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PLAN_OPTION_NAME" ("DBID", "OPTION_ID", "OPTION_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, option_id, option_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(con_dbid_to_id(dbid), 1, 0, con_dbid_to_id(dbid)) con_id
from WRH$_PLAN_OPTION_NAME;

   COMMENT ON TABLE "SYS"."AWR_PDB_PLAN_OPTION_NAME"  IS 'Optimizer Explain Plan Option Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PROCESS_MEM_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PROCESS_MEM_SUMMARY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "CATEGORY", "IS_INSTANCE_WIDE", "NUM_PROCESSES", "NON_ZERO_ALLOCS", "USED_TOTAL", "ALLOCATED_TOTAL", "ALLOCATED_AVG", "ALLOCATED_STDDEV", "ALLOCATED_MAX", "MAX_ALLOCATED_MAX", "CON_DBID", "CON_ID") AS 
  select pmem.snap_id, pmem.dbid, pmem.instance_number,
       category, decode(pmem.per_pdb_nn, 0, 1, 0) is_instance_wide,
       num_processes, non_zero_allocs,
       used_total, allocated_total, allocated_total / num_processes,
       allocated_stddev, allocated_max, max_allocated_max,
       decode(pmem.con_dbid, 0, pmem.dbid, pmem.con_dbid),
       decode(pmem.per_pdb, 0, 0,
         con_dbid_to_id(
           decode(pmem.con_dbid, 0, pmem.dbid, pmem.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_PROCESS_MEMORY_SUMMARY pmem
  where     sn.snap_id         = pmem.snap_id
        and sn.dbid            = pmem.dbid
        and sn.instance_number = pmem.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_PROCESS_MEM_SUMMARY"  IS 'Process Memory Historical Summary Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_PROCESS_WAITTIME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_PROCESS_WAITTIME" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PROCESS_TYPE", "DESCRIPTION", "WAIT_CLASS_TYPE", "VALUE", "CON_DBID", "CON_ID") AS 
  select cw.snap_id, cw.dbid, cw.instance_number,
       process_type, description, wait_class_type, value,
       decode(cw.con_dbid, 0, cw.dbid, cw.con_dbid),
       decode(cw.per_pdb, 0, 0,
         con_dbid_to_id(decode(cw.con_dbid, 0, cw.dbid, cw.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_PROCESS_WAITTIME cw
  where     sn.snap_id         = cw.snap_id
        and sn.dbid            = cw.dbid
        and sn.instance_number = cw.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_PROCESS_WAITTIME"  IS 'cpu and wait time by process types'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_RECOVERY_PROGRESS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_RECOVERY_PROGRESS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "START_TIME", "TYPE", "ITEM", "UNITS", "SOFAR", "TOTAL", "TIMESTAMP", "CON_DBID", "CON_ID") AS 
  select rp.snap_id, rp.dbid, rp.instance_number, start_time, type,
       item, units, sofar, total, timestamp,
       decode(rp.con_dbid, 0, rp.dbid, rp.con_dbid),
       decode(rp.per_pdb, 0, 0,
         con_dbid_to_id(decode(rp.con_dbid, 0, rp.dbid, rp.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_RECOVERY_PROGRESS rp
  where     sn.snap_id = rp.snap_id
        and sn.dbid    = rp.dbid
        and sn.instance_number = rp.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_RECOVERY_PROGRESS"  IS 'Recovery Progress'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_REPLICATION_TBL_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_REPLICATION_TBL_STATS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "APPLY_NAME", "TABLE_NAME", "TABLE_OWNER", "SESSION_MODULE", "TOTAL_INSERTS", "TOTAL_UPDATES", "TOTAL_DELETES", "CDR_SUCCESSFUL", "CDR_FAILED", "REPERR_CNT", "HANDLE_COLLISIONS", "CON_DBID", "CON_ID") AS 
  select rt.snap_id, rt.dbid, rt.instance_number, rt.apply_name,
       rt.table_name, rt.table_owner, rt.session_module,
       rt.total_inserts, rt.total_updates,
       rt.total_deletes, rt.cdr_successful, rt.cdr_failed, rt.reperr_cnt,
       rt.handle_collisions,
       decode(rt.con_dbid, 0, rt.dbid, rt.con_dbid),
       decode(rt.per_pdb, 0, 0,
         con_dbid_to_id(decode(rt.con_dbid, 0, rt.dbid, rt.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_REPLICATION_TBL_STATS rt
  where    rt.snap_id           = sn.snap_id
      and  rt.dbid              = sn.dbid
      and  rt.instance_number   = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_REPLICATION_TBL_STATS"  IS 'Replication Table Stats For GoldenGate/XStream Sessions'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_REPLICATION_TXN_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_REPLICATION_TXN_STATS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "OBJECT_NAME", "SESSION_TYPE", "SESSION_MODULE", "SOURCE_DATABASE", "SOURCE_TXN_ID", "FIRST_LCR_TIME", "TOTAL_LCRS_COUNT", "CON_DBID", "CON_ID") AS 
  select rt.snap_id, rt.dbid, rt.instance_number,
       rt.object_name, rt.session_type, rt.session_module, rt.source_database,
       rt.source_txn_id, rt.first_lcr_time, rt.total_lcrs_count,
       decode(rt.con_dbid, 0, rt.dbid, rt.con_dbid),
       decode(rt.per_pdb, 0, 0,
         con_dbid_to_id(decode(rt.con_dbid, 0, rt.dbid, rt.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_REPLICATION_TXN_STATS rt
  where    rt.snap_id           = sn.snap_id
      and  rt.dbid              = sn.dbid
      and  rt.instance_number   = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_REPLICATION_TXN_STATS"  IS 'Replication Transaction Stats For GoldenGate/XStream Sessions'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_RESOURCE_LIMIT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_RESOURCE_LIMIT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "RESOURCE_NAME", "CURRENT_UTILIZATION", "MAX_UTILIZATION", "INITIAL_ALLOCATION", "LIMIT_VALUE", "CON_DBID", "CON_ID") AS 
  select rl.snap_id, rl.dbid, rl.instance_number, resource_name,
       current_utilization, max_utilization, initial_allocation,
       limit_value,
       decode(rl.con_dbid, 0, rl.dbid, rl.con_dbid),
       decode(rl.per_pdb, 0, 0,
         con_dbid_to_id(decode(rl.con_dbid, 0, rl.dbid, rl.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_RESOURCE_LIMIT rl
  where     sn.snap_id         = rl.snap_id
        and sn.dbid            = rl.dbid
        and sn.instance_number = rl.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_RESOURCE_LIMIT"  IS 'Resource Limit Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_ROWCACHE_SUMMARY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_ROWCACHE_SUMMARY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "PARAMETER", "TOTAL_USAGE", "USAGE", "GETS", "GETMISSES", "SCANS", "SCANMISSES", "SCANCOMPLETES", "MODIFICATIONS", "FLUSHES", "DLM_REQUESTS", "DLM_CONFLICTS", "DLM_RELEASES", "CON_DBID", "CON_ID") AS 
  select rc.snap_id, rc.dbid, rc.instance_number,
       parameter, total_usage,
       usage, gets, getmisses, scans, scanmisses, scancompletes,
       modifications, flushes, dlm_requests, dlm_conflicts,
       dlm_releases,
       decode(rc.con_dbid, 0, rc.dbid, rc.con_dbid),
       decode(rc.per_pdb, 0, 0,
         con_dbid_to_id(decode(rc.con_dbid, 0, rc.dbid, rc.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_ROWCACHE_SUMMARY rc
  where     sn.snap_id         = rc.snap_id
        and sn.dbid            = rc.dbid
        and sn.instance_number = rc.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_ROWCACHE_SUMMARY"  IS 'Row Cache Historical Statistics Information Summary'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_RSRC_CONSUMER_GROUP
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_RSRC_CONSUMER_GROUP" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SEQUENCE#", "CONSUMER_GROUP_ID", "CONSUMER_GROUP_NAME", "REQUESTS", "CPU_WAIT_TIME", "CPU_WAITS", "CONSUMED_CPU_TIME", "YIELDS", "ACTIVE_SESS_LIMIT_HIT", "UNDO_LIMIT_HIT", "SWITCHES_IN_CPU_TIME", "SWITCHES_OUT_CPU_TIME", "SWITCHES_IN_IO_MEGABYTES", "SWITCHES_OUT_IO_MEGABYTES", "SWITCHES_IN_IO_REQUESTS", "SWITCHES_OUT_IO_REQUESTS", "SWITCHES_IN_IO_LOGICAL", "SWITCHES_OUT_IO_LOGICAL", "SWITCHES_IN_ELAPSED_TIME", "SWITCHES_OUT_ELAPSED_TIME", "PGA_LIMIT_SESSIONS_KILLED", "SQL_CANCELED", "ACTIVE_SESS_KILLED", "IDLE_SESS_KILLED", "IDLE_BLKR_SESS_KILLED", "QUEUED_TIME", "QUEUE_TIME_OUTS", "IO_SERVICE_TIME", "IO_SERVICE_WAITS", "SMALL_READ_MEGABYTES", "SMALL_WRITE_MEGABYTES", "LARGE_READ_MEGABYTES", "LARGE_WRITE_MEGABYTES", "SMALL_READ_REQUESTS", "SMALL_WRITE_REQUESTS", "LARGE_READ_REQUESTS", "LARGE_WRITE_REQUESTS", "PQS_QUEUED", "PQ_QUEUED_TIME", "PQ_QUEUE_TIME_OUTS", "PQS_COMPLETED", "PQ_SERVERS_USED", "PQ_ACTIVE_TIME", "CON_DBID", "CON_ID") AS 
  select
  cg.snap_id,
  cg.dbid,
  cg.instance_number,
  cg.sequence#,
  cg.consumer_group_id,
  cg.consumer_group_name,
  cg.requests,
  cg.cpu_wait_time,
  cg.cpu_waits,
  cg.consumed_cpu_time,
  cg.yields,
  cg.active_sess_limit_hit,
  cg.undo_limit_hit,
  cg.switches_in_cpu_time,
  cg.switches_out_cpu_time,
  cg.switches_in_io_megabytes,
  cg.switches_out_io_megabytes,
  cg.switches_in_io_requests,
  cg.switches_out_io_requests,
  cg.switches_in_io_logical,
  cg.switches_out_io_logical,
  cg.switches_in_elapsed_time,
  cg.switches_out_elapsed_time,
  cg.pga_limit_sessions_killed,
  cg.sql_canceled,
  cg.active_sess_killed,
  cg.idle_sess_killed,
  cg.idle_blkr_sess_killed,
  cg.queued_time,
  cg.queue_time_outs,
  cg.io_service_time,
  cg.io_service_waits,
  cg.small_read_megabytes,
  cg.small_write_megabytes,
  cg.large_read_megabytes,
  cg.large_write_megabytes,
  cg.small_read_requests,
  cg.small_write_requests,
  cg.large_read_requests,
  cg.large_write_requests,
  nvl(cg.pqs_queued, 0),
  nvl(cg.pq_queued_time, 0),
  nvl(cg.pq_queue_time_outs, 0),
  nvl(cg.pqs_completed, 0),
  nvl(cg.pq_servers_used, 0),
  nvl(cg.pq_active_time, 0),
  decode(cg.con_dbid, 0, cg.dbid, cg.con_dbid),
  decode(cg.per_pdb, 0, 0,
    con_dbid_to_id(decode(cg.con_dbid, 0, cg.dbid, cg.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_RSRC_CONSUMER_GROUP cg
  where     sn.snap_id         = cg.snap_id
        and sn.dbid            = cg.dbid
        and sn.instance_number = cg.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_RSRC_CONSUMER_GROUP"  IS 'Historical resource consumer group statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_RSRC_METRIC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_RSRC_METRIC" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE_CSEC", "SEQUENCE#", "CONSUMER_GROUP_ID", "CPU_CONSUMED_TIME", "CPU_WAIT_TIME", "AVG_RUNNING_SESSIONS", "AVG_WAITING_SESSIONS", "AVG_CPU_UTILIZATION", "IO_REQUESTS", "IO_MEGABYTES", "IOPS", "IOMBPS", "AVG_ACTIVE_PARALLEL_STMTS", "AVG_QUEUED_PARALLEL_STMTS", "AVG_ACTIVE_PARALLEL_SERVERS", "AVG_QUEUED_PARALLEL_SERVERS", "CON_DBID", "CON_ID") AS 
  select
  rm.snap_id,
  rm.dbid,
  rm.instance_number,
  rm.begin_time,
  rm.end_time,
  rm.intsize_csec,                                           /* centiseconds */
  rm.sequence#,
  rm.consumer_group_id,
  rm.cpu_consumed_time,                                      /* milliseconds */
  rm.cpu_wait_time,                                          /* milliseconds */
  rm.cpu_consumed_time  / (10 * rm.intsize_csec),    /* avg running sessions */
  rm.cpu_wait_time      / (10 * rm.intsize_csec),    /* avg waiting sessions */
  decode(rm.os_num_cpus, 0, 0,
         (10 * rm.cpu_consumed_time / rm.intsize_csec / rm.os_num_cpus)),
  rm.io_requests,                                                /* requests */
  rm.io_megabytes,                                              /* megabytes */
  rm.io_requests  / (rm.intsize_csec / 100),      /* I/O requests per second */
  rm.io_megabytes / (rm.intsize_csec / 100),     /* I/O megabytes per second */
  rm.pq_active_time / (10 * rm.intsize_csec),   /* avg active parallel stmts */
  rm.pq_queued_time / (10 * rm.intsize_csec),   /* avg queued parallel stmts */
  rm.ps_active_time / (10 * rm.intsize_csec),/* avg running parallel servers */
  rm.ps_queued_time / (10 * rm.intsize_csec),/* avg parallel servers requested
                                              * by queued parallel servers   */
  decode(rm.con_dbid, 0, rm.dbid, rm.con_dbid),
  decode(rm.per_pdb, 0, 0,
    con_dbid_to_id(decode(rm.con_dbid, 0, rm.dbid, rm.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_RSRC_METRIC rm
  where     rm.dbid            = sn.dbid
        and rm.snap_id         = sn.snap_id
        and rm.instance_number = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_RSRC_METRIC"  IS 'Historical resource manager metrics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_RSRC_PDB_METRIC
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_RSRC_PDB_METRIC" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "INTSIZE_CSEC", "SEQUENCE#", "CPU_CONSUMED_TIME", "CPU_WAIT_TIME", "AVG_RUNNING_SESSIONS", "AVG_WAITING_SESSIONS", "AVG_CPU_UTILIZATION", "IOPS", "IOMBPS", "IOPS_THROTTLE_EXEMPT", "IOMBPS_THROTTLE_EXEMPT", "AVG_IO_THROTTLE", "AVG_ACTIVE_PARALLEL_STMTS", "AVG_QUEUED_PARALLEL_STMTS", "AVG_ACTIVE_PARALLEL_SERVERS", "AVG_QUEUED_PARALLEL_SERVERS", "SGA_BYTES", "BUFFER_CACHE_BYTES", "SHARED_POOL_BYTES", "PGA_BYTES", "PLAN_ID", "CON_DBID", "CON_ID") AS 
  select
  rm.snap_id,
  rm.dbid,
  rm.instance_number,
  rm.begin_time,
  rm.end_time,
  rm.intsize_csec,                                           /* centiseconds */
  rm.sequence#,
  rm.cpu_consumed_time,                                      /* milliseconds */
  rm.cpu_wait_time,                                          /* milliseconds */
  rm.cpu_consumed_time  / (10 * rm.intsize_csec),    /* avg running sessions */
  rm.cpu_wait_time      / (10 * rm.intsize_csec),    /* avg waiting sessions */
  decode(rm.os_num_cpus, 0, 0,
         (10 * rm.cpu_consumed_time / rm.intsize_csec / rm.os_num_cpus)),
  rm.io_requests  / (rm.intsize_csec / 100),      /* I/O requests per second */
  rm.io_megabytes / (rm.intsize_csec / 100),     /* I/O megabytes per second */
  rm.io_requests_throttle_exempt  / (rm.intsize_csec / 100),
                           /* I/O requests per second exempt from throttling */
  rm.io_megabytes_throttle_exempt / (rm.intsize_csec / 100),
                          /* I/O megabytes per second exempt from throttling */
  decode(rm.io_requests, 0, 0,      /* avg I/O throttle time per I/O request */
         rm.io_throttle_time / rm.io_requests),
  rm.pq_active_time / (10 * rm.intsize_csec),   /* avg active parallel stmts */
  rm.pq_queued_time / (10 * rm.intsize_csec),   /* avg queued parallel stmts */
  rm.ps_active_time / (10 * rm.intsize_csec),/* avg running parallel servers */
  rm.ps_queued_time / (10 * rm.intsize_csec),/* avg parallel servers requested
                                              * by queued parallel servers   */
  rm.sga_bytes,                                                     /* bytes */
  rm.buffer_cache_bytes,                                            /* bytes */
  rm.shared_pool_bytes,                                             /* bytes */
  rm.pga_bytes,                                                     /* bytes */
  rm.plan_id,
  decode(rm.con_dbid, 0, rm.dbid, rm.con_dbid),
  decode(rm.per_pdb, 0, 0,
    con_dbid_to_id(decode(rm.con_dbid, 0, rm.dbid, rm.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_RSRC_PDB_METRIC rm
  where     rm.dbid            = sn.dbid
        and rm.snap_id         = sn.snap_id
        and rm.instance_number = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_RSRC_PDB_METRIC"  IS 'Historical resource manager metrics by PDB'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_RSRC_PLAN
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_RSRC_PLAN" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SEQUENCE#", "START_TIME", "END_TIME", "PLAN_ID", "PLAN_NAME", "CPU_MANAGED", "PARALLEL_EXECUTION_MANAGED", "INSTANCE_CAGING", "CON_DBID", "CON_ID") AS 
  select
  pl.snap_id,
  pl.dbid,
  pl.instance_number,
  pl.sequence#,
  pl.start_time,
  pl.end_time,
  pl.plan_id,
  pl.plan_name,
  pl.cpu_managed,
  nvl(pl.parallel_execution_managed, 'OFF'),
  pl.instance_caging,
  decode(pl.con_dbid, 0, pl.dbid, pl.con_dbid),
  decode(pl.per_pdb, 0, 0,
    con_dbid_to_id(decode(pl.con_dbid, 0, pl.dbid, pl.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_RSRC_PLAN pl
  where     sn.snap_id         = pl.snap_id
        and sn.dbid            = pl.dbid
        and sn.instance_number = pl.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_RSRC_PLAN"  IS 'Historical resource plan statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_RULE_SET
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_RULE_SET" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "OWNER", "NAME", "STARTUP_TIME", "CPU_TIME", "ELAPSED_TIME", "EVALUATIONS", "SQL_FREE_EVALUATIONS", "SQL_EXECUTIONS", "RELOADS", "CON_DBID", "CON_ID") AS 
  select rs.snap_id, rs.dbid, rs.instance_number,
       rs.owner, rs.name, rs.startup_time, rs.cpu_time, rs.elapsed_time,
       rs.evaluations, rs.sql_free_evaluations, rs.sql_executions, rs.reloads,
       decode(rs.con_dbid, 0, rs.dbid, rs.con_dbid),
       decode(rs.per_pdb, 0, 0,
         con_dbid_to_id(decode(rs.con_dbid, 0, rs.dbid, rs.con_dbid))) con_id
  from wrh$_rule_set rs, AWR_PDB_SNAPSHOT sn
  where     sn.snap_id          = rs.snap_id
        and sn.dbid             = rs.dbid
        and sn.instance_number  = rs.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_RULE_SET"  IS 'Rule sets historical statistics information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_SEG_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_SEG_STAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "TS#", "OBJ#", "DATAOBJ#", "LOGICAL_READS_TOTAL", "LOGICAL_READS_DELTA", "BUFFER_BUSY_WAITS_TOTAL", "BUFFER_BUSY_WAITS_DELTA", "DB_BLOCK_CHANGES_TOTAL", "DB_BLOCK_CHANGES_DELTA", "PHYSICAL_READS_TOTAL", "PHYSICAL_READS_DELTA", "PHYSICAL_WRITES_TOTAL", "PHYSICAL_WRITES_DELTA", "PHYSICAL_READS_DIRECT_TOTAL", "PHYSICAL_READS_DIRECT_DELTA", "PHYSICAL_WRITES_DIRECT_TOTAL", "PHYSICAL_WRITES_DIRECT_DELTA", "ITL_WAITS_TOTAL", "ITL_WAITS_DELTA", "ROW_LOCK_WAITS_TOTAL", "ROW_LOCK_WAITS_DELTA", "GC_CR_BLOCKS_SERVED_TOTAL", "GC_CR_BLOCKS_SERVED_DELTA", "GC_CU_BLOCKS_SERVED_TOTAL", "GC_CU_BLOCKS_SERVED_DELTA", "GC_BUFFER_BUSY_TOTAL", "GC_BUFFER_BUSY_DELTA", "GC_CR_BLOCKS_RECEIVED_TOTAL", "GC_CR_BLOCKS_RECEIVED_DELTA", "GC_CU_BLOCKS_RECEIVED_TOTAL", "GC_CU_BLOCKS_RECEIVED_DELTA", "GC_REMOTE_GRANTS_TOTAL", "GC_REMOTE_GRANTS_DELTA", "SPACE_USED_TOTAL", "SPACE_USED_DELTA", "SPACE_ALLOCATED_TOTAL", "SPACE_ALLOCATED_DELTA", "TABLE_SCANS_TOTAL", "TABLE_SCANS_DELTA", "CHAIN_ROW_EXCESS_TOTAL", "CHAIN_ROW_EXCESS_DELTA", "PHYSICAL_READ_REQUESTS_TOTAL", "PHYSICAL_READ_REQUESTS_DELTA", "PHYSICAL_WRITE_REQUESTS_TOTAL", "PHYSICAL_WRITE_REQUESTS_DELTA", "OPTIMIZED_PHYSICAL_READS_TOTAL", "OPTIMIZED_PHYSICAL_READS_DELTA", "IM_SCANS_TOTAL", "IM_SCANS_DELTA", "POPULATE_CUS_TOTAL", "POPULATE_CUS_DELTA", "REPOPULATE_CUS_TOTAL", "REPOPULATE_CUS_DELTA", "IM_DB_BLOCK_CHANGES_TOTAL", "IM_DB_BLOCK_CHANGES_DELTA", "CON_DBID", "CON_ID") AS 
  select seg.snap_id, seg.dbid, seg.instance_number, ts#, obj#, dataobj#,
       logical_reads_total, logical_reads_delta,
       buffer_busy_waits_total, buffer_busy_waits_delta,
       db_block_changes_total, db_block_changes_delta,
       physical_reads_total, physical_reads_delta,
       physical_writes_total, physical_writes_delta,
       physical_reads_direct_total, physical_reads_direct_delta,
       physical_writes_direct_total, physical_writes_direct_delta,
       itl_waits_total, itl_waits_delta,
       row_lock_waits_total, row_lock_waits_delta,
       gc_cr_blocks_received_total, gc_cr_blocks_received_delta,
       gc_cu_blocks_received_total, gc_cu_blocks_received_delta,
       gc_buffer_busy_total, gc_buffer_busy_delta,
       gc_cr_blocks_received_total, gc_cr_blocks_received_delta,
       gc_cu_blocks_received_total, gc_cu_blocks_received_delta,
       gc_remote_grants_total, gc_remote_grants_delta,
       space_used_total, space_used_delta,
       space_allocated_total, space_allocated_delta,
       table_scans_total, table_scans_delta,
       chain_row_excess_total, chain_row_excess_delta,
       physical_read_requests_total, physical_read_requests_delta,
       physical_write_requests_total, physical_write_requests_delta,
       optimized_physical_reads_total, optimized_physical_reads_delta,
       im_scans_total, im_scans_delta,
       populate_cus_total, populate_cus_delta,
       repopulate_cus_total, repopulate_cus_delta,
       im_db_block_changes_total, im_db_block_changes_delta,
       decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid),
       decode(seg.per_pdb, 0, 0,
         con_dbid_to_id(decode(seg.con_dbid, 0, seg.dbid, seg.con_dbid))) con_id
from AWR_PDB_SNAPSHOT sn, WRH$_SEG_STAT seg
where     seg.snap_id         = sn.snap_id
      and seg.dbid            = sn.dbid
      and seg.instance_number = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_SEG_STAT"  IS ' Historical Statistics Information'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_SEG_STAT_OBJ
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_SEG_STAT_OBJ" ("DBID", "TS#", "OBJ#", "DATAOBJ#", "OWNER", "OBJECT_NAME", "SUBOBJECT_NAME", "OBJECT_TYPE", "TABLESPACE_NAME", "PARTITION_TYPE", "CON_DBID", "CON_ID") AS 
  select so.dbid, so.ts#, so.obj#, so.dataobj#, so.owner, so.object_name,
       so.subobject_name, so.object_type,
       coalesce(ts.tsname, tablespace_name) tablespace_name,
       so.partition_type,
       decode(so.con_dbid, 0, so.dbid, so.con_dbid),
       decode(so.per_pdb, 0, 0,
         con_dbid_to_id(decode(so.con_dbid, 0, so.dbid, so.con_dbid))) con_id
from WRH$_SEG_STAT_OBJ so LEFT OUTER JOIN WRH$_TABLESPACE ts
     on (so.dbid = ts.dbid
         and so.ts# = ts.ts#
         and so.con_dbid = ts.con_dbid);

   COMMENT ON TABLE "SYS"."AWR_PDB_SEG_STAT_OBJ"  IS 'Segment Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_SERVICE_NAME
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_SERVICE_NAME" ("DBID", "SERVICE_NAME_HASH", "SERVICE_NAME", "CON_DBID", "CON_ID") AS 
  select dbid, service_name_hash, service_name,
       decode(con_dbid, 0, dbid, con_dbid),
       decode(per_pdb, 0, 0,
         con_dbid_to_id(decode(con_dbid, 0, dbid, con_dbid))) con_id
  from WRH$_SERVICE_NAME sn;

   COMMENT ON TABLE "SYS"."AWR_PDB_SERVICE_NAME"  IS 'Service Names'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_SERVICE_STAT
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_SERVICE_STAT" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SERVICE_NAME_HASH", "SERVICE_NAME", "STAT_ID", "STAT_NAME", "VALUE", "CON_DBID", "CON_ID") AS 
  select st.snap_id, st.dbid, st.instance_number,
       st.service_name_hash, sv.service_name,
       nm.stat_id, nm.stat_name, value,
       decode(st.con_dbid, 0, st.dbid, st.con_dbid),
       decode(st.per_pdb, 0, 0,
         con_dbid_to_id(decode(st.con_dbid, 0, st.dbid, st.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_SERVICE_STAT st,
       WRH$_SERVICE_NAME sv, WRH$_STAT_NAME nm
  where    st.service_name_hash = sv.service_name_hash
      and  st.dbid              = sv.dbid
      and  st.stat_id           = nm.stat_id
      and  st.dbid              = nm.dbid
      and  st.snap_id           = sn.snap_id
      and  st.dbid              = sn.dbid
      and  st.instance_number   = sn.instance_number
      and  st.con_dbid          = sv.con_dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_SERVICE_STAT"  IS 'Historical Service Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_SERVICE_WAIT_CLASS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_SERVICE_WAIT_CLASS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SERVICE_NAME_HASH", "SERVICE_NAME", "WAIT_CLASS_ID", "WAIT_CLASS", "TOTAL_WAITS", "TIME_WAITED", "CON_DBID", "CON_ID") AS 
  select st.snap_id, st.dbid, st.instance_number,
       st.service_name_hash, nm.service_name,
       wait_class_id, wait_class, total_waits, time_waited,
       decode(st.con_dbid, 0, st.dbid, st.con_dbid),
       decode(st.per_pdb, 0, 0,
         con_dbid_to_id(decode(st.con_dbid, 0, st.dbid, st.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_SERVICE_WAIT_CLASS st,
       WRH$_SERVICE_NAME nm
  where    st.service_name_hash = nm.service_name_hash
      and  st.dbid              = nm.dbid
      and  st.snap_id           = sn.snap_id
      and  st.dbid              = sn.dbid
      and  st.instance_number   = sn.instance_number
      and  st.con_dbid          = nm.con_dbid;

   COMMENT ON TABLE "SYS"."AWR_PDB_SERVICE_WAIT_CLASS"  IS 'Historical Service Wait Class Statistics'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_SESSMETRIC_HISTORY
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_SESSMETRIC_HISTORY" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "BEGIN_TIME", "END_TIME", "SESSID", "SERIAL#", "INTSIZE", "GROUP_ID", "METRIC_ID", "METRIC_NAME", "VALUE", "METRIC_UNIT", "CON_DBID", "CON_ID") AS 
  select m.snap_id, m.dbid, m.instance_number, begin_time, end_time, sessid,
       serial#, intsize, m.group_id, m.metric_id, mn.metric_name,
       value, mn.metric_unit,
       decode(m.con_dbid, 0, m.dbid, m.con_dbid),
       decode(m.per_pdb, 0, 0,
         con_dbid_to_id(decode(m.con_dbid, 0, m.dbid, m.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_SESSMETRIC_HISTORY m, WRH$_METRIC_NAME mn
  where     m.group_id         = mn.group_id
        and m.metric_id        = mn.metric_id
        and m.dbid             = mn.dbid
        and sn.snap_id         = m.snap_id
        and sn.dbid            = m.dbid
        and sn.instance_number = m.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_SESSMETRIC_HISTORY"  IS 'System Metrics History'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_SESS_SGA_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_SESS_SGA_STATS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "OBJECT_NAME", "SESSION_TYPE", "SESSION_MODULE", "SGA_USED", "SGA_ALLOCATED", "CON_DBID", "CON_ID") AS 
  select st.snap_id, st.dbid, st.instance_number, st.object_name,
       st.session_type, st.session_module, st.sga_used, st.sga_allocated,
       decode(st.con_dbid, 0, st.dbid, st.con_dbid),
       decode(st.per_pdb, 0, 0,
         con_dbid_to_id(decode(st.con_dbid, 0, st.dbid, st.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_SESS_SGA_STATS st
  where    st.snap_id           = sn.snap_id
      and  st.dbid              = sn.dbid
      and  st.instance_number   = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_SESS_SGA_STATS"  IS 'SGA Usage Stats For High Utilization GoldenGate/XStream Sessions'
;
--------------------------------------------------------
--  DDL for View AWR_PDB_SESS_TIME_STATS
--------------------------------------------------------

  CREATE OR REPLACE FORCE NONEDITIONABLE VIEW "SYS"."AWR_PDB_SESS_TIME_STATS" ("SNAP_ID", "DBID", "INSTANCE_NUMBER", "SESSION_TYPE", "MIN_LOGON_TIME", "SUM_CPU_TIME", "SUM_SYS_IO_WAIT", "SUM_USER_IO_WAIT", "CON_DBID", "SESSION_MODULE", "CON_ID") AS 
  select st.snap_id, st.dbid, st.instance_number, st.session_type,
       st.min_logon_time, st.sum_cpu_time, st.sum_sys_io_wait,
       st.sum_user_io_wait,
       decode(st.con_dbid, 0, st.dbid, st.con_dbid),
       st.session_module,
       decode(st.per_pdb, 0, 0,
         con_dbid_to_id(decode(st.con_dbid, 0, st.dbid, st.con_dbid))) con_id
  from AWR_PDB_SNAPSHOT sn, WRH$_SESS_TIME_STATS st
  where    st.snap_id           = sn.snap_id
      and  st.dbid              = sn.dbid
      and  st.instance_number   = sn.instance_number;

   COMMENT ON TABLE "SYS"."AWR_PDB_SESS_TIME_STATS"  IS 'CPU And I/O Time For High Utilization Streams/GoldenGate/XStream sessions'
;
